[{"categories":["problemlist"],"content":"剑指offer","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":" 在leetcode平台上做一下剑指offer的题，不定时更新 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:0:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"03 数组中重复的数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:1:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:1:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 找出数组中任一重复的数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:1:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func findRepeatNumber(nums []int) int {\rmp := make(map[int]int)\rfor i := range nums {\rif _, ok := mp[nums[i]]; ok {\rreturn nums[i]\r}\rmp[nums[i]] = 1\r}\rreturn 0\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:1:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"04 二维数组中的查找 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:2:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 线性查找 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:2:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 在二维数组中查找目标数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:2:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 暴力时间复杂度O(n*m) 从右上角开始，如果这个值小于目标数，则往下一行查找，如果大于目标数，则往前一列查找 func findNumberIn2DArray(matrix [][]int, target int) bool {\rif matrix == nil || len(matrix) == 0 {\rreturn false\r}\rr, c := len(matrix), len(matrix[0])\ri, j := 0, c - 1\rfor i \u003c r \u0026\u0026 j \u003e= 0 {\rtmp := matrix[i][j]\rif tmp == target {\rreturn true\r}\rif tmp \u003c target {\ri++\r} else {\rj--\r}\r}\rreturn false\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:2:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"05 替换空格 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:3:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:3:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 把字符串中的空格替换成%20 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:3:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func replaceSpace(s string) string {\rans := \"\"\rfor _, v := range s {\rif v == ' ' {\rans += \"%20\"\r} else {\rans += string(v)\r}\r}\rreturn ans\r}\r func replaceSpace(s string) string {\rreturn strings.Replace(s, \" \", \"%20\", -1)\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:3:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"06 从尾到头打印链表 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:4:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:4:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 如题名 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:4:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /**\r* Definition for singly-linked list.\r* type ListNode struct {\r* Val int\r* Next *ListNode\r* }\r*/\rfunc reversePrint(head *ListNode) []int {\rvar ans []int\rfor head != nil {\rans = append(ans, head.Val)\rhead = head.Next\r}\rfor i, j := 0, len(ans) - 1; i \u003c j; i, j = i + 1, j - 1 {\rans[i], ans[j] = ans[j], ans[i]\r}\rreturn ans\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:4:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"07 重建二叉树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:5:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dfs、迭代 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:5:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 给二叉树的先序遍历和中序遍历，还原树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:5:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 dfs，只要锁定根在中序中的位置，然后类似于分治的做法，递归重建左子树和右子树 /**\r* Definition for a binary tree node.\r* type TreeNode struct {\r* Val int\r* Left *TreeNode\r* Right *TreeNode\r* }\r*/\rvar mp = make(map[int]int)\rfunc sol(pre []int, in []int, prel int, prer int, inl int, inr int) *TreeNode {\rif prel \u003e prer {\rreturn nil\r}\rrt := pre[prel]\rnode := \u0026TreeNode{rt, nil, nil}\rleftsize := mp[rt] - inl\rnode.Left = sol(pre, in, prel + 1, prel + leftsize, inl, leftsize - 1)\rnode.Right = sol(pre, in, prel + leftsize + 1, prer, mp[rt] + 1, inr)\rreturn node\r}\rfunc buildTree(preorder []int, inorder []int) *TreeNode {\rn := len(preorder)\rfor i, v := range inorder {\rmp[v] = i\r}\rreturn sol(preorder, inorder, 0, n - 1, 0, n - 1)\r}\r 用栈代替dfs可以节省时间和空间 /**\r* Definition for a binary tree node.\r* type TreeNode struct {\r* Val int\r* Left *TreeNode\r* Right *TreeNode\r* }\r*/\rvar mp = make(map[int]int)\rtype foo struct {\rnode *TreeNode\rprel, prer, inl, inr int\r}\rfunc buildTree(preorder []int, inorder []int) *TreeNode {\rn := len(preorder)\rfor i, v := range inorder {\rmp[v] = i\r}\rvar stack []foo\rif n == 0 {\rreturn nil\r}\rnode := \u0026TreeNode{preorder[0], nil, nil}\rstack = append(stack, foo{node, 0, n - 1, 0, n - 1})\rfor len(stack) != 0 {\rtmp := stack[len(stack)-1]\rstack = stack[:len(stack)-1]\rrt := tmp.node.Val\rleftsize := mp[rt] - tmp.inl\rcurprel := tmp.prel + 1\rcurprer := tmp.prel + leftsize\rcurinl := tmp.inl\rcurinr := leftsize - 1\rif curprel \u003e curprer {\rtmp.node.Left = nil\r} else {\rlnode := \u0026TreeNode{preorder[curprel], nil, nil}\rtmp.node.Left = lnode\rstack = append(stack, foo{lnode, curprel, curprer, curinl, curinr})\r}\rcurprel = tmp.prel + leftsize + 1\rcurprer = tmp.prer\rcurinl = mp[rt] + 1\rcurinr = tmp.inr\rif curprel \u003e curprer {\rtmp.node.Right = nil\r} else {\rrnode := \u0026TreeNode{preorder[curprel], nil, nil}\rtmp.node.Right = rnode\rstack = append(stack, foo{rnode, curprel, curprer, curinl, curinr})\r}\r}\rreturn node\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:5:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"09 用两个栈实现队列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:6:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 栈、队列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:6:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 两个栈，入队操作就是直接push到栈顶，出队操作要获得栈底元素，就把它们倒到另一个栈中，这样队首就是另一个栈的栈顶 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:6:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 type CQueue struct {\rst1, st2 []int\r}\rfunc Constructor() CQueue {\rreturn CQueue{}\r}\rfunc (this *CQueue) AppendTail(value int) {\rthis.st1 = append(this.st1, value)\r}\rfunc (this *CQueue) DeleteHead() int {\rif len(this.st1) == 0 \u0026\u0026 len(this.st2) == 0 {\rreturn -1\r}\rif len(this.st2) == 0 {\rfor len(this.st1) != 0 {\rthis.st2 = append(this.st2, this.st1[len(this.st1) - 1])\rthis.st1 = this.st1[:len(this.st1) - 1]\r}\r}\rv := this.st2[len(this.st2) - 1]\rthis.st2 = this.st2[:len(this.st2) - 1]\rreturn v\r}\r/**\r* Your CQueue object will be instantiated and called as such:\r* obj := Constructor();\r* obj.AppendTail(value);\r* param_2 := obj.DeleteHead();\r*/\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:6:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"10-1 斐波那契数列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:7:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:7:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:7:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func fib(n int) int {\rconst mod int = 1e9 + 7\rif n \u003c 2 {\rreturn n\r}\rp, q, r := 0, 0, 1\rfor i := 2; i \u003c= n; i++ {\rp = q\rq = r\rr = (p + q) % mod\r}\rreturn r\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:7:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"10-2 青蛙跳台阶问题 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:8:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy dp ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:8:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:8:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func numWays(n int) int {\rconst mod = 1e9 + 7\rdp := make([]int, n + 3)\rdp[0] = 1\rdp[1] = 1\rfor i := 2; i \u003c= n; i++ {\rdp[i] = dp[i - 1] + dp[i - 2]\rdp[i] %= mod\r}\rreturn dp[n]\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:8:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"11 旋转数组的最小数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:9:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 二分 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:9:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:9:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 二分，注意细节 func minArray(numbers []int) int {\rlow := 0\rhi := len(numbers) - 1\rfor low \u003c hi {\rmid := low + (hi-low)/2\rif numbers[mid] \u003c numbers[hi] {\rhi = mid\r} else if numbers[mid] \u003e numbers[hi] {\rlow = mid + 1\r} else {\rhi--\r}\r}\rreturn numbers[low]\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:9:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"12 矩阵中的路径 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:10:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dfs、回溯、剪枝 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:10:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:10:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 注意要加剪枝、有几处需要回溯 题解在调用dfs时传递字符串，这样很浪费时间，不是一个快速的方法 func exist(board [][]byte, word string) bool {\rdir := [][]int{{0, 1}, {0, -1}, {-1, 0}, {1, 0}}\rn := len(board)\rm := len(board[0])\rif len(word) \u003e n*m {\rreturn false\r}\rvis := make([][]bool, n)\rfor i := range vis {\rvis[i] = make([]bool, m)\r}\rle := len(word)\rvar dfs func(x, y int, str string) bool\rdfs = func(x, y int, str string) bool {\rvis[x][y] = true\rdefer func() { vis[x][y] = false }()\rfor i := 0; i \u003c len(str); i++ {\rif str[i] != word[i] {\rreturn false\r}\r}\rif len(str) == le {\rreturn true\r}\rfor i := 0; i \u003c 4; i++ {\rnx := x + dir[i][0]\rny := y + dir[i][1]\rif nx \u003e= 0 \u0026\u0026 nx \u003c n \u0026\u0026 ny \u003e= 0 \u0026\u0026 ny \u003c m \u0026\u0026 !vis[nx][ny] {\rif dfs(nx, ny, str+string(board[nx][ny])) {\rreturn true\r}\r}\r}\rreturn false\r}\rfor i, row := range board {\rfor j, v := range row {\rif dfs(i, j, string(v)) {\rreturn true\r}\r}\r}\rreturn false\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:10:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"13 机器人的运动范围 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:11:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 搜索 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:11:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:11:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 把数位和\u003ek的格子当做障碍 func movingCount(m int, n int, k int) int {\rvar queue [][2]int\rcheck := func(x int) int {\rres := 0\rfor x != 0 {\rres += x % 10\rx /= 10\r}\rreturn res\r}\robstacle := make([][]bool, m)\rfor i := range obstacle {\robstacle[i] = make([]bool, n)\r}\rvis := make([][]bool, m)\rfor i := range vis {\rvis[i] = make([]bool, n)\r}\rdir := [][]int{{0, 1}, {0, -1}, {-1, 0}, {1, 0}}\rsx, sy := 0, 0\rfor i := 0; i \u003c m; i++ {\rfor j := 0; j \u003c n; j++ {\rif check(i) + check(j) \u003e k {\robstacle[i][j] = true\r}\r}\r}\rqueue = append(queue, [2]int{sx, sy})\rvis[sx][sy] = true\rans := 1\rfor len(queue) != 0 {\rtmp := queue[0]\rqueue = queue[1:]\rsx, sy = tmp[0], tmp[1]\rfor i := 0; i \u003c 4; i++ {\rnx, ny := sx + dir[i][0], sy + dir[i][1]\rif nx \u003e= 0 \u0026\u0026 nx \u003c m \u0026\u0026 ny \u003e= 0 \u0026\u0026 ny \u003c n \u0026\u0026 !vis[nx][ny] \u0026\u0026 !obstacle[nx][ny] {\rqueue = append(queue, [2]int{nx, ny})\rans++\rvis[nx][ny] = true\r}\r}\r}\rreturn ans\r}\r ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:11:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["GAME"],"content":"CS:GO参数设置","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"N卡设置 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:1:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"Config文件 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:2:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"默认 命名为conf.cfg rate \"786432\"\r alias +cjump \"+jump; +duck\"\r alias -cjump \"-jump; -duck\"\r bind \"space\" \"+cjump\"\r cl_interp \"0\"\r cl_interp_ratio \"1\"\r viewmodel_recoil \"0\"\r bind \"Capslock\"\"+jump;-attack;-attack2;-jump\"\r sv_grenade_trajectory \"1\"\r bind \"MWHEELDOWN\" \"toggle cl_righthand 1 0\"\r ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:2:1","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"跑图 命名为paotu.cfg mp_freezetime 0\r mp_limitteams 10\r mp_autoteambalance 0\r mp_buytime \"999\"\r bot_kick\r cl_showpos 1\r sv_cheats 1\r bot_stop 1\r sv_infinite_ammo 1\r mp_startmoney 16000\r mp_buytime \"999\"\r sv_grenade_trajectory 1\r sv_grenade_trajectory_thickness 1\r sv_infinite_ammo 1\r mp_restartgame \"1\"\r mp_roundtime_defuse 60\r bind \"alt\" \"noclip\"\r bind \"f1\" \"sv_rethrow_last_grenade\"\r mp_buy_anywhere \"1\"\r ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:2:2","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"启动项 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:3:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"steam -high -freq 144 -tickrate 128 +exec conf.cfg ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:3:1","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"5e ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:3:2","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"游戏设置 edpi = 400 * 2.17 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:4:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"显示器设置 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:5:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["note"],"content":"Learning CPP","date":"2022-02-09","objectID":"/learning-cpp/","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Introduction\r\r学习一下c++ 教程视频地址，搬运自youtube 个人认为是一个非常不错的c++教程 空着的待补 \r\r ","date":"2022-02-09","objectID":"/learning-cpp/:0:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"How C++ works pre-process compile link ","date":"2022-02-09","objectID":"/learning-cpp/:1:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Variables ","date":"2022-02-09","objectID":"/learning-cpp/:2:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Functions ","date":"2022-02-09","objectID":"/learning-cpp/:3:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Header Files 当我们需要在cpp文件中用别的cpp的函数，需要先声明（declaration） 声明函数\r\rmain.cpp // main.cpp\r#include \u003ciostream\u003e\r\rvoid log(const char* msg) {\rstd::cout \u003c\u003c msg \u003c\u003c std::endl;\r}\rint main() {\rlog(\"hello world\");\rreturn 0;\r}\r log.cpp // log.cpp\rvoid log(const char* msg);\rvoid initLog() {\rlog(\"hello world\");\r}\r \r\r 使用头文件的基本例子 使用头文件\r\rmain.cpp // main.cpp\r#include \u003ciostream\u003e\r#include \"log.h\"\r\rint main() {\rinitLog();\rlog(\"hello world\");\rreturn 0;\r}\r log.cpp #include \"log.h\"\r#include \u003ciostream\u003e\r\rvoid initLog() {\rlog(\"yello\");\r}\rvoid log(const char* msg) {\rstd::cout \u003c\u003c msg \u003c\u003c std::endl;\r}\r log.h #pragma once\r\rvoid initLog();\rvoid log(const char* message);\r CMakeLists.txt cmake_minimum_required(VERSION 3.16)\rproject(LearnCPP)\rset(CMAKE_CXX_STANDARD 20)\radd_executable(main main.cpp)\radd_executable(log log.cpp)\radd_library(liblog log.h log.cpp)\rtarget_link_libraries(main liblog)\r \r\r #pragma once 的意思是这个头文件只会被include一次到一个编译单元（translate unit）（即一个cpp文件）中 举一个错误的例子 不使用#pragma once的错误例子\r\rmain.cpp #include \u003ciostream\u003e\r#include \"log.h\"\r\rint main() {\rinitLog();\rlog(\"hello world\");\rreturn 0;\r}\r log.cpp #include \"log.h\"\r#include \"common.h\"\r#include \u003ciostream\u003e\r\rvoid initLog() {\rlog(\"yello\");\r}\rvoid log(const char* msg) {\rstd::cout \u003c\u003c msg \u003c\u003c std::endl;\r}\r log.h // #pragma once\r\rvoid initLog();\rvoid log(const char* message);\rstruct hello {};\r common.h #pragma once\r#include \"log.h\"\r 编译之后， \r\r 另一种发挥 #pragma once 的方法是，在log.h中这样写，这个意思是如果没定义_LOG_H则会定义_LOG_H为一下代码，可见当include一次后_LOG_H就会被定义，所以之后不会在执行这些代码 #ifndef _LOG_H\r#define _LOG_H\r\rvoid initLog();\rvoid log(const char* message);\rstruct hello {};\r#endif\r 带 # 的都是预处理指令，在编译前执行，include\u003c\u003e和include\"“的区别是前者在系统库所在路径下搜寻，后者在当前项目的相对路径下搜寻 include某个cpp文件就相当于把那个cpp文件的代码拷贝到这个cpp文件中 为什么cpp的头文件没有.h？ 这是为了和c的头文件区分，c++的头文件不含.h，比如iostream，cstring ","date":"2022-02-09","objectID":"/learning-cpp/:4:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"How to debug ","date":"2022-02-09","objectID":"/learning-cpp/:5:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Conditions and Branches ","date":"2022-02-09","objectID":"/learning-cpp/:6:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Project Structures ","date":"2022-02-09","objectID":"/learning-cpp/:7:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Loops ","date":"2022-02-09","objectID":"/learning-cpp/:8:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Pointers 指针只是一个地址，他所存储的数据取决于你所要的字节长度 void* ptr = 0; void* 表示暂时不关心这个数据的类型，只是声明一个指针， 0就是NULL，在cpp源码中有 #define NULL 0和 #define NULL ((void*)0), 或者用nullptr表示真正意义上的空指针 指针的间接引用（derefence） #include \u003ciostream\u003e\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\rint main() {\rint a = 8;\rint* ptr = \u0026a;\r*ptr = 10;\rlog(a);\rreturn 0;\r}\r//output\r// 10\r new delete #include \u003ciostream\u003e\r#include \u003cmemory.h\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rchar *buffer = new char[8];\rmemset(buffer, 0, 8);\rdelete[] buffer;\rreturn 0;\r}\r 指向指针的指针 #include \u003ciostream\u003e\r#include \u003cmemory.h\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rchar *buffer = new char[8];\rmemset(buffer, 0, 8);\rchar** ptr = \u0026buffer;\rdelete[] buffer;\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:9:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"References 引用是一种基于指针的语法糖（Syntactic sugar） 基本例子 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rint a = 5;\rint\u0026 ref = a;\rref = 2;\rlog(a);\rreturn 0;\r}\r//output\r// 2\r 引用在初始化时就要指定一个变量，在指定完变量后，不能更改（即不能变成其他变量的引用），如果硬要这样做的话只能用指针 ","date":"2022-02-09","objectID":"/learning-cpp/:10:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Classes 类成员和函数需要public声明才可以在外部访问和初始化，默认是private。 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Player {\rpublic:\rint x, y, speed;\rvoid go(int dx, int dy) {\rx = dx;\ry = dy;\r}\r};\rint main() {\rPlayer player{};\rplayer.go(1, 2);\rreturn 0;\r}\r class和struct的区别是class的成员变量和函数默认是private，struct是public。struct可以继承，但不会去使用。看起来struct似乎是没有必要的，之所以有struct是因为它要和c兼容，c只有struct，没有class。 struct和class的使用场景没有严格要求，看个人习惯 struct适合用在数据的集合，class适合当作对象，具有比较大的功能 在写class的时候注意变量和函数的可见性（public，private，protected），protected变量可以被子类的访问 ","date":"2022-02-09","objectID":"/learning-cpp/:11:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Static static有两种，在结构体和类内的，在外面的。 外部的static，the linkage of the symbol declared as static is going to be internal, i.e. only visible in the translation unit defined in 内部的static，share memory with all instances of the class/struct; i.e. among all the instances created in this class/struct: only one instance of the variable 要使用外部的变量或函数，用extern，告诉linker这个变量或函数在外面找 extern和static举例\r\rmain.cpp #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rextern int var; // declaration\r\rint main() {\rlog(var);\rreturn 0;\r}\r// output // 11\r static.cpp //static int var = 11;\rint var = 11; // definition\r CMakeLists.txt （关键） add_library(libstatic static.cpp)\rtarget_link_libraries(main libstatic)\r \r\r 函数同理 实际上static非常常用，extern似乎还有很多用法，参考网上 类或结构体内部的static，用它修饰的变量，在创建多个实例时，不会创建多个变量（不会多分配内存） #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct Entity {\rstatic int x, y;\rstatic void Print() {\rstd::cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c std::endl;\r}\r};\rint Entity::x;\rint Entity::y;\rint main() {\rEntity e1, e2;\r// e1.x = 2; e1.y = 3;\r// e1.Print();\r// e2.x = 4; e2.y = 5;\r// e2.Print();\r Entity::x = 2;\rEntity::y = 3;\re2.Print();\rEntity::Print();\rreturn 0;\r}\r// output\r// 2 3\r// 2 3\r 注意如果变量非static，函数就不能用static，因为static函数不能访问非static变量 local static变量，它只有一个变量，尽管所在代码块被调用多次，因为它是local的，所以不能被外界访问 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid func() {\rstatic int i = 0;\ri++;\rlog(i);\r}\rint main() {\rfunc();\rfunc();\rfunc();\rfunc();\rreturn 0;\r}\r// output\r// 1\r// 2\r// 3\r// 4\r #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Singleton {\rpublic:\rstatic Singleton\u0026 get() {\rstatic Singleton instance;\rreturn instance;\r}\rvoid hello() {\r}\r};\rint main() {\rSingleton::get().hello();\rreturn 0;\r}\r 如果去掉local static，那么Singleton就会在栈上创建，特别是返回值是引用时会产生很大的错误，如果没有引用，那就是返回一份复制，没多大问题。 ","date":"2022-02-09","objectID":"/learning-cpp/:12:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Enums 作用：增加代码可读性 enum里面的值默认是从0递增的，且是整数，当然你可以给它赋值 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct node {\renum haha {\rA, B\r};\r};\renum e1 {\rA, B, C = 4\r};\renum e2 : char {\ra, b, c, d\r};\rint main() {\rnode::A; // 注意这种写法，A需要在enum里，否则需要加static\r int foo = B;\re1 bar = B; // 这样bar只能是e1中的值\r int hoge = bar;\rlog(bar);\rlog(hoge);\rreturn 0;\r}\r//output\r//1\r//1\r ","date":"2022-02-09","objectID":"/learning-cpp/:13:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Constructors 构造函数本身就存在，再java中变量初始化为0，c++并不是，是之前存在内存中的值，构造函数可以对其初始化，构造函数可以写多个（只要参数不同就行），这就是重载（overload） #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass node {\rpublic:\rint x, y;\rnode() {\rx = 1;\ry = 2;\r}\r[[maybe_unused]] node(int q, int w) { // [[maybe_unused]] 抑制针对未使用实体的警告, c++ 17\rx = q;\ry = w;\r}\rvoid Print() const {\rstd::cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c std::endl;\r}\r};\rint main() {\rnode n1;\rn1.Print();\rnode n2(4, 5);\rn2.Print();\rreturn 0;\r}\r//output\r// 1 2 // 4 5\r 一种不允许创建实例的方法是把构造函数写在private里或者写[类名]() = delete 这样默认构造函数被删除了，这样你只能使用类的static函数 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass node {\rprivate:\r//node() {}\rpublic:\rint x, y;\rnode() = delete ;\r};\rint main() {\rnode n1{};\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:14:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Destructor 析构函数默认也有，在对象被销毁时调用 c++类的四个默认函数，构造函数、析构函数、拷贝函数、赋值函数 class String\r{ public: String(const char *str = NULL); // 普通构造函数\r\rString(const String \u0026other); // 拷贝构造函数\r\r~ String(void); // 析构函数 \rString \u0026 operate =(const String \u0026other); // 赋值函数\r\rprivate: char *m_data; // 用于保存字符串\r\r};\r String a(“hello”);\rString b(“world”);\rString c = a; // 调用了拷贝构造函数，最好写成c(a);\rc = b; // 调用了赋值函数\r 参考 注意：析构函数没有重载，如果只自己写了一个构造函数，它不算重载，因为默认构造函数会被抛弃 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass node {\rpublic:\rint x, y;\rnode() {\rx = 1, y = 2;\rlog(\"created\");\r}\r~node() {\rlog(\"destroyed\");\r}\rvoid Print() {\rstd::cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c std::endl;\r}\r};\rvoid func() {\rnode n1;\rn1.Print();\rn1.~node(); // 不推荐这样写\r}\rint main() {\rfunc();\rreturn 0;\r}\r//output\r//\r//created\r//1 2\r//destroyed\r//destroyed\r ","date":"2022-02-09","objectID":"/learning-cpp/:15:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Inheritance 子类的类型可以是父类，如果一个函数的参数是父类，则输入子类也是可以的。 三种继承 公有继承(public) 公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。 私有继承(private) 私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。 保护继承(protected) 保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。 参考 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rfloat x, y;\rEntity() {\rx = 1.0f;\ry = 2.0f;\r}\rvoid move(float dx, float dy) {\rx += dx;\ry += dy;\r}\r};\rclass Player : public Entity {\rpublic:\rconst char *name;\rPlayer() {\rname = \"robot\";\r}\rvoid PrintName() const {\rlog(name);\r}\r};\rint main() {\rPlayer player;\rlog(player.x);\rlog(player.y);\rlog(player.name);\rlog(sizeof(Entity));\rlog(sizeof(Player));\rreturn 0;\r}\r//output\r//1\r//2\r//robot\r//8\r//16\r ","date":"2022-02-09","objectID":"/learning-cpp/:16:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Virtual Functions 看一下代码 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rstd::string GetName() {\rreturn \"Entity\";\r}\r};\rclass Player : public Entity {\rprivate:\rstd::string mName;\rpublic:\rPlayer(const std::string\u0026 name) : mName(name) {}\rstd::string GetName() {\rreturn mName;\r}\r};\rvoid PrintName(Entity* entity) {\rlog(entity-\u003eGetName());\r}\rint main() {\rEntity *e1 = new Entity();\rPlayer* p1 = new Player(\"dyh\");\rPrintName(e1);\rPrintName(p1);\rreturn 0;\r}\r//output\r//Entity\r//Entity\r 之所以会输出两个Entity是因为PrintName()的参数类型是Entity，所以会当作Entity。 虚函数通过虚表（vtable）来编译，虚表是类中所有虚函数映射的表，通过虚表可以找到正确重写的函数。 当你需要在子类中重写父类的方法时，需要把父类的方法设置为虚函数 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rvirtual std::string GetName() {\rreturn \"Entity\";\r}\r};\rclass Player : public Entity {\rprivate:\rstd::string mName;\rpublic:\rPlayer(const std::string\u0026 name) : mName(name) {}\rstd::string GetName() override {\rreturn mName;\r}\r};\rvoid PrintName(Entity* entity) {\rlog(entity-\u003eGetName());\r}\rint main() {\rEntity *e1 = new Entity();\rPlayer* p1 = new Player(\"dyh\");\rPrintName(e1);\rPrintName(p1);\rreturn 0;\r}\r//output\r//Entity\r//dyh\r 虚函数的额外开销：虚表需要占一定的空间，基类有一个指针指向虚表，调用虚函数时，需要遍历虚表。但这些开销在大部分情况下都可以忽略不计 ","date":"2022-02-09","objectID":"/learning-cpp/:17:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Interfaces (Pure Virtual Functions) 纯虚函数就是虚函数里不写任何内容，带有纯虚函数的父类不能被实例化，就想java的接口不能实例化只能实现。如果父类有纯虚函数，子类必须重写该函数才可以被实例化。 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rvirtual std::string GetName() = 0;\r};\rclass Player : public Entity {\rprivate:\rstd::string mName;\rpublic:\rPlayer(const std::string\u0026 name) : mName(name) {}\rstd::string GetName() override {\rreturn mName;\r}\r};\rvoid PrintName(Entity* entity) {\rlog(entity-\u003eGetName());\r}\rint main() {\r//Entity *e1 = new Entity(); // error\r Entity* e1 = new Player(\"\");\rPlayer* p1 = new Player(\"dyh\");\rPrintName(e1);\rPrintName(p1);\rreturn 0;\r}\r//output\r//\r//dyh\r 下列代码中如果Player类没有重写GetClassName()函数，则输出两个Entity #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Printable {\rpublic:\rvirtual std::string GetClassName() = 0;\r};\rclass Entity : public Printable {\rpublic:\rvirtual std::string GetName() { return \"hello\"; }\rstd::string GetClassName() override {\rreturn \"Entity\";\r}\r};\rclass Player : public Entity {\rprivate:\rstd::string mName;\rpublic:\rPlayer(const std::string \u0026name) : mName(name) {}\rstd::string GetName() override {\rreturn mName;\r}\rstd::string GetClassName() override {\rreturn \"Player\";\r}\r};\rvoid Print(Printable *obj) {\rlog(obj-\u003eGetClassName());\r}\rint main() {\rEntity *e = new Entity();\rPlayer *p = new Player(\"dyh\");\rPrint(e);\rPrint(p);\rreturn 0;\r}\r//output\r//Entity\r//Player\r ","date":"2022-02-09","objectID":"/learning-cpp/:18:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Visibility c++ 的三种可见性：private、protected、public。可以把一个类或函数标记成另一个类的友元（friend），这样它就可以访问这个类的private成员 public大家都可以访问、private只有类成员可以访问（友元也行）、protected只有基类和派生类可以访问 ","date":"2022-02-09","objectID":"/learning-cpp/:19:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Arrays 如果一个函数想返回一个数组，就要用new来创建，除非传入地址参数 创建数组的方式有三种 #include \u003ciostream\u003e\r#include \u003carray\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rint a[5]; //在栈上面创建的，这个代码块结束后，它会被销毁\r a[2] = 3;\rlog(a[2]); // 3\r int *ptr = a;\r*(ptr + 2) = 4;\rlog(a[2]); // 4\r *(int *) ((char *) ptr + 8) = 5;\rlog(a[2]); // 5\r log(sizeof(a)); // 20\r log(sizeof(*a)); // 4\r log(sizeof(\u0026a)); // 8\r\rint *b = new int[5]; //创建在堆上（内存间接寻址），直到用delete销毁或程序结束\r log(sizeof(b)); // 8 // 地址长度\r delete[] b;\rint c[] = {1, 2, 3};\rstd::array\u003cint, 5\u003e d{};\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:20:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Strings 两种形式：char数组和std::string（或者wide string） #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid Print(const std::string\u0026 x) { //加const是因为我们不想让x被修改，加\u0026是因为这样就变成一个引用，不需要拷贝字符串，拷贝字符串很占时间\r log(x);\r}\rint main() {\rchar a[3] = {'d', 'y', 'h'};\rlog(a); // dyh?Y╗ 后面的随机字符是因为char数组没有\\0作为结束标志，所以不知道打印到哪里\r std::string b = \"dyh\";\rlog(b); // dyh\r Print(b); // dyh\r return 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:21:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"String Literals 字符串字面量就是双引号之间的字符们，它总是存储在只读内存中 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\r// char* name = \"dyh\"; // warning: ISO c++11 does not allow conversion from string literal to 'char*'\r// name[1] = 'a';\r// char* name = (char*) \"dyh\"; //这样去修改字符是一种未定义的行为undefined behavior，所以不要这样做，如果要修改字符串数组应该按下面的方式写\r// name[1] = 'a'; //这个代码会让程序崩溃\r char another[5] = \"dyh\"; //按这种方式写。用数组不要用指针\r another[1] = 'a';\rconst char *yes = \"dyh\"; // 当用char指针时，最好加上const，这样可以提醒自己用char*时不能修改内容\r // const char* yes = u8\"dyh\";\r const wchar_t *bar = L\"dyh\"; // 长度由编译器决定，一般wins2字节，Linux4字节，macos4字节\r const char16_t *foo = u\"dyh\";\rconst char32_t *hoge = U\"dyh\";\rusing namespace std::string_literals;\rstd::string pop = \"happy \"s + \"new year\"; // s是一个函数\r std::wstring pop2 = L\"happy\"s + L\"new year\";\rstd::u32string pop3 = U\"happy\"s + U\"new year\";\rconst char *example = R\"(Line1\r Line2\rLine3\rLine4)\"; // R可以忽略转义字符，可以多行输入而不会黏在一起\r log(example);\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:22:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Const const修饰指针 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\r//const int* a = new int; // 不能改变指针存储的值，但可以改变指针的指向\r //int const* a = new int; // 同上\r // int* const a = new int; // 可以改变指针存储的值，不能改变指针的指向\r //const int* const a = new int;\r //*a = 2;\r int b = 100;\r//a = \u0026b;\r //log(*a);\r return 0;\r}\r 如果是 int* a, b;那么a是指针，b是int型，如果是int* a, *b; 那么a是指针，b是指针 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rint x, y;\rint* ptr;\rmutable int var;\rpublic:\rint getx() const { // 只有在类里面才这么用 意思是只读取类数据，不修改\r var = 2; //用mutable修饰的变量可以修改\r return x;\r}\rint getx() {\rreturn x;\r}\rconst int* const getptr() const { // 返回一个不能改变指向，不能改变存储数据的指针\r return ptr;\r}\rvoid setx(int xx) {\rx = xx;\r}\r};\rvoid Print(const Entity\u0026 e) {\rlog(e.getx()); //如果把getx的const去掉，e就不能调用getx()，因为getx可能会修改类，这样与形参的const冲突，尽管getx并没有改变类\r // 只要有const版本的getx存在就行\r}\rint main() {\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:23:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Mutable mutable的两种用法：一种是和const一起用，一种是和lambda #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rint x = 5;\rauto f = [=]() mutable { // 在按值传递的情况下，如果把mutable去掉，就要改成下面的代码，它们是等价的\r x++; // lambda里使用mutable的情况极少见\r log(x);\r// int y = x;\r// y++;\r// log(y);\r// log(x);\r };\rf();\rlog(x);\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:24:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Member Initializer Lists (Constructor Initializer Lists) #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rstd::string m_name;\rint m_score;\rpublic:\rEntity() : m_name(\"hello\"), m_score(123) {} // 初始化顺序最好和声明的顺序一样\r Entity(const std::string\u0026 name) : m_name(name), m_score(456) {}\r};\rint main() {\rreturn 0;\r}\r 初始化列表和赋值形式初始化还有功能上的区别，看以下两段代码的区别。如果不用列表，类将会被实例化两次，用初始化列表，类被初始化一次，节省资源 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass A {\rpublic:\rA() {\rlog(\"created\");\r}\rA(int x) {\rlog(x);\r}\r};\rclass B {\rprivate:\rint x;\rA a;\rpublic:\rB() {\rx = 3;\ra = A(2);\r}\r};\rint main() {\rB b;\rreturn 0;\r}\r//output\r//created\r//2\r #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass A {\rpublic:\rA() {\rlog(\"created\");\r}\rA(int x) {\rlog(x);\r}\r};\rclass B {\rprivate:\rint x;\rA a;\rpublic:\rB() : x(3), a(A(2)) {}\r//B() : x(3), a(2) {} // 效果和上面相同\r};\rint main() {\rB b;\rreturn 0;\r}\r//output\r// 2\r ","date":"2022-02-09","objectID":"/learning-cpp/:25:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Ternary Operators 为什么用三元运算符，因为它快，更整洁 ","date":"2022-02-09","objectID":"/learning-cpp/:26:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"How to Create Instantiate Object 实例化就是看在堆上创建还是在栈上 在堆上，你决定什么时侯销毁，在栈上，超出作用域就销毁 在堆上创建实例的理由有：不想在超出作用域后被销毁，对象太大了，在栈上创建很多太占空间，栈比较小，会爆栈 在堆上分配会比在栈上费时间 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\rusing namespace std;\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rprivate:\rstring m_name;\rpublic:\rEntity() : m_name(\"hello\") {}\rEntity(const string\u0026 name) : m_name(name) {}\rconst string\u0026 getname() const {\rreturn m_name;\r}\r};\rint main() {\rEntity *e;\r{\r//Entity entity(\"dyh\"); // 在栈上创建，过了这个代码块就会被销毁\r Entity* entity = new Entity(\"dyh\"); // 在堆上创建\r //e = \u0026entity;\r e = entity;\rdelete entity;\r}\r//delete entity; // wrong should be 'delete e'\r return 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:27:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"New new 返回分配的内存的指针 placement new 留坑 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\rusing namespace std;\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rprivate:\rstring m_name;\rpublic:\rEntity() : m_name(\"hello\") {}\rEntity(const string\u0026 name) : m_name(name) {}\rconst string\u0026 getname() const {\rreturn m_name;\r}\r};\rint main() {\rEntity* entity = new Entity;\rEntity* e = (Entity*) malloc(sizeof(Entity)); // 不要用这种，它没有调用构造函数，而且可读性差\r return 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:28:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Implicit Conversion and Explicit Keyword #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\rusing namespace std;\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rprivate:\rstring m_name;\rint m_age;\rpublic:\rEntity(const string\u0026 name) : m_name(name), m_age(-1) {}\rEntity(int x) : m_name(\"unknown\"), m_age(x) {}\r};\rint main() {\r// 一般不会这样写代码，可读性差\r Entity e = 22; // int implicit convert to Entity\r //Entity e2 = \"abc\"; // wrong, because \"abc\" is char array type not string\r Entity e2 = (string) \"abc\"; // ok\r return 0;\r}\r explicit 禁止隐式转化 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\rusing namespace std;\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rprivate:\rstring m_name;\rint m_age;\rpublic:\rEntity(const string\u0026 name) : m_name(name), m_age(-1) {}\rexplicit Entity(int x) : m_name(\"unknown\"), m_age(x) {}\r};\rint main() {\rEntity e = 22; // wrong\r return 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:29:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Operators and Operator Overloading java不支持运算符重载 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\rusing namespace std;\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Vector2d {\rpublic:\rfloat x, y;\r//Vector2d() {}\r Vector2d(float x, float y) : x(x), y(y) {}\rVector2d add(const Vector2d\u0026 other) const {\r//return *this + other;\r return operator+(other); // 两种都行\r }\rVector2d operator+(const Vector2d \u0026other) const {\rreturn Vector2d(x + other.x, y + other.y);\r}\rbool operator==(const Vector2d\u0026 other) const {\rreturn x == other.x \u0026\u0026 y == other.y;\r}\r};\r// 重载\u003c\u003c流运算符，在class外面，因为这和class无关，而且写到类里面报错。这里重载\u003c\u003c很像java里的to_string方法\r// 重载==就像重写equals\rstd::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const Vector2d\u0026 v) {\rstream \u003c\u003c v.x \u003c\u003c \", \" \u003c\u003c v.y;\rreturn stream;\r}\rint main() {\rVector2d v1(2.0f, 1.0f), v2(3.0f, 7.0f);\r//Vector2d v3 = v1 + v2;\r Vector2d v3 = v1.add(v2);\rlog(v3.x);\rlog(v3.y);\rlog(v3);\rbool condition = v1 == v2;\rcondition = v1 != v2;\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:30:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"This this是指向当前对象的指针且是const修饰的，比如const A* 试试在class里写delete this（X） ","date":"2022-02-09","objectID":"/learning-cpp/:31:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Object Lifetime 在栈上创建 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\rusing namespace std;\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rEntity() {\rlog(\"created entity\");\r}\r~Entity() {\rlog(\"destroyed entity\");\r}\r};\rint main() {\r{\rEntity entity;\r}\rreturn 0;\r}\r//created entity\r//destroyed entity\r 在堆上创建 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\rusing namespace std;\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rEntity() {\rlog(\"created entity\");\r}\r~Entity() {\rlog(\"destroyed entity\");\r}\r};\rint main() {\r{\rEntity* entity = new Entity;\r}\rreturn 0;\r}\r//created entity\r int* CreateArray() {\r// int a[20]; //这是错误的，因为它在栈上创建\r// return a;\r int* a = new int[20];\rreturn a;\r}\r 如果想用new在堆上分配，又想在跳出作用域时自动删除（智能指针雏形） #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\rusing namespace std;\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rEntity() {\rlog(\"created entity\");\r}\r~Entity() {\rlog(\"destroyed entity\");\r}\r};\rclass ScopedPtr {\rprivate:\rEntity* m_ptr;\rpublic:\rScopedPtr(Entity* entity) : m_ptr(entity) {}\r~ScopedPtr() {\rdelete m_ptr;\r}\r};\rint main() {\r{\rScopedPtr ptr = new Entity(); // implicit conversion\r }\rreturn 0;\r}\r//created entity\r//destroyed entity\r ","date":"2022-02-09","objectID":"/learning-cpp/:32:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Smart Pointers unique_ptr unique_ptr不能复制，因为如果复制的话，当之前的指针指向的内存区域释放后，复制的指针将指向已释放的内存，这没有意义 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003cmemory\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rEntity() {\rlog(\"created entity\");\r}\r~Entity() {\rlog(\"destroyed entity\");\r}\rvoid Print() {\r}\r};\rint main() {\r//std::unique_ptr\u003cEntity\u003e entity(new Entity);\r std::unique_ptr\u003cEntity\u003e entity = std::make_unique\u003cEntity\u003e(); // 更安全的写法，如果构造函数跑出异常，它不会得到一个悬空的指针而造成内存泄露\r entity-\u003ePrint();\r// std::unique_ptr\u003cEntity\u003e e(entity);\r// std::unique_ptr\u003cEntity\u003e e = entity; // unique_ptr不能复制\r return 0;\r}\r shared_ptr 使用引用计数（reference counting），就是记录有多少个指针指向它，如果引用计数变成0就删掉这块内存 如果shared_ptr复制给weak_ptr ，不会增加这个内存的引用计数。weak_ptr 不会真正占有内存块 使用时优先考虑unique，如果必须要复制，再用shared，shared比unique开销大 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003cmemory\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rEntity() {\rlog(\"created entity\");\r}\r~Entity() {\rlog(\"destroyed entity\");\r}\rvoid Print() {\r}\r};\rint main() {\rstd::shared_ptr\u003cEntity\u003e entity = std::make_shared\u003cEntity\u003e();\r// 一般不用new，因为share_ptr需要控制块来记录引用计数，如果用new，要做两次内存分配，一次是new Entity，一次是分配控制块，用这种方法可以把它们结合起来更高效\r std::shared_ptr\u003cEntity\u003e e1 = entity;\rstd::weak_ptr\u003cEntity\u003e e2 = e1;\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:33:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Copying and Copy Constructors #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003cmemory\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rint a = 2;\rint b = a; // copy value\r b = 3;\rlog(a);\rint *c;\r*c = 5;\rint *d = c; // copy pointer\r *d = 6;\rlog(*c);\rreturn 0;\r}\r// 2\r// 6\r// 6\r 以下是模拟写一个string类 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass String {\rprivate:\rchar* m_buffer;\runsigned int m_size;\rpublic:\rString(const char* string) {\rm_size = strlen(string);\rm_buffer = new char[m_size + 1];\rmemcpy(m_buffer, string, m_size);\rm_buffer[m_size] = 0; //or memcpy(m_buffer, string, m_size + 1);\r }\r~String() {\rdelete[] m_buffer;\r}\rfriend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string);\r};\rstd::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string) {\rstream \u003c\u003c string.m_buffer;\rreturn stream;\r}\rint main() {\rString s = \"hello\";\r//String s(\"hello\");\r String s1 = s; // 这样拷贝程序会崩溃，因为s1的指针和s的指针一样，指向同一块内存区域，当s1析构时，内存区域被释放了，s析构时，又会对同一片区域释放，出错\r log(s);\rlog(s1);\rreturn 0;\r}\r// hello\r// hello\r 重载[]运算符 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass String {\rprivate:\rchar* m_buffer;\runsigned int m_size;\rpublic:\rString(const char* string) {\rm_size = strlen(string);\rm_buffer = new char[m_size + 1];\rmemcpy(m_buffer, string, m_size);\rm_buffer[m_size] = 0; //or memcpy(m_buffer, string, m_size + 1);\r }\r~String() {\rdelete[] m_buffer;\r}\rchar\u0026 operator[](unsigned int index) {\rreturn m_buffer[index];\r}\rfriend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string);\r};\rstd::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string) {\rstream \u003c\u003c string.m_buffer;\rreturn stream;\r}\rint main() {\rString s = \"hello\";\r//String s(\"hello\");\r String s1 = s; // （浅拷贝）这样拷贝程序会崩溃，因为s1的指针和s的指针一样，指向同一块内存区域，当s1析构时，内存区域被释放了，s析构时，又会对同一片区域释放，出错\r s1[1] = 'a';\rlog(s);\rlog(s1);\rreturn 0;\r}\r// hallo\r// hallo\r\r 只拷贝了指针却没有拷贝指针所指向的区域，这是浅拷贝（shallow copy）如何才能拷贝指针且拷贝指针指向的区域（不同的指针加上不同的内存区域），这是深拷贝（deep copy）。深拷贝可以通过改写拷贝构造函数实现 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass String {\rprivate:\rchar* m_buffer;\runsigned int m_size;\rpublic:\rString(const char* string) {\rm_size = strlen(string);\rm_buffer = new char[m_size + 1];\rmemcpy(m_buffer, string, m_size);\rm_buffer[m_size] = 0; //or memcpy(m_buffer, string, m_size + 1);\r }\r//String(const String\u0026 other) : m_buffer(other.m_buffer), m_size(other.m_size) {} // 这是c++提供的默认的拷贝构造函数\r// String(const String\u0026 other) { // 实际上c++提供的默认拷贝构造函数是这样的\r// memcpy(this, \u0026other, sizeof(String));\r// }\r // deep copy\r String(const String\u0026 other) : m_size(other.m_size) {\rlog(\"copyed\");\rm_buffer = new char[m_size + 1];\rmemcpy(m_buffer, other.m_buffer, m_size + 1);\r}\r~String() {\rdelete[] m_buffer;\r}\rchar\u0026 operator[](unsigned int index) {\rreturn m_buffer[index];\r}\rfriend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string);\r};\rstd::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string) {\rstream \u003c\u003c string.m_buffer;\rreturn stream;\r}\r// 用引用避免不必要的拷贝，用const是因为它不会被修改，要多用const引用，好处多多\rvoid Print(const String\u0026 s) {\rlog(s);\r}\rint main() {\rString s = \"hello\";\r//String s(\"hello\");\r String s1 = s; // （浅拷贝）这样拷贝程序会崩溃，因为s1的指针和s的指针一样，指向同一块内存区域，当s1析构时，内存区域被释放了，s析构时，又会对同一片区域释放，出错\r s1[1] = 'a';\rPrint(s);\rPrint(s1);\rreturn 0;\r}\r// hello\r// hallo\r\r 记得多用const引用！ ","date":"2022-02-09","objectID":"/learning-cpp/:34:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Arrow -\u003e重载的使用和场景 如果不用重载，要这样写 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rint x;\rvoid Print() const {\rlog(\"hello\");\r}\r};\rclass ScopedPtr {\rprivate:\rEntity* entity;\rpublic:\rScopedPtr(Entity* e) : entity(e) {\r}\r~ScopedPtr() {\rdelete entity;\r}\rEntity* getObj() {\rreturn entity;\r}\r};\rint main() {\rScopedPtr e = new Entity(); // Implicit conversion\r e.getObj()-\u003ePrint(); // 要这样写\r return 0;\r}\r 重载运算符就这样写了 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rpublic:\rint x;\rvoid Print() const {\rlog(\"hello\");\r}\r};\rclass ScopedPtr {\rprivate:\rEntity* entity;\rpublic:\rScopedPtr(Entity* e) : entity(e) {\r}\r~ScopedPtr() {\rdelete entity;\r}\rEntity* operator-\u003e() {\rreturn entity;\r}\rconst Entity* operator-\u003e() const {\rreturn entity;\r}\r};\rint main() {\rScopedPtr e = new Entity(); // Implicit conversion\r //const ScopedPtr e = new Entity(); //如果用const就加上const版本的重载\r e-\u003ePrint();\rreturn 0;\r}\r -\u003e的一个应用，取数据的偏移地址 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct A {\rfloat x, y, z; // Q：想找y或者z在内存里对于x的偏移\r};\rint main() {\r// 为了可读性全加上括号\r // 经实验c++20不能把地址转换成int\r int offsetx = (int) (\u0026(((A*) nullptr)-\u003ex)); // 0\r int offsety = (int) (\u0026(((A*) nullptr)-\u003ex)); // 4\r log(offsetx);\rint x = 5;\rint y = (int)\u0026x; // wrong\r return 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:35:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Vector vector作为动态数组为什么叫vector，据设计者称，这是一个命名错误，详见网上资料 vector的使用优化 以下这段代码之所以会拷贝那么多次是因为 首先在main栈上创建值为123的Vertex对象，然后将值为123的Vertex对象拷贝进vector中，这是1次。在main栈上创建值为456的Vertex对象，然后因为vector的大小默认为1，空间不够，所以在内存中找一块值为2或更大的空间，然后把Vertex123拷贝进那个空间，这是第2次，再将Vertex456拷贝进那个空间，这是第3次，其他同理。但是输出的copied并不像预想的那么多，是因为机器不同、当前环境不同，实际的过程略有差异 优化的方法，1：预先分配一定大小的空间，减少对象的转移 2：直接在vector后面创建，不要在main栈里创建，再拷贝 #include \u003ciostream\u003e\r#include \u003cvector\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct Vertex {\rfloat x, y, z;\rVertex(float x, float y, float z) : x(x), y(y), z(z) {}\rVertex(const Vertex\u0026 v) : x(v.x), y(v.y), z(v.z) {\rlog(\"copied\");\r}\r};\rint main() {\rstd::vector\u003cVertex\u003e vertices;\rvertices.push_back({1, 2, 3});\rvertices.push_back({4, 5, 6});\rvertices.push_back({7, 8, 9});\rvertices.push_back({10, 11, 12});\rreturn 0;\r}\r//copied\r//copied\r//copied\r//copied\r//copied\r//copied\r//copied\r 针对优化1 #include \u003ciostream\u003e\r#include \u003cvector\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct Vertex {\rfloat x, y, z;\rVertex(float x, float y, float z) : x(x), y(y), z(z) {}\rVertex(const Vertex\u0026 v) : x(v.x), y(v.y), z(v.z) {\rlog(\"copied\");\r}\r};\rint main() {\rstd::vector\u003cVertex\u003e vertices;\rvertices.reserve(4);\rvertices.push_back({1, 2, 3});\rvertices.push_back({4, 5, 6});\rvertices.push_back({7, 8, 9});\rvertices.push_back({10, 11, 12});\rreturn 0;\r}\r//copied\r//copied\r//copied\r//copied\r 针对优化2，注意emplace_back传入的是数字参数，而不是对象 #include \u003ciostream\u003e\r#include \u003cvector\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct Vertex {\rfloat x, y, z;\rVertex(float x, float y, float z) : x(x), y(y), z(z) {}\rVertex(const Vertex\u0026 v) : x(v.x), y(v.y), z(v.z) {\rlog(\"copied\");\r}\r};\rint main() {\rstd::vector\u003cVertex\u003e vertices;\rvertices.reserve(4);\rvertices.emplace_back(1, 2, 3);\rvertices.emplace_back(4, 5, 6);\rvertices.emplace_back(7, 8, 9);\rvertices.emplace_back(10, 11, 12);\rreturn 0;\r}\r//\r ","date":"2022-02-09","objectID":"/learning-cpp/:36:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Multiple Return Values 用pair、tuple、struct等等 std::tie 和 std::ignore 的用法 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003ctuple\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rstd::tuple\u003cint, float, std::string\u003e tp = std::make_tuple(3, 2.0f, \"qwe\");\rint x;\rfloat y;\rstd::string z;\rstd::tie(x, y, z) = tp;\rlog(x);\rlog(y);\rlog(z);\rstd::tie(x, std::ignore, z) = tp;\rreturn 0;\r}\r//3\r//2\r//qwe\r ","date":"2022-02-09","objectID":"/learning-cpp/:37:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Templates #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\r//template\u003cclass T\u003e\r//它们是连在一起的，叫模板，Print不是一个单独的函数，如果没有调用这个函数，这个函数就不存在，只有在调用时，才会根据类型创建出函数（代码）\rtemplate\u003ctypename T\u003e\rvoid Print(T x) {\rlog(x);\r}\rint main() {\rPrint(3);\rPrint(\"hello\");\rPrint(5.2);\rPrint\u003cint\u003e(4);\rreturn 0;\r}\r #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rtemplate\u003ctypename T, int N\u003e\rclass Array {\rprivate:\rT m_array[N];\rpublic:\rint getsize() const {\rreturn N;\r}\r};\rint main() {\rArray\u003cint, 5\u003e array;\rlog(array.getsize());\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:38:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Stack vs Heap Memory 程序运行时，操作系统会分配一堆的ram，堆和栈是ram中的区域 栈通常是一个固定大小的区域，大概为2M，堆可以扩充 栈的空间分配是连续的，很快的，堆的分配比较慢，一个主要原因是，栈的空间分配是预先分配好的，堆的空间分配不是预先分配的，堆的每一次分配都要找空间碎片。 另一个影响效率的是cache命中率的问题 ","date":"2022-02-09","objectID":"/learning-cpp/:39:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Macros 宏很适合用来调试 #include \u003ciostream\u003e\r\r//#ifdef LOCAL\r//#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r//#else\r//#define log(x)\r//#endif\r\r//以下写法比上面更好\r\r#if LOCAL == 1\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r#else\r#define log(x)\r#endif\r\r//#if LOCAL == 1\r//#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r//#elif defined(DEBUG)\r//#define log(x)\r//#endif\r\r//#if 0\r//#endif\r\r//多行的define, \\是enter的转义，\\后不要打符号\r#define Main int main() {\\\r int a = 3;\\\rlog(a);\\\rreturn 0;\\\r}\rMain\r ","date":"2022-02-09","objectID":"/learning-cpp/:40:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"auto auto的一个用法，当类型很长时用auto代替，有时候可以这样写const auto\u0026 #include \u003ciostream\u003e\r#include \u003cfunctional\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\r//c++ 14\r auto func = [\u0026](int x) -\u003e int {\rreturn x + 1;\r};\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:41:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Static Arrays std::array 固定类型、固定长度 std::array的好处是具有STL特性，可以用STL函数 时间也很快 基本不占额外的空间 #include \u003ciostream\u003e\r#include \u003carray\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\r//int fun(std::array\u003cint, 3\u003e a) {\r// return (int) a.size();\r//}\r\r//一种不用传递数组大小也能知道数组大小的方式\r//template\u003ctypename T, size_t n\u003e\r//int fun(const T (\u0026arr)[n]) {\r// return (int) n;\r//}\r\rtemplate\u003ctypename T\u003e\rint fun(const T\u0026 a) {\rreturn (int) a.size();\r}\rint main() {\rstd::array\u003cint, 6\u003e data;\rdata[0] = 1;\rdata[1] = 2;\rint a[] = {1, 2, 3};\r//log(fun(a)); // 3\r log(fun(data)); // 6\r return 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:42:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Function Pointers #include \u003ciostream\u003e\r#include \u003carray\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid Print(int x) {\rlog(\"hello\");\rlog(x);\r}\rint main() {\rauto func = Print;\rfunc(5);\rvoid(*foo)(int);\rfoo = Print;\rfoo(6);\rtypedef void(*PrintFunction)(int);\rPrintFunction bar = Print;\rbar(7);\rreturn 0;\r}\r// hello\r// 5\r// hello\r// 6\r// hello\r// 7\r #include \u003ciostream\u003e\r#include \u003cvector\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid Print(int x) {\rlog(x);\r}\rvoid ForEach(const std::vector\u003cint\u003e\u0026 v, void(*func)(int)) {\rfor (int i : v) {\rfunc(i);\r}\r}\rint main() {\rstd::vector\u003cint\u003e v = {5, 4, 3, 2, 1};\rForEach(v, Print);\rreturn 0;\r}\r//5\r//4\r//3\r//2\r//1\r ","date":"2022-02-09","objectID":"/learning-cpp/:43:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"lambdas #include \u003ciostream\u003e\r#include \u003cvector\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid ForEach(const std::vector\u003cint\u003e\u0026 v, void(*func)(int)) {\rfor (int i : v) {\rfunc(i);\r}\r}\rint main() {\rstd::vector\u003cint\u003e v = {5, 4, 3, 2, 1};\rauto fun = [](int x){log(x);};\rForEach(v, fun);\rreturn 0;\r}\r//5\r//4\r//3\r//2\r//1\r 捕获（capture） [a, \u0026b] a通过复制捕获，b通过引用捕获 [this] 通过引用捕获当前对象 [\u0026] 通过引用捕获所有变量和当前对象 [=] 通过拷贝捕获所有变量，通过引用捕获当前对象 [] 不捕获 #include \u003ciostream\u003e\r#include \u003cvector\u003e\r#include \u003cfunctional\u003e\r#include \u003calgorithm\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid ForEach(const std::vector\u003cint\u003e\u0026 v, const std::function\u003cvoid(int)\u003e\u0026 func) { // 不加const报错\r for (int i : v) {\rfunc(i);\r}\r}\rint main() {\rstd::vector\u003cint\u003e v = {5, 4, 3, 2, 1};\rint a = 5;\rauto fun = [\u0026](int x){log(x);}; // 传值，也可以修改变量的值，要加mutable\r ForEach(v, fun);\rstd::find_if(v.begin(), v.end(), [\u0026](int val){return val \u003e 3;});\rreturn 0;\r}\r//5\r//4\r//3\r//2\r//1\r ","date":"2022-02-09","objectID":"/learning-cpp/:44:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Namespaces 命名空间是为了避免命名冲突 命名空间可以嵌套 类本身就是一个命名空间 #include \u003ciostream\u003e\r#include \u003cvector\u003e\r#include \u003cfunctional\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rnamespace apple {\rvoid Print(const char* text) {\rlog(text);\r}\r}\rnamespace orange {\rvoid Print(const char* text) {\rstd::string tmp = text;\rstd::reverse(tmp.begin(), tmp.end());\rlog(tmp);\r}\r}\rint main() {\rapple::Print(\"apple\");\rorange::Print(\"orange\");\r//using namespace apple;\r //using apple::Print;\r //namespace a = apple;\r\r// 两个namespace不能同时存在\r return 0;\r}\r//apple\r//egnaro\r ","date":"2022-02-09","objectID":"/learning-cpp/:45:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Threads #include \u003ciostream\u003e\r#include \u003cthread\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid DoWork() {\rwhile (true) {\rlog(\"working\");\rstd::cin.get();\r}\r}\rint main() {\rstd::thread worker(DoWork); // 在这里立即启动线程，并行运行\r worker.join(); //运行到这一步时，阻塞当前线程（主线程），等待这个线程执行完再回到主线程\r std::cin.get(); // 有了上面的join，在DoWork没有执行完是不会执行这一步的\r return 0;\r}\r//...\r 想实现按回车结束某个线程 #include \u003ciostream\u003e\r#include \u003cthread\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstatic bool is_finished = false;\rvoid DoWork() {\rusing namespace std::literals::chrono_literals;\rlog(std::this_thread::get_id());\rwhile (!is_finished) {\rlog(\"working\");\rstd::this_thread::sleep_for(1s);\r}\r}\rint main() {\rstd::thread worker(DoWork);\rstd::cin.get();\ris_finished = true;\rworker.join();\rstd::cin.get();\rreturn 0;\r}\r//2\r//working\r//working\r//working\r//working\r ","date":"2022-02-09","objectID":"/learning-cpp/:46:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Timing #include \u003ciostream\u003e\r#include \u003cthread\u003e\r#include \u003cchrono\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rusing namespace std::literals::chrono_literals;\rauto start = std::chrono::high_resolution_clock::now();\rstd::this_thread::sleep_for(1s);\rauto end = std::chrono::high_resolution_clock::now();\rstd::chrono::duration\u003cfloat\u003e duration = end - start;\rlog(duration.count());\rreturn 0;\r}\r//1.0006\r 一种更好的计算方式 #include \u003ciostream\u003e\r#include \u003cthread\u003e\r#include \u003cchrono\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct Timer {\rstd::chrono::time_point\u003cstd::chrono::steady_clock\u003e start, end;\rstd::chrono::duration\u003cfloat\u003e duration;\rTimer() {\rstart = std::chrono::steady_clock::now();\r}\r~Timer() {\rend = std::chrono::steady_clock::now();\rduration = end - start;\rstd::cout \u003c\u003c duration.count() * 1000 \u003c\u003c \" ms\" \u003c\u003c std::endl;\r}\r};\rvoid Print() {\rTimer timer;\rfor (int i = 0; i \u003c 100; ++i) {\rlog(\"hello world\"); // endl比'\\n'慢\r }\r}\rint main() {\rPrint();\rreturn 0;\r}\r//hello world\r//...\r// 37.1672 ms\r ","date":"2022-02-09","objectID":"/learning-cpp/:47:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Multidimensional Arrays 一维数组比多维数组好 待补 ","date":"2022-02-09","objectID":"/learning-cpp/:48:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Sorting sort中，true和false的意义 #include \u003ciostream\u003e\r#include \u003cvector\u003e\r#include \u003calgorithm\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rstd::vector\u003cint\u003e a = {2, 4, 5, 1, 3};\r// 让1排在最后\r std::sort(a.begin(), a.end(), [](int a, int b) {\rif (a == 1) return false; // false表示a在后，b在前，true相反\r if (b == 1) return true;\rreturn a \u003c b;\r});\rfor (int i : a) {\rstd::cout \u003c\u003c i \u003c\u003c ' ';\r}\rreturn 0;\r}\r//2 3 4 5 1\r ","date":"2022-02-09","objectID":"/learning-cpp/:49:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Type Punning 类型双关 #include \u003ciostream\u003e\r#include \u003cvector\u003e\r#include \u003calgorithm\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rint a = 5;\rdouble b = a; // 隐式转化，内存的内容改动\r log(b);\rdouble c = *(double *) \u0026a; // 内存的值不变，变成用double读取\r log(c);\rreturn 0;\r}\r//5\r//2.47033e-323\r ","date":"2022-02-09","objectID":"/learning-cpp/:50:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Unions 联合体中的变量内存值相同，只占一个变量的空间 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rstruct Union {\runion {\rfloat a;\rint b;\r};\r};\rUnion u;\ru.a = 2.0f;\rlog(u.a);\rlog(u.b);\rreturn 0;\r}\r//2\r//1073741824\r union的用法 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct Vector2d {\rfloat x, y;\r};\rstruct Vector4d {\runion { // anonymous\r struct { // anonymous\r float x, y, z, w;\r};\rstruct {\rVector2d a, b; // a的值就是x，y的值， b的值就是z，w的值\r };\r};\r};\rvoid PrintV2(const Vector2d\u0026 v) {\rstd::cout \u003c\u003c v.x \u003c\u003c ' ' \u003c\u003c v.y \u003c\u003c '\\n';\r}\rint main() {\rVector4d v4 = {1.0f, 2.0f, 3.0f, 4.0f};\rPrintV2(v4.a);\rPrintV2(v4.b);\rv4.z = 500.f;\rPrintV2(v4.a);\rPrintV2(v4.b);\rreturn 0;\r}\r//1 2\r//3 4\r//1 2\r//500 4\r ","date":"2022-02-09","objectID":"/learning-cpp/:51:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Virtual Destructors 和虚构造函数类似 虚函数在有子类的情况下通常都要考虑 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Base {\rpublic:\rBase() {\rlog(\"base constructor\");\r}\r~Base() {\rlog(\"base destructor\");\r}\r};\rclass Derived : public Base {\rpublic:\rDerived() {\rlog(\"derived constructor\");\r}\r~Derived() { // 对于基类不是重写，而是增加一个析构函数\r log(\"derived destructor\");\r}\r};\rint main() {\rBase* base = new Base();\rdelete base;\rlog(\"----------\");\rDerived* derived = new Derived();\rdelete derived;\rlog(\"----------\");\rBase* poly = new Derived();\rdelete poly;\rreturn 0;\r}\r//base constructor\r//base destructor\r//----------\r//base constructor\r//derived constructor\r//derived destructor\r//base destructor\r//----------\r//base constructor\r//derived constructor\r//base destructor\r 可以看到最后没有调用derived的析构函数，这可能造成内存泄露，比如在derived的构造函数中new内存，在derived的析构函数中delete，但是因为没有调用，所有没有释放（这种情况在堆上有） #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Base {\rpublic:\rBase() {\rlog(\"base constructor\");\r}\rvirtual ~Base() {\rlog(\"base destructor\");\r}\r};\rclass Derived : public Base {\rpublic:\rDerived() {\rlog(\"derived constructor\");\r}\r~Derived() { // 对于基类不是重写，而是增加一个析构函数\r log(\"derived destructor\");\r}\r};\rint main() {\rBase* base = new Base();\rdelete base;\rlog(\"----------\");\rDerived* derived = new Derived();\rdelete derived;\rlog(\"----------\");\rBase* poly = new Derived(); // 多态\r delete poly;\rreturn 0;\r}\r//base constructor\r//base destructor\r//----------\r//base constructor\r//derived constructor\r//derived destructor\r//base destructor\r//----------\r//base constructor\r//derived constructor\r//derived destructor\r//base destructor\r ","date":"2022-02-09","objectID":"/learning-cpp/:52:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Casting c++风格的casting比c风格的casting，好在如果你想要去掉casting，你要去搜索，在c里要搜索int，在c++里要搜索static_cast\u003cint\u003e，这比int好搜。另一个好处是编译器会做严格的检查 static_cast , dynamic_cast , reinterpret_cast, const_cast #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Base {\rpublic:\rBase() {}\rvirtual ~Base() {}\r};\rclass Derived : public Base {\rpublic:\rDerived() {}\r~Derived() {}\r};\rclass AnotherClass : public Base {\rpublic:\rAnotherClass(){};\r~AnotherClass(){};\r};\rint main() {\rDerived* derived = new Derived();\rBase* base = derived;\r//AnotherClass* ac = dynamic_cast\u003cAnotherClass*\u003e(base); // ac is null\r Derived* ac = dynamic_cast\u003cDerived*\u003e(base); // ac is not null\r // dynamic会在运行时检查\r return 0;\r}\r dynamic casting #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\r};\rclass Player : public Entity {\r};\rclass Enemy : public Entity {\r};\rint main() {\rPlayer* player = new Player();\rEntity* e = player; // ok\r Player* p = dynamic_cast\u003cPlayer*\u003e(e); // e可以是enemy，所以错了，但是在Entity加虚函数就行，多态\r return 0;\r}\r #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Entity {\rvirtual void Print() {}\r};\rclass Player : public Entity {\r};\rclass Enemy : public Entity {\r};\rint main() {\rPlayer* player = new Player();\rEntity* actuallyEnemy = new Enemy();\rEntity* actuallyPlayer = player;\rPlayer* p0 = dynamic_cast\u003cPlayer*\u003e(actuallyEnemy); //p0是null\r Player* p1 = dynamic_cast\u003cPlayer*\u003e(actuallyPlayer); // p1不是null\r // 之所以可以吧Entity类转化成功，是因为根本不用担心Entity是enemy，因为加了虚函数相当于Entity是个接口，Entity不会被实例化\r // Entity只能是Player或者Enemy，根据上文actuallyPlayer已经是player了，所以转换成功\r if (dynamic_cast\u003cPlayer*\u003e(actuallyEnemy)) { // 用if检查是否能转换\r\r}\rreturn 0;\r}\r dynamic_cast可以做到检查类型是因为它存储了RTTI（runtime type information） dynamic_cast 存储RTTI增加了开销，检查类型是否匹配也增加了开销 ","date":"2022-02-09","objectID":"/learning-cpp/:53:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Conditional and Action Breakpoints 在断点处设置条件，当条件为true时，触发断点 ","date":"2022-02-09","objectID":"/learning-cpp/:54:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Precompiled Headers ","date":"2022-02-09","objectID":"/learning-cpp/:55:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Benchmarking 怎样测试一个代码块的运行时间 #include \u003ciostream\u003e\r#include \u003cmemory\u003e\r#include \u003cchrono\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Timer {\rpublic:\rTimer() {\rstartTimePoint = std::chrono::steady_clock::now();\r}\r~Timer() {\rstop();\r}\rvoid stop() {\rauto endTimePoint = std::chrono::steady_clock::now();\rauto start = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(startTimePoint).time_since_epoch().count();\rauto end = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(endTimePoint).time_since_epoch().count();\rauto duration = end - start;\rstd::cout \u003c\u003c duration \u003c\u003c \" us\" \u003c\u003c std::endl;\r}\rprivate:\rstd::chrono::time_point\u003cstd::chrono::steady_clock\u003e startTimePoint;\r};\rint main() {\rint v = 0;\r{\rTimer timer;\rfor (int i = 0; i \u003c 1000000; ++i) { // 有时候编译器会对这段代码进行优化，直接得出结果，这样就测不出时间\r v += 2;\r}\r}\rlog(v);\r__debugbreak(); //手动打断点\r return 0;\r}\r share_ptr new unique_ptr性能对比 最好再release模式下测试，release比debug快，会减少很多不必要的东西 #include \u003ciostream\u003e\r#include \u003cmemory\u003e\r#include \u003cchrono\u003e\r#include \u003carray\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass Timer {\rpublic:\rTimer() {\rstartTimePoint = std::chrono::steady_clock::now();\r}\r~Timer() {\rstop();\r}\rvoid stop() {\rauto endTimePoint = std::chrono::steady_clock::now();\rauto start = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(startTimePoint).time_since_epoch().count();\rauto end = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(endTimePoint).time_since_epoch().count();\rauto duration = end - start;\rstd::cout \u003c\u003c duration \u003c\u003c \" us\" \u003c\u003c std::endl;\r}\rprivate:\rstd::chrono::time_point\u003cstd::chrono::steady_clock\u003e startTimePoint;\r};\rint main() {\rstruct V {\rfloat x, y;\r};\rlog(\"make share\");\r{\rstd::array\u003cstd::shared_ptr\u003cV\u003e, 1000\u003e sharePtrs;\rTimer timer;\rfor (int i = 0; i \u003c sharePtrs.size(); i++) {\rsharePtrs[i] = std::make_shared\u003cV\u003e();\r}\r}\rlog(\"new shared\");\r{\rstd::array\u003cstd::shared_ptr\u003cV\u003e, 1000\u003e sharePtrs;\rTimer timer;\rfor (int i = 0; i \u003c sharePtrs.size(); i++) {\rsharePtrs[i] = std::shared_ptr\u003cV\u003e(new V());\r}\r}\rlog(\"make unique\");\r{\rstd::array\u003cstd::unique_ptr\u003cV\u003e, 1000\u003e uniquePtrs;\rTimer timer;\rfor (int i = 0; i \u003c uniquePtrs.size(); i++) {\runiquePtrs[i] = std::make_unique\u003cV\u003e();\r}\r}\r//__debugbreak(); //手动打断点\r return 0;\r}\r//debug\r//make share\r//405 us\r//new shared\r//322 us\r//make unique\r//219 us\r//\r\r//release\r\r//make share\r//126 us\r//new shared\r//184 us\r//make unique\r//66 us\r ","date":"2022-02-09","objectID":"/learning-cpp/:56:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Structured Bindings c++17特性 处理多返回值问题 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003ctuple\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstd::tuple\u003cstd::string, int\u003e createPerson() {\rreturn {\"dyh\", 22};\r}\rint main() {\rauto [name, age] = createPerson();\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:57:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Optional Data std::optional c++17特性 optional修饰的数据可有可无 optional用法 #include \u003ciostream\u003e\r#include \u003cfstream\u003e\r#include \u003coptional\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstd::optional\u003cstd::string\u003e ReadFileAsString(const std::string\u0026 filepath) {\rstd::ifstream stream(filepath);\rif (stream) {\rstd::string result;\r// read file\r stream.close();\rreturn result;\r}\rreturn {};\r}\rint main() {\rstd::optional\u003cstd::string\u003e data = ReadFileAsString(\"data.txt\");\rstd::string value = data.value_or(\"not present\");\rif (data) { // if(data.has_value)\r log(\"read successfully\");\r} else {\r//std::string\u0026 string = *data;\r data.value();\rlog(\"file could not be opened\");\r}\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:58:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Multiple Types of Data in A Single Variable std::variant c++17特性 它和union的区别是，union的大小是最大变量的长度，variant的长度是每个类型长度和 #include \u003ciostream\u003e\r#include \u003cvariant\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rstd::variant\u003cstd::string, int\u003e data;\r// 要按这个顺序读取\r data = \"dyh\";\rlog(std::get\u003cstd::string\u003e(data));\rdata = 12;\rlog(std::get\u003cint\u003e(data));\rlog(data.index());\rif (auto val = std::get_if\u003cstd::string\u003e(\u0026data)) {\r// 如果不是string，返回NULL\r std::string\u0026 v = *val;\r}\rreturn 0;\r}\r//dyh\r//12\r//1\r variant在读取文件的应用 enum class ErrorCode {\rNone = 0, NotFound = 1, NotAccess = 2;\r};\rstd::variant\u003cstd::string, ErrorCode\u003e ReadFileAsStirng() {\rreturn {};\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:59:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Store Any Data std::any c++17特性 any和variant的区别，any会动态分配空间，variant要先指定类型 应该要多用variant，而不是any，variant是安全版的any #include \u003ciostream\u003e\r#include \u003cany\u003e\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rstd::any a;\ra = 2;\ra = \"hello\"; //const char*\r a = std::string(\"abc\");\rlog(std::any_cast\u003cstd::string\u003e(a));\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:60:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Make C++ Run Faster 用多线程 #include \u003ciostream\u003e\r#include \u003cfuture\u003e\r#include \u003cvector\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rnamespace Hazel {\rstatic std::mutex s_MeshMutex;\rstd::vector\u003cHazel::Ref\u003cHazel::Mesh\u003e\u003e m_Meshes;\r// void是因为LoadMesh的返回值是void\r std::vector\u003cstd::future\u003cvoid\u003e\u003e m_Futures;\r// 为什么string不传引用，这是生命周期的问题。线程函数参数按值传送，传拷贝，如果传引用要用Ref包裹，\r static void LoadMesh(std::vector\u003cRef\u003cMesh\u003e\u003e* meshes, std::string filepath) {\rauto mesh = Mesh::Load(filepath);\rstd::lock_guard\u003cstd::mutex\u003e lock(s_MeshMutex);\rmeshed-\u003epush_back(mesh);\r}\rvoid func() {\r#define ASYNC 1\r#if ASYNC\r // concurrent for-loop\r for (const auto\u0026 file : meshFilepaths) { // std::launch::async 在不同线程上工作, deferred是根据工作负载自动选线程\r // async返回std::future，要保留这个返回值，因为如果不保留，每次for循环结束后，async就会被摧毁（被析构），而析构需要等待LoadMesh结束，，这样就变成顺序执行\r m_Futures.push_back(std::async(std::launch::async, LoadMesh, \u0026m_Meshes, file));\r}\r#else\r // original for-loop\r for (const auto\u0026 file : meshFilepaths) {\rm_Meshes.push_back(Mesh::Load(file));\r}\r#endif\r\r}\r}\rint main() {\rreturn 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:61:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Make Strings Faster 使用string_view减少内存分配，本质是个指针 #include \u003ciostream\u003e\r#include \u003cstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstatic uint32_t s_AllocCount = 0;\rvoid* operator new(size_t size) {\rs_AllocCount++;\rstd::cout \u003c\u003c \"Allocating \" \u003c\u003c size \u003c\u003c \" bytes\\n\";\rreturn malloc(size);\r}\rvoid Print(const std::string\u0026 x) {\rlog(x);\r}\rvoid Print(std::string_view x) {\rlog(x);\r}\rint main() {\rstd::string name = \"yhdai\"; // 把string换成const char*更快，这样后面不需要加c_str()\r Print(name);\r//std::string firstName = name.substr(0, 2);\r //std::string lastName = name.substr(2, 3);\r log(s_AllocCount); // 0 不同编译器有不同结果\r //减少字符串分配的一种方法是用string_view，本质是一个指针\r std::string_view firstName(name.c_str(), 2);\rstd::string_view lastName(name.c_str() + 2, 3);\rPrint(firstName);\rPrint(lastName);\rreturn 0;\r}\r//yhdai\r//0\r//yh\r//dai\r ","date":"2022-02-09","objectID":"/learning-cpp/:62:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Track Memory Allocation the Easy Way #include \u003ciostream\u003e\r#include \u003cstring\u003e\r#include \u003cmemory\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rstruct AllocationMetrics {\ruint32_t TotalAllocated = 0;\ruint32_t TotalFreed = 0;\ruint32_t CurrentUsage() const {return TotalAllocated - TotalFreed;}\r};\rstatic AllocationMetrics allocationMetrics;\rvoid* operator new(size_t size) {\rallocationMetrics.TotalAllocated += size;\rreturn malloc(size);\r}\rvoid operator delete(void* memory, size_t size) {\rallocationMetrics.TotalFreed += size;\rfree(memory);\r}\rstatic void PrintMemoryUsage() {\rstd::cout \u003c\u003c \"memory usage: \" \u003c\u003c allocationMetrics.CurrentUsage() \u003c\u003c \" bytes\\n\";\r}\rstruct obj {\rint x, y, z;\r};\rint main() {\rPrintMemoryUsage();\rstd::string str = \"dddyyyhhh\";\rPrintMemoryUsage();\r{\rstd::unique_ptr\u003cobj\u003e ptr = std::make_unique\u003cobj\u003e();\rPrintMemoryUsage();\r}\rPrintMemoryUsage();\rreturn 0;\r}\r//memory usage: 0 bytes\r//memory usage: 0 bytes\r//memory usage: 12 bytes\r//memory usage: 0 bytes\r ","date":"2022-02-09","objectID":"/learning-cpp/:63:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Lvalues and Rvalues 通常人们会说左值是等号左边的值，右值是等号右边的值，这不一定对。 左值一般指某个地址的值，右值一般指一个没有地址的数据，暂时的数据 #include \u003ciostream\u003e\r\rint\u0026 func() {\rstatic int v = 10;\rreturn v;\r}\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rint a = 5;\rfunc() = 3; // func返回int\u0026可以，它是左值，返回int不行\r func() = a;\rreturn 0;\r}\r #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rint main() {\rint a = 5;\rint\u0026 b = a;\r//int\u0026 c = 3; // wrong 右值不能赋给左值引用\r const int\u0026 c = 3; // ok 等价于int tmp = 3; int\u0026 c = tmp;\r return 0;\r}\r 一种检查左值还是右值的方法，不加const的类型引用，这只接收左值，不接受右值，加上const都接收 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid Print(std::string\u0026 str) {\rstd::cout \u003c\u003c str \u003c\u003c std::endl;\r}\rvoid Print2(const std::string\u0026 str) {\rstd::cout \u003c\u003c str \u003c\u003c std::endl;\r}\rint main() {\r// a,b,c is lvalue, \"qwe\", \"asd\", a + b is rvalue\r std::string a = \"qwe\";\rstd::string b = \"asd\";\rstd::string c = a + b;\rPrint(a);\r//Print(a + b); // wrong\r Print2(a + b); return 0;\r}\r//qwe\r//qweasd\r 函数参数只接受右值，不接受左值，用\u0026\u0026 #include \u003ciostream\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rvoid Print(std::string\u0026\u0026 str) {\rstd::cout \u003c\u003c str \u003c\u003c std::endl;\r}\rvoid Print2(const std::string\u0026 str) {\rstd::cout \u003c\u003c str \u003c\u003c std::endl;\r}\rint main() {\r// a,b,c is lvalue, \"qwe\", \"asd\", a + b is rvalue\r std::string a = \"qwe\";\rstd::string b = \"asd\";\rstd::string c = a + b;\r//Print(a); // wrong\r Print(a + b);\rPrint(\"qwe\");\rreturn 0;\r}\r//qweasd\r//qwe\r ","date":"2022-02-09","objectID":"/learning-cpp/:64:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Move Semantics #include \u003ciostream\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass String {\rpublic:\rString() = default;\rString(const char *str) {\rprintf(\"created\\n\");\rm_size = strlen(str);\rm_data = new char[m_size];\rmemcpy(m_data, str, m_size);\r}\rString(const String\u0026 other) {\rprintf(\"copied\\n\");\rm_size = other.m_size;\rm_data = new char[m_size];\rmemcpy(m_data, other.m_data, m_size);\r}\r~String() {\rprintf(\"destroyed\");\rdelete m_data;\r}\rvoid Print() {\rfor (uint32_t i = 0; i \u003c m_size; ++i) {\rprintf(\"%c\", m_data[i]);\r}\rprintf(\"\\n\");\r}\rprivate:\rchar *m_data;\ruint32_t m_size;\r};\rclass Entity {\rpublic:\rEntity(const String\u0026 name) : m_name(name) {\r}\rvoid PrintName() {\rm_name.Print();\r}\rprivate:\rString m_name;\r};\rint main() {\rEntity entity(\"hello\");\rentity.PrintName();\rreturn 0;\r}\r//created\r//copied\r//hello\r 以上代码可以发现hello被分配了两次，一次在main函数里，一次在String的构造函数的new里，hello会在Entity的String m_name里被拷贝（通过new）。那么是否有方法在main函数里分配一次，然后把这段内存“移动”（实际数据并不是真正移动了）到Entity的String m_name里？ 这样实现move #include \u003ciostream\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass String {\rpublic:\rString() = default;\rString(const char *str) {\rprintf(\"created\\n\");\rm_size = strlen(str);\rm_data = new char[m_size];\rmemcpy(m_data, str, m_size);\r}\rString(const String\u0026 other) {\r// 深拷贝\r printf(\"copied\\n\");\rm_size = other.m_size;\rm_data = new char[m_size];\rmemcpy(m_data, other.m_data, m_size);\r}\rString(String\u0026\u0026 other) noexcept { // 只能传右值，右值优先选这个函数\r // implement MOVE\r //相当于直接占据那块内存，指针指向那块内存，原来的指针（other）让它失效(因为析构里有delete)\r printf(\"moved\");\rm_size = other.m_size;\rm_data = other.m_data;\rother.m_size = 0;\rother.m_data = nullptr;\r}\r~String() {\rprintf(\"destroyed\\n\");\rdelete m_data;\r}\rvoid Print() {\rfor (uint32_t i = 0; i \u003c m_size; ++i) {\rprintf(\"%c\", m_data[i]);\r}\rprintf(\"\\n\");\r}\rprivate:\rchar *m_data;\ruint32_t m_size;\r};\rclass Entity {\rpublic:\rEntity(const String\u0026 name) : m_name(name) {\r}\rEntity(String\u0026\u0026 name) : m_name(name) { //只传右值，右值优先选这个函数\r\r}\rvoid PrintName() {\rm_name.Print();\r}\rprivate:\rString m_name;\r};\rint main() {\rEntity entity(\"hello\");\rentity.PrintName();\rreturn 0;\r}\r//created\r//copied\r//destroyed\r//hello\r//destroyed\r 但是还是有copy，这是因为还是使用了String(const String\u0026 other)，应该使用Entity(String\u0026\u0026 name) : m_name((String\u0026\u0026) name) 或者Entity(String\u0026\u0026 name) : m_name(std::move(name)) #include \u003ciostream\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass String {\rpublic:\rString() = default;\rString(const char *str) {\rprintf(\"created\\n\");\rm_size = strlen(str);\rm_data = new char[m_size];\rmemcpy(m_data, str, m_size);\r}\rString(const String\u0026 other) {\r// 深拷贝\r printf(\"copied\\n\");\rm_size = other.m_size;\rm_data = new char[m_size];\rmemcpy(m_data, other.m_data, m_size);\r}\rString(String\u0026\u0026 other) noexcept { // 只能传右值，右值优先选这个函数\r // implement MOVE\r //相当于直接占据那块内存，指针指向那块内存，原来的指针（other）让它失效(因为析构里有delete)\r printf(\"moved\\n\");\rm_size = other.m_size;\rm_data = other.m_data;\rother.m_size = 0;\rother.m_data = nullptr;\r}\r~String() {\rprintf(\"destroyed\\n\");\rdelete m_data;\r}\rvoid Print() {\rfor (uint32_t i = 0; i \u003c m_size; ++i) {\rprintf(\"%c\", m_data[i]);\r}\rprintf(\"\\n\");\r}\rprivate:\rchar *m_data;\ruint32_t m_size;\r};\rclass Entity {\rpublic:\rEntity(const String\u0026 name) : m_name(name) {\r}\rEntity(String\u0026\u0026 name) : m_name((String\u0026\u0026) name) { //只传右值，右值优先选这个函数\r\r}\rvoid PrintName() {\rm_name.Print();\r}\rprivate:\rString m_name;\r};\rint main() {\rEntity entity(\"hello\");\rentity.PrintName();\rreturn 0;\r}\r//created\r//moved\r//destroyed\r//hello\r//destroyed\r ","date":"2022-02-09","objectID":"/learning-cpp/:65:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Move move把一个对象“移到”一个地方 #include \u003ciostream\u003e\r#include \u003ccstring\u003e\r\r#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl\r\rclass String {\rpublic:\rString() = default;\rString(const char *str) {\rprintf(\"created\\n\");\rm_size = strlen(str);\rm_data = new char[m_size];\rmemcpy(m_data, str, m_size);\r}\rString(const String\u0026 other) {\r// 深拷贝\r printf(\"copied\\n\");\rm_size = other.m_size;\rm_data = new char[m_size];\rmemcpy(m_data, other.m_data, m_size);\r}\rString(String\u0026\u0026 other) noexcept { // 只能传右值，右值优先选这个函数\r // implement MOVE\r //相当于直接占据那块内存，指针指向那块内存，原来的指针（other）让它失效(因为析构里有delete)\r printf(\"moved\\n\");\rm_size = other.m_size;\rm_data = other.m_data;\rother.m_size = 0;\rother.m_data = nullptr;\r}\rString\u0026 operator=(String\u0026\u0026 other) noexcept {\rprintf(\"moved\\n\");\rif (this != \u0026other) { // 防止 a = std::move(a);\r delete [] m_data;\rm_size = other.m_size;\rm_data = other.m_data;\rother.m_size = 0;\rother.m_data = nullptr;\r}\rreturn *this;\r}\r~String() {\rprintf(\"destroyed\\n\");\rdelete m_data;\r}\rvoid Print() {\rfor (uint32_t i = 0; i \u003c m_size; ++i) {\rprintf(\"%c\", m_data[i]);\r}\rprintf(\"\\n\");\r}\rprivate:\rchar *m_data;\ruint32_t m_size;\r};\rclass Entity {\rpublic:\rEntity(const String\u0026 name) : m_name(name) {\r}\rEntity(String\u0026\u0026 name) : m_name(std::move(name)) { //只传右值，右值优先选这个函数\r\r}\rvoid PrintName() {\rm_name.Print();\r}\rprivate:\rString m_name;\r};\rint main() {\rEntity entity(\"hello\");\rentity.PrintName();\rString s = \"world\";\rString t = std::move(s);\r//s.Print(); // wrong s is moved\r //t = s; // wrong\r\rputs(\"\");\rString apple = \"Apple\";\rString q;\r//q = apple; // wrong\r q = std::move(apple); // ok\r String w = apple; // ok 没有用到等号运算符，用构造函数\r String e = std::move(apple); // ok 用move版构造函数\r return 0;\r}\r ","date":"2022-02-09","objectID":"/learning-cpp/:66:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"How to Learn C++ 看需要的或感兴趣的开源项目 ","date":"2022-02-09","objectID":"/learning-cpp/:67:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Conclusions 不会真有人不学rust学c++吧😅 ","date":"2022-02-09","objectID":"/learning-cpp/:68:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note","courses"],"content":"tf-idf","date":"2021-10-05","objectID":"/tf-idf/","tags":["cs"],"title":"tf-idf","uri":"/tf-idf/"},{"categories":["note","courses"],"content":"记录一下tf-idf TF-IDF（term frequency–inverse document frequency）是一种用于信息检索与数据挖掘的常用加权技术。TF为词频，定义为 $$ TF_i = \\frac{n_i}{n} $$ 其中TFi为第i种单词的TF值，ni为该文档中第i种单词出现的频数，n为文档的总单词数 IDF为逆文档频率，定义为 $$ IDF_i = \\log\\frac{F}{F_w} $$ 其中IDF为第i种单词的idf值，F是语料库文档数量，Fw是包含这个单词的文档数量， $$ (TF-IDF)_i = TF_i * IDF_i $$ 可以看出tf-idf值越小，这个词越常用 信息检索系统的作业是：试按tf-idf算法在剔除一些常用词后给出文本中术语的统计算法和程序，并按降序进行排序 # encoding=utf-8\r import jieba\rimport re\rimport os\rimport math\rpunc_reg = '\\u3002|\\uff1f|\\uff01|\\uff0c|\\u3001|\\uff1b|\\uff1a|\\u201c|\\u201d|\\u2018|\\u2019|\\uff08|\\uff09|\\u300a|\\u300b|\\u3008|\\u3009|\\u3010|\\u3011|\\u300e|\\u300f|\\u300c|\\u300d|\\ufe43|\\ufe44|\\u3014|\\u3015|\\u2026|\\u2014|\\uff5e|\\ufe4f|\\uffe5'\rclass Article:\rdef __init__(self, content):\rself.content = content\rdef cut_word(self):\rself.cut_result = list(jieba.cut(self.content))\rtmp_result = []\rfor word in self.cut_result:\rif re.match(punc_reg, word) == None:\rtmp_result.append(word)\rself.cut_result = tmp_result\rdef cal_tf(self):\rself.tf = {}\rsz = len(self.cut_result)\rfor word in self.cut_result:\rif word not in self.tf.keys():\rself.tf[word] = 1\relse:\rself.tf[word] += 1\rfor word in self.tf:\rself.tf[word] = float(self.tf[word] / sz)\rdef cal_tf_idf(self):\rself.tf_idf = {}\rfor word in self.tf:\rself.tf_idf[word] = self.tf[word] * idf[word]\rdef get_result(self):\rtmp_list = list(zip(self.tf_idf.keys(), self.tf_idf.values()))\rtmp_list = sorted(tmp_list, key=lambda x : x[1], reverse=True)\rprint('----------------------------')\rfor i in range(20):\rprint(tmp_list[i][0], tmp_list[i][1])\rprint('----------------------------')\rprint()\rdef cal_idf():\rfor article in articles:\rfor word in article.cut_result:\ridf[word] = 1\rfor word in idf:\rfor article in articles:\rif word in article.cut_result:\ridf[word] += 1\rfor word in idf:\ridf[word] -= 1\rsz = len(articles)\rfor word in idf:\ridf[word] = math.log(sz / idf[word])\rdef read_content():\rpath = 'material/Chinese article'\rfiles = os.listdir(path)\rfor file in files:\rwith open(str(path + '/' + file), encoding='utf-8') as f:\rdata = f.read()\rarticle = Article(data)\rarticles.append(article)\rdef work():\rfor article in articles:\rarticle.cut_word()\rarticle.cal_tf()\rcal_idf()\rfor article in articles:\rarticle.cal_tf_idf()\rarticle.get_result()\rif __name__ == '__main__':\ridf = {}\rarticles = []\rread_content()\rwork()\r 其中一篇文章的测试效果 ","date":"2021-10-05","objectID":"/tf-idf/:0:0","tags":["cs"],"title":"tf-idf","uri":"/tf-idf/"},{"categories":["problemlist"],"content":"每日一题 (CF)","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"扫描线 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:1:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给N个区间，N\u003c=2e5，区间长度最大1e9，对于每个区间，区间里面的每个数+1，求数字分别为1,2,3…N的id个数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:1:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 如果区间长度很小，可以直接做。区间长度很大时，就类似于分段处理，用扫描线。把区间端点排序，求在当前端点到下一个端点这个区间内数字为多少。 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main() {\rint n;\rcin \u003e\u003e n;\rvector\u003cint\u003e a(n + 1);\rvector\u003cpair\u003cint, int\u003e\u003e v;\rfor (int i = 0; i \u003c n; ++i) {\rint l, r;\rcin \u003e\u003e l \u003e\u003e r;\rr += l;\rv.emplace_back(l, 1);\rv.emplace_back(r, -1);\r}\rsort(v.begin(), v.end());\rint cnt = 0;\rfor (int i = 0; i \u003c (int) v.size() - 1; ++i) {\rcnt += v[i].second;\ra[cnt] += v[i + 1].first - v[i].first;\r}\rfor (int i = 1; i \u003c= n; ++i) {\rcout \u003c\u003c a[i] \u003c\u003c \" \\n\"[i == n];\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:1:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"贪心 实现 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:2:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 电影院座位有n行m列，给座位编号从上到下，从左到右为1,2,3,…nm，给nm个人安排座位，每个人的视力为ai，安排座位需要满足对于任意两个座位i,j上的人的视力ai,aj满足i \u003c j 时一定ai \u003c aj，每个人按自己的id顺序坐进去。首先，ta来到自己被安排座位的那一行，然后从左开始往右走。每个人的不方便度为ta从左走向自己座位时需要经过多少个已经在座位上的人，求不方便度总和的最小值 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:2:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 按视力排序，对于同一个视力的人，将小的id尽可能地排在最上面和最右边 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main() {\rios::sync_with_stdio(false);\rcin.tie(nullptr);\rcout.tie(nullptr);\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rmap\u003cint, vector\u003cint\u003e\u003e mp;\rint n, m;\rcin \u003e\u003e n \u003e\u003e m;\rvector\u003cvector\u003cint\u003e\u003e id(n + 1, vector\u003cint\u003e(m + 1));\rfor (int i = 1; i \u003c= n * m; ++i) {\rint t;\rcin \u003e\u003e t;\rmp[t].push_back(i);\r}\rfor (auto\u0026 i : mp) {\rsort(i.second.rbegin(), i.second.rend());\r}\rint rem = m;\rint row = 1;\rfor (const auto\u0026 i : mp) {\rauto cnt = i.second;\rwhile (!cnt.empty()) {\rif (rem \u003e= (int) cnt.size()) {\rfor (int j = m - rem + (int) cnt.size(); !cnt.empty(); --j) {\rid[row][j] = cnt.back();\rcnt.pop_back();\rrem--;\r}\r}else {\rfor (int j = m; rem \u003e 0; --j) {\rid[row][j] = cnt.back();\rcnt.pop_back();\rrem--;\r}\rrem = m;\rrow++;\r}\r}\r}\rint ans = 0;\rfor (int i = 1; i \u003c= n; ++i) {\rvector\u003cint\u003e vt;\rfor (int j = 1; j \u003c= m; ++j) {\rint num = 0;\rauto ite = lower_bound(vt.begin(), vt.end(), id[i][j]);\rnum = ite - vt.begin();\rvt.insert(ite, id[i][j]);\rans += num;\r}\r}\rcout \u003c\u003c ans \u003c\u003c '\\n';\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:2:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"构造 数学 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:3:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给数n（3-1e9）和k（3-1e5），构造出k个数，和为n，lcm不超过n/2 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:3:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 刚开始想了个fake算法：构造成a,a,a,a,….b 实际上可以构造成1,1,1,1,1…a,b,c （长度大于2） 假设a+b+c=m，如果m是奇数，就是1, m/2, m/2，如果m是偶数可以2, (m-2)/2, (m-2)/2，但是这样(m-2)/2可能是奇数。可以发现当(m-2)/2是奇数时，m为4的倍数，所以这样构造m/2, m/4, m/4 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n, k;\rcin \u003e\u003e n \u003e\u003e k;\rif (n % k == 0) {\rfor (int i = 0; i \u003c k; ++i) {\rcout \u003c\u003c n / k \u003c\u003c \" \\n\"[i == k - 1];\r}\r}else {\rint a, b, c;\rn -= (k - 3);\rif (n % 2 == 1) {\ra = 1;\rb = c = n / 2;\r}else if (n % 4 == 0) {\ra = n / 2;\rb = n / 4;\rc = n / 4;\r}else {\ra = 2;\rb = c = (n - 2) / 2;\r}\rcout \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c ' ' \u003c\u003c c \u003c\u003c ' ';\rfor (int i = 0; i \u003c k - 3; ++i) {\rcout \u003c\u003c 1 \u003c\u003c \" \\n\"[i == k - 4];\r}\r}\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:3:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"构造 贪心 欧拉路径 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:4:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给数n（2e5）和k（26），构造长度为n的字符串，字符串只能出现前k种字母，使得它的cost最小，cost定义为num(i, j) [s[i] == s[j] \u0026\u0026 s[i+1] == s[j+1]] ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:4:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 最直接的方法是查看每个字符可以向哪些字符转移，这样就画出一个dfa，然后求欧拉路径，另一种方法是贪心。（假设k=4） 先写下a，然后查看a与哪个字母未匹配，发现a与a未匹配，所以字符串为aa，对于第2个a，只能与b匹配，字符串为aab，b与a未匹配，字符串为aaba，a与c未匹配，字符串为aabac，c与a未匹配，字符串为aabaca，a与d未匹配，字符串为aabacad，d与a未匹配，但是如果d与a匹配了，a匹配满了就只能重复之前的匹配，所以贪心选择d与b匹配，字符串为aabacadb，b与b未匹配，字符串为aabacadbb，所以cost为0的字符串为aabacadbbcbdccdd，最后再加一个a，发现最后一个a可以作为字符串的开始，作为下一个循环 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rint main() {\rint n, k;\rcin \u003e\u003e n \u003e\u003e k;\rstring s;\rfor (int i = 0; i \u003c k; ++i) {\rs += char('a' + i);\rfor (int j = i + 1; j \u003c k; ++j) {\rs += char('a' + i);\rs += char('a' + j);\r}\r}\rfor (int i = 0; i \u003c n; ++i) {\rcout \u003c\u003c s[i % (k * k)];\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:4:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"构造 贪心 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:5:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给长度为n（2e5）的01串，构造两个长度为n的字符串a、b，满足a、b为括号序列，如果第i个为0，则对应位的括号不同，为1则相同，a、b都是合法的括号序列 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:5:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 一开始想了个fake的贪心，记录当前剩余左括号个数，然后分情况讨论，贪心地增加左括号，没法增加左括号就增加右括号，后来发现反例a=’(())()'， b=’((()))’ 可以发现0的个数必须是偶数，这样1的个数也是偶数，将1的前半部分填’('，后半部分填’)'，对于0，则交错填a:')'，b:'(‘和a:'('，b:')'，填的时候记录还有多少个左括号未匹配，如果为负数就是不存在 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n;\rcin \u003e\u003e n;\rstring s;\rcin \u003e\u003e s;\rint n0, n1;\rn0 = n1 = 0;\rbool ok = true;\rfor (int i = 0; i \u003c n; ++i) {\rif (s[i] == '1') n1++; else n0++;\r}\rif (n0 % 2 != 0 or n1 % 2 != 0) {\rputs(\"no\");\rcontinue;\r}\rint up = 0, down = 0;\rint cnt = 0;\rstring ans1, ans2;\rbool nor = true;\rfor (int i = 0; i \u003c n; ++i) {\rif (s[i] == '1') {\rcnt++;\rif (cnt * 2 \u003c= n1) {\rans1 += '(';\rans2 += '(';\rup++;\rdown++;\r} else {\rans1 += ')';\rans2 += ')';\rup--;\rdown--;\r}\r} else {\rif (nor) {\rans1 += ')';\rans2 += '(';\rup--;\rdown++;\rnor ^= 1;\r} else {\rans1 += '(';\rans2 += ')';\rup++;\rdown--;\rnor ^= 1;\r}\r}\rif (up \u003c 0 or down \u003c 0) {\rok = false;\rbreak;\r}\r}\rif (ok and up != 0 or down != 0) {\rputs(\"no\");\r}else if (ok) {\rputs(\"yes\");\rcout \u003c\u003c ans1 \u003c\u003c '\\n' \u003c\u003c ans2 \u003c\u003c '\\n';\r}\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:5:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"图 模拟 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:6:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给一棵树，每次操作删除当前树的所有叶子，求k次操作后剩下几个节点 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:6:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 存度数模拟 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n, k;\rcin \u003e\u003e n \u003e\u003e k;\rif (n == 1) {\rputs(\"0\");\rcontinue;\r}\rvector\u003cint\u003e G[n + 1];\rint degree[n + 1];\rmemset(degree, 0, sizeof(degree));\rbool used[n + 1];\rmemset(used, 0, sizeof(used));\rfor (int i = 0; i \u003c n - 1; ++i) {\rint u, v;\rcin \u003e\u003e u \u003e\u003e v;\rG[u].push_back(v);\rG[v].push_back(u);\rdegree[u]++;\rdegree[v]++;\r}\rqueue\u003cint\u003e q;\rfor (int i = 1; i \u003c= n; ++i) {\rif (degree[i] == 1) q.push(i), used[i] = true;\r}\rint cut_num = 0;\rwhile (k--) {\rif (cut_num == n) break;\rint sz = (int) q.size();\rcut_num += sz;\rwhile (sz--) {\rauto tmp = q.front();\rq.pop();\rfor (int i : G[tmp]) {\rif (used[i]) continue;\rif (--degree[i] \u003c= 1) {\rq.push(i);\rused[i] = true;\r}\r}\r}\r}\rcout \u003c\u003c n - cut_num \u003c\u003c '\\n';\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:6:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"二分 交互 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:7:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有一个数组由0和1组成，每次可以查询一个区间的和，使用不超过20次查询求出从左往右的第k个0的位置 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:7:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint n, t, k;\rint ask(int l, int r) {\rint ret ;\rcout \u003c\u003c \"? \" \u003c\u003c l \u003c\u003c ' ' \u003c\u003c r \u003c\u003c endl;\rcout.flush();\rcin \u003e\u003e ret;\rreturn ret;\r}\rint query(int l, int r, int th) {\rif (l == r and ask(l, r) == 0) {\rreturn l;\r}\rint one = ask(l, l + (r - l) / 2);\rif ((r - l) / 2 + 1 - one \u003e= th) {\rreturn query(l, l + (r - l) / 2, th);\r} else {\rreturn query(l + (r - l) / 2 + 1, r, th - (r - l) / 2 - 1 + one);\r}\r}\rint main() {\rcin \u003e\u003e n \u003e\u003e t;\rcin \u003e\u003e k;\rint ans = query(1, n, k);\rcout \u003c\u003c \"! \" \u003c\u003c ans \u003c\u003c endl;\rcout.flush();\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:7:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"记忆化搜索 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:8:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有n个平面从左往右放置，一个粒子会以衰竭时间k打到平面上。粒子打到平面上会产生两种效果，以相同衰竭时间穿过平面到达下一个平面，产生一个反方向，衰竭时间-1的粒子到达之前的平面。衰竭时间为1的粒子不会产生反射粒子。求一个衰竭时间为k的粒子从左往右打到第一个平面总共会产生几个粒子 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:8:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 模拟粒子的穿过和反射操作，递归搜索，记忆化搜索，用dp[i][j][k]表示一个衰竭时间为j的粒子以k方向打到第i个平面产生的粒子数，搜索时分情况讨论 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9 + 7;\rconst int maxn = 1005;\rll dp[maxn][maxn][2]; //0 is -\u003e , 1 is \u003c-\rint n, k;\rll dfs(int id, int da, int dir) {\rif (dp[id][da][dir] != -1) {\rreturn dp[id][da][dir];\r}\rll ans = 0;\rif (dir == 0) {\rif (id == 1) {\rif (da != 1) {\rans += (1 + dfs(id + 1, da, 0));\rans %= mod;\r}\r}else if (id == n) {\rif (da != 1) {\rans += (1 + dfs(id - 1, da - 1, 1));\rans %= mod;\r}\r}else {\rif (da != 1) {\rans += (1 + dfs(id + 1, da, 0));\rans %= mod;\rans += dfs(id - 1, da - 1, 1);\rans %= mod;\r}\r}\r}else { // dir == 1\r if (id == 1) {\rif (da != 1) {\rans += (1 + dfs(id + 1, da - 1, 0));\rans %= mod;\r}\r}else if (id != n) {\rif (da != 1) {\rans += (1 + dfs(id - 1, da, 1));\rans %= mod;\rans += dfs(id + 1, da - 1, 0);\rans %= mod;\r}\r}\r}\rdp[id][da][dir] = ans;\rreturn ans;\r}\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rmemset(dp, -1, sizeof(dp));\rcin \u003e\u003e n \u003e\u003e k;\rif (n == 1) {\rif (k == 1) {\rputs(\"1\");\r}else puts(\"2\");\rcontinue;\r}\rcout \u003c\u003c 1 + dfs(1, k, 0) \u003c\u003c '\\n';\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:8:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"dfs lca ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:9:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给一棵树，每个节点有权值，给一个数k，求是否满足删掉1~k-1条边，让连通块的异或和相等 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:9:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 这题是我近期来做得最久的一道题，基本都在debug，就各种思维漏洞🤡 由异或的性质想到如果连通块是偶数就是0，奇数假设是x 所以如果每个值异或和为0就存在，如果为x就要判断是否能划成奇数个，每个是x，容易发现只要考虑能否被划分成3个就行 在一开始我想到删掉一条边就相当于把这条边所连节点的子树划出去，所以只需要求每个子树的异或和，然后看是否有两个同值就行（首先你要假设一个根） 这是我犯的第一个错，因为如果删除的两条边在一条链上就不满足上面的条件 所以我想那就把这种情况也考虑进去，如果删除的两条边在一条链上，那么我只需要找一棵子树异或和为0，然后看这棵子树的子树有没有异或和为x的，这是正确的 然后是我犯的第二个错误，如果要分成三个连通块就要特判k\u003e2 接下来是我犯的第三个错误，之前说到看两个子树的异或和是否有同值，这是错的。如果子树是另一个子树的子树就不行，所以这种情况需要满足两个子树不相交 我想那就把这部分补上，我便考虑求一棵树上是否存在两个节点，值相同且没有祖先后代关系 我想这可以用dfs解决，首先求每个值出现几次，然后dfs过程求每个值最多出现几次（因为dfs序，所以遍历过程一定满足祖先后代关系），如果有最多出现次数小于总次数就存在 但是这个方法单独运行应该不会超时（X），反正最后超时了 然后我想其实这个更特殊要求子树异或和为x，所以把异或和为x的节点抽出来，暴力lca判断（直觉上时间应该短） 最后居然跑得比最开始交的代码还快，属于是用空间换时间了 不过真正优美的做法肯定不是这样的━┳━　━┳━ hh 保留debug痕迹，时刻提醒自己思维要严谨 #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\rtemplate \u003ctypename A, typename B\u003e\rstring to_string(pair\u003cA, B\u003e p) {\rreturn \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\r}\rtemplate \u003ctypename A, typename B, typename C\u003e\rstring to_string(tuple\u003cA, B, C\u003e p) {\rreturn \"(\" + to_string(get\u003c0\u003e(p)) + \", \" + to_string(get\u003c1\u003e(p)) + \", \" + to_string(get\u003c2\u003e(p)) + \")\";\r}\rtemplate \u003ctypename A, typename B, typename C, typename D\u003e\rstring to_string(tuple\u003cA, B, C, D\u003e p) {\rreturn \"(\" + to_string(get\u003c0\u003e(p)) + \", \" + to_string(get\u003c1\u003e(p)) + \", \" + to_string(get\u003c2\u003e(p)) + \", \" + to_string(get\u003c3\u003e(p)) + \")\";\r}\rvoid debug_val() {cerr \u003c\u003c '\\n';}\rtemplate \u003ctypename Head, typename... Tail\u003e\rvoid debug_val(Head H, Tail... T) {\rcerr \u003c\u003c \" \" \u003c\u003c to_string(H);\rdebug_val(T...);\r}\r#ifdef LOCAL\r#define debug(...) cerr \u003c\u003c \"[\" \u003c\u003c #__VA_ARGS__ \u003c\u003c \"]:\", debug_val(__VA_ARGS__)\r#define split() cerr \u003c\u003c \"===============================================\" \u003c\u003c '\\n'\r#define timeused() cerr \u003c\u003c \"time_used: \" \u003c\u003c t_clock - s_clock \u003c\u003c '\\n'\r#endif\r\rconst int maxn = 100005;\rvector\u003cint\u003e G[maxn];\rint xor_sum[maxn];\rint n, k;\rint val[maxn];\rint a;\rint par[maxn];\runordered_map\u003cint, int\u003e mp[maxn];\rvoid dfs(int x, int p) {\rpar[x] = p;\rif ((int) G[x].size() == 1 and G[x][0] == p) {\rxor_sum[x] = val[x];\rreturn;\r}\rfor (int i : G[x]) {\rif (i == p) continue;\rdfs(i, x);\rxor_sum[x] ^= xor_sum[i];\r}\rxor_sum[x] ^= val[x];\r}\rbool dfs2(int x, int p) {\rif ((int) G[x].size() == 1 and G[x][0] == p) {\rreturn val[x] == a;\r}\rfor (int i : G[x]) {\rif (i == p) continue;\rif (xor_sum[i] == a) return true;\r//else return dfs2(i, x); wrong\r else {\rif (dfs2(i, x)) return true;\r}\r}\rreturn false;\r}\r//unordered_map\u003cint, int\u003e col_num;\r//unordered_map\u003cint, int\u003e mx_col_num;\r//unordered_map\u003cint, int\u003e cur_col_num;\r\r//void dfs3(int x, int p) {\r// if (xor_sum[x] == a) {\r// cur_col_num[xor_sum[x]]++;\r// mx_col_num[xor_sum[x]] = max(mx_col_num[xor_sum[x]], cur_col_num[xor_sum[x]]);\r// }\r// for (int i : G[x]) {\r// if (i == p) continue;\r// dfs3(i, x);\r// }\r// if (xor_sum[x] == a) {\r// cur_col_num[xor_sum[x]]--;\r// }\r//}\r//\r//bool sol() {\r// for (int i = 1; i \u003c= n; ++i) {\r// col_num[xor_sum[i]]++;\r// }\r// dfs3(1, 0);\r// for (int i = 1; i \u003c= n; ++i) {\r// if (xor_sum[i] != a) continue;\r// if (mx_col_num[xor_sum[i]] \u003c col_num[xor_sum[i]]) return true;\r// }\r// return false;\r//}\r\rint root;\rint parent[20][maxn];\rint depth[maxn];\rvoid dfs(int v,int p,int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i=0;i\u003cG[v].size();i++){\rif(G[v][i]!=p) dfs(G[v][i],v,d+1);\r}\r}\rvoid init(int V){\rdfs(root,-1,0);\rfor(int k=0;k+1\u003c20;k++){\rfor(int v=0;v\u003cV;v++){\rif(parent[k][v]\u003c0) parent[k+1][v]=-1;\relse parent[k+1][v]=parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u]\u003edepth[v]) swap(u,v);\rfor(int k=0;k\u003c20;k++){\rif((depth[v]-depth[u])\u003e\u003ek\u00261) v=parent[k][v];\r}\rif(u==v) return u;\rfor(int k=20-1;k\u003e=0;k--){\rif(parent[k][u]!=parent[k][v]){\ru=parent[k][u];\rv=parent[k][v];\r}\r}\rreturn parent[0][u];\r}\rbool sol() {\rroot = 1;\rinit(n + 1);\rvector\u003cint\u003e tmp;\rfor (int i = 2; i \u003c= n; ++i) {\rif (xor_sum[i] == a)\rtmp.push_back(i);\r}\rfor (int i = 0; i \u003c (int) tmp.size(); ++i) {\rfor (int j = i + 1; j \u003c (int) tmp.size(); ++j) {\rint cp = lca(tmp[i], tmp[j]);\rif (cp != tmp[i] and cp != tmp[j]) return true;\r}\r}\rreturn false;\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:9:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"组合 推理 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:10:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有n对数，每对数有两个属性a、b，选出三对数使得a属性完全不同或b属性完全不同，求方案数（题目保证没有完全相同的数对） ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:10:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 全部方案数-不满足的方案数，由于题目保证没有完全相同的数对，所以a属性只有两个相同，不可能有三个相同。不满足的方案数为a属性有两个相同且b属性有两个相同，即(x,y) (x,z) (q,y)/(q,z)，然后就容易推导出公式。注意long long #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main() {\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\rll n;\rcin \u003e\u003e n;\rvector\u003cll\u003e a(n + 1), b(n + 1);\runordered_map\u003cll, vector\u003cll\u003e\u003e mp1;\runordered_map\u003cll, vector\u003cll\u003e\u003e mp2;\rfor (ll i = 1; i \u003c= n; ++i) {\rcin \u003e\u003e a[i] \u003e\u003e b[i];\rmp1[a[i]].push_back(b[i]);\rmp2[b[i]].push_back(a[i]);\r}\rll ans;\rans = n * (n - 1) * (n - 2) / 6;\rll tmp = 0;\rfor (auto i : mp1) {\rll sz = (ll) i.second.size();\rfor (auto j : i.second) {\rif (mp2.find(j) != mp2.end())\rtmp += ((ll) mp2[j].size() - 1) * (sz - 1);\r}\r}\r//cout \u003c\u003c tmp \u003c\u003c '\\n';\r ans -= tmp;\rcout \u003c\u003c ans \u003c\u003c '\\n';\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:10:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"dp ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:11:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有n把椅子n=5000，从左往右排，有m个人坐在椅子上，每个人只能坐一把椅子，m\u003cn/2，你需要一个接一个让每个人移动到空座位上，移动的代价是椅子距离，最后使得每个刚开始有人占据的椅子都是空的，求最小代价 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:11:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 如果n小的话可以直接用二分图匹配。因为移动后每个人的相对顺序不变，考虑O(n^2)做法，考虑用dp来调度。 dp[i][j]表示前i个人坐前j个空座位的最小代价 dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + 第i个人和第j个空座位的距离) 最后输出dp[人数][空椅子数] 注意初始化dp[0][i] = 0，其他全为inf #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main() {\rint n;\rcin \u003e\u003e n;\rvector\u003cint\u003e one(n + 1), zero(n + 1);\rint ct0 = 0, ct1 = 0;\rfor (int i = 1; i \u003c= n; ++i) {\rint u;\rcin \u003e\u003e u;\rif (u == 0) {\rzero[++ct0] = i;\r}else {\rone[++ct1]= i;\r}\r}\rvector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(n + 1, 0x3f3f3f3f));\rfor (int i = 0; i \u003c= n; ++i) dp[0][i] = 0; // !!! notice initialize dp[0][i] means no person need moving, dp[i][0]\r // means there're some persons need moving but they can't, so the cost is inf, also dp[0][0] = 0\r if (ct1 == 0) {\rputs(\"0\");\rexit(0);\r}\rfor (int i = 1; i \u003c= ct1; ++i) {\rfor (int j = 1; j \u003c= ct0; ++j) {\rdp[i][j] = min(dp[i][j - 1], dp[i - 1][j - 1] + abs(one[i] - zero[j]));\r}\r}\rcout \u003c\u003c dp[ct1][ct0] \u003c\u003c '\\n';\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:11:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"思维 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:12:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 3e5长度的数组，每次选择一个数删除，删除的数需满足条件：假设这个数是第i个数，则num[i]不能被i+1整除，问是否能删空 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:12:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 对于1-n的每个位置i，枚举2-i+1看是否满足num[i] % j != 0，如果存在就在那个位置删除，如果不存在这个位置就不能删空 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n;\rcin \u003e\u003e n;\rvector\u003cint\u003e a(n + 1);\rfor (int i = 1; i \u003c= n; ++i) {\rcin \u003e\u003e a[i];\r}\rbool output = false;\rfor (int i = 1; i \u003c= n; ++i) {\rbool ok = false;\rfor (int j = 2; j \u003c= i + 1; ++j) {\rif (a[i] % j != 0) {\rok = true;\rbreak;\r}\r}\rif (!ok) {\rputs(\"NO\");\routput = true;\rbreak;\r}\r}\rif (!output) puts(\"YES\");\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:12:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"数论 规律 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:13:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给两个偶数x、y，在1-2e18中找一数n，满足n % x = y % n x、y范围为1e9 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:13:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 设 c1x+k=n, c2n+k=y, n=(y+c1x) / (1+c2) 打表找规律，找c1和c2的规律 枚举多组x，y，枚举c1和c2，发现当x\u003ey时c1=1， c2=0 当x\u003c=y时，猜测是否与y/x或y%x有关，所以一并打y/x和y%x，发现c1=y/x，c2=1 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rll x, y;\rcin \u003e\u003e x \u003e\u003e y;\rll ans = (x \u003e y ? (x + y) : ((y / x) * x + y) / 2);\rcout \u003c\u003c ans \u003c\u003c '\\n';\r}\r// int x = 378, y = 99364;\r// //int x = 118502, y = 778;\r// cout \u003c\u003c y / x \u003c\u003c ' ' \u003c\u003c y % x \u003c\u003c '\\n';\r// for (int c1 = 0; c1 \u003c= 1000; ++c1) {\r// for (int c2 = 0; c2 \u003c= 100000; ++c2) {\r// if ((y + c1 * x) % (1 + c2) == 0) {\r// int n = (y + c1 * x) / (1 + c2);\r// if (n % x == y % n) {\r// cout \u003c\u003c c1 \u003c\u003c ' ' \u003c\u003c c2 \u003c\u003c ' ' \u003c\u003c n \u003c\u003c '\\n';\r// }\r// }\r// }\r// }\r return 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:13:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"树状数组 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:14:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 经典的求逆序三元组的个数，求逆序对可以用归并排序和树状数组，求逆序三元组就是在逆序对的基础上求，遍历数组，只是需要把逆序对的+1变成+该位置与前面产生的逆序对数量。这样就可以求逆序k元组 注意读入long ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:14:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 import java.util.Arrays;\rimport java.util.Scanner;\rpublic class Main {\rpublic static void main(String[] args) {\rScanner in = new Scanner(System.in);\rint n = in.nextInt();\rlong[] nums = new long[n];\rfor (int i = 0; i \u003c n; ++i) {\rnums[i] = in.nextLong();\r}\rlong[] tmp = new long[n];\rSystem.arraycopy(nums, 0, tmp, 0, n);\rArrays.sort(tmp);\rfor (int i = 0; i \u003c n; ++i) {\rnums[i] = Arrays.binarySearch(tmp, nums[i]) + 1;\r}\rFenwickTree fenwickTree = new FenwickTree(n);\rfor (int i = 0; i \u003c n; ++i) {\rtmp[i] = i - fenwickTree.sum((int) nums[i]);\rfenwickTree.add((int) nums[i], 1);\r}\rlong ans = 0;\rlong sum = 0;\rfenwickTree = new FenwickTree(n);\rfor (int i = 0; i \u003c n; ++i) {\rans += sum - fenwickTree.sum((int) nums[i]);\rfenwickTree.add((int) nums[i], tmp[i]);\rsum += tmp[i];\r}\rSystem.out.println(ans);\r}\r}\rclass FenwickTree {\r//[1, n]\r private long[] bit;\rprivate long n;\rpublic FenwickTree(int n) {\rthis.bit = new long[n + 2];\rthis.n = n;\r}\rpublic long sum(int i) {\rlong s = 0;\rwhile (i \u003e 0) {\rs += bit[i];\ri -= i \u0026 -i;\r}\rreturn s;\r}\rpublic void add(int i, long x) {\rwhile (i \u003c= n) {\rbit[i] += x;\ri += i \u0026 -i;\r}\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:14:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"欧拉降幂 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:15:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 求M^(K^N)，每个数1e18 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:15:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 欧拉降幂，注意底数取模防long long溢出 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll qpow(ll x,ll n,ll mod) {\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rconst ll mod = 998244353;\rconst ll phimod = 998244352;\rll gcd(ll a , ll b){\rreturn b == 0 ? a : gcd(b , a % b);\r}\rint main() {\rll n, k, m;\rcin \u003e\u003e n \u003e\u003e k \u003e\u003e m;\rif (m % mod == 0) {\rputs(\"0\");\rexit(0);\r}\rll ans;\rans = qpow(m % mod, qpow(k % phimod, n, phimod), mod);\rcout \u003c\u003c ans \u003c\u003c '\\n';\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:15:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"数论 辗转相除法 规律 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:16:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给俩数a,b和x，范围是1e18，求是否可以如下操作使得a=x或b=x，用a、b差替换a或替换b ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:16:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 如果x \u003e 最大的数无解 一开始想的是贪心，就是什么情况替换a，什么情况替换b，然后WA爆（其实这么做本身就没有道理） 列出每种情况找规律，举个例子 发现有些路产生的数别的路也会产生，最上面那条路始终是最快产生新数字的，所以只要考虑那条路就行，即 始终替换最大的数 这样只要模拟这个过程就行，但是会T 把这条路单独拎出来，观察发现这和求最大公约数的辗转相除法很像 但是少了11，这是因为11是余数4加7的结果，实际上只要满足%7=4都可以，这样就可以依赖欧几里得算法使时间复杂度变成logn #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\r#define YES cout \u003c\u003c \"YES\" \u003c\u003c '\\n'\r#define NO cout \u003c\u003c \"NO\" \u003c\u003c '\\n'\r#define Yes cout \u003c\u003c \"Yes\" \u003c\u003c '\\n'\r#define No cout \u003c\u003c \"No\" \u003c\u003c '\\n'\r#define yes cout \u003c\u003c \"yes\" \u003c\u003c '\\n'\r#define no cout \u003c\u003c \"no\" \u003c\u003c '\\n'\r\rbool sol(ll a, ll b, ll k) {\rif (b == 0 or k \u003e a) return false;\rif (k % b == a % b) return true;\rreturn sol(b, a % b, k);\r}\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rll a, b, k;\rcin \u003e\u003e a \u003e\u003e b \u003e\u003e k;\rif (a \u003c b) swap(a, b);\rif (sol(a, b, k)) YES; else NO;\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:16:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"计数dp 排列组合 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:17:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有n个人，每个人初始有生命值ai，每一轮每个人生命值同时减k-1，k为该轮存活人数，生命值为\u003c=0时死亡，问如何安排每个人的初始生命值，使得所有生命值不超过x，且最后无人生还，求方案数。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:17:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 计数，有递推关系的考虑dp dp[i][j]表示前i个，血量不超过j的方案数，如果如果i-1 \u003e= j，血量可以随便安排即dp[i][j] = j ^ i 否则考虑一轮后剩下k个（可能也可以假设一轮后消灭k个） $$ dp[i][j] = \\sum_{k=0}^{i}{C_i^kdp[k]j-i+1^{i-k}} $$ 之前以为k从1开始加，然后样例过不了，发现需要加dp[0][j]=1 所以初始化为dp=0，dp[0][j]=1 （表示前0个是可行的） #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll dp[505][505];\rll qpow(ll x,ll n,ll mod){\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll inv[505];\rll fac[505];\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinline ll A(ll m,ll n){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main() {\rfor(ll i=0;i\u003c=502;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u003c=502;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!!\r for(ll i=2;i\u003c=502;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=502;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rll n, x;\rcin \u003e\u003e n \u003e\u003e x;\rfor (int i = 1; i \u003c= x; ++i) {\rdp[0][i] = 1;\r}\rfor (int i = 1; i \u003c= n; ++i) {\rfor (int j = 1; j \u003c= x; ++j) {\rif (i - 1 \u003e= j) dp[i][j] = qpow(j, i, mod);\relse {\rfor (int k = 0; k \u003c= i; ++k) {\rdp[i][j] += (C(k, i) * dp[k][j - i + 1] % mod * qpow(i - 1, i - k, mod) % mod);\rdp[i][j] %= mod;\r}\r}\r}\r}\rcout \u003c\u003c dp[n][x];\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:17:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"二分 ST ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:18:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有一个数组和一个初始数，选择最长的子区间，使得数字遍历区间时不断加上该区间的数且该数字一直不小于0，输出该区间 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:18:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 二分区间长度，暴力判断，维护前缀和，用st表求区间最小值，时间复杂度O(nlognlogn) 注意二分的初始L和R，我把L设为0，wa了，要设为1 注意long long #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\r//O(nlogn) preprocess, O(1) query\r// llerval minimum, maxmum, bit-or, bit-xor, gcd(less efficient than segment tree)\rconst ll maxlogn = 21;\rconst ll maxn = 2e5 + 10;\rll f[maxn][maxlogn], logn[maxn];\rvoid pre() {\rlogn[1] = 0;\rlogn[2] = 1;\rfor (ll i = 3; i \u003c maxn; ++i) {\rlogn[i] = logn[i / 2] + 1;\r}\r}\rll dat[maxn], ini;\rll ansl, ansr;\rll n;\rbool ok(ll x) {\rfor (ll i = 1; i \u003c= n - x + 1; ++i) {\rll l = i, r = i + x - 1;\rll s = logn[r - l + 1];\rll tmp = min(f[l][s], f[r - (1 \u003c\u003c s) + 1][s]);\rif (tmp - dat[i - 1] + ini \u003e= 0) {\ransl = l, ansr = r;\rreturn true;\r}\r}\rreturn false;\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(nullptr);\rcout.tie(nullptr);\rpre();\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\rcin \u003e\u003e n \u003e\u003e dat[0];\rini = dat[0];\rfor (ll i = 1; i \u003c= n; ++i) cin \u003e\u003e dat[i];\rfor (ll i = 1; i \u003c= n; ++i) dat[i] += dat[i - 1];\rfor (ll i = 1; i \u003c= n; ++i) f[i][0] = dat[i];\rfor (ll j = 1; j \u003c maxlogn; ++j) for (ll i = 1; i + (1 \u003c\u003c j) - 1 \u003c= n; ++i) f[i][j] = min(f[i][j - 1], f[i + (1 \u003c\u003c (j - 1))][j - 1]);\rll l = 1, r = n;\r//dat[0] = 0;\r while (l \u003c= r) {\rll mid = (l + r) \u003e\u003e 1;\rif (ok(mid)) l = mid + 1;\relse r = mid - 1;\r}\rif (l == 1) cout \u003c\u003c -1 \u003c\u003c '\\n';\relse cout \u003c\u003c ansl \u003c\u003c ' ' \u003c\u003c ansr \u003c\u003c '\\n';\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:18:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"并查集 图论 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:19:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 对于一个森林，按顺序删除点和所连的边，求每次删除后剩几个连通块 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:19:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 反向加点，并查集，每次加点判断该点和所连的点是否在同一个连通块中，如果不在，则连通块-1（说明有一条边把两个连通块连在一起） #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\rconst int maxn = 2e5 + 10;\r//union find\rint par[maxn];\rint rankk[maxn];\rint sz[maxn];\rvoid init(int n)\r{\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ;\rif(rankk[x]\u003crankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main() {\rint n, m;\rcin \u003e\u003e n \u003e\u003e m;\rinit(n + 1);\rvector\u003cint\u003e G[n + 1];\rfor (int i = 0; i \u003c m; ++i) {\rint u, v;\rcin \u003e\u003e u \u003e\u003e v;\rif (u \u003e v) swap(u, v);\rG[u].push_back(v);\r}\rvector\u003cint\u003e ans;\rint cnt = 0;\rfor (int i = n; i \u003e= 1; --i) {\rcnt++;\rfor (int j : G[i]) {\rif (!same(j, i)) {\rcnt--;\runite(j, i);\r}\r}\rans.push_back(cnt);\r}\rreverse(ans.begin(), ans.end());\rfor (int i = 1; i \u003c (int) ans.size(); ++i) cout \u003c\u003c ans[i] \u003c\u003c '\\n';\rcout \u003c\u003c 0 \u003c\u003c '\\n';\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:19:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"规律 dp ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:20:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:20:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 像我这种不能一眼看出规律的就要多写几组数据。从前往后填数 如果找不到规律就多写几层，可以看出每次都有3个分支，但是有些有两个分支 少掉的那个分支一定当前要填的数是前面数的mex，如果当前填的数是前面数的mex，使得现在的mex+1就可以填，否则使mex+2就不能填 三个分支填的数是前面数的mex，mex-1，mex+1，其中填mex如果造成mex+2就不能填（即前面的数有mex+1） 所以设dp[i]表示以 i 结尾的个数，num[i]表示前面mex为 i 的个数，numex[i]表示前面mex为 i 且前面没有mex+1的个数 每次dp[i] = num[a[i]-1] + num[a[i]+1] + numex[a[i]] 注意判断a[i]-1\u003e=0 更新num，numex，如果选了前面mex为a[i]-1则mex不变，个数翻倍，num[a[i]-1]*=2，但是出现了mex+1，所以不更新numex 如果选了前面mex为a[i]+1，mex不变，个数翻倍，num[a[i]+1]*=2，numex[a[i]+1]*=2 如果选了前面mex为a[i]，mex变成mex+1，num[a[i]+1] += numex[a[i]]，考虑是否更新numex即前面是否有mex+2，一定不会有，所以numex[a[i]+1] += numex[a[i]] 最后特判，如果当前数是0，dp[i]++ num[1]++ numex[1]++ 当前数是1，dp[i]++ num[0]++; 初始化全为0 答案为dp求和 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n;\rcin \u003e\u003e n;\rvector\u003cint\u003e a(n + 5);\rfor (int i = 1; i \u003c= n; ++i) cin \u003e\u003e a[i];\rvector\u003cll\u003e dp(n + 5);\rvector\u003cll\u003e num(n + 5), numex(n + 5);\rfor (int i = 1; i \u003c= n; ++i) {\rif (a[i] - 1 \u003e= 0)\rdp[i] = num[a[i] - 1] + num[a[i] + 1] % mod + numex[a[i]] % mod;\relse\rdp[i] = num[a[i] + 1] % mod + numex[a[i]] % mod;\rif (a[i] - 1 \u003e= 0) num[a[i] - 1] = (num[a[i] - 1] * 2) % mod;\rnum[a[i] + 1] *= 2;\rnum[a[i] + 1] %= mod;\rnumex[a[i] + 1] *= 2;\rnumex[a[i] + 1] %= mod;\rnum[a[i] + 1] += numex[a[i]];\rnum[a[i] + 1] %= mod;\rnumex[a[i] + 1] += numex[a[i]];\rnumex[a[i] + 1] %= mod;\rif (a[i] == 0) {\rdp[i]++;\rdp[i] %= mod;\rnum[1]++;\rnum[1] %= mod;\rnumex[1]++;\rnumex[1] %= mod;\r}\rif (a[i] == 1) {\rdp[i]++;\rdp[i] %= mod;\rnum[0]++;\rnum[0] %= mod;\r}\r}\rll ans = 0;\rfor (int i = 1; i \u003c= n; ++i) {\rans += dp[i];\rans %= mod;\r}\rcout \u003c\u003c ans \u003c\u003c '\\n';\r}\rreturn 0;\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:20:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"每日一题 (LeetCode)","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":" 在这篇文章下更新LeetCode的每日一题，之所以选择LeetCode，是因为好像只有它有每日一题版块，每日一题并不是为了提高编程水平，而是保持手感，从10月2日开始更新，应该过几天批量更新一次 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:0:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"进制转化 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:1:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 把一个有符号数数转化成16进制，不能使用内置函数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:1:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意无符号数的转化 class Solution {\rpublic String toHex(int num) {\rif (num == 0) return \"0\";\rlong NUM = num \u0026 0xffffffffl;\rStringBuffer sb = new StringBuffer();\rwhile (NUM != 0) {\rlong tmp = NUM \u0026 0xf;\rif (tmp \u003e 9) sb.append((char)('a' + tmp - 10));\relse sb.append((char)('0' + tmp));\rNUM \u003e\u003e= 4;\r}\rreturn sb.reverse().toString();\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:1:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟，哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:2:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给定分数的分子和分母，求小数形式，如有循环节则标出 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:2:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意long类型的转化 class Solution {\rpublic String fractionToDecimal(int numerator, int denominator) {\rif (numerator == 0) return \"0\";\rboolean neg = (numerator \u003c 0) ^ (denominator \u003c 0);\rlong NUM = Math.abs((long)numerator);\rlong DEN = Math.abs((long)denominator);\rlong interger = NUM / DEN;\rNUM %= DEN;\rMap\u003cLong, Boolean\u003e mp = new HashMap\u003cLong, Boolean\u003e();\rif (NUM == 0) {\rStringBuffer sb = new StringBuffer();\rif (neg) sb.append('-');\rsb.append(String.valueOf(interger));\rreturn sb.toString();\r}\rList\u003clong []\u003e ans = new ArrayList\u003clong []\u003e();\rlong loop = 0;\rlong remaider = NUM;\rwhile (true) {\rif (remaider == 0) break;\rif (mp.containsKey(remaider)) {\rloop = remaider;\rbreak;\r}\rmp.put(remaider, true);\rlong tmp = remaider * 10 / DEN;\rlong a[] = new long[2];\ra[0] = tmp;\ra[1] = remaider;\rans.add(a);\rremaider = remaider * 10 % DEN;\r}\rStringBuffer sb = new StringBuffer();\rif (neg) sb.append('-');\rsb.append(String.valueOf(interger));\rsb.append('.');\rboolean circle = false;\rfor (long [] i : ans) {\rif (i[1] == loop) {\rcircle = true;\rsb.append('(');\r}\rsb.append((char)('0' + i[0]));\r}\rif (circle) sb.append(')');\rreturn sb.toString();\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:2:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:3:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:3:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic String licenseKeyFormatting(String s, int k) {\rint sum = 0;\rfor (int i = 0; i \u003c s.length(); ++i) {\rif (s.charAt(i) != '-') sum++;\r}\rif (sum == 0) {\rreturn \"\";\r}\rint rem = sum % k;\rif (rem == 0) rem = k;\rStringBuilder sb = new StringBuilder();\rint cnt = 0;\rwhile (cnt \u003c s.length()) {\rwhile (rem \u003e 0) {\rif (s.charAt(cnt) == '-') {\rcnt++;\rcontinue;\r}\rsb.append(s.charAt(cnt));\rrem--;\rcnt++;\r}\rif (cnt \u003e= s.length()) break;\rsb.append('-');\rint kk = k;\rwhile (kk \u003e 0) {\rif (s.charAt(cnt) == '-') {\rcnt++;\rif (cnt \u003e= s.length()) break;\rcontinue;\r}\rsb.append(s.charAt(cnt));\rcnt++;\rkk--;\r}\r}\rfor (int i = 0; i \u003c sb.length(); ++i) {\rif (Character.isAlphabetic(sb.charAt(i))) {\rsb.setCharAt(i, Character.toUpperCase(sb.charAt(i)));\r}\r}\rif (sb.charAt(sb.length() - 1) == '-') sb.deleteCharAt(sb.length() - 1);\rreturn sb.toString();\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:3:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:4:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:4:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rprivate static final int mod = 1000000007;\rpublic int numDecodings(String s) {\rint sz = s.length();\rStringBuilder sb = new StringBuilder(s);\rsb.insert(0, '#');\rlong dp[] = new long[sz + 1];\rdp[0] = 1;\rchar cnt = sb.charAt(1);\rif (cnt == '*') {\rdp[1] = 9;\r}else {\rif (cnt == '0') dp[1] = 0;\relse dp[1] = 1;\r}\rfor (int i = 2; i \u003c= sz; ++i) {\rcnt = sb.charAt(i);\rif (cnt == '*') {\rdp[i] += 9 * dp[i - 1];\rdp[i] %= mod;\rchar pre = sb.charAt(i - 1);\rif (pre == '*') {\rdp[i] += 15 * dp[i - 2];\rdp[i] %= mod;\r}else { // num\r if (pre == '1') {\rdp[i] += 9 * dp[i - 2];\rdp[i] %= mod;\r}else if (pre == '2') {\rdp[i] += 6 * dp[i - 2];\rdp[i] %= mod;\r}\r}\r}else { // num\r if (cnt == '0') {\rchar pre = sb.charAt(i - 1);\rif (pre == '*') {\rdp[i] += 2 * dp[i - 2];\rdp[i] %= mod;\r}else {\rif (pre == '1' || pre == '2') {\rdp[i] += dp[i - 2];\rdp[i] %= mod;\r}else return 0;\r}\rcontinue;\r}\rdp[i] += dp[i - 1];\rdp[i] %= mod;\rchar pre = sb.charAt(i - 1);\rif (pre == '*') {\rif (cnt \u003e '6') {\rdp[i] += dp[i - 2];\rdp[i] %= mod;\r}else {\rdp[i] += 2 * dp[i - 2];\rdp[i] %= mod;\r}\r}else {\rStringBuilder str = new StringBuilder();\rstr.append(pre);\rstr.append(cnt);\rif (str.compareTo(new StringBuilder(\"10\")) \u003e= 0 \u0026\u0026 str.compareTo(new StringBuilder(\"26\")) \u003c= 0) {\rdp[i] += dp[i - 2];\rdp[i] %= mod;\r}\r}\r}\r}\rreturn (int) dp[sz];\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:4:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"贪心 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:5:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:5:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int findMinMoves(int[] machines) {\rint ans = 0;\rint sum = 0;\rfor (int i : machines) sum += i;\rint sz = machines.length;\rif (sum % sz != 0) return -1;\rint avg = sum / sz;\rfor (int i = 0; i \u003c machines.length; ++i) {\rmachines[i] = machines[i] - avg;\r}\rsum = 0;\rfor (int i : machines) {\rsum += i;\rans = Math.max(ans, Math.max(i, Math.abs(sum)));\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:5:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"迭代器的了解 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:6:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 分析样例感觉题目说的有点不清楚，具体方法的功能写在注释里 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:6:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 泛型就直接用E代替Integer // Java Iterator interface reference:\r// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html\r\rclass PeekingIterator implements Iterator\u003cInteger\u003e {\rprivate Iterator\u003cInteger\u003e ite;\rprivate Integer currentElement;\rpublic PeekingIterator(Iterator\u003cInteger\u003e iterator) {\r// initialize any member here.\r ite = iterator;\rcurrentElement = ite.next();\r}\r// Returns the next element in the iteration without advancing the iterator.\r // Coder's note: return the current element, starting from the first one\r public Integer peek() {\rreturn currentElement;\r}\r// hasNext() and next() should behave the same as in the Iterator interface.\r // Override them if needed.\r // CN: return the current element and advance the iterator\r @Override\rpublic Integer next() {\rInteger tmp = currentElement;\rcurrentElement = ite.hasNext() ? ite.next() : null;\rreturn tmp;\r}\r//CN: return if the current element exist\r @Override\rpublic boolean hasNext() {\rreturn currentElement != null;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:6:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:7:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求数组第三大的数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:7:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int thirdMax(int[] nums) {\rTreeSet\u003cInteger\u003e ts = new TreeSet\u003c\u003e();\rfor (int i : nums) {\rts.add(i);\rif (ts.size() \u003e 3) {\rts.remove(ts.first());\r}\r}\rreturn (ts.size() == 3) ? ts.first() : ts.last();\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:7:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:8:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求字符串有多少个单词，单词是由没有空格的连续字符组成的字符串 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:8:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int countSegments(String s) {\rint ans = 0;\rboolean word = false;\rfor (int i = 0; i \u003c s.length(); ++i) {\rif (s.charAt(i) != ' ') {\rword = true;\r}else {\rif (word == true) {\rword = false;\rans++;\r}\r}\r}\rif (word) ++ans;\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:8:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:9:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 查找字符串中长度为10且不止出现过一次的子串 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:9:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic List\u003cString\u003e findRepeatedDnaSequences(String s) {\rHashMap\u003cString, Integer\u003e mp = new HashMap\u003c\u003e();\rStringBuilder sb = new StringBuilder();\rList\u003cString\u003e ans = new ArrayList\u003c\u003e();\rif (s.length() \u003c 10) return ans;\rfor (int i = 0; i \u003c 10; i++) {\rsb.append(s.charAt(i));\r}\rmp.put(sb.toString(), 1);\rfor (int i = 10; i \u003c s.length(); ++i) {\rsb.append(s.charAt(i));\rsb.deleteCharAt(0);\rif (mp.containsKey(sb.toString()) \u0026\u0026 mp.get(sb.toString()) == 1) {\rans.add(sb.toString());\rmp.put(sb.toString(), mp.get(sb.toString()) + 1);\r}else if (!mp.containsKey(sb.toString())) {\rmp.put(sb.toString(), 1);\r}\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:9:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"分类讨论 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:10:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 编写一个类的三个函数，初始化、添加一个元素、查找当前所有元素由几个区间组成（输出区间） ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:10:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 考虑合并，插入一个元素后能否和左边的数合并成一个区间、 能否和右边的数合并，分成4种情况 class SummaryRanges {\rprivate TreeMap\u003cInteger, Integer\u003e mp;\rint[] left;\rboolean[] used;\rpublic SummaryRanges() {\rmp = new TreeMap\u003c\u003e();\rused = new boolean[10005];\rleft = new int[10005];\r}\rpublic void addNum(int val) {\rif (used[val]) return;\rused[val] = true;\rif (val - 1 \u003e= 0 \u0026\u0026 used[val - 1]) { // exist left number\r if (used[val + 1]) { // exist left number and right number\r int tmp_left = left[val - 1];\rint tmpsz = mp.get(tmp_left);\rtmpsz = tmpsz + 1 + mp.get(val + 1);\rleft[val + mp.get(val + 1)] = tmp_left;\rmp.remove(val + 1);\rmp.put(tmp_left, tmpsz);\r}else { // exist left number but not right number\r int tmp_left = left[val - 1];\rleft[val] = tmp_left;\rmp.put(tmp_left, mp.get(tmp_left) + 1);\r}\r}else { // val == 0 or not exitst left number\r if (used[val + 1]) { // not exist left number but exist right number\r left[val + mp.get(val + 1)] = val;\rmp.put(val, mp.get(val + 1) + 1);\rmp.remove(val + 1);\r}else { // both left and right number are not exist\r left[val] = val;\rmp.put(val, 1);\r}\r}\r}\rpublic int[][] getIntervals() {\rint[][] ans = new int[mp.size()][2];\rint id = 0;\rfor (Map.Entry\u003cInteger, Integer\u003e entry : mp.entrySet()) {\rans[id][0] = entry.getKey();\rans[id][1] = entry.getValue() + ans[id][0] - 1;\rid++;\r}\rreturn ans;\r}\r}\r/**\r* Your SummaryRanges object will be instantiated and called as such:\r* SummaryRanges obj = new SummaryRanges();\r* obj.addNum(val);\r* int[][] param_2 = obj.getIntervals();\r*/\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:10:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:11:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 n个硬币按阶梯式排列，求最后一层被排满的阶梯 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:11:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int arrangeCoins(int n) {\rlong l = 1, r = n;\rwhile (l \u003c= r) {\rlong mid = (l + r) \u003e\u003e 1;\rif ((1 + mid) * mid / 2 \u003c= n) {\rl = mid + 1;\r}else r = mid - 1;\r}\rreturn (int)(l - 1);\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:11:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:12:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 把数字转化成英文 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:12:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意特判0，注意20 class Solution {\rString[] thousand = {\"Billion\", \"Million\", \"Thousand\", \"\"};\rString[] number = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\rString[] ty = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\rString[] teen = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\rpublic String numberToWords(int num) {\rif (num == 0) return \"Zero\";\rStringBuilder sb = new StringBuilder();\rfor (int i = 1000000000, j = 0; num != 0; i /= 1000, j++) {\rif (i == 1) { // 3-digital number\r if (num \u003e= 100) {\rsb.append(number[num / 100]);\rsb.append(' ');\rsb.append(\"Hundred\");\rsb.append(' ');\rnum %= 100;\r}\rif (num \u003e= 20) {\rsb.append(ty[num / 10]);\rsb.append(' ');\rnum %= 10;\r}\rif (num == 0) break;\rif (num \u003c 10) {\rsb.append(number[num]);\rsb.append(' ');\r}else {\rsb.append(teen[num - 10]);\rsb.append(' ');\r}\rbreak;\r}\rif (num \u003e= i) {\rsb.append(numberToWords(num / i));\rsb.append(' ');\rsb.append(thousand[j]);\rsb.append(' ');\rnum %= i;\r}\r}\rsb.deleteCharAt(sb.length() - 1);\rreturn sb.toString();\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:12:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分、快速乘 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:13:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求一个数除以另一个数的结果（保留整数部分），不能使用乘法、除法、模运算 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:13:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 用快速乘的加法代替乘法，注意特判溢出 class Solution {\rpublic int divide(int dividend, int divisor) {\rboolean neg = (dividend \u003e 0) ^ (divisor \u003e 0);\rlong tmp_dividend = dividend;\rlong tmp_divisor = divisor;\rtmp_dividend = Math.abs(tmp_dividend);\rtmp_divisor = Math.abs(tmp_divisor);\rlong l = 0, r = tmp_dividend;\rwhile (l \u003c= r) {\rlong mid = (l + r) \u003e\u003e 1;\rif (qmul(mid, tmp_divisor) \u003c= tmp_dividend \u0026\u0026 qmul(mid + 1, tmp_divisor) \u003e tmp_dividend) {\rif (neg) mid = -mid;\rif (mid \u003e Integer.MAX_VALUE) return Integer.MAX_VALUE;\rreturn (int) mid;\r}\rif (qmul(mid, tmp_divisor) \u003c tmp_dividend) {\rl = mid + 1;\r}else {\rr = mid - 1;\r}\r}\rreturn Integer.MAX_VALUE; //!!\r }\rprivate long qmul(long x, long y) {\rlong ans = 0;\rwhile (y \u003e 0) {\rif (y % 2 == 1) ans += x;\rx += x;\ry \u003e\u003e= 1;\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:13:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:14:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:14:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic List\u003cString\u003e fizzBuzz(int n) {\rList\u003cString\u003e ls = new ArrayList\u003c\u003e();\rfor (int i = 1; i \u003c= n; ++i) {\rif (i % 3 == 0 \u0026\u0026 i % 5 == 0) {\rls.add(\"FizzBuzz\");\r}else if (i % 3 == 0) {\rls.add(\"Fizz\");\r}else if (i % 5 == 0) {\rls.add(\"Buzz\");\r}else {\rls.add(String.valueOf(i));\r}\r}\rreturn ls;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:14:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"三分 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:15:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 logn内求单峰数组的最大值 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:15:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 三分，最高效的应该是黄金分割，其实还可以模拟退火（X） class Solution {\rpublic int peakIndexInMountainArray(int[] arr) {\rint l = 0, r = arr.length - 1;\rwhile (l \u003c= r) {\rint midl = l + (r - l) / 3;\rint midr = r - (r - l) / 3;\rif (arr[midl] \u003c arr[midr]) {\rl = midl + 1;\r}else {\rr = midr - 1;\r}\r}\rreturn l;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:15:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:16:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 不想描述 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:16:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic String countAndSay(int n) {\rif (n == 1) return \"1\";\relse return describe(countAndSay(n - 1));\r}\rprivate String describe(String str) {\rchar cnt = str.charAt(0);\rint num = 1;\rStringBuilder sb = new StringBuilder();\rfor (int i = 1; i \u003c str.length(); ++i) {\rif (str.charAt(i) == cnt) {\rnum++;\r}else {\rsb.append(String.valueOf(num));\rsb.append(cnt);\rcnt = str.charAt(i);\rnum = 1;\r}\r}\rsb.append(String.valueOf(num));\rsb.append(cnt);\rreturn sb.toString();\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:16:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:17:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 对一个由数字组成的字符串中加运算符（+-*），求表达式能得到target值的所有方案，sb中文翻译居然没说数字不能有前导0 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:17:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 为了图方便，直接用python的eval，但是eval不能有前导0，但是允许000的存在，这个要后处理特判，注意list不能边遍历边删除 注意在ide中用python3.5以上的类型检查时要导入typing包 class Solution:\rdef addOperators(self, num: str, target: int) -\u003e List[str]: # 0-based index\r le = len(num)\rans = []\rdef dfs(now: str, pos: int, added: int):\rif pos == le - 1:\rtry:\rif eval(now) == target:\rans.append(now)\rexcept SyntaxError:\rpass\rreturn\rtmp_now = now[: pos + added + 1] + '+' + now[pos + added + 1:]\rdfs(tmp_now, pos + 1, added + 1)\rtmp_now = now[: pos + added + 1] + '-' + now[pos + added + 1:]\rdfs(tmp_now, pos + 1, added + 1)\rtmp_now = now[: pos + added + 1] + '*' + now[pos + added + 1:]\rdfs(tmp_now, pos + 1, added + 1)\rtmp_now = now\rdfs(tmp_now, pos + 1, added)\rdef all_zero(s: str) -\u003e bool:\rif len(s) == 1: return False\rfor i in s:\rif i != '0':\rreturn False\rreturn True\rdfs(num, 0, 0)\rfans = []\r# postprocess\r for i in ans:\rremoved = False\rs = ''\rfor j in i:\rif j != '+' and j != '-' and j != '*':\rs += j\relse:\rif all_zero(s):\rremoved = True\rbreak\relse:\rs = ''\rif not removed and all_zero(s):\rremoved = True\rif not removed:\rfans.append(i)\rreturn fans\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:17:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 中序遍历 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:18:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求bst的第k小元素，允许多次求 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:18:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 bst的中序是有序的，插入、删除、搜索均可二分 /**\r* Definition for a binary tree node.\r* public class TreeNode {\r* int val;\r* TreeNode left;\r* TreeNode right;\r* TreeNode() {}\r* TreeNode(int val) { this.val = val; }\r* TreeNode(int val, TreeNode left, TreeNode right) {\r* this.val = val;\r* this.left = left;\r* this.right = right;\r* }\r* }\r*/\rclass Solution {\rList\u003cInteger\u003e li = new ArrayList\u003c\u003e();\rpublic int kthSmallest(TreeNode root, int k) {\rdfs(root);\r//Collections.sort(li);\r return li.get(k - 1);\r}\rprivate void dfs(TreeNode node) {\rif (node.left != null) dfs(node.left);\rli.add(node.val);\rif (node.right != null) dfs(node.right);\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:18:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"次短路 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:19:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一个无向图，经过每条边的时间为t，任何时候可以到达任何点，但是只能在该点绿灯时离开且必须离开，一开始每个点都是绿灯，红绿灯以m时间交替，求从1到n的严格第二短时间 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:19:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 dijkstra求次短路是最直接的想法，求次短路需要同时存储到每个点的次短路和最短路 class Solution {\rpublic:\rtypedef pair\u003cint,int\u003e pii; //first 是距离 ，second是点编号\r static const int maxv = 1e4 + 10;\rstruct edge\r{\rint to,cost;\r};\rint V;\rvector\u003cedge\u003e G[maxv];\rint d[maxv];\rint dd[maxv];\rint cg ;\rint secondMinimum(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 edges, int time, int change) {\rcg = change;\rfor (auto i : edges) {\rG[i[0]].push_back({i[1], time});\rG[i[1]].push_back({i[0], time});\r}\rdijkstra(1);\rreturn dd[n];\r}\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003c\u003e \u003e q; //使小的在上面\r memset(d, 0x3f, sizeof(d));\rmemset(dd, 0x3f, sizeof(dd));\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(dd[v]\u003cp.first) continue;\rfor(int i=0;i\u003c(int)G[v].size();i++)\r{\redge e=G[v][i];\r// if(d[e.to]\u003ed[v]+e.cost)\r// {\r// d[e.to]=d[v]+e.cost;\r// q.push(pii(d[e.to],e.to));\r// }\r int tmpdist;\rif (p.first % (cg * 2) \u003c cg) {\rtmpdist = p.first + e.cost;\r}else {\rtmpdist = p.first + e.cost + 2 * cg - p.first % (2 * cg);\r}\rif (tmpdist \u003c d[e.to]) {\rswap(d[e.to], tmpdist);\rq.emplace(d[e.to], e.to);\r}\rif (d[e.to] \u003c tmpdist and dd[e.to] \u003e tmpdist) {\rdd[e.to] = tmpdist;\rq.emplace(dd[e.to], e.to);\r}\r}\r}\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:19:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"位运算 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:20:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求一个数耳朵二进制中0变成1,1变成0后的数字 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:20:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 将它和全1异或 class Solution {\rpublic int findComplement(int num) {\rint bitnum = 0;\rint tmp = num;\rwhile (tmp != 0) {\rtmp \u003e\u003e= 1;\rbitnum++;\r}\rint now = 0;\rfor (int i = 0; i \u003c bitnum; ++i) {\rnow |= (1 \u003c\u003c i);\r}\rreturn num ^ now;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:20:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:21:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求一个100位数+1的结果 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:21:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 分享一篇Array\u003cInteger\u003e 、Integer[] 、int[]相互转换的方法，点它，不过应该尽量避免转化 class Solution {\rpublic int[] plusOne(int[] digits) {\rboolean carry = false;\rint sz = digits.length;\rList\u003cInteger\u003e ls = new ArrayList\u003c\u003e();\rif (digits[sz - 1] + 1 \u003e 9) {\rcarry = true;\rls.add(0);\r}else {\rls.add(digits[sz - 1] + 1);\r}\rfor (int i = sz - 2; i \u003e= 0; --i) {\rif (carry) {\rif (digits[i] + 1 \u003e 9) {\rls.add(0);\r}else {\rcarry = false;\rls.add(digits[i] + 1);\r}\r}else {\rls.add(digits[i]);\r}\r}\rif (carry) ls.add(1);\rCollections.reverse(ls);\rreturn ls.stream().mapToInt(Integer::valueOf).toArray();\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:21:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"摩尔投票 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:22:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求一个数组中出现次数超过n/3的元素，要求时间复杂度O(n)，空间复杂度O(1) ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:22:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 摩尔投票法一般用来求出现次数超过n/k的元素，这样的元素至多有k-1个，本质是相互抵消，注意判断条件的顺序 相似的题 class Solution {\rpublic List\u003cInteger\u003e majorityElement(int[] nums) {\rint candidate1 = 0xc0c0c0c0, candidate2 = 0xc0c0c0c0;\rint count1 = 0, count2 = 0;\rfor (int i : nums) {\rif (count1 \u003e 0 \u0026\u0026 i == candidate1) {\rcount1++;\r}else if (count2 \u003e 0 \u0026\u0026 i == candidate2) {\rcount2++;\r}else if (count1 == 0) {\rcandidate1 = i;\rcount1 = 1;\r}else if (count2 == 0) {\rcandidate2 = i;\rcount2 = 1;\r}else {\rcount1--;\rcount2--;\r}\r}\rint cnt1 = 0, cnt2 = 0;\rfor (int i : nums) {\rif (count1 \u003e 0 \u0026\u0026 i == candidate1) cnt1++;\rif (count2 \u003e 0 \u0026\u0026 i == candidate2) cnt2++;\r}\rList\u003cInteger\u003e ls = new ArrayList\u003c\u003e();\rint n = nums.length;\rif (cnt1 \u003e n / 3) ls.add(candidate1);\rif (cnt2 \u003e n / 3) ls.add(candidate2);\rreturn ls;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:22:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"数学 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:23:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:23:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int[] constructRectangle(int area) {\rint ans = 0;\rfor (int i = 1; i * i \u003c= area; ++i) {\rif (area % i == 0) ans = i;\r}\rint[] ANS = new int[]{area / ans, ans};\rreturn ANS;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:23:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:24:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:24:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 按题意模拟 （要多写模拟，不要惧怕模拟😄） class Solution:\rdef countValidWords(self, sentence: str) -\u003e int:\rls = list(sentence.split(' '))\r#print(ls)\r num = 0\rfor i in ls:\rif i == '':\rcontinue\rok = True\rfor j in i:\rif j.isdigit():\rok = False\rbreak\rif ok:\rif i.count('-') == 0:\rif (i.count('!') + i.count(',') + i.count('.') == 1) and (\ri[len(i) - 1] == '!' or i[len(i) - 1] == ',' or i[len(i) - 1] == '.'):\rnum += 1\relif i.count('!') + i.count(',') + i.count('.') == 0:\rnum += 1\relif i.count('-') == 1:\rindex = i.find('-')\rif index != 0 and index != len(i) - 1 and i[index - 1].isalpha() and i[index + 1].isalpha():\rif (i.count('!') + i.count(',') + i.count('.') == 1) and (\ri[len(i) - 1] == '!' or i[len(i) - 1] == ',' or i[len(i) - 1] == '.'):\rnum += 1\relif i.count('!') + i.count(',') + i.count('.') == 0:\rnum += 1\rreturn num\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:24:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:25:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 如果整数 x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。 给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:25:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 模拟 class Solution:\rdef nextBeautifulNumber(self, n: int) -\u003e int:\rdef ok(n: int) -\u003e bool:\rst = str(n)\rfor i in st:\rif st.count(i) != int(i):\rreturn False\rreturn True\rwhile True:\rn += 1\rif ok(n):\rreturn n\rreturn 0\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:25:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs 分类讨论 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:26:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一棵二叉树，每个节点的分数为把这个节点和所连的边移除的连通块大小之积，求具有最大分数的点的个数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:26:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 dfs求一下子树大小，然后分情况讨论（叶子、一个孩子、两个孩子） class Solution {\rpublic:\rusing ll = long long;\rint countHighestScoreNodes(vector\u003cint\u003e\u0026 parents) {\rll num = (ll) parents.size();\rvector\u003cll\u003e ch[num + 1];\rll subnum[num + 1];\rfor (ll i = 0; i \u003c num; ++i) {\rif (parents[i] == -1) continue;\rch[parents[i]].push_back(i);\r}\rfunction\u003cvoid(ll)\u003e dfs = [\u0026](ll x) {\rif (ch[x].empty()) {\rsubnum[x] = 1;\rreturn;\r}\rsubnum[x] = 1;\rfor (ll i : ch[x]) {\rdfs(i);\rsubnum[x] += subnum[i];\r}\r};\rdfs(0);\rll mx = -1;\rll cnt = 0;\rif (ch[0].size() == 2) {\rmx = subnum[ch[0][0]] * subnum[ch[0][1]];\rcnt = 1;\r}else if (ch[0].size() == 1) {\rmx = subnum[ch[0][0]];\rcnt = 1;\r}\rfor (ll i = 1; i \u003c num; ++i) {\rll tmp;\rif ((ll) ch[i].size() == 2) {\rtmp = subnum[ch[i][0]] * subnum[ch[i][1]] * (num - subnum[ch[i][0]] - subnum[ch[i][1]] - 1);\r}else if ((ll) ch[i].size() == 1) {\rtmp = subnum[ch[i][0]] * (num - subnum[ch[i][0]] - 1);\r}else {\rtmp = num - 1;\r}\rif (tmp \u003e mx) {\rmx = tmp;\rcnt = 1;\r}else if (tmp == mx) {\rcnt++;\r}\r}\rreturn (int) cnt;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:26:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"拓扑序 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:27:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一个DAG，每个点表示一门课，有一个权值表示修这门课花费的时间，课程的修读有先后顺序，从起点开始修读到最后，求完成课程的最少时间，可以同时修多门课 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:27:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 求拓扑序的过程更新每个点的最少时间，注意可能有多个DAG class Solution {\rpublic:\rint minimumTime(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 relations, vector\u003cint\u003e\u0026 time) {\rvector\u003cint\u003e indegree(n + 1);\rvector\u003cint\u003e G[n + 1];\rfor (auto i : relations) {\rG[i[0]].push_back(i[1]);\rindegree[i[1]]++;\r}\rstack\u003cint\u003e s;\rvector\u003cint\u003e val(n + 1);\rfor (int i = 1; i \u003c= n; ++i) {\rif (indegree[i] == 0) s.push(i);\r}\r// for (int i = 1; i \u003c= n; ++i) {\r // cout \u003c\u003c indegree[i] \u003c\u003c ' ';\r // }\r int ans;\rvector\u003cint\u003e tmp;\rwhile (!s.empty()) {\rint now = s.top();\rs.pop();\rbool ok = false;\rfor (int j : G[now]) {\rok = true;\rval[j] = max(val[j], val[now] + time[now - 1]);\rif (--indegree[j] == 0) s.push(j);\r}\rif (!ok) tmp.push_back(now);\r}\rans = 0;\rfor (int i : tmp) {\rans = max(ans, val[i] + time[i - 1]);\r}\rreturn ans;\r//return 0;\r }\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:27:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:28:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:28:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic:\runordered_map\u003cstring, int\u003e mp;\rstring kthDistinct(vector\u003cstring\u003e\u0026 arr, int k) {\rfor (auto i : arr) {\rmp[i]++;\r}\rfor (auto i : arr) {\rif (mp[i] == 1) {\rk--;\rif (k == 0) {\rreturn i;\r}\r}\r}\rreturn \"\";\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:28:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:29:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 对于一个只有*和 | 的字符串，每次询问一个子串，求夹在 | 的*有几个 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:29:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 存一个前缀*和，存一下 | 出现的位置，对于每个子区间，先算有多少个*，然后算区间第一个 | 和最后一个 | ，在算一下之前和之后有几个*，减一下。注意很多种情况都是0，注意细节 class Solution {\rpublic:\rvector\u003cint\u003e platesBetweenCandles(string s, vector\u003cvector\u003cint\u003e\u003e\u0026 queries) {\rint n = s.length();\rs.insert(s.begin(), '#');\rvector\u003cint\u003e prestar(n + 2);\rif (s[1] == '*') prestar[1] = 1;\rfor (int i = 2; i \u003c= n; ++i) {\rprestar[i] = prestar[i - 1] + (s[i] == '*' ? 1 : 0);\r}\rvector\u003cint\u003e bar;\rfor (int i = 1; i \u003c= n; ++i) {\rif (s[i] == '|') {\rbar.push_back(i);\r}\r}\rvector\u003cint\u003e ans;\rfor (auto i : queries) {\rint l = i[0], r = i[1];\rl++, r++;\rint starnum = prestar[r] - prestar[l - 1];\rif (bar.empty()) {\rans.push_back(0);\r}else {\rauto ite = lower_bound(bar.begin(), bar.end(), l);\rif (ite == bar.end()) {\rans.push_back(0);\r}else if (*ite \u003e r) {\rans.push_back(0);\r}else {\rint tmpl = *ite;\rite = upper_bound(bar.begin(), bar.end(), r);\rif (ite == bar.begin()) {\rans.push_back(0);\r}else {\rite--;\rif (*ite \u003c l) {\rans.push_back(0);\r}else {\rint tmpr = *ite;\rans.push_back(starnum - (tmpl - l) - (r - tmpr));\r}\r}\r}\r}\r}\rreturn ans;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:29:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"排序 前缀 离散化 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:30:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 有n个区间，每个区间有一个价值，求两个不重叠区间价值和的最大值 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:30:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 区间按右端点排序，离散化求到每个区间右端点的前缀最大值 遍历每个区间，对于该区间，求小于左端点的前缀最大值并和该区间价值相加，不断更新答案 注意排序用pair排，用vector排会超时！！！ class Solution {\rpublic:\rint maxTwoEvents(vector\u003cvector\u003cint\u003e\u003e\u0026 events) {\rint mx = -1;\rfor (auto i : events) {\rmx = max(mx, i[2]);\r}\rint n = (int) events.size();\rvector\u003cint\u003e premax(n + 1);\rvector\u003cint\u003e bd;\rvector\u003cpair\u003cint, int\u003e\u003e v;\rfor (auto i : events) {\rv.emplace_back(i[1], i[2]);\r}\rsort(v.begin(), v.end(), [\u0026](pair\u003cint, int\u003e p1, pair\u003cint, int\u003e p2){\rreturn p1.first \u003c p2.first;\r});\rpremax[0] = v[0].second;\rbd.push_back(v[0].first);\rint ptr = 1;\rfor (int i = 1; i \u003c n; ++i) {\rif (v[i].first == bd.back()) {\rpremax[ptr - 1] = max(premax[ptr - 1], v[i].second);\r}else {\rbd.push_back(v[i].first);\rpremax[ptr] = max(premax[ptr - 1], v[i].second);\rptr++;\r}\r}\rv.clear();\rfor (auto i : events) {\rv.emplace_back(i[0], i[2]);\r}\rsort(v.begin(), v.end(), [\u0026](pair\u003cint, int\u003e p1, pair\u003cint, int\u003e p2) {\rreturn p1.first \u003c p2.first;\r});\rfor (int i = 1; i \u003c n; ++i) {\rint tmp = v[i].first - 1;\rauto ite = lower_bound(bd.begin(), bd.end(), tmp);\rif (ite != bd.end()) {\rif (*ite == tmp) {\rmx = max(mx, v[i].second + premax[ite - bd.begin()]);\r}else {\rif (ite != bd.begin()) {\rmx = max(mx, v[i].second + premax[ite - bd.begin() - 1]);\r}\r}\r}\r}\rreturn mx;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:30:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:31:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:31:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic:\rint smallestEqual(vector\u003cint\u003e\u0026 nums) {\rfor (int i = 0; i \u003c (int) nums.size(); ++i) {\rif (i % 10 == nums[i]) {\rreturn i;\r}\r}\rreturn -1;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:31:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:32:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:32:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 /**\r* Definition for singly-linked list.\r* struct ListNode {\r* int val;\r* ListNode *next;\r* ListNode() : val(0), next(nullptr) {}\r* ListNode(int x) : val(x), next(nullptr) {}\r* ListNode(int x, ListNode *next) : val(x), next(next) {}\r* };\r*/\rclass Solution {\rpublic:\rvector\u003cint\u003e nodesBetweenCriticalPoints(ListNode* head) {\rListNode* now = head;\rListNode* nn = head-\u003enext;\rvector\u003cint\u003e vals;\rint pos = 1;\rwhile (nn-\u003enext != NULL) {\rint l = now-\u003eval;\rint m = nn-\u003eval;\rint r = nn-\u003enext-\u003eval;\rif (m \u003e l and m \u003e r) {\rvals.push_back(pos);\r}else if (m \u003c l and m \u003c r) {\rvals.push_back(pos);\r}\rnow = now-\u003enext;\rnn = nn-\u003enext;\rpos++;\r}\rsort(vals.begin(), vals.end());\rif ((int) vals.size() \u003c 2) {\rreturn {-1, -1};\r} else {\rint mx = vals.back() - vals.front();\rint mn = 1e6;\rfor (int i = 0; i \u003c (int) vals.size() - 1; ++i) {\rmn = min(mn, vals[i + 1] - vals[i]);\r}\rreturn {mn, mx};\r}\r} };\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:32:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"异或 思维 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:33:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。在线性时间复杂度和常数空间复杂度求解 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:33:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 假设两个数为x、y，将所有数异或为m，则x^y=m，求m二进制的某一位1，这一定是1^0的结果，遍历一遍数，把该位为1的和0的分开，两堆分开异或得到答案 注意__builtin_ffs返回最后一位1的位置，下标从1开始 class Solution {\rpublic:\rvector\u003cint\u003e singleNumber(vector\u003cint\u003e\u0026 nums) {\rint a = 0;\rfor (int i : nums) {\ra ^= i;\r}\rint pos = __builtin_ffs(a);\rpos--;\rvector\u003cint\u003e v1, v2;\rfor (int i : nums) {\rif (i \u003e\u003e pos \u0026 1) {\rv1.push_back(i);\r} else v2.push_back(i);\r}\rint l = 0, r = 0;\rfor (int i : v1) {\rl ^= i;\r}\rfor (int i : v2) {\rr ^= i;\r}\rreturn {l, r};\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:33:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"预处理 哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:34:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:34:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 预处理所有的2次幂，求每个数字出现的次数，一一比较 class Solution {\rpublic:\rbool reorderedPowerOf2(int n) {\rvector\u003cint\u003e num(10);\rwhile (n != 0) {\rnum[n % 10]++;\rn /= 10;\r}\rvector\u003cvector\u003cint\u003e\u003e p;\rfor (long long i = 1; i \u003c= 1000000000; i *= 2) {\rvector\u003cint\u003e tmp(10);\rint now = i;\rwhile (now != 0) {\rtmp[now % 10]++;\rnow /= 10;\r}\rp.push_back(tmp);\r}\rfor (auto i : p) {\rbool same = true;\rfor (int j = 0; j \u003c 10; ++j) {\rif (i[j] != num[j]) {\rsame = false;\rbreak;\r}\r}\rif (same) return true; }\rreturn false;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:34:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp 完全背包 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:35:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 商店有n种商品，有k个礼包，礼包将商品捆绑售卖，即给出里面每一种商品的个数和礼包的价格，购物清单上写了每种商品的需求，求恰好按购物清单上买的最低花费（\u003c=6种商品, \u003c=100个大礼包） ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:35:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 非常好的dp题，看数据大小可以暴搜，但我不会（官方题解有） 看起来很像完全背包，传统的完全背包是dp[i][j]表示前i个物品，容量不超过j的最大价值，这个题也有前i种物品（大礼包），也有容量（每种物品的购买个数），价值就变成了花费，但是有6种物品，所以有6种容量，所以可以设dp[i][j1][j2][j3][j4][j5][j6]，7重循环求解，（可以把6个容量维度状态压缩成1维，具体见民间题解），降维一下7重循环，6个维度的dp，初始化为dp = inf, dp[0][0][0][0][0][0] = 0，注意当物品没有6个时补齐6个 class Solution {\rpublic:\rint shoppingOffers(vector\u003cint\u003e\u0026 price, vector\u003cvector\u003cint\u003e\u003e\u0026 special, vector\u003cint\u003e\u0026 needs) {\rint n = (int) price.size();\rfor (int i = 0; i \u003c n; ++i) {\rvector\u003cint\u003e tmp(n + 1);\rtmp[i] = 1;\rtmp[n] = price[i];\rspecial.push_back(tmp);\r}\rvector\u003cvector\u003cint\u003e\u003e SP;\rfor (auto i : special) {\rvector\u003cint\u003e tmp = i;\rtmp.pop_back();\rwhile ((int) tmp.size() != 6) {\rtmp.push_back(0);\r}\rtmp.push_back(i.back());\rSP.push_back(tmp);\r}\rint dp[12][12][12][12][12][12];\rwhile ((int) needs.size() \u003c 6) {\rneeds.push_back(0);\r}\rmemset(dp, 0x3f, sizeof(dp));\rdp[0][0][0][0][0][0] = 0;\rint m = (int) special.size();\rfor (int i = 0; i \u003c m; ++i) {\rvector\u003cint\u003e bd(6);\rfor (int j = 0; j \u003c 6; ++j) {\rbd[j] = SP[i][j];\r}\rint money = SP[i][6];\rfor (int k0 = bd[0]; k0 \u003c= needs[0]; ++k0) {\rfor (int k1 = bd[1]; k1 \u003c= needs[1]; ++k1) {\rfor (int k2 = bd[2]; k2 \u003c= needs[2]; ++k2) {\rfor (int k3 = bd[3]; k3 \u003c= needs[3]; ++k3) {\rfor (int k4 = bd[4]; k4 \u003c= needs[4]; ++k4) {\rfor (int k5 = bd[5]; k5 \u003c= needs[5]; ++k5) {\rdp[k0][k1][k2][k3][k4][k5] = min(dp[k0][k1][k2][k3][k4][k5],\rdp[k0 - SP[i][0]][k1 - SP[i][1]][k2 - SP[i][2]][k3 - SP[i][3]][k4 - SP[i][4]][k5 - SP[i][5]] + money);\r}\r}\r}\r}\r}\r}\r}\rreturn dp[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]];\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:35:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"状态压缩 剪枝 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:36:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给你一个由若干括号和字母组成的字符串 s（长度为25，括号为20） ，删除最小数量的无效括号，使得输入的字符串有效。 返回所有可能的结果。答案可以按 任意顺序 返回。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:36:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 因为合法括号序列左括号一定等于有括号，所以状压枚举左括号和右括号，数量不相等直接剪枝，去掉的括号数小于临时答案直接剪枝，最后判断是否真的合法 class Solution {\rpublic:\rvector\u003cstring\u003e removeInvalidParentheses(string s) {\rauto ok = [\u0026](string str) {\rstack\u003cint\u003e st;\rfor (char i : str) {\rif (i == '(') st.push(1);\rif (i == ')') {\rif (st.empty()) return false;\relse st.pop();\r}\r}\rreturn st.empty();\r};\rint n = s.length();\rint lnum = 0, rnum = 0;\rfor (char i : s) {\rif (i == '(') lnum ++;\rif (i == ')') rnum ++;\r}\rint mn = min(lnum, rnum);\runordered_set\u003cstring\u003e ans;\rint mncut = 100000;\rvector\u003cint\u003e lind, rind;\rfor (int i = 0; i \u003c n; ++i) {\rif (s[i] == '(') lind.push_back(i);\rif (s[i] == ')') rind.push_back(i);\r}\rfor (int i = 0; i \u003c (1 \u003c\u003c lnum); ++i) {\rfor (int j = 0; j \u003c (1 \u003c\u003c rnum); ++j) {\rint lonenum = __builtin_popcount(i);\rint ronenum = __builtin_popcount(j);\rif (lonenum != ronenum) continue;\rint tmpcut = lnum + rnum - lonenum - ronenum;\rif (tmpcut \u003e mncut) continue;\rvector\u003cint\u003e ex(n);\rfor (int k = 0; k \u003c lnum; ++k) {\rif ((i \u003e\u003e k \u0026 1) == 0) {\rex[lind[k]] = 1;\r}\r}\rfor (int k = 0; k \u003c rnum; ++k) {\rif ((j \u003e\u003e k \u0026 1) == 0) {\rex[rind[k]] = 1;\r}\r}\rstring tmpstr;\rfor (int k = 0; k \u003c n; ++k) {\rif (ex[k]) continue;\rtmpstr.push_back(s[k]);\r}\rif (ok(tmpstr)) {\rif (tmpcut == mncut) {\rans.insert(tmpstr);\r}else {\rmncut = tmpcut;\rans.clear();\rans.insert(tmpstr);\r}\r}\r}\r}\rvector\u003cstring\u003e fans;\rfor (auto i : ans) {\rfans.push_back(i);\r}\rreturn fans;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:36:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:37:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:37:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic:\rint countVowelSubstrings(string word) {\rauto ok = [\u0026](string s) {\rauto ed = string::npos;\rfor (char i : s) {\rif (i != 'a' and i != 'e' and i != 'i' and i != 'o' and i != 'u') return false;\r}\rif (s.find('a') != ed and s.find('e') != ed and s.find('i') != ed and s.find('o') != ed and s.find('u') != ed) return true;\rreturn false;\r};\rint ans = 0;\rint n = word.length();\rfor (int i = 0; i \u003c n; ++i) {\rfor (int j = i; j \u003c n; ++j) {\rstring s = word.substr(i, j - i + 1);\rif (ok(s)) {\r//cout \u003c\u003c s \u003c\u003c '\\n';\r ans++;\r}\r}\r}\rreturn ans;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:37:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:38:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 有n个商店，有m种商品，每种商品有v[i]个，你需要把商品分到各个商店中，满足每个商店只能分一种商品（可以一个都不分），求商店最大商品数能达到的最小值 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:38:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 像这种既贪心又单调的可以考虑二分！二分答案 class Solution {\rpublic:\rint minimizedMaximum(int n, vector\u003cint\u003e\u0026 quantities) {\rint sz = (int) quantities.size();\rint l = 1, r = *max_element(quantities.begin(), quantities.end());\rwhile (l \u003c= r) {\rint mid = (l + r) \u003e\u003e 1;\rint now = 0;\rfor (int i : quantities) {\rnow += ceil(i / (double)mid);\r}\rif (now \u003c= n) {\rr = mid - 1;\r} else {\rl = mid + 1;\r}\r}\rreturn l;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:38:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"找规律 归纳 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:39:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一组行动序列，从原点出发，每次走move[i]步，每走一次自身逆时针90旋转，问走过的路径是否交叉 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:39:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 考虑交叉的情况，可以发现4条及以上才会交叉 5条（最后一条和第一条交叉才算） 6条 7条 （可以发现7条可以看做最后一条和第2条重复，所以应该算作6条） 之后也画不出更多的条数，所以对于每步只需要考虑4、5、6条的情况就行 class Solution {\rpublic boolean isSelfCrossing(int[] distance) {\rint n = distance.length;\rfor (int i = 0; i \u003c n; ++i) {\rif (i \u003e= 3 \u0026\u0026 distance[i - 1] \u003c= distance[i - 3] \u0026\u0026 distance[i] \u003e= distance[i - 2]) return true;\r}\rfor (int i = 0; i \u003c n; ++i) {\rif (i \u003e= 4 \u0026\u0026 distance[i - 2] \u003e distance[i - 4] \u0026\u0026 distance[i - 1] == distance[i - 3] \u0026\u0026 distance[i] + distance[i - 4] \u003e= distance[i - 2]) return true;\r}\rfor (int i = 0; i \u003c n; ++i) {\rif (i \u003e= 5 \u0026\u0026 distance[i - 3] \u003e distance[i - 5] \u0026\u0026 distance[i - 2] \u003e distance[i - 4] \u0026\u0026 distance[i - 1] + distance[i - 5] \u003e= distance[i - 3] \u0026\u0026 distance[i - 1] \u003c distance[i - 3] \u0026\u0026 distance[i] + distance[i - 4] \u003e= distance[i - 2]) return true;\r}\rreturn false;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:39:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"堆 类dijkstra Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:40:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:40:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 没做过这种类型的题，感谢leetcode，设water[i][j]为水位高度，那么 water[i][j]=max(heightMap[i][j],min(water[i−1][j],water[i+1][j],water[i][j−1],water[i][j+1]))，所以water[i][j]需要四周来更新自己，但四周需要自己来更新对方 对于边缘 water[i][j] = heightMap[i][j]之后不会再改变，由于木桶效应，所以每次选择已经确定水位的方块中的最低水位的方块，来更新四周没有确定水位的方块，这就需要小根堆，用类dijkstra的思想 注意入堆时是Math.max(height[tx][ty], val) class Solution {\rpublic int trapRainWater(int[][] height) {\rint n = height.length;\rint m = height[0].length;\rboolean[][] used = new boolean[n][m];\rint[][] dir = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\rPriorityQueue\u003cint[]\u003e pq = new PriorityQueue\u003c\u003e((a, b) -\u003e a[1] - b[1]); // 小根堆\r for (int i = 0; i \u003c n; ++i) {\rfor (int j = 0; j \u003c m; ++j) {\rif (i == 0 || i == n - 1 || j == 0 || j == m - 1) {\rpq.offer(new int[]{i * m + j, height[i][j]});\rused[i][j] = true;\r}\r}\r}\rint ans = 0;\rwhile (!pq.isEmpty()) {\rint[] cnt = pq.poll();\rint x = cnt[0] / m;\rint y = cnt[0] % m;\rint val = cnt[1];\rfor (int i = 0; i \u003c 4; ++i) {\rint tx = x + dir[i][0];\rint ty = y + dir[i][1];\rif (tx \u003e= 0 \u0026\u0026 tx \u003c n \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c m \u0026\u0026 !used[tx][ty]) {\rif (val \u003e height[tx][ty]) ans += val - height[tx][ty];\rused[tx][ty] = true;\rpq.offer(new int[]{tx * m + ty, Math.max(height[tx][ty], val)});\r}\r}\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:40:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"枚举 模拟 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:41:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 强烈建议看英文题面 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:41:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 由于数据大小，枚举所有局面判断是否合法 代码来自吴自华 在计算时间复杂度时注意最多只有一个queen（这也太细节了，我直接忽略😫） const int d[8][2] = {{-1, 0}, {-1, -1}, {0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1}, {-1, 1}};\rclass Solution {\rvector\u003cvector\u003cint\u003e\u003e positions, possible;\rint n, ans = 0;\rvector\u003cint\u003e direction, step, xinit, yinit;\rbool valid(int x, int y) {\rreturn x \u003e= 1 \u0026\u0026 x \u003c= 8 \u0026\u0026 y \u003e= 1 \u0026\u0026 y \u003c= 8;\r}\rvoid check() {\rvector\u003cint\u003e x(xinit), y(yinit), s(step);\rbool go = true;\rwhile (go) {\rgo = false;\rfor (int i = 0; i \u003c n; ++i) {\rif (s[i] \u003e 0) {\rs[i]--;\rx[i] += d[direction[i]][0];\ry[i] += d[direction[i]][1];\r}\rif (s[i])\rgo = true;\r}\rfor (int i = 0; i \u003c n; ++i)\rfor (int j = i + 1; j \u003c n; ++j)\rif (x[i] == x[j] \u0026\u0026 y[i] == y[j])\rreturn;\r}\rans++;\r}\rvoid dfs(int i) { if (i == n) {\rcheck();\r} else {\rdirection.push_back(0);\rstep.push_back(0);\rdfs(i + 1);\rdirection.pop_back();\rstep.pop_back();\rfor (int j = 1; j \u003c 8; ++j) {\rfor (int k : possible[i]) {\rint x = positions[i][0] + d[k][0] * j, y = positions[i][1] + d[k][1] * j;\rif (valid(x, y)) {\rdirection.push_back(k);\rstep.push_back(j);\rdfs(i + 1);\rdirection.pop_back();\rstep.pop_back();\r}\r}\r}\r}\r}\rpublic:\rint countCombinations(vector\u003cstring\u003e\u0026 pieces, vector\u003cvector\u003cint\u003e\u003e\u0026 positions) {\rn = pieces.size();\rpossible = vector\u003cvector\u003cint\u003e\u003e(n);\rthis-\u003epositions = positions;\rxinit = vector\u003cint\u003e(n), yinit = vector\u003cint\u003e(n);\rfor (int i = 0; i \u003c n; ++i) {\rxinit[i] = positions[i][0], yinit[i] = positions[i][1];\rif (pieces[i] != \"rook\") {\rpossible[i].emplace_back(1);\rpossible[i].emplace_back(3);\rpossible[i].emplace_back(5);\rpossible[i].emplace_back(7);\r}\rif (pieces[i] != \"bishop\") {\rpossible[i].emplace_back(0);\rpossible[i].emplace_back(2);\rpossible[i].emplace_back(4);\rpossible[i].emplace_back(6);\r}\r}\rdfs(0);\rreturn ans;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:41:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:42:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求有多少个n的排列有k个逆序对（n\u003c=1000, k\u003c=1000） ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:42:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 裸dp，设dp[i][j]表示i的排列有j个逆序对的答案，对于数字i，它可以插到i-1的排列的任何位置而产生逆序对 dp[i][j] = dp[i-1][max(0, j-i+1)] + .. + dp[i-1][j] 初始化dp=0, dp[1][0] = 1，注意初始化和特判 class Solution {\rpublic int kInversePairs(int n, int k) {\rif (k \u003e n * (n - 1) / 2) return 0;\rfinal long mod = (long) (1e9 + 7);\rlong[][] dp = new long[n + 1][k + 1];\rlong[] presum = new long[k + 1];\rdp[1][0] = 1;\rArrays.fill(presum, 1);\rfor (int i = 2; i \u003c= n; ++i) {\rfor (int j = 0; j \u003c= k; ++j) {\rif (j \u003e i * (i - 1) / 2) break;\relse {\r//dp[i][j] = (presum[j] - presum[Math.max(j - i, )]);\r if (j - i \u003e= 0) {\rdp[i][j] = presum[j] - presum[j - i];\r}else {\rdp[i][j] = presum[j];\r}\rdp[i][j] += mod;\rdp[i][j] %= mod;\r}\r}\rpresum[0] = dp[i][0];\rfor (int p = 1; p \u003c= k; ++p) {\rpresum[p] = presum[p - 1] + dp[i][p];\rpresum[p] %= mod;\r}\r}\rreturn (int) dp[n][k];\r}\r}\r// 2 2 (0)\r// 3 2 (2)\r// 3 3 (1)\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:42:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"区间dp Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:43:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:43:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 这个题的本质是猜一个数后，会转到左边区间还是右边区间，然后一直重复，所以是个区间dp。设dp[i][j]表示从i到j的答案，对于某个区间，枚举区间的每个数作为猜测的数，dp[i][j] = max(dp[i][k-1], dp[k+1][j]) + val[k]，注意特判猜测的数为左端点和右端点，初始化为最大值，dp[i][i] = 0 class Solution {\rpublic int getMoneyAmount(int n) {\rint[][] dp = new int[n + 1][n + 1];\rfor (int i = 0; i \u003c n + 1; ++i) {\rfor (int j = 0; j \u003c n + 1; ++j) {\rdp[i][j] = Integer.MAX_VALUE;\r}\r}\rfor (int len = 1; len \u003c= n; ++len) {\rfor (int i = 1; i \u003c= n - len + 1; ++i) {\rif (len == 1) {\rdp[i][i] = 0;\r}else {\rfor (int j = i; j \u003c= i + len - 1; ++j) {\rif (j == i) {\rdp[i][i + len - 1] = Math.min(dp[i][i + len - 1], dp[i + 1][i + len - 1] + j);\r}else if (j == i + len - 1) {\rdp[i][i + len - 1] = Math.min(dp[i][i + len - 1], dp[i][i + len - 2] + j);\r}else {\rdp[i][i + len - 1] = Math.min(dp[i][i + len - 1], Math.max(dp[i][j - 1], dp[j + 1][i + len - 1]) + j);\r}\r}\r}\r}\r}\rreturn dp[1][n];\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:43:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:44:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:44:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic:\rbool checkAlmostEquivalent(string word1, string word2) {\rint num1[26] = {0};\rint num2[26] = {0};\rfor (char i : word1) {\rnum1[i - 'a']++;\r}\rfor (char i : word2) {\rnum2[i - 'a']++;\r}\rfor (int i = 0; i \u003c 26; ++i) {\rif (abs(num1[i] - num2[i]) \u003e 3) return false;\r}\rreturn true;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:44:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:45:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:45:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic:\rvector\u003cint\u003e maximumBeauty(vector\u003cvector\u003cint\u003e\u003e\u0026 items, vector\u003cint\u003e\u0026 queries) {\rint qn = (int) queries.size();\rint in = (int) items.size();\rvector\u003cint\u003e ans(qn);\rvector\u003cpair\u003cint, int\u003e\u003e Q;\rfor (int i = 0; i \u003c qn; ++i) {\rQ.emplace_back(queries[i], i);\r}\rsort(Q.begin(), Q.end());\rvector\u003cpair\u003cint, int\u003e\u003e tmp;\rfor (auto i : items) {\rtmp.emplace_back(i[0], i[1]);\r}\rsort(tmp.begin(), tmp.end());\rint cnt = 0;\rint mx = 0;\rfor (int i = 0; i \u003c qn; ++i) {\rwhile (cnt \u003c in and tmp[cnt].first \u003c= Q[i].first) {\rmx = max(mx, tmp[cnt].second);\rcnt++;\r}\rans[Q[i].second] = mx;\r}\rreturn ans;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:45:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:46:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:46:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意题目说机器人走到头如果没有下一步是不会转向的 注意用周期优化 降低dirt！！ class Robot {\rpublic:\rint dir; // 0 right 1 up 2 left 3 down\r int w, h;\rint x, y;\rint circle;\rRobot(int width, int height) {\rdir = 0;\rw = width;\rh = height;\rx = 0;\ry = 0;\rcircle = (w + h) * 2 - 4;\r}\rvoid move(int num) {\r//cout \u003c\u003c num \u003c\u003c \": \";\r while (num \u003e 0) {\rif (dir == 0) {\rif (w - 1 - x \u003e= num) {\rx += num;\rnum = 0;\r}else {\rnum -= (w - 1 - x);\rx = w - 1;\rnum %= circle;\rif (num != 0) dir ++;\rdir %= 4;\r}\r} else if (dir == 3) {\rif (y \u003e= num) {\ry -= num;\rnum = 0;\r}else {\rnum -= y;\ry = 0;\rnum %= circle;\rif (num != 0) dir ++;\rdir %= 4;\r}\r} else if (dir == 2) {\rif (x \u003e= num) {\rx -= num;\rnum = 0;\r}else {\rnum -= x;\rx = 0;\rnum %= circle;\rif (num != 0) dir++;\rdir %= 4;\r}\r} else {\rif (h - 1 - y \u003e= num) {\ry += num;\rnum = 0;\r}else {\rnum -= (h - 1 - y);\ry = h - 1;\rnum %= circle;\rif (num != 0) dir++;\rdir %= 4;\r}\r}\r}\r//cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c ' ' \u003c\u003c dir \u003c\u003c '\\n';\r }\rvector\u003cint\u003e getPos() {\rreturn vector\u003cint\u003e{x, y};\r}\rstring getDir() {\rif (dir == 0) return \"East\";\rif (dir == 1) return \"North\";\rif (dir == 2) return \"West\";\rreturn \"South\";\r}\r};\r/**\r* Your Robot object will be instantiated and called as such:\r* Robot* obj = new Robot(width, height);\r* obj-\u003emove(num);\r* vector\u003cint\u003e param_2 = obj-\u003egetPos();\r* string param_3 = obj-\u003egetDir();\r*/\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:46:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"数论 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:47:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 强烈建议阅读英文题面 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:47:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 只有被转换奇数次的才会亮着，也就是约数有奇数个的才行，约数有奇数个的是完全平方数，所以就是求n以内的完全平方数个数 注意如果出现精度问题要+0.0000001这种 class Solution {\rpublic int bulbSwitch(int n) {\rreturn (int) Math.sqrt(n);\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:47:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"扫描线 结论 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:48:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 坐标系上有n个矩形，问是否这n个矩形不重叠且可以组成恰1个矩形 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:48:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 如果可以拼成1个矩形，需要满足除边缘的线，组成的区间都有左边矩形和右边矩形匹配，因为最终只能是1个矩形，所以每条竖线只能合并成1个区间（且原来的碎片区间不相交）而不是分裂的几个区间，比如说 这是我一开始的想法，后来被证伪，反例是 所以应该是除边缘线外可以是分裂的区间，边缘线必须合并成1个区间 class Solution {\rpublic boolean isRectangleCover(int[][] rectangles) {\rint L, R;\rL = Integer.MAX_VALUE;\rR = Integer.MIN_VALUE;\rint n = rectangles.length;\rfor (int[] rectangle : rectangles) {\rL = Math.min(L, rectangle[0]);\rR = Math.max(R, rectangle[2]);\r}\rHashMap\u003cInteger, ArrayList\u003cint[]\u003e\u003e LineL = new HashMap\u003c\u003e();\rHashMap\u003cInteger, ArrayList\u003cint[]\u003e\u003e LineR = new HashMap\u003c\u003e();\rHashSet\u003cInteger\u003e Line = new HashSet\u003c\u003e();\rfor (int[] rectangle : rectangles) {\rLine.add(rectangle[0]);\rLine.add(rectangle[2]);\rint[] tmp = {rectangle[1], rectangle[3]};\rif (!LineR.containsKey(rectangle[0])) {\rLineR.put(rectangle[0], new ArrayList\u003c\u003e());\r}\rLineR.get(rectangle[0]).add(tmp);\rif (!LineL.containsKey(rectangle[2])) {\rLineL.put(rectangle[2], new ArrayList\u003c\u003e());\r}\rLineL.get(rectangle[2]).add(tmp);\r}\rfor (Map.Entry\u003cInteger, ArrayList\u003cint[]\u003e\u003e entry : LineL.entrySet()) {\rentry.getValue().sort((a, b) -\u003e {\rif (a[0] != b[0]) return a[0] - b[0];\rreturn a[1] - b[1];\r});\r}\rfor (Map.Entry\u003cInteger, ArrayList\u003cint[]\u003e\u003e entry : LineR.entrySet()) {\rentry.getValue().sort((a, b) -\u003e {\rif (a[0] != b[0]) return a[0] - b[0];\rreturn a[1] - b[1];\r});\r}\rfor (int i : Line) {\rif (i == L) {\rList\u003cint[]\u003e tmp = LineR.get(i);\rfor (int j = 1; j \u003c tmp.size(); ++j) {\rif (tmp.get(j)[0] == tmp.get(j - 1)[1]) continue;\rreturn false;\r}\r}else if (i == R) {\rList\u003cint[]\u003e tmp = LineL.get(i);\rfor (int j = 1; j \u003c tmp.size(); ++j) {\rif (tmp.get(j)[0] == tmp.get(j - 1)[1]) continue;\rreturn false;\r}\r}else {\rif (!LineL.containsKey(i)) return false;\rif (!LineR.containsKey(i)) return false;\rList\u003cint[]\u003e tmpl = new ArrayList\u003c\u003e(), tmpr = new ArrayList\u003c\u003e();\rList\u003cint[]\u003e tmp = LineL.get(i);\rint cnt = tmp.get(0)[0];\rfor (int j = 1; j \u003c tmp.size(); ++j) {\rif (tmp.get(j)[0] == tmp.get(j - 1)[1]) continue;\rtmpl.add(new int[]{cnt, tmp.get(j - 1)[1]});\rcnt = tmp.get(j)[0];\r}\rtmpl.add(new int[]{cnt, tmp.get(tmp.size() - 1)[1]});\rtmp = LineR.get(i);\rcnt = tmp.get(0)[0];\rfor (int j = 1; j \u003c tmp.size(); ++j) {\rif (tmp.get(j)[0] == tmp.get(j - 1)[1]) continue;\rtmpr.add(new int[]{cnt, tmp.get(j - 1)[1]});\rcnt = tmp.get(j)[0];\r}\rtmpr.add(new int[]{cnt, tmp.get(tmp.size() - 1)[1]});\rif (tmpl.size() != tmpr.size()) return false;\rfor (int j = 0; j \u003c tmpl.size(); ++j) {\rif (tmpl.get(j)[0] == tmpr.get(j)[0] \u0026\u0026 tmpl.get(j)[1] == tmpr.get(j)[1]) continue;\rreturn false;\r}\r}\r}\rreturn true;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:48:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:49:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:49:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 小技巧是用二进制存信息优化 class Solution {\rpublic int maxProduct(String[] words) {\rint n = words.length;\rint[] num = new int[n];\rint ans = 0;\rfor (int j = 0; j \u003c n; ++j) {\rint tmp = 0;\rfor (int i = 0; i \u003c words[j].length(); ++i) {\rtmp |= (1 \u003c\u003c (words[j].charAt(i) - 'a'));\r}\rnum[j] = tmp;\r}\rfor (int i = 0; i \u003c n; ++i) {\rfor (int j = i + 1; j \u003c n; ++j) {\rif ((num[j] \u0026 num[i]) == 0) {\rans = Math.max(ans, words[i].length() * words[j].length());\r}\r}\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:49:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp 分类讨论 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:50:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:50:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 正则表达式匹配最高效的做法应该是用状态机？ 很好的dp题，细节比较多（官方题解似乎很简洁🤔） dp[i][j]表示s串前i个和p串的前j个是否匹配 如果s[i] = p[j] 那一定可以匹配， dp[i][j] = dp[i-1][j-1] 否则如果p[j] 是个字母，由于两个字母不同，一定不匹配 dp[i][j] = false 否则如果p[j]是’.'，它可以匹配任意一个字母，可以匹配dp[i][j] = dp[i-1][j-1] 否则如果p[j] = ‘*'， 这个比较麻烦 如果p[j-1] = s[i] 则这个*可以把前面的字母和自己吞掉，可以把自己吞掉，可以复制前面的字母，所以 dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j-1] 否则如果p[j-1]是个字母，那*只能把前面的字母吞掉，dp[i][j] = dp[i][j-2] 否则如果p[j-1]是’.'， 那它可以当做任何一个字母，dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j-1] 不可能出现两个连续的’*’ 初始化 dp = false, dp[0][0] = true 这么做有几个漏洞 “aab”, “cab” 无法通过，因为一开始就不匹配，后面都匹配不了（这肯能和代码有关），所以需要在s串和p串加个’a'来启动匹配 “aaa”, “.*” 无法通过，最后漏考虑了一种情况，因为 “.*” 的 ‘.’ 可以是任意字母，所以dp[i][j] |= dp[i-1][j]，即当前s串的最后一个字母一定能匹配 有罚时的比赛应该考虑怎么通过想这些样例来降低dirt！！ class Solution {\rpublic boolean isMatch(String s, String p) {\rs = new StringBuilder(s).insert(0, 'a').toString(); // insert 'a' in front to make aligned, pass \"aab\", \"c*a*b\"\r p = new StringBuilder(p).insert(0, 'a').toString();\rint sn = s.length(), pn = p.length();\rs = new StringBuilder(s).insert(0, 'a').toString();\rp = new StringBuilder(p).insert(0, 'a').toString();\rboolean[][] dp = new boolean[sn + 1][pn + 1];\rdp[0][0] = true;\rfor (int i = 1; i \u003c= sn; ++i) {\rfor (int j = 1; j \u003c= pn; ++j) {\rif (s.charAt(i) == p.charAt(j)) {\rdp[i][j] = dp[i - 1][j - 1];\r} else if ('a' \u003c= p.charAt(j) \u0026\u0026 p.charAt(j) \u003c= 'z') {\rdp[i][j] = false;\r} else if (p.charAt(j) == '.') {\rdp[i][j] = dp[i - 1][j - 1];\r} else if (p.charAt(j) == '*') {\rif (p.charAt(j - 1) == s.charAt(i)) {\rdp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j - 1];\r} else if (p.charAt(j - 1) \u003e= 'a' \u0026\u0026 p.charAt(j - 1) \u003c= 'z') {\rdp[i][j] = dp[i][j - 2];\r} else if (p.charAt(j - 1) == '.') {\rdp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j - 1] || dp[i - 1][j]; // add dp[i - 1][j] to pass \"aaa\", \".*\"\r }\r}\r}\r}\rreturn dp[sn][pn];\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:50:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"预处理 数位dp 递归 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:51:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:51:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 预处理dp[i]表示小于等于i位数的1的个数 对于数n，比如它为114514，就可以先算1-99999中1的个数，然后计算100000-114514的1的个数，接下来算最高位的1，有14515个，最后递归算1-14514的1的个数 再比如7355608，可以先算1-999999的1的个数，然后计算1000000-7355608的1的个数，接下来算最高位1，有1000000个，再算2000000-7355608，这等价于递归算1-355608中1的个数 class Solution {\rint[] dp = new int[11];\rpublic int countDigitOne(int n) {\rdp[1] = 1;\rfor (int i = 2; i \u003c 11; ++i) {\rdp[i] += dp[i - 1];\rdp[i] += 9 * dp[i - 1] + Math.pow(10, i - 1);\r}\rreturn cal(n);\r}\rprivate int digitNum(int n) {\rif (n == 0) return 1;\rint res = 0;\rwhile (n != 0) {\rres++;\rn /= 10;\r}\rreturn res;\r}\rprivate int cal(int n) {\rint num = digitNum(n);\rif (num == 1) {\rreturn n \u003c 1 ? 0 : 1;\r}\rint ans = dp[num - 1];\rint tmp = (int) (n / Math.pow(10, num - 1));\rtmp--;\rans += tmp * dp[num - 1];\rans += Math.min(n - Math.pow(10, num - 1) + 1, Math.pow(10, num - 1));\rans += cal((int) (n % Math.pow(10, num - 1)));\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:51:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"bfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:52:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 将二叉树序列化和反序列化，不管实现逻辑，只要能保证不同二叉树对应不同序列即可 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:52:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 本来想试试用prufer code，顺便复习一波，后来发现prufer code只能用在labeled tree 只要bfs层序遍历，多记一层的空节点 /**\r* Definition for a binary tree node.\r* public class TreeNode {\r* int val;\r* TreeNode left;\r* TreeNode right;\r* TreeNode(int x) { val = x; }\r* }\r*/\rpublic class Codec {\r// Encodes a tree to a single string.\r public String serialize(TreeNode root) {\rif (root == null) return \"null\";\rStringBuilder sb = new StringBuilder();\rQueue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(){{add(root);}};\rwhile (!q.isEmpty()) {\rTreeNode tmp = q.poll();\rif (tmp == null) {\rsb.append(\",null\");\r} else {\rif (tmp != root) sb.append(',');\rsb.append(String.valueOf(tmp.val));\r}\rif (tmp != null) {\rq.add(tmp.left);\rq.add(tmp.right);\r}\r}\r//System.out.println(sb.toString());\r return sb.toString();\r}\r// Decodes your encoded data to tree.\r public TreeNode deserialize(String data) {\rif (data.equals(\"null\")) return null;\rString[] d = data.split(\",\");\rTreeNode root = new TreeNode(Integer.parseInt(d[0]));\rQueue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(){{add(root);}};\rint cur = 1;\rwhile (!q.isEmpty()) {\rTreeNode tmp = q.poll();\rString left = d[cur]; String right = d[cur + 1];\rcur += 2;\rif (!left.equals(\"null\")) {\rTreeNode lnode = new TreeNode(Integer.parseInt(left));\rtmp.left = lnode;\rq.add(lnode);\r}\rif (!right.equals(\"null\")) {\rTreeNode rnode = new TreeNode(Integer.parseInt(right));\rtmp.right = rnode;\rq.add(rnode);\r}\r}\rreturn root;\r}\r}\r// Your Codec object will be instantiated and called as such:\r// Codec codec = new Codec();\r// codec.deserialize(codec.serialize(root));\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:52:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"双端队列 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:53:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 经典的滑动窗口 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:53:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 参考此处 class Solution {\rpublic int[] maxSlidingWindow(int[] nums, int k) {\rif (nums.length == 0) return new int[0];\rint n = nums.length;\rint[] ans = new int[n - k + 1];\rDeque\u003cInteger\u003e dq = new LinkedList\u003c\u003e();\rfor (int i = 0; i \u003c n; ++i) {\rif (!dq.isEmpty() \u0026\u0026 dq.peekFirst() \u003c= i - k) {\rdq.pollFirst();\r}\rwhile (!dq.isEmpty() \u0026\u0026 nums[dq.peekLast()] \u003c= nums[i]) {\rdq.pollLast();\r}\rdq.offerLast(i);\rif (i \u003e= k - 1) {\rans[i - k + 1] = nums[dq.peekFirst()];\r}\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:53:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"堆 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:54:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:54:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 三年前啥也不会的我在紫书上看到这个题以为无解。。。😄 参考此处 class MedianFinder {\r/** initialize your data structure here. */\rQueue\u003cInteger\u003e minHeap, maxHeap;\rpublic MedianFinder() {\rminHeap = new PriorityQueue\u003c\u003e((a, b) -\u003e a - b);\rmaxHeap = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a);\r}\rpublic void addNum(int num) {\rif (maxHeap.isEmpty()) {\rmaxHeap.add(num);\r} else {\rif (num \u003e maxHeap.peek()) {\rminHeap.add(num);\r} else {\rmaxHeap.add(num);\r}\r}\rif (maxHeap.size() \u003e minHeap.size() + 1) {\rminHeap.add(maxHeap.poll());\r}\rif (minHeap.size() \u003e maxHeap.size() + 1) {\rmaxHeap.add(minHeap.poll());\r}\r}\rpublic double findMedian() {\rif (maxHeap.size() == minHeap.size() + 1) {\rreturn maxHeap.peek();\r} else if (minHeap.size() == maxHeap.size() + 1) {\rreturn minHeap.peek();\r} else {\rreturn (minHeap.peek() + maxHeap.peek()) / 2.0;\r}\r}\r}\r/**\r* Your MedianFinder object will be instantiated and called as such:\r* MedianFinder obj = new MedianFinder();\r* obj.addNum(num);\r* double param_2 = obj.findMedian();\r*/\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:54:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"归并排序 树状数组 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:55:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求逆序对个数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:55:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 经典的就是归并排序求，但是这个细节太多不好写，树状数组思路比较直接 求三元逆序组参考此处 归并排序 class Solution {\rint[] tmp;\rpublic int reversePairs(int[] nums) {\rint n = nums.length;\rif (n \u003c 2) return 0;\rtmp = new int[n];\rreturn cal(nums, 0, n - 1);\r}\rprivate int cal(int[] nums, int l, int r) {\rif (l == r) return 0;\rint mid = l + (r - l) / 2;\rint leftCount = cal(nums, l, mid);\rint rightCount = cal(nums, mid + 1, r);\rif (nums[mid] \u003c= nums[mid + 1]) {\rreturn leftCount + rightCount;\r}\rreturn leftCount + rightCount + crossCount(nums, l, mid, r);\r}\rprivate int crossCount(int[] nums, int l, int mid, int r) {\rfor (int i = l; i \u003c= r; ++i) {\rtmp[i] = nums[i];\r}\rint res = 0;\rint ptrL = l, ptrR = mid + 1;\rfor (int i = l; i \u003c= r; ++i) {\rif (ptrL == mid + 1) {\rnums[i] = tmp[ptrR];\rptrR++;\r} else if (ptrR == r + 1) {\rnums[i] = tmp[ptrL];\rptrL++;\r} else if (tmp[ptrL] \u003c= tmp[ptrR]) {\rnums[i] = tmp[ptrL];\rptrL++;\r} else {\rnums[i] = tmp[ptrR];\rptrR++;\rres += mid - ptrL + 1;\r}\r}\rreturn res;\r}\r}\r 树状数组 class Solution {\rpublic int reversePairs(int[] nums) {\rint n = nums.length;\rint[] tmp = new int[n];\rSystem.arraycopy(nums, 0, tmp, 0, n);\rArrays.sort(tmp);\rfor (int i = 0; i \u003c n; ++i) {\rnums[i] = Arrays.binarySearch(tmp, nums[i]) + 1;\r}\rFenwickTree fenwickTree = new FenwickTree(n);\rint ans = 0;\rfor (int i = 0; i \u003c n; ++i) {\rans += i - fenwickTree.sum(nums[i]);\rfenwickTree.add(nums[i], 1);\r}\rreturn ans;\r}\r}\rclass FenwickTree {\r//[1, n]\r private int[] bit;\rprivate int n;\rpublic FenwickTree(int n) {\rthis.bit = new int[n + 1];\rthis.n = n;\r}\rpublic int sum(int i) {\rint s = 0;\rwhile (i \u003e 0) {\rs += bit[i];\ri -= i \u0026 -i;\r}\rreturn s;\r}\rpublic void add(int i, int x) {\rwhile (i \u003c= n) {\rbit[i] += x;\ri += i \u0026 -i;\r}\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:55:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"数论 结论 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:56:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给定一个正整数 n ，你可以做如下操作： 如果 n 是偶数，则用 n / 2替换 n 。 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。 n 变为 1 所需的最小替换次数是多少？ ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:56:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 直接搜索或者 对于奇数+1还是-1，分情况讨论 可以发现奇数n%4=1选-1，否则选+1 注意特判3和int溢出，这个也太细节了😣，什么时候能做到思维严谨，都是以前养成的不好习惯 class Solution {\rpublic int integerReplacement(int n) {\rlong nn = n;\rint ans = 0;\rwhile (nn != 1) {\rif (nn == 3) return ans + 2;\rif ((nn \u0026 1) == 1) {\rif ((nn \u003e\u003e 1 \u0026 1) == 1) {\rnn++;\r} else {\rnn--;\r}\r} else {\rnn /= 2;\r}\rans++;\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:56:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"k进制 思维 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:57:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:57:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 经典面试题，用k进制做 class Solution {\rpublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\rreturn (int) Math.ceil(Math.log(buckets) / Math.log(minutesToTest / minutesToDie + 1));\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:57:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:58:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 实现随机取1-1e8中的数字，取过的数字不再取的方法 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:58:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 用哈希表，将取过的数据交换到后面，没取的数交换到前面。假设还能取x个，这样每次都随机取1-x，这里面包含了之前被交换过来没取过的数 class Solution {\rMap\u003cInteger, Integer\u003e mp;\rint m, n;\rint curNum;\rRandom random;\rpublic Solution(int m, int n) {\rthis.m = m;\rthis.n = n;\rmp = new HashMap\u003c\u003e();\rrandom = new Random();\rcurNum = m * n;\r}\rpublic int[] flip() {\rint tmp = random.nextInt(curNum);\rcurNum--;\rint id = mp.getOrDefault(tmp, tmp);\rmp.put(tmp, mp.getOrDefault(curNum, curNum));\rreturn new int[]{id / n, id % n};\r}\rpublic void reset() {\rmp.clear();\rcurNum = m * n;\r}\r}\r/**\r* Your Solution object will be instantiated and called as such:\r* Solution obj = new Solution(m, n);\r* int[] param_1 = obj.flip();\r* obj.reset();\r*/\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:58:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"可重置节点并查集 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:59:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:59:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 按时间顺序用并查集模拟，但是需要撤销操作。做法是把这个时刻的点都加完，遍历这一轮的点，如果和0不在一个集合里，就重置par[x] = x 主要是和 “重置节点” 结合 class Solution {\rpublic:\rvector\u003cint\u003e findAllPeople(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 meetings, int firstPerson) {\rqueue\u003cint\u003e q;\rint par[n];\rint rankk[n];\rfor (int i = 0; i \u003c n; ++i) {\rpar[i] = i;\rrankk[i] = 0;\r}\rfunction\u003cint(int)\u003e find = [\u0026](int x) {\rif (par[x] == x) return x;\rreturn par[x] = find(par[x]);\r}; auto unite = [\u0026](int x, int y) {\rx = find(x);\ry = find(y);\rif (x == y) return ;\rif (rankk[x] \u003c rankk[y]) par[x] = y;\relse {\rpar[y] = x;\rif (rankk[x] == rankk[y]) rankk[x]++;\r}\r};\rauto same = [\u0026](int x, int y) {\rreturn find(x) == find(y);\r};\rauto reset = [\u0026](int x) {\rpar[x] = x;\rrankk[x] = 0;\r};\rmap\u003cint, vector\u003cpair\u003cint, int\u003e\u003e\u003e mp;\rfor (auto\u0026 i : meetings) {\rmp[i[2]].emplace_back(i[0], i[1]);\r}\rmp[0].emplace_back(0, firstPerson);\rfor (auto\u0026 [x, y] : mp) {\rfor (auto\u0026 [i, j] : y) {\runite(i, j);\rq.push(i);\rq.push(j);\r}\rwhile (!q.empty()) {\rint tmp = q.front();\rq.pop();\rif (!same(tmp, 0)) reset(tmp);\r}\r}\rvector\u003cint\u003e ans;\rfor (int i = 0; i \u003c n; ++i) if (same(0, i)) ans.push_back(i);\rreturn ans;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:59:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 双指针 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:60:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:60:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 bf或者 二分第k大的数的值x（在0-1） 检测小于等于x的数有几个，如果小于k，l=mid，否则r=mid 用双指针i,j表示arr[i]/arr[j]是否小于等于x，如果是则i++，否则counter+=i 遍历每个j，i跟随着移动（类似于用归并排序算逆序对时，算跨过左右两个区间的逆序对个数） 时间复杂度O(n*logC)，C为(3e4)^2 class Solution {\rpublic int[] kthSmallestPrimeFraction(int[] arr, int k) {\rdouble l = 0, r = 1;\rfinal double eps = 1e-9;\rint n = arr.length;\rwhile (r - l \u003e= eps) {\rdouble mid = (l + r) / 2;\rint count = 0;\rint cnti = 0;\rint ansi = 0, ansj = n - 1;\rfor (int j = 1; j \u003c n; ++j) {\rwhile (true) {\rif ((double) arr[cnti] / arr[j] \u003c= mid) {\rif (arr[cnti] * arr[ansj] \u003e arr[j] * arr[ansi]) {\ransi = cnti;\ransj = j;\r}\rcnti++;\r}\relse {\rcount += cnti;\rbreak;\r}\r}\r}\rif (count == k) return new int[]{arr[ansi], arr[ansj]};\rif (count \u003e k) r = mid;\relse l = mid;\r}\rreturn null;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:60:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:61:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:61:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 二分 class Solution {\rpublic int findNthDigit(int n) {\rlong l = 1, r = n;\rwhile (l \u003c= r) {\rlong mid = l + (r - l) / 2;\rlong cnt = count(mid);\rif (cnt \u003c n) l = mid + 1;\relse r = mid - 1;\r}\rlong ct = count(l);\rct -= n;\rString s = String.valueOf(l);\rreturn (int) (s.charAt((int) (s.length() - ct - 1)) - '0');\r}\rpublic long count(long x) {\rint digitNum = 0;\rlong tmp = x;\rwhile (tmp \u003e 0) {\rtmp /= 10;\rdigitNum++;\r}\rlong res = 0;\rfor (int i = 1; i \u003c digitNum; ++i) {\rres += 9 * Math.pow(10, i - 1) * i;\r}\rres += (x - Math.pow(10, digitNum - 1) + 1) * digitNum;\rreturn res;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:61:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"欧拉降幂 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:62:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求a ^ b % 1337 ， b是大数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:62:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 除了欧拉降幂就不会做了捏😭 class Solution {\rpublic long quickPow(long x, long n, long mod) {\rlong res = 1;\rwhile (n \u003e 0) {\rif (n % 2 == 1) res = res * x % mod;\rx = x * x % mod;\rn \u003e\u003e= 1;\r}\rreturn res;\r}\rpublic int gcd(int a, int b) {\rreturn b == 0 ? a : gcd(b, a % b);\r}\rpublic int superPow(int a, int[] b) {\rlong phi = 1140;\rint n = b.length;\rlong now = 0;\rlong multiple = 1;\rfor (int i = n - 1; i \u003e= 0; --i) {\rnow += b[i] * multiple % phi;\rnow %= phi;\rmultiple *= 10;\rmultiple %= phi;\r}\rif (gcd(a, 1337) == 1) {\rreturn (int) quickPow(a, now, 1337);\r} else {\rreturn (int) quickPow(a, now + phi, 1337);\r}\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:62:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"完全背包 四平方和定理 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:63:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求1个正整数最少可以表示成几个完全平方数之和 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:63:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 完全背包或 四平方数之和（Lagrange’s four-square theorem），任何一个正整数都可以表示成最多四个完全平方数之和，特殊地，如果一个数不能表示成4^k*(8m+7)，(k\u003e=0, m\u003e=0)的形式，那它最多只需要三个数 class Solution:\rdef numSquares(self, n: int) -\u003e int:\rdp = [100000 for i in range(10005)]\rdp[0] = 0\ra = []\rk = 1\rwhile k * k \u003c= n + 5:\ra.append(k * k)\rk += 1\rsz = len(a)\rfor i in range(1, sz + 1):\rfor j in range(a[i - 1], n + 1):\rdp[j] = min(dp[j], dp[j - a[i - 1]] + 1) return dp[n]\r class Solution {\rpublic int numSquares(int n) {\r//Lagrange's four-square theorem\r if (isPerfectSquare(n)) return 1;\rfor (int i = 1; i * i \u003c n; ++i) {\rif (isPerfectSquare(n - i * i)) return 2;\r}\r// 4 ^ k * (8 * m + 7)\r while (n % 4 == 0) {\rn /= 4;\r}\rif (n % 8 == 7) return 4;\rreturn 3;\r}\rprivate boolean isPerfectSquare(int n) {\rint x = (int) Math.sqrt(n);\rreturn x * x == n;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:63:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:64:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求网格某个连通块的边界 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:64:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rprivate int[][] grid;\rprivate int cl;\rprivate int[][] dir = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\rprivate int n, m;\rpublic int[][] colorBorder(int[][] grid, int row, int col, int color) {\rQueue\u003cint[]\u003e q = new ArrayDeque\u003c\u003e();\rthis.grid = grid;\rthis.cl = grid[row][col];\rthis.n = grid.length;\rthis.m = grid[0].length;\rdfs(row, col);\rfor (int i = 0; i \u003c n; ++i) {\rfor (int j = 0; j \u003c m; ++j) {\rif (this.grid[i][j] == -1) {\rboolean ok = true;\rfor (int k = 0; k \u003c 4; ++k) {\rint tx = i + dir[k][0];\rint ty = j + dir[k][1];\rif (!(tx \u003e= 0 \u0026\u0026 tx \u003c n \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c m \u0026\u0026 this.grid[tx][ty] == -1)) {\rok = false;\rbreak;\r}\r}\rif (!ok) q.add(new int[]{i, j});\r}\r}\r}\rfor (int[] i : q) {\rgrid[i[0]][i[1]] = color;\r}\rfor (int i = 0; i \u003c n; ++i) {\rfor (int j = 0; j \u003c m; ++j) {\rif (grid[i][j] == -1) grid[i][j] = cl;\r}\r}\rreturn grid;\r}\rprivate void dfs(int x, int y) {\rgrid[x][y] = -1;\rfor (int i = 0; i \u003c 4; ++i) {\rint tx = x + dir[i][0];\rint ty = y + dir[i][1];\rif (tx \u003e= 0 \u0026\u0026 tx \u003c n \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c m \u0026\u0026 grid[tx][ty] == cl) dfs(tx, ty);\r}\r}\r}\r// [[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]\r// 1\r// 3\r// 1\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:64:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"欧拉路径 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:65:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:65:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 hierholzer算法，注意删边，不要判断边是否被遍历过 参考 class Solution {\rpublic:\rvector\u003cvector\u003cint\u003e\u003e validArrangement(vector\u003cvector\u003cint\u003e\u003e\u0026 pairs) {\rvector\u003cint\u003e id;\rfor (auto i : pairs) {\rid.push_back(i[0]);\rid.push_back(i[1]);\r}\rsort(id.begin(), id.end());\rid.erase(unique(id.begin(), id.end()), id.end());\rint n = (int) id.size();\rvector\u003cint\u003e G[n];\rauto get_id = [\u0026](int x) {\rreturn lower_bound(id.begin(), id.end(), x) - id.begin();\r};\rauto get_val = [\u0026](int x) {\rreturn id[x];\r};\rvector\u003cint\u003e indegree(n), outdegree(n);\rfor (auto i : pairs) {\rG[get_id(i[0])].push_back(get_id(i[1]));\routdegree[get_id(i[0])]++;\rindegree[get_id(i[1])]++;\r}\rint s = -1, t = -1;\rfor (int i = 0; i \u003c n; ++i) {\rif (outdegree[i] - indegree[i] == 1) s = i;\rif (indegree[i] - outdegree[i] == 1) t = i;\r}\rif (s == -1) s = 0;\rif (t == -1) t = 1;\rstack\u003cint\u003e st;\r//unordered_map\u003cpair\u003cint, int\u003e, bool, pair_hash\u003e used;\r function\u003cvoid(int)\u003e dfs = [\u0026](int x) {\rwhile (!G[x].empty()) {\rint tmp = G[x].back();\rG[x].pop_back();\rdfs(tmp);\r}\rst.push(x);\r};\rdfs(s);\rvector\u003cint\u003e tmp;\rwhile (!st.empty()) {\rtmp.push_back(st.top());\rst.pop();\r}\rvector\u003cvector\u003cint\u003e\u003e ans;\rfor (int i = 0; i \u003c (int) tmp.size() - 1; ++i) {\rans.push_back({get_val(tmp[i]), get_val(tmp[i + 1])});\r} return ans;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:65:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"前缀和 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:66:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:66:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int[] maxSumOfThreeSubarrays(int[] nums, int k) {\rlong mx = -1;\rint left = 0, mid = 0, right = 0;\rint n = nums.length;\rlong[] data = new long[n - k + 2];\rlong tmp = 0;\rfor (int i = 0; i \u003c k; ++i) {\rtmp += nums[i];\r}\rfor (int i = 1; i \u003c= n - k + 1; ++i) {\rdata[i] = tmp;\rif (i != n - k + 1) {\rtmp -= nums[i - 1];\rtmp += nums[i + k - 1];\r}\r}\rint[] premaxId = new int[n - k + 2];\rint[] sufmaxId = new int[n - k + 2];\rlong[] premax = new long[n - k + 2];\rlong[] sufmax = new long[n - k + 3];\rlong cntMx = -1;\rfor (int i = 1; i \u003c= n - k + 1; ++i) {\rif (data[i] \u003e cntMx) {\rcntMx = data[i];\rpremaxId[i] = i;\r} else premaxId[i] = premaxId[i - 1];\rpremax[i] = Math.max(premax[i - 1], data[i]);\r}\rcntMx = -1;\rfor (int i = n - k + 1; i \u003e= 1; --i) {\rif (data[i] \u003e= cntMx) {\rcntMx = data[i];\rsufmaxId[i] = i;\r} else sufmaxId[i] = sufmaxId[i + 1];\rsufmax[i] = Math.max(sufmax[i + 1], data[i]);\r}\rfor (int i = 2; i \u003c n - k + 1; ++i) {\rlong tmpval = data[i];\rif (i - k \u003e= 1) tmpval += premax[i - k]; else continue;\rif (i + k \u003c= n - k + 1) tmpval += sufmax[i + k]; else continue;\rif (tmpval \u003e mx) {\rmx = tmpval;\rleft = premaxId[i - k];\rmid = i;\rright = sufmaxId[i + k];\r}\r}\rreturn new int[]{left - 1, mid - 1, right - 1};\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:66:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"分类讨论 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:67:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:67:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic boolean validTicTacToe(String[] board) {\rchar[][] Board = new char[3][3];\rfor (int i = 0; i \u003c 3; ++i) {\rfor (int j = 0; j \u003c 3; ++j) {\rBoard[i][j] = board[i].charAt(j);\r}\r}\rint xnum = 0, onum = 0;\rboolean xwin = false, owin = false;\rfor (int i = 0; i \u003c 3; ++i) for (int j = 0; j \u003c 3; ++j) if (Board[i][j] == 'X') xnum++; else if (Board[i][j] == 'O') onum++;\rif (Board[0][0] == Board[0][1] \u0026\u0026 Board[0][1] == Board[0][2] \u0026\u0026 Board[0][2] == Board[0][0]) {\rif (Board[0][0] == 'X') xwin = true; else if (Board[0][0] == 'O') owin = true;\r}\rif (Board[1][0] == Board[1][1] \u0026\u0026 Board[1][1] == Board[1][2] \u0026\u0026 Board[1][2] == Board[1][0]) {\rif (Board[1][0] == 'X') xwin = true; else if (Board[1][0] == 'O') owin = true;\r}\rif (Board[2][0] == Board[2][1] \u0026\u0026 Board[2][1] == Board[2][2] \u0026\u0026 Board[2][2] == Board[2][0]) {\rif (Board[2][0] == 'X') xwin = true; else if (Board[2][0] == 'O') owin = true;\r}\rif (Board[0][0] == Board[1][0] \u0026\u0026 Board[1][0] == Board[2][0] \u0026\u0026 Board[2][0] == Board[0][0]) {\rif (Board[0][0] == 'X') xwin = true; else if (Board[0][0] == 'O') owin = true;\r}\rif (Board[0][1] == Board[1][1] \u0026\u0026 Board[1][1] == Board[2][1] \u0026\u0026 Board[2][1] == Board[0][1]) {\rif (Board[0][1] == 'X') xwin = true; else if (Board[0][1] == 'O') owin = true;\r}\rif (Board[0][2] == Board[1][2] \u0026\u0026 Board[1][2] == Board[2][2] \u0026\u0026 Board[2][2] == Board[0][2]) {\rif (Board[0][2] == 'X') xwin = true; else if (Board[0][2] == 'O') owin = true;\r}\rif (Board[0][0] == Board[1][1] \u0026\u0026 Board[1][1] == Board[2][2] \u0026\u0026 Board[2][2] == Board[0][0]) {\rif (Board[0][0] == 'X') xwin = true; else if (Board[0][0] == 'O') owin = true;\r}\rif (Board[0][2] == Board[1][1] \u0026\u0026 Board[1][1] == Board[2][0] \u0026\u0026 Board[2][0] == Board[0][2]) {\rif (Board[0][2] == 'X') xwin = true; else if (Board[0][2] == 'O') owin = true;\r}\rif (xwin \u0026\u0026 owin) return false;\rif (!xwin \u0026\u0026 !owin) {\rif (xnum == onum || xnum == onum + 1) return true; else return false;\r} else {\rif (xwin) { if (xnum == onum + 1) return true; else return false; // xnum != onum\r } else {\rif (xnum == onum) return true; else return false;\r}\r}\r}\r}\r// [\"XXX\",\"XOO\",\"OO \"]\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:67:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"前缀和 贪心 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:68:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:68:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 至多拐弯一次，注意细节 class Solution {\rpublic:\rint maxTotalFruits(vector\u003cvector\u003cint\u003e\u003e\u0026 f, int st, int k) {\rint n = (int) f.size();\rvector\u003cint\u003e presum(2e5 + 10);\runordered_map\u003cint, int\u003e mp;\rfor (int i = 0; i \u003c n; ++i) {\rmp[f[i][0] + 1] = f[i][1];\r}\rfor (int i = 1; i \u003c 2e5 + 10; ++i) {\rif (mp.find(i) != mp.end()) {\rpresum[i] = presum[i - 1] + mp[i];\r} else {\rpresum[i] = presum[i - 1];\r}\r}\rint mx = -1;\rst++;\rif (k == 0) return mp[st];\rfor (int i = 1; i \u003c= 2e5 + 3; ++i) {\rint now = 0;\rif (abs(st - i) \u003e k) continue;\rif (i \u003c= st) {\rnow += presum[st] - presum[i - 1];\rint rem = k - 2 * (st - i);\rif (rem \u003c= 0 ) {\rmx = max(mx, now);\rcontinue;\r} else if (st + rem \u003e 2e5 + 3) {\rnow += presum[2e5 + 3] - presum[st];\rmx = max(mx, now);\rcontinue;\r}\rnow += presum[st + rem] - presum[st];\r} else {\rnow += presum[i] - presum[st - 1];\rint rem = k - 2 * (i - st);\rif (rem \u003c= 0) {\rmx = max(now, mx);\rcontinue;\r} else if (st - rem \u003c= 0) {\rnow += presum[st - 1] - presum[0];\rmx = max(mx, now);\rcontinue;\r}\rnow += presum[st - 1] - presum[st - rem - 1];\r}\rmx = max(mx, now);\r}\rreturn mx;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:68:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"贪心 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:69:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:69:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int maxIncreaseKeepingSkyline(int[][] grid) {\rint n = grid.length;\rint m = grid[0].length;\rint[] maxrow = new int[n];\rint[] maxcol = new int[n];\rfor (int i = 0; i \u003c n; ++i) {\rint mx = -1;\rfor (int j = 0; j \u003c m; ++j) {\rmx = Math.max(mx, grid[i][j]);\r}\rmaxrow[i] = mx;\r}\rfor (int i = 0; i \u003c m; ++i) {\rint mx = -1;\rfor (int j = 0; j \u003c n; ++j) {\rmx = Math.max(mx, grid[j][i]);\r}\rmaxcol[i] = mx;\r}\rint ans = 0;\rfor (int i = 0; i \u003c n; ++i) {\rfor (int j = 0; j \u003c m; ++j) {\rans += Math.min(maxcol[j], maxrow[i]) - grid[i][j]; //System.out.print(Math.min(maxcol[j], maxrow[i]) + \" \"); }\r//System.out.println();\r }\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:69:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"思维 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:70:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:70:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 奇妙利用查询的特殊性，参考这位大佬，思路真的十分神奇巧妙 class SORTracker {\rpublic:\rset\u003cpair\u003cint, string\u003e\u003e st;\rset\u003cpair\u003cint, string\u003e\u003e::iterator ite;\rSORTracker() {\rst.insert({0, \"\"});\rite = st.begin();\r}\rvoid add(string name, int score) {\rpair\u003cint, string\u003e p = make_pair(-score, name);\rst.insert(p);\rif (p \u003c *ite) ite--;\r}\rstring get() {\rreturn ite++-\u003esecond;\r}\r};\r/**\r1. Your SORTracker object will be instantiated and called as such:\r2. SORTracker* obj = new SORTracker();\r3. obj-\u003eadd(name,score);\r4. string param_2 = obj-\u003eget();\r*/\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:70:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs 图论 技巧 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:71:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 有n个人，每个人都有一个喜欢的人，让他们中的几个围着一个圆桌，满足所有人喜欢的人都坐在ta的旁边，求最多可以安排几个人 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:71:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 假设a喜欢b，则他们之间建立一条a指向b的有向边，组成有向图（可能不连通） 经分析可以发现有两种方式满足条件 把基环内向树最大的环放上去（只能放一个环） 把类似于a-\u003eb-\u003ec-\u003ed\u003c-\u003ee\u003c-f\u003c-g结构放上去（全都放） 分别求这两种情况 对于第一种，dfs，用着色判断这个点是没遍历过，还是当前遍历的序列，还是以前遍历的 对于第二种，把环长度为2的单独存（假设u\u003c-\u003ev），把边反向，求u往非v方向的最长链+v往非u方向的方向的最长链，注意基环内向树变成基环外向树，一个点能延伸的最长链等于所连接点的最长链的最大值+1 class Solution {\rList\u003cInteger\u003e[] G;\rint[] sta, d;\rint max_circle = 0;\rint max_chain = 0;\rList\u003cint[]\u003e mu_pair;\rpublic int maximumInvitations(int[] fav) {\rint n = fav.length;\rG = new ArrayList[n + 3];\rmu_pair = new ArrayList\u003c\u003e();\rfor (int i = 0; i \u003c n; ++i) {\rG[i] = new ArrayList\u003c\u003e();\r}\rfor (int i = 0; i \u003c n; ++i) {\rG[fav[i]].add(i);\r}\rsta = new int[n + 3];\rd = new int[n + 3];\rfor (int i = 0; i \u003c n; ++i) {\rif (sta[i] == 0) dfs1(i);\r}\rfor (int[] i : mu_pair) {\rmax_chain += dfs2(i[0], i[1]);\rmax_chain += dfs2(i[1], i[0]);\r}\rreturn Math.max(max_circle, max_chain);\r}\rpublic void dfs1(int x) {\rsta[x] = 1;\rfor (int i : G[x]) {\rif (sta[i] == 0) {\rd[i] = d[x] + 1;\rdfs1(i);\r} else if (sta[i] == 1) {\rint now_circle = d[x] - d[i] + 1;\rif (now_circle == 2) {\rmu_pair.add(new int[]{x, i});\r} else {\rmax_circle = Math.max(max_circle, now_circle);\r}\r}\r}\rsta[x] = 2;\r}\rpublic int dfs2(int x, int p) {\rif (G[x].isEmpty() || (G[x].size() == 1 \u0026\u0026 G[x].get(0) == p)) {\rreturn 1;\r}\rint ret = 0;\rfor (int i : G[x]) {\rif (i != p) {\rret = Math.max(ret, dfs2(i, x));\r}\r}\rreturn ret + 1;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:71:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp 记忆化搜索 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:72:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:72:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意判断平局的条件 class Solution {\rstatic final int WIN = 3;\rstatic final int LOSE = 4;\rstatic final int DRAW = 0;\rstatic final int MOUSE_WIN = 1;\rstatic final int CAT_WIN = 2;\rint n;\rint[][] G;\rint[][][] dp; // mouse cat round, val is WIN / LOSE\r public int catMouseGame(int[][] graph) {\rthis.n = graph.length;\rthis.G = graph;\rdp = new int[n + 2][n + 2][n * 2 + 2];\rfor (int i = 0; i \u003c n; ++i) {\rfor (int j = 0; j \u003c n; ++j) {\rArrays.fill(dp[i][j], -1);\r}\r}\rint result = getResult(1, 2, 0);\rif (result == WIN) return MOUSE_WIN;\relse if (result == LOSE) return CAT_WIN;\relse return DRAW;\r}\rpublic int getResult(int mouse, int cat, int round) {\rif (dp[mouse][cat][round] != -1) return dp[mouse][cat][round];\rif (round \u003e= 2 * n) {\rdp[mouse][cat][round] = DRAW;\rreturn DRAW;\r}\rif (mouse == 0) {\rif (round % 2 == 0) {\rdp[mouse][cat][round] = WIN;\rreturn WIN;\r} else {\rdp[mouse][cat][round] = LOSE;\rreturn LOSE;\r}\r}\rif (mouse == cat) {\rif (round % 2 == 0) {\rdp[mouse][cat][round] = LOSE;\rreturn LOSE;\r} else {\rdp[mouse][cat][round] = WIN;\rreturn WIN;\r}\r}\rboolean draw = false;\rboolean mouseRound = round % 2 == 0;\rint curMove = round % 2 == 0 ? mouse : cat;\rint curResult;\rfor (int i : G[curMove]) {\rif (!mouseRound \u0026\u0026 i == 0) continue;\rif (mouseRound) {\rcurResult = getResult(i, cat, round + 1);\r} else {\rcurResult = getResult(mouse, i, round + 1);\r}\rif (curResult == LOSE) {\rdp[mouse][cat][round] = WIN;\rreturn WIN;\r} else if (curResult == DRAW) {\rdraw = true;\r}\r}\rif (draw) {\rdp[mouse][cat][round] = DRAW;\rreturn DRAW;\r} else {\rdp[mouse][cat][round] = LOSE;\rreturn LOSE;\r}\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:72:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"bfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:73:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 有一个数组，初始时在0位置，每次可以选择向前一个位置或向后一个位置，或者跳到和当前值相同的位置，不能跳出界，求最少几次到最后一个位置 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:73:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 转化成图，bfs求最短路，注意标记走过的点和值 class Solution {\rpublic int minJumps(int[] arr) {\rMap\u003cInteger, List\u003cInteger\u003e\u003e mp = new HashMap\u003c\u003e();\rint n = arr.length;\rboolean[] vis = new boolean[n];\rSet\u003cInteger\u003e hoge = new HashSet\u003c\u003e();\rfor (int i = 0; i \u003c n; ++i) {\rmp.putIfAbsent(arr[i], new ArrayList\u003cInteger\u003e());\rmp.get(arr[i]).add(i);\r}\rint ans = 0;\rQueue\u003cInteger\u003e q = new ArrayDeque\u003c\u003e();\rq.offer(0);\rvis[0] = true;\rint num = 0;\rwhile (!q.isEmpty()) {\rif (num == 0) {\rnum = q.size();\rans++;\r}\rnum--;\rint cnt = q.poll();\rif (cnt == n - 1) return ans - 1;\rint val = arr[cnt];\rif (cnt - 1 \u003e= 0 \u0026\u0026 !vis[cnt - 1]) {\rq.offer(cnt - 1);\r}\rif (cnt + 1 \u003c n \u0026\u0026 !vis[cnt + 1]) {\rq.offer(cnt + 1);\r}\rif (hoge.contains(val)) continue;\rList\u003cInteger\u003e tmp = mp.get(val);\rfor (int i = 0; i \u003c tmp.size(); ++i) {\rif (!vis[tmp.get(i)]) {\rq.offer(tmp.get(i));\rvis[tmp.get(i)] = true;\r}\r}\rhoge.add(val);\r}\rreturn 0;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:73:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"穷举 模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:74:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:74:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意细节，减少dirt class Solution {\rpublic boolean isAdditiveNumber(String num) {\rint n = num.length();\rif (n \u003c 3) return false;\r// split after index\r for (int i = 0; i \u003c n - 2; ++i) {\rfor (int j = i + 1; j \u003c n - 1; ++j) {\r// checkPtr is the beginning of the number need checking\r int checkPtr = j + 1;\rString first = num.substring(0, i + 1);\rString second = num.substring(i + 1, j + 1);\rwhile (checkPtr \u003c n) {\rif (haveLeadingZero(first) || haveLeadingZero(second)) break;\rString tmp = addForBigInteger(first, second);\rif (haveLeadingZero(tmp)) break;\rif (num.length() \u003e= checkPtr + tmp.length() \u0026\u0026 tmp.equals(num.substring(checkPtr, checkPtr + tmp.length()))) {\rcheckPtr += tmp.length();\rfirst = second;\rsecond = tmp;\r} else\rbreak;\r}\rif (checkPtr == n) return true;\r}\r}\rreturn false;\r}\rprivate String addForBigInteger(String x, String y) {\rint len = Math.max(x.length(), y.length());\rStringBuffer sb1 = new StringBuffer(x);\rStringBuffer sb2 = new StringBuffer(y);\rsb1.reverse();\rsb2.reverse();\rwhile (sb1.length() \u003c len) {\rsb1.append('0');\r}\rwhile (sb2.length() \u003c len) {\rsb2.append('0');\r}\rStringBuffer sb = new StringBuffer();\rboolean carry = false;\rfor (int i = 0; i \u003c len; ++i) {\rint foo = sb1.charAt(i) - '0';\rint bar = sb2.charAt(i) - '0';\rint tmp = foo + bar + (carry ? 1 : 0);\rsb.append((char) (tmp % 10 + '0'));\rif (tmp \u003e 9) carry = true; else carry = false;\r}\rif (carry) sb.append('1');\rsb.reverse();\rreturn sb.toString();\r}\rprivate boolean haveLeadingZero(String x) {\rif (x.isEmpty()) return true;\rif (x.length() == 1) return false;\rreturn x.charAt(0) == '0';\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:74:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"归纳 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:75:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:75:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int removePalindromeSub(String s) {\rint n = s.length();\rfor (int i = 0; i \u003c n; ++i) {\rif (s.charAt(i) != s.charAt(n - 1 - i)) return 2;\r}\rreturn 1;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:75:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"贪心 技巧 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:76:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:76:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 如果没有空间限制直接用前后缀 在遍历的过程中维护三元组的第一个数和第二个数，贪心地选择最小的数作为第一个数和第二个数 注意注释的部分，我本来是这样写的，[2,3,1,4]这个用例错误，当遍历到1时，第一个数变成1，第二个数变成无穷，导致找不到三元组，实际上只应该更新第一个数即第一个数是1，第二个数是3，这个意思是已经有正序的二元组（还差第三个数），且第二个数最小为3 应该在提交前用一些容易想到的corner case来测试，比如说一个数、两个数、[2,3,1,4]等等 class Solution {\rpublic boolean increasingTriplet(int[] nums) {\rint n = nums.length;\rint first = nums[0];\rint second = Integer.MAX_VALUE;\rfor (int i = 1; i \u003c n; ++i) {\rif (nums[i] \u003e second) return true;\rif (nums[i] \u003c first) {\r// second = Integer.MAX_VALUE;\r first = nums[i];\r} else if (nums[i] \u003e first) {\rsecond = nums[i];\r}\r}\rreturn false;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:76:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"堆 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:77:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 合并k个有序链表 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:77:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 /**\r* Definition for singly-linked list.\r* public class ListNode {\r* int val;\r* ListNode next;\r* ListNode() {}\r* ListNode(int val) { this.val = val; }\r* ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r* }\r*/\rclass Solution {\rpublic ListNode mergeKLists(ListNode[] lists) {\rif (lists == null) return null;\rPriorityQueue\u003cListNode\u003e pq = new PriorityQueue\u003c\u003e((x, y) -\u003e x.val - y.val);\rint n = lists.length;\rListNode ptrListNode = new ListNode();\rListNode ans = ptrListNode;\rfor (int i = 0; i \u003c n; ++i) {\rif (lists[i] == null) continue;\rpq.offer(lists[i]);\r}\rwhile (!pq.isEmpty()) {\rListNode cntListNode = pq.poll();\rptrListNode.next = cntListNode;\rptrListNode = ptrListNode.next;\rif (cntListNode.next != null) pq.offer(cntListNode.next);\r}\rreturn ans.next;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:77:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:78:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:78:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 模拟 class StockPrice {\rMap\u003cInteger, Integer\u003e prices;\rTreeSet\u003cInteger\u003e treeSet;\rMap\u003cInteger, Integer\u003e num;\rint lastestTimestamp;\rpublic StockPrice() {\rprices = new HashMap\u003c\u003e();\rtreeSet = new TreeSet\u003c\u003e();\rnum = new HashMap\u003c\u003e();\rlastestTimestamp = -1;\r}\rpublic void update(int timestamp, int price) {\rlastestTimestamp = Math.max(timestamp, lastestTimestamp);\rint prevPrice = prices.getOrDefault(timestamp, -1);\rprices.put(timestamp, price);\rif (prevPrice == -1) {\rnum.put(price, num.getOrDefault(price, 0) + 1);\r} else {\rnum.put(prevPrice, num.get(prevPrice) - 1);\rnum.put(price, num.getOrDefault(price, 0) + 1);\r}\rtreeSet.add(price);\r}\rpublic int current() {\rreturn prices.get(lastestTimestamp);\r}\rpublic int maximum() {\rwhile (num.getOrDefault(treeSet.last(), 0) == 0) {\rtreeSet.remove(treeSet.last());\r}\rreturn treeSet.last();\r}\rpublic int minimum() {\rwhile (num.getOrDefault(treeSet.first(), 0) == 0) {\rtreeSet.remove(treeSet.first());\r}\rreturn treeSet.first();\r}\r}\r/**\r* Your StockPrice object will be instantiated and called as such:\r* StockPrice obj = new StockPrice();\r* obj.update(timestamp,price);\r* int param_2 = obj.current();\r* int param_3 = obj.maximum();\r* int param_4 = obj.minimum();\r*/\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:78:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"贪心 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:79:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:79:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 石子数对3取模 枚举alice选择1和选择2的情况，对于每个人，假设当前和为1，则优先选择1，如果没有1再选择0，如果当前和为2，则优先选择2，如果没有2则选择0，如果都没得选就输了 为什么这样贪心是对的，可以看做选择1而不是选择0，是对自己有好处，对别人有坏处（损人又利己），而选择0是对自己有好处，对别人没坏处 class Solution {\rpublic boolean stoneGameIX(int[] stones) {\rint n = stones.length;\rboolean aliceTurn = true;\rboolean aliceWin1 = false, aliceWin2 = false; int zeroNum = 0, oneNum = 0, twoNum = 0;\rfor (int i : stones) {\rif (i % 3 == 0) zeroNum++;\relse if (i % 3 == 1) oneNum++;\relse twoNum++;\r}\rint cnt;\rint cntOneNum = oneNum, cntTwoNum = twoNum;\rint cntZeroNum = zeroNum;\raliceTurn = true;\rif (cntOneNum \u003e 0) {\rcnt = 1;\rcntOneNum--;\raliceTurn = !aliceTurn;\rwhile (true) {\rif (cntZeroNum == 0 \u0026\u0026 cntOneNum == 0 \u0026\u0026 cntTwoNum == 0) {\raliceWin1 = false;\rbreak;\r}\rif (cnt == 1 \u0026\u0026 cntOneNum \u003e 0) {\rcntOneNum--;\rcnt = 2;\raliceTurn = !aliceTurn;\r} else if (cnt == 2 \u0026\u0026 cntTwoNum \u003e 0) {\rcntTwoNum--;\rcnt = 1;\raliceTurn = !aliceTurn;\r} else if (cnt == 1 \u0026\u0026 cntOneNum == 0 \u0026\u0026 cntZeroNum \u003e 0) {\rcntZeroNum--;\raliceTurn = !aliceTurn;\r} else if (cnt == 2 \u0026\u0026 cntTwoNum == 0 \u0026\u0026 cntZeroNum \u003e 0) {\rcntZeroNum--;\raliceTurn = !aliceTurn;\r} else {\rif (aliceTurn) {\raliceWin1 = false;\rbreak;\r} else {\raliceWin1 = true;\rbreak;\r}\r}\r}\r}\rcntOneNum = oneNum;\rcntTwoNum = twoNum;\rcntZeroNum = zeroNum;\raliceTurn = true;\rif (cntTwoNum \u003e 0) {\rcnt = 2;\rcntTwoNum--;\raliceTurn = !aliceTurn;\rwhile (true) {\rif (cntZeroNum == 0 \u0026\u0026 cntOneNum == 0 \u0026\u0026 cntTwoNum == 0) {\raliceWin2 = false;\rbreak;\r}\rif (cnt == 1 \u0026\u0026 cntOneNum \u003e 0) {\rcntOneNum--;\rcnt = 2;\raliceTurn = !aliceTurn;\r} else if (cnt == 2 \u0026\u0026 cntTwoNum \u003e 0) {\rcntTwoNum--;\rcnt = 1;\raliceTurn = !aliceTurn;\r} else if (cnt == 1 \u0026\u0026 cntOneNum == 0 \u0026\u0026 cntZeroNum \u003e 0) {\rcntZeroNum--;\raliceTurn = !aliceTurn;\r} else if (cnt == 2 \u0026\u0026 cntTwoNum == 0 \u0026\u0026 cntZeroNum \u003e 0) {\rcntZeroNum--;\raliceTurn = !aliceTurn;\r} else {\rif (aliceTurn) {\raliceWin2 = false;\rbreak;\r} else {\raliceWin2 = true;\rbreak;\r}\r}\r}\r}\rreturn aliceWin1 || aliceWin2;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:79:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:80:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:80:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic int numberOfMatches(int n) {\rint ans = 0;\rwhile (n \u003e 1) {\rans += n / 2;\rif (n % 2 == 1) {\rn++;\r}\rn /= 2;\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:80:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"排序 后缀 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:81:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:81:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 排序，维护后缀最大值 注意特判边界 class Solution {\rpublic int numberOfWeakCharacters(int[][] properties) {\rArrays.sort(properties, (x, y) -\u003e {\rreturn x[0] == y[0] ? (x[1] - y[1]) : (x[0] - y[0]);\r});\rint n = properties.length;\rint ans = 0;\rint[] sufmax = new int[n];\rsufmax[n - 1] = properties[n - 1][1];\rfor (int i = n - 2; i \u003e= 0; --i) {\rsufmax[i] = Math.max(sufmax[i + 1], properties[i][1]);\r}\rint ptr = 1;\rfor (int i = 0; i \u003c n - 1; ++i) {\rwhile (ptr \u003c n \u0026\u0026 properties[ptr][0] \u003c= properties[i][0]) ptr++;\rif (ptr \u003e= n) break;\rif (sufmax[ptr] \u003e properties[i][1]) ans++;\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:81:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"bfs Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:82:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:82:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 bfs class Solution {\rpublic int[][] highestPeak(int[][] isWater) {\rint[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\rint n = isWater.length;\rint m = isWater[0].length;\rint[][] ans = new int[n][m];\rfor (int i = 0; i \u003c n; ++i) {\rArrays.fill(ans[i], -1);\r}\rQueue\u003cint[]\u003e queue = new ArrayDeque\u003c\u003e();\rfor (int i = 0; i \u003c n; ++i) {\rfor (int j = 0; j \u003c m; ++j) {\rif (isWater[i][j] == 1) {\rans[i][j] = 0;\rqueue.offer(new int[]{i, j});\r}\r}\r}\rwhile (!queue.isEmpty()) {\rint[] tmp = queue.poll();\rint x = tmp[0], y = tmp[1];\rfor (int i = 0; i \u003c 4; ++i) {\rint dx = x + dir[i][0];\rint dy = y + dir[i][1];\rif (dx \u003e= 0 \u0026\u0026 dx \u003c n \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c m \u0026\u0026 ans[dx][dy] == -1) {\rans[dx][dy] = ans[x][y] + 1;\rqueue.offer(new int[]{dx, dy});\r}\r}\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:82:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:83:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:83:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 Java语法注意点\r\r注意int[]不能作为HashMap的Key，理论上可以但这样得不到想要的结果，比如插入[1, 2]数组，调用containsKey(new int[]{1, 2})找不到，原因是containsKey只会识别相同的对象，而这两个对象虽然值相同，但地址不同，java在比较两个对象是否是同一个时，会先比较hashcode，如果hashcode不同就不是同一个，如果hashcode相同就会调用equals()方法，所以可以通过重写hashcode()和equals()方法达到目的，但这样比较麻烦，这就像c++中unordered_map\u003cpair\u003cint, int\u003e, int\u003e mp;或者unordered_map\u003cvector\u003cint\u003e, int\u003e mp;一样需要一个hash_pair。如果数组作为TreeMap的Key，会报错，因为数组没有实现Comparable，无法比较（排序） 用List\u003cInteger\u003e作为HashMap的Key是可以的（Map\u003cList\u003cInteger\u003e, Integer\u003e mp; mp.put(Arrays.asList(1, 2), 3;）， 因为 java.util.Collection自己有hashcode()和equals()且是比较值是否相同的 不过用List\u003cInteger\u003e作为Key很慢，慎用 \r\r 用List作为Key的TLE版本 class DetectSquares {\rMap\u003cList\u003cInteger\u003e, Integer\u003e mp;\rpublic DetectSquares() {\rmp = new HashMap\u003c\u003e();\r}\rpublic void add(int[] point) {\rmp.put(Arrays.asList(point[0], point[1]), mp.getOrDefault(Arrays.asList(point[0], point[1]), 0) + 1);\r}\rpublic int count(int[] point) {\rint ans = 0;\rint x = point[0], y = point[1];\rfor (int i = 1; i \u003c= 1000; ++i) {\rans += mp.getOrDefault(Arrays.asList(x - i, y), 0) * mp.getOrDefault(Arrays.asList(x, y - i), 0) * mp.getOrDefault(Arrays.asList(x - i, y - i), 0);\rans += mp.getOrDefault(Arrays.asList(x - i, y), 0) * mp.getOrDefault(Arrays.asList(x, y + i), 0) * mp.getOrDefault(Arrays.asList(x - i, y + i), 0);\rans += mp.getOrDefault(Arrays.asList(x, y - i), 0) * mp.getOrDefault(Arrays.asList(x + i, y), 0) * mp.getOrDefault(Arrays.asList(x + i, y - i), 0);\rans += mp.getOrDefault(Arrays.asList(x + i, y), 0) * mp.getOrDefault(Arrays.asList(x, y + i), 0) * mp.getOrDefault(Arrays.asList(x + i, y + i), 0);\r}\rreturn ans;\r}\r}\r/**\r* Your DetectSquares object will be instantiated and called as such:\r* DetectSquares obj = new DetectSquares();\r* obj.add(point);\r* int param_2 = obj.count(point);\r*/\r c++ 用pair作为Key的TLE版本 class DetectSquares {\rpublic:\rstruct pair_hash {\rtemplate\u003cclass T1, class T2\u003e\rstd::size_t operator()(const std::pair\u003cT1, T2\u003e \u0026p) const {\rauto h1 = std::hash\u003cT1\u003e{}(p.first);\rauto h2 = std::hash\u003cT2\u003e{}(p.second);\rreturn h1 ^ h2;\r}\r};\runordered_map\u003cpair\u003cint, int\u003e, int, pair_hash\u003e mp;\rDetectSquares() {\r}\rvoid add(vector\u003cint\u003e point) {\rmp[{point[0], point[1]}]++;\r}\rint count(vector\u003cint\u003e point) {\rint ans = 0;\rint x = point[0], y = point[1];\rfor (int i = 1; i \u003c= 1000; ++i) {\rans += mp[{x - i, y}] * mp[{x, y - i}] * mp[{x - i, y - i}];\rans += mp[{x - i, y}] * mp[{x, y + i}] * mp[{x - i, y + i}];\rans += mp[{x, y - i}] * mp[{x + i, y}] * mp[{x + i, y - i}];\rans += mp[{x + i, y}] * mp[{x, y + i}] * mp[{x + i, y + i}];\r}\rreturn ans;\r}\r};\r 用哈希表嵌套哈希表，TLE，没有用判断优化的版本（单样例没超时，总时间超时） class DetectSquares {\rMap\u003cInteger, Map\u003cInteger, Integer\u003e\u003e mp;\rpublic DetectSquares() {\rmp = new HashMap\u003c\u003e();\r}\rpublic void add(int[] point) {\rint x = point[0], y = point[1];\rmp.putIfAbsent(x, new HashMap\u003c\u003e());\rMap\u003cInteger, Integer\u003e tmp = mp.get(x);\rtmp.put(y, tmp.getOrDefault(y, 0) + 1);\rmp.put(x, tmp);\r}\rpublic int count(int[] point) {\rint ans = 0;\rint x = point[0], y = point[1];\rfor (int i = 1; i \u003c= 1000; ++i) {\rans += mp.getOrDefault(x - i, new HashMap\u003c\u003e()).getOrDefault(y, 0) * mp.getOrDefault(x, new HashMap\u003c\u003e()).getOrDefault(y - i, 0) * mp.getOrDefault(x - i, new HashMap\u003c\u003e()).getOrDefault(y - i, 0);\rans += mp.getOrDefault(x - i, new HashMap\u003c\u003e()).getOrDefault(y, 0) * mp.getOrDefault(x, new HashMap\u003c\u003e()).getOrDefault(y + i, 0) * mp.getOrDefault(x - i, new HashMap\u003c\u003e()).getOrDefault(y + i, 0);\rans += mp.getOrDefault(x, new HashMap\u003c\u003e()).getOrDefault(y - i, 0) * mp.getOrDefault(x + i, new HashMap\u003c\u003e()).getOrDefault(y, 0) * mp.getOrDefault(x + i, new HashMap\u003c\u003e()).getOrDefault(y - i, 0);\rans += mp.getOrDefault(x + i, new HashMap\u003c\u003e()).getOrDefault(y, 0) * mp.getOrDefault(x, new HashMap\u003c\u003e()).getOrDefault(y + i, 0) * mp.getOrDefault(x + i, new HashMap\u003c\u003e()).getOrDefault(y + i, 0);\r}\rreturn ans;\r}\r}\r/**\r* Your DetectSquares object will be instantiated and called as such:\r* DetectSquares obj = new DetectSquares();\r* obj.add(point);\r* int param_2 = obj.count(point);\r*/\r 优化后的AC代码（还可以再优化） class DetectSquares {\rMap\u003cInteger, Map\u003cInteger, Integer\u003e\u003e mp;\rpubl","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:83:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"哈希表 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:84:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:84:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution {\rpublic String[] uncommonFromSentences(String s1, String s2) {\rMap\u003cString, Integer\u003e mp = new HashMap\u003c\u003e();\rString[] word1 = s1.split(\" \");\rString[] word2 = s2.split(\" \");\rfor (String i : word1) {\rmp.put(i, mp.getOrDefault(i, 0) + 1);\r}\rfor (String i : word2) {\rmp.put(i, mp.getOrDefault(i, 0) + 1);\r}\rList\u003cString\u003e ans = new ArrayList\u003c\u003e();\rfor (Map.Entry\u003cString, Integer\u003e entry : mp.entrySet()) {\rif (entry.getValue() == 1) ans.add(entry.getKey());\r}\rreturn ans.toArray(new String[0]);\r}\r}\r 注意通过toArray(new String[0])这种方法来转变成String数组，如果在前面加(String[]) 强制类型转化会转化失败，因为toArray不知道转化成什么类型，返回一个object，虽然前者也是返回obj，但指定了类型 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:84:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"并查集 状态压缩 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:85:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:85:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 周赛的一道题，思路很简单，当时一直TLE，然后一直想着优化代码。赛后发现是时间复杂度算错了，原来以为时间复杂度是O(n*26*26)，后来发现如果数组中存在大量重复字符串时，比如说在计算not change部分时，“abc”会遍历一遍所有“abc”的下标，这样时间复杂度就是O(n*n)，其实只要遍历第一个“abc”的下标就行，预处理时把所有相同字符串加到一个集合中 为什么会犯这种错误或找不出错？可能是因为在做题时很少有时间复杂度算错的情况，大多数都是代码冗余或数据结构或者STL低效的问题，所以条件反射地往这方面想 我如何找出这个错误？先是花大量的时间在优化代码上，后来我企图测试是哪部分代码直接造成超时，最后发现当预处理二进制和not change部分共存时，超时，我仔细地看了一遍预处理二进制的代码，发现没有任何问题（甚至还怀疑是不是用for each更快），然后将not change的遍历mp[cnt]数组注释掉，发现这两部分代码可以共存，很大概率是这条代码超时，后来就想到如果存在很多一样的字符串，那么每次都需要完整遍历一遍，时间复杂度是O(n*n) 不知道怎样快速查找出错误，一直都在摸索，只能说下次要再检查一遍时间复杂度是否算对 最开始还忘记算相同的情况（not change） class Solution {\rpublic:\rvector\u003cint\u003e par;\rvector\u003cint\u003e rankk;\rvoid init(int n) {\rfor (int i = 0; i \u003c n; i++) {\rpar[i] = i;\rrankk[i] = 0;\r}\r}\rint find(int x) {\rif (par[x] == x) return x;\relse return par[x] = find(par[x]);\r}\rvoid unite(int x, int y) {\rx = find(x);\ry = find(y);\rif (x == y) return;\rif (rankk[x] \u003c rankk[y]) par[x] = y;\relse {\rpar[y] = x;\rif (rankk[x] == rankk[y]) rankk[x]++;\r}\r}\rbool same(int x, int y) {\rreturn find(x) == find(y);\r}\rvector\u003cint\u003e groupStrings(vector\u003cstring\u003e \u0026words) {\runordered_map\u003cint, vector\u003cint\u003e\u003e mp;\rint n = (int) words.size();\rpar.resize(n + 10);\rrankk.resize(n + 10);\rinit(n + 5);\rvector\u003cint\u003e bin(n + 10);\rfor (int i = 0; i \u003c n; ++i) {\rint tmp = 0;\rfor (int j = 0; j \u003c words[i].length(); ++j) {\rtmp |= (1 \u003c\u003c (words[i][j] - 'a'));\r}\rmp[tmp].push_back(i);\rbin[i] = tmp;\r}\r// !!!\r for (auto [i, j] : mp) {\rfor (int k = 0; k \u003c (int) j.size() - 1; ++k) {\runite(j[k], j[k + 1]);\r} }\rfor (int i = 0; i \u003c n; ++i) {\rint cnt = bin[i];\rvector\u003cint\u003e exist, notexist;\rfor (int j = 0; j \u003c 26; ++j) {\rif (cnt \u003e\u003e j \u0026 1) {\rexist.push_back(j);\r} else {\rnotexist.push_back(j);\r}\r}\r// delete\r for (int j : exist) {\rint tmp = cnt ^ (1 \u003c\u003c j);\rif (mp.find(tmp) != mp.end()) {\runite(i, mp[tmp][0]);\r}\r}\r// add\r for (int j : notexist) {\rint tmp = cnt | (1 \u003c\u003c j);\rif (mp.find(tmp) != mp.end()) {\runite(i, mp[tmp][0]);\r}\r}\r// replace\r for (int j : exist) {\rfor (int k : notexist) {\rint tmp = cnt ^ (1 \u003c\u003c j);\rtmp |= (1 \u003c\u003c k);\rif (mp.find(tmp) != mp.end()) {\runite(i, mp[tmp][0]);\r}\r}\r}\r// not change\r if (mp.find(cnt) != mp.end()) {\runite(i, mp[cnt][0]);\r}\r}\runordered_map\u003cint, int\u003e sz;\rint ans1, ans2;\rans2 = -1;\rfor (int i = 0; i \u003c n; ++i) {\rsz[find(i)]++;\r}\rans1 = (int) sz.size();\rfor (auto [i, j] : sz) {\rans2 = max(ans2, j);\r}\rreturn vector\u003cint\u003e{ans1, ans2};\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:85:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"分治 状压 二分 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:86:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:86:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 meet in the middle 分治把前一半2^15的情况枚举出来，把后一半2^15的情况枚举出来，然后枚举前一半，在后一半中二分查找，时间复杂度O(nlogn) n最大2^15 class Solution {\rpublic:\rint minimumDifference(vector\u003cint\u003e\u0026 nums) {\rint n = (int) nums.size();\rn /= 2;\runordered_map\u003cint, vector\u003cint\u003e\u003e mpL, mpR;\rvector\u003cint\u003e L(nums.begin(), nums.begin() + n);\rvector\u003cint\u003e R(nums.begin() + n, nums.end());\rfor (int i = 1; i \u003c= n; ++i) {\rint ss = (1 \u003c\u003c i) - 1;\rwhile (ss \u003c (1 \u003c\u003c n)) {\rint tmp = 0;\rfor (int j = 0; j \u003c n; ++j) {\rif (ss \u003e\u003e j \u0026 1) {\rtmp += L[j];\r} else {\rtmp -= L[j];\r}\r}\rmpL[i].push_back(tmp);\rint x = ss \u0026 -ss, y = ss + x;\rss = ((ss \u0026 ~y) / x \u003e\u003e 1) | y;\r}\r}\r// i = 0\r mpL[0].push_back(-accumulate(L.begin(), L.end(), 0));\rfor (int i = 1; i \u003c= n; ++i) {\rint ss = (1 \u003c\u003c i) - 1;\rwhile (ss \u003c (1 \u003c\u003c n)) {\rint tmp = 0;\rfor (int j = 0; j \u003c n; ++j) {\rif (ss \u003e\u003e j \u0026 1) {\rtmp += R[j];\r} else {\rtmp -= R[j];\r}\r}\rmpR[i].push_back(tmp);\rint x = ss \u0026 -ss, y = ss + x;\rss = ((ss \u0026 ~y) / x \u003e\u003e 1) | y;\r}\r}\r// i = 0\r mpR[0].push_back(-accumulate(R.begin(), R.end(), 0));\rint ans = 0x3f3f3f3f;\rfor (int i = 0; i \u003c= n; ++i) {\rsort(mpL[i].begin(), mpL[i].end());\rmpL[i].erase(unique(mpL[i].begin(), mpL[i].end()), mpL[i].end());\rsort(mpR[i].begin(), mpR[i].end());\rmpR[i].erase(unique(mpR[i].begin(), mpR[i].end()), mpR[i].end());\r}\rfor (int i = 0; i \u003c= n; ++i) {\rfor (int j : mpL[i]) {\rauto ite = lower_bound(mpR[n - i].begin(), mpR[n - i].end(), -j);\rif (ite != mpR[n - i].end()) {\rans = min(ans, abs(j + *ite));\r}\rif (ite != mpR[n - i].begin()) {\rite--;\rans = min(ans, abs(j + *ite));\r}\r}\r}\rreturn ans;\r}\r};\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:86:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"字典树 异或 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:87:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一长度为2e4的数组，每个值最大为2e4，求有多少个数对，异或值在low和high之间 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:87:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 遍历数组建字典树，对于当前数，查询字典树中有多少个数满足条件，再把这个数插入到字典树中 查询字典树有多少个数满足条件，可以查询字典树中有多少个数异或\u003c=high，有多少个\u003c=low-1，相减 查询字典树中有多少个数和y异或值\u003c=x，就是从根节点往下遍历，如果x的当前位为0，则只能找和y相同的位，如果x的当前位为1，那和y当前位相同的位之后的所有节点都满足条件，和y当前位不同的继续往下搜，所以维护每个节点下面存了几个数 维护每个节点下面存了几个数，用sz[i]表示i节点存了几个数，只要在每次插入的时候，给沿途的每个节点sz[i]++就行 时间复杂度O(2e4 * 15) class Solution {\rint[][] next;\rint cnt;\rint[] sz;\rint low, high;\rpublic void insert(int num) {\rint p = 0;\rfor (int i = 14; i \u003e= 0; --i) {\rint c = (num \u003e\u003e i \u0026 1) == 1 ? 1 : 0;\rif (next[p][c] == 0) {\r++cnt;\rnext[p][c] = cnt;\r}\rp = next[p][c];\rsz[p]++;\r}\r}\rpublic int count(int x) {\rreturn countLessThanOrEquals(high, x) - countLessThanOrEquals(low - 1, x);\r}\rpublic int countLessThanOrEquals(int bd, int x) {\rint p = 0;\rint ret = 0;\rfor (int i = 14; i \u003e= 0; --i) {\rint cx = (x \u003e\u003e i \u0026 1) == 1 ? 1 : 0;\rint cbd = (bd \u003e\u003e i \u0026 1) == 1 ? 1 : 0;\rif (cbd == 0) {\rif (next[p][cx] == 0) {\rreturn ret;\r}\rp = next[p][cx];\rif (i == 0) {\rret += sz[p];\rreturn ret;\r}\r} else {\rif (next[p][cx] != 0) {\rret += sz[next[p][cx]];\r}\rif (next[p][cx ^ 1] != 0) {\rp = next[p][cx ^ 1];\r} else {\rreturn ret;\r}\rif (i == 0) {\rret += sz[p];\rreturn ret;\r}\r}\r}\rreturn 0;\r}\rpublic int countPairs(int[] nums, int low, int high) {\rthis.low = low;\rthis.high = high;\rint n = nums.length;\rnext = new int[16 * (n + 2)][2];\rsz = new int[16 * (n + 2)];\rint ans = 0;\rfor (int i : nums) {\rans += count(i);\rinsert(i);\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:87:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 贪心 结论 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:88:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:88:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 二分找答案，假设最长时间是k，有一个结论是，\u003e=k的电池只会给一个电脑供电，不会出现给一个电脑供一会儿电，再转移给另一个电脑的情况，因为这样不会更优 所以每个电池能提供的电是min(pi, k)，累加就是总的能提供的电，check就是判断总的电和nk的大小，如果大于nk，一定存在一种调度满足每个电脑同时充k时间（可以把电池看做电量为1的若干电池去填充） class Solution {\rpublic long maxRunTime(int n, int[] batteries) {\rlong l = 1, r = (long)1e14 + 10;\rwhile (l \u003c= r) {\rlong mid = l + (r - l) / 2;\rlong tmp = 0;\rfor (int i : batteries) {\rtmp += Math.min(i, mid);\r}\rif (tmp \u003e= n * mid) {\rl = mid + 1;\r} else {\rr = mid - 1;\r}\r}\rreturn l - 1;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:88:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"bfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:89:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 有一个1e6*1e6的格子，有200个障碍，求能否从s点到t点，只能4方向走 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:89:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 因为只有200个障碍，所以看s点有没有被障碍围起来，看t点有没有被障碍围起来即可 由于障碍45°斜着排，把点困在某个角落里，能困住的格子最多，或者用的障碍最少，即最优。这样点最多只能到达400步以内的格子，所以只要bfs判断点能否到达400步以外的格子就行，两个一起搜，如果搜的过程中，能碰到对方也行 然后我超时了。。。单样例200+ms，我懵逼了，时间复杂度O(6.4e5)，leetcode的超时到底是怎么算的，单样例能过，总的就超时？难道还要算样例总时间？这合理吗 所以我被迫用另一个方法，最优的障碍设置使得点最多访问200*(200-1)/2个格子，所以bfs判断访问了多少个格子，而不是能否到达400步以外的格子，这样时间复杂度从O(6.4e5)降到O(4e4)，单样例10+ms 谢谢你，leetcode，让我去想更高效的方法🙏 最初TLE代码 class Solution {\rpublic boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\rfinal long STEP = 410;\rfinal int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\rMap\u003cLong, Integer\u003e used = new HashMap\u003c\u003e();\rlong sx = source[0], sy = source[1];\rlong tx = target[0], ty = target[1];\rSet\u003cLong\u003e b = new HashSet\u003c\u003e();\rfor (int[] i : blocked) {\rb.add((long) (i[0] * 1e6 + i[1]));\r}\rQueue\u003cLong\u003e q = new ArrayDeque\u003c\u003e();\rq.offer((long) (sx * 1e6 + sy));\rused.put((long) (sx * 1e6 + sy), 0);\rboolean sok = false, tok = false;\rwhile (!q.isEmpty()) {\rlong val = q.poll();\rlong cntx = (long) (val / 1e6);\rlong cnty = (long) (val % 1e6);\rfor (int i = 0; i \u003c 4; ++i) {\rlong dx = cntx + dir[i][0];\rlong dy = cnty + dir[i][1];\rif (dx == tx \u0026\u0026 dy == ty) return true;\rif (dx \u003e= 0 \u0026\u0026 dx \u003c 1e6 \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c 1e6 \u0026\u0026 !b.contains((long) (dx * 1e6 + dy)) \u0026\u0026 !used.containsKey((long) (dx * 1e6 + dy))) {\rused.put((long) (dx * 1e6 + dy), used.get(val) + 1);\rq.offer((long) (dx * 1e6 + dy));\rif (used.get((long) (dx * 1e6 + dy)) \u003e= STEP) {\rsok = true;\rq.clear();\rused.clear();\rbreak;\r}\r}\r}\r}\rq.offer((long) (tx * 1e6 + ty));\rused.put((long) (tx * 1e6 + ty), 0);\rwhile (!q.isEmpty()) {\rlong val = q.poll();\rlong cntx = (long) (val / 1e6);\rlong cnty = (long) (val % 1e6);\rfor (int i = 0; i \u003c 4; ++i) {\rlong dx = cntx + dir[i][0];\rlong dy = cnty + dir[i][1];\rif (dx == sx \u0026\u0026 dy == sy) return true;\rif (dx \u003e= 0 \u0026\u0026 dx \u003c 1e6 \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c 1e6 \u0026\u0026 !b.contains((long) (dx * 1e6 + dy)) \u0026\u0026 !used.containsKey((long) (dx * 1e6 + dy))) {\rused.put((long) (dx * 1e6 + dy), used.get(val) + 1);\rq.offer((long) (dx * 1e6 + dy));\rif (used.get((long) (dx * 1e6 + dy)) \u003e= STEP) {\rtok = true;\rq.clear();\rbreak;\r}\r}\r}\r}\rif (sok \u0026\u0026 tok) return true;\rreturn false;\r}\r}\r 以为不是时间复杂度的问题，想去优化代码，提取重复的代码，改版的TLE代码 class Solution {\rpublic boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\rfinal long STEP = 410;\rfinal int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\rMap\u003cLong, Integer\u003e used = new HashMap\u003c\u003e();\rlong sx = source[0], sy = source[1];\rlong tx = target[0], ty = target[1];\rSet\u003cLong\u003e b = new HashSet\u003c\u003e();\rfor (int[] i : blocked) {\rb.add((long) (i[0] * 1e6 + i[1]));\r}\rQueue\u003cLong\u003e q = new ArrayDeque\u003c\u003e();\rq.offer((long) (sx * 1e6 + sy));\rused.put((long) (sx * 1e6 + sy), 0);\rboolean sok = false, tok = false;\rwhile (!q.isEmpty()) {\rlong val = q.poll();\rlong cntx = (long) (val / 1e6);\rlong cnty = (long) (val % 1e6);\rfor (int i = 0; i \u003c 4; ++i) {\rlong dx = cntx + dir[i][0];\rlong dy = cnty + dir[i][1];\rif (dx == tx \u0026\u0026 dy == ty) return true;\rlong tmp = (long) (dx * 1e6 + dy);\rif (dx \u003e= 0 \u0026\u0026 dx \u003c 1e6 \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c 1e6 \u0026\u0026 !b.contains(tmp) \u0026\u0026 !used.containsKey(tmp)) {\rused.put(tmp, used.get(val) + 1);\rq.offer(tmp);\rif (used.get(tmp) \u003e= STEP) {\rsok = true;\rq.clear();\r//used.clear();\r break;\r}\r}\r}\r}\rif (!sok) return false;\rq.offer((long) (tx * 1e6 + ty));\rused.put((long) (tx * 1e6 + ty), 0);\rwhile (!q.isEmpty()) {\rlong val = q.poll();\rlong cntx = (long) (val / 1e6);\rlong cnty = (long) (val % 1e6);\rfor (int i = 0; i \u003c 4; ++i) {\rlong dx = cntx + dir[i][0];\rlong dy = cnty + dir[i][1];\rif (dx == sx \u0026\u0026 dy == sy) return true;\rlong tmp = (long) (dx * 1e6 + dy);\rif (dx \u003e= 0 \u0026\u0026 dx \u003c 1e6 \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c 1e6 \u0026\u0026 !b.contains(tmp) \u0026\u0026 !used.containsKey(tmp)) {\rused.put(tmp, used.get(val) + 1);\rq.offer(tmp);\rif (used.get(tmp) \u003e= STEP) {\rtok = true;\rq.clear();\rbreak;\r}\r}\r}\r}\rif (sok \u0026\u0026 tok) return true;\rreturn false;\r}\r}\r 优化时间复杂度的AC代码 class Solution {\rpublic boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {\rfinal long COUNT = 20010;\rfinal int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\rMap\u003cLong, I","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:89:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:90:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:90:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意到边权\u003e=10，最大时间\u003c=100和最多4条出边这种反常数据范围，直接搜索时间复杂度O(4^10)，注意回溯时不要记录是否访问过，应该记录访问次数，因为可以重复访问，如果回溯撤销了就相当于没访问过，这不是我们想要的 注意特判只有一个点 class Solution {\rint ans;\rint[] used;\rint[] values;\rMap\u003cInteger, List\u003cint[]\u003e\u003e mp;\rint maxTime;\rpublic void dfs(int vertex, int cost, int value) {\rif (vertex == 0 \u0026\u0026 used[vertex] \u003e 0) {\rif (cost \u003c= maxTime) {\rans = Math.max(ans, value);\r//return;\r }\r}\rused[vertex]++;\rList\u003cint[]\u003e list = mp.getOrDefault(vertex, null);\rif (list == null) return;\rfor (int[] i : list) {\rif (i[1] + cost \u003e maxTime) continue;\rif (used[i[0]] \u003e 0) dfs(i[0], i[1] + cost, value);\relse dfs(i[0], i[1] + cost, value + values[i[0]]);\r}\rused[vertex]--;\r}\rpublic int maximalPathQuality(int[] values, int[][] edges, int maxTime) {\rans = values[0];\rint n = values.length;\rused = new int[n + 5];\rthis.values = values;\rthis.maxTime = maxTime;\rmp = new HashMap\u003c\u003e();\rfor (int[] i : edges) {\rmp.putIfAbsent(i[0], new LinkedList\u003c\u003e());\rint[] tmp = new int[]{i[1], i[2]};\rList\u003cint[]\u003e list = mp.get(i[0]);\rlist.add(tmp);\rmp.put(i[0], list);\rmp.putIfAbsent(i[1], new LinkedList\u003c\u003e());\rtmp = new int[]{i[0], i[2]};\rlist = mp.get(i[1]);\rlist.add(tmp);\rmp.put(i[1], list);\r}\rdfs(0, 0, values[0]);\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:90:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs 回溯 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:91:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:91:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 暴搜 class Solution {\rint ans;\rint[][] grid;\rstatic int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\rint n, m;\rpublic void dfs(int x, int y, int gold) {\rans = Math.max(ans, gold);\rint tmp = grid[x][y];\rgrid[x][y] = 0;\rfor (int i = 0; i \u003c 4; ++i) {\rint nx = x + dir[i][0];\rint ny = y + dir[i][1];\rif (nx \u003e= 0 \u0026\u0026 nx \u003c n \u0026\u0026 ny \u003e= 0 \u0026\u0026 ny \u003c m \u0026\u0026 grid[nx][ny] != 0) {\rdfs(nx, ny, gold + grid[nx][ny]);\r}\r}\rgrid[x][y] = tmp;\r}\rpublic int getMaximumGold(int[][] grid) {\rthis.n = grid.length;\rthis.m = grid[0].length;\rthis.grid = grid;\rfor (int i = 0; i \u003c n; ++i) {\rfor (int j = 0; j \u003c m; ++j) {\rif (grid[i][j] != 0) {\rdfs(i, j, grid[i][j]);\r}\r}\r}\rreturn ans;\r}\r}\r ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:91:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["linux"],"content":"simplest colorful bash promt","date":"2021-03-17","objectID":"/simplest-colorful-bash-promt/","tags":["shell","linux"],"title":"simplest colorful bash promt","uri":"/simplest-colorful-bash-promt/"},{"categories":["linux"],"content":" ######################### begin ###############################\rbash_prompt() {\rlocal NO_FORMAT=\"\\[\\033[0m\\]\"\rlocal ORANGE_BOLD=\"\\[\\033[1;38;5;208m\\]\"\rlocal TOXIC_GREEN_BOLD=\"\\[\\033[1;38;5;118m\\]\"\rlocal RED_BOLD=\"\\[\\033[1;38;5;1m\\]\"\rlocal CYAN_BOLD=\"\\[\\033[1;38;5;87m\\]\"\rlocal BLACK_BOLD=\"\\[\\033[1;38;5;0m\\]\"\rlocal WHITE_BOLD=\"\\[\\033[1;38;5;15m\\]\"\rlocal GRAY_BOLD=\"\\[\\033[1;90m\\]\"\rlocal BLUE_BOLD=\"\\[\\033[1;38;5;74m\\]\"\rlocal PROMT_USER_COLOR=$CYAN_BOLD\rlocal PROMT_AT_COLOR=$WHITE_BOLD\rlocal PROMT_HOST_COLOR=$CYAN_BOLD\rlocal PROMT_COLON_COLOR=$WHITE_BOLD\rlocal PROMT_PATH_COLOR=$ORANGE_BOLD\rlocal PROMT_DOLLAR_COLOR=$WHITE_BOLD\rlocal PROMT_INPUT_COLOR=$TOXIC_GREEN_BOLD\rlocal PROMT_USER=$\"$PROMT_USER_COLOR\\u\"\rlocal PROMT_AT=$\"$PROMT_AT_COLOR@\"\rlocal PROMT_HOST=$\"$PROMT_HOST_COLOR\\h\"\rlocal PROMT_COLON=$\"$PROMT_COLON_COLOR:\"\rlocal PROMT_PATH=$\"$PROMT_PATH_COLOR\\w\"\rlocal PROMT_DOLLAR=$\"$PROMT_DOLLAR_COLOR$\"\rlocal PROMT_INPUT=$\"$PROMT_INPUT_COLOR\"\rPS1=\"${PROMT_USER}${PROMT_AT}${PROMT_HOST}${PROMT_COLON}${PROMT_PATH}${PROMT_DOLLAR}${PROMT_INPUT}\"\rnone=\"$(tput sgr0)\"\rtrap 'echo -ne \"${none}\"' DEBUG\r}\rbash_prompt\runset bash_prompt\r################################# end ###############################\r inspired by https://github.com/ChrisTitusTech/scripts add the code to ~/.bashrc and run source ~/.bashrc you can rewrite PS1 to make it more fancy, like time display, graph ","date":"2021-03-17","objectID":"/simplest-colorful-bash-promt/:0:0","tags":["shell","linux"],"title":"simplest colorful bash promt","uri":"/simplest-colorful-bash-promt/"},{"categories":["GAME"],"content":"steep","date":"2021-03-02","objectID":"/steep/","tags":[],"title":"steep","uri":"/steep/"},{"categories":["GAME"],"content":"steep是育碧在2016年12月2日发行的滑雪游戏 在steam上要一百多，在育碧商城上免费 在很早以前就看过有人玩育碧的肖恩怀特滑雪 但是一直找不到，可能因为知名度很低 后来育碧出了steep 游戏风景很好 有很多玩法：跳伞、单板滑雪、雪橇、翼装飞行等 操作难度较大，手残党会自闭 小黑盒评分（仅供参考） 故事发生在阿尔卑斯山。。。 ","date":"2021-03-02","objectID":"/steep/:0:0","tags":[],"title":"steep","uri":"/steep/"},{"categories":["GAME"],"content":"极限竞速地平线4","date":"2021-03-02","objectID":"/%E6%9E%81%E9%99%90%E7%AB%9E%E9%80%9F%E5%9C%B0%E5%B9%B3%E7%BA%BF4/","tags":[],"title":"极限竞速地平线4","uri":"/%E6%9E%81%E9%99%90%E7%AB%9E%E9%80%9F%E5%9C%B0%E5%B9%B3%E7%BA%BF4/"},{"categories":["GAME"],"content":"Forza Horizon 4是微软在2018年10月2日发行的开车游戏 用xbox玩就很爽 风景做得很不错 有关汽车的专业知识做得很丰富 嘉年华的各种活动安排得很合理 整个游戏体系很完善 小黑盒评分 真正的赛车游戏只玩过地平线和极品飞车，然而极品飞车没怎么玩，没有什么印象，因为地平线做得太好了。 《极限竞速：地平线4》的开放世界以英国为背景，地图更广阔真实，而且官方还确认本作中将会拥有450辆汽车。此外，《极限竞速：地平线4》中还拥有季节变化系统，在完全共享的开放世界中，可以让玩家同步一天的时间、季节、天气。 ","date":"2021-03-02","objectID":"/%E6%9E%81%E9%99%90%E7%AB%9E%E9%80%9F%E5%9C%B0%E5%B9%B3%E7%BA%BF4/:0:0","tags":[],"title":"极限竞速地平线4","uri":"/%E6%9E%81%E9%99%90%E7%AB%9E%E9%80%9F%E5%9C%B0%E5%B9%B3%E7%BA%BF4/"},{"categories":["GAME"],"content":"赛博朋克2077","date":"2021-03-02","objectID":"/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B2077/","tags":[],"title":"赛博朋克2077","uri":"/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B2077/"},{"categories":["GAME"],"content":"cyberpunk2077是CD Projekt RED开发的rpg游戏 经历了一次次跳票，终于在年底玩到这款游戏 小黑盒的评分 小黑盒社区的玩家评分并不高，很多人都很失望 确实游戏内容和宣传内容有很多不符，可以说宣传的内容过于夸大 像地铁系统、超梦只是概念的东西 前期bug超多 十足的养成游戏 总体还行，希望波兰蠢驴能够再完善一下游戏 《赛博朋克 2077》是一款开放世界动作冒险游戏，故事发生在夜之城。这是一座五光十色的大都会，权力更迭和身体改造是不变的主题。您扮演一名野心勃勃的雇佣兵：V，正在追寻一种独一无二的植入体。只要得到它，就能掌握获得永生的关键。您可以自定义角色的义体、技能和玩法，探索包罗万象的城市。您做出的选择也将会对剧情和周遭的世界产生影响。 ","date":"2021-03-02","objectID":"/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B2077/:0:0","tags":[],"title":"赛博朋克2077","uri":"/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B2077/"},{"categories":["note","slam"],"content":"相机模型","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"针孔相机模型 针孔相机模型和畸变模型把三维点投影到相机内的二维平面，构成相机的内参数（intrinsics） 根据三角形的相似性 $$ \\frac{Z}{f}=-\\frac{X}{X^{\\prime}}=-\\frac{Y}{Y^{\\prime}} $$ 把成像平面翻转到前面 $$ \\frac{Z}{f}=\\frac{X}{X^{\\prime}}=\\frac{Y}{Y^{\\prime}} $$ $$ \\begin{array}{l}X^{\\prime}=f \\frac{X}{Z} \\\\ Y^{\\prime}=f \\frac{Y}{Z}\\end{array} $$ 把成像平面投影到像素平面 像素坐标系和成像坐标系之间相差了一个缩放和原点的平移 用u轴和v轴表示像素坐标系 设像素坐标系在u轴上缩放了α倍，在v轴上缩放了β倍，原点平移了[cx, cy]T，投影坐标和像素坐标的关系是 $$ \\left\\{\\begin{array}{l}u=\\alpha X^{\\prime}+c_{x} \\\\ v=\\beta Y^{\\prime}+c_{y}\\end{array}\\right. $$ 代入此式 $$ \\begin{array}{l}X^{\\prime}=f \\frac{X}{Z} \\\\Y^{\\prime}=f \\frac{Y}{Z}\\end{array} $$ fx=αf，fy=βf $$ \\left\\{\\begin{array}{l}u=f_{x} \\frac{X}{Z}+c_{x} \\\\v=f_{y} \\frac{Y}{Z}+c_{y}\\end{array}\\right. $$ 将上式矩阵化（左侧是齐次式，右侧是非齐次式） $$ \\left(\\begin{array}{l}u \\\\v \\\\1\\end{array}\\right)=\\frac{1}{Z}\\left(\\begin{array}{ccc}f_{x} \u0026 0 \u0026 c_{x} \\\\0 \u0026 f_{y} \u0026 c_{y} \\\\0 \u0026 0 \u0026 1\\end{array}\\right)\\left(\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right) \\triangleq \\frac{1}{Z} K P $$ 一般习惯这样写 $$ Z\\left(\\begin{array}{l}u \\\\v \\\\1\\end{array}\\right)=\\left(\\begin{array}{ccc}f_{x} \u0026 0 \u0026 c_{x} \\\\0 \u0026 f_{y} \u0026 c_{y} \\\\0 \u0026 0 \u0026 1\\end{array}\\right)\\left(\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right) \\triangleq K P $$ K就是相机的内参数（camera intrinsics），在相机出厂时已经固定，是个常量 有些相机生产厂商会告诉你内参，有些不会。需要自己确定相机内参就叫做标定 在最开始的问题中，拿一个坐标点p进行投影。但这个p是相对于相机的坐标，实际应该是相对于世界的坐标Pw，所以要做一个转换。这个转换实际上只需要做一个旋转和平移就行，这在之前已经讨论过 假设相机的位姿由旋转矩阵R和平移向量t表示，那么世界坐标系到相机坐标系的转换如下 $$ Z P_{u v}=Z\\left[\\begin{array}{l}u \\\\v \\\\1\\end{array}\\right]=K\\left(R P_{w}+t\\right)=K T P_{w} $$ T为变换矩阵，=KTPw这个式子隐含了一次齐次坐标到非齐次坐标的转换 相机的位姿R，t为相机的外参（camera extrinsics） 归一化处理，令z=1，即所有的点都假设在归一化平面上 $$ \\left(R P_{\\mathrm{w}}+t\\right)=\\underbrace{[X, Y, Z]^{\\mathrm{T}}}_{\\text {相机坐标 }} \\rightarrow \\underbrace{[X / Z, Y / Z, 1]^{\\mathrm{T}}}_{\\text {归一化坐标 }} . $$ 这样归一化坐标左乘内参就可以得到像素坐标，上式也说明单目视觉中点的深度信息丢失了 投影的顺序：世界-相机-归一化平面-像素 ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:1:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"畸变模型 畸变（distortion）又叫失真，类似于这样 径向畸变由透镜形状引起的，分为桶形畸变和枕形畸变。 桶形畸变：放大率随着与光轴之间距离增加而减小 枕形畸变：放大率随着与光轴之间距离增加而增加 切向畸变是成像平面与透镜不平行引起的 数学表示径向畸变和切向畸变 考虑归一化平面（z=1）上的一点p，坐标[x,y]T，极坐标[r,θ]T 附加：如何理解切向畸变就是发生旋转？ 径向畸变 $$ \\begin{array}{l}x_{\\text {distrred }}=x\\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\\right) \\\\y_{\\text {distorted }}=y\\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\\right)\\end{array} $$ (xdistorted, ydistorted)是径向畸变后的归一化坐标 切向畸变 $$ \\begin{array}{l}x_{\\text {distorted }}=x+2 p_{1} x y+p_{2}\\left(r^{2}+2 x^{2}\\right) \\\\y_{\\text {distorred }}=y+p_{1}\\left(r^{2}+2 y^{2}\\right)+2 p_{2} x y\\end{array} $$ 径向畸变+切向畸变 $$ \\left\\{\\begin{array}{l}x_{\\text {distorted }}=x\\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\\right)+2 p_{1} x y+p_{2}\\left(r^{2}+2 x^{2}\\right) \\\\y_{\\text {distorted }}=y\\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\\right)+p_{1}\\left(r^{2}+2 y^{2}\\right)+2 p_{2} x y\\end{array}\\right. $$ 实际可灵活保留各项系数 投影到像素平面 $$ \\left\\{\\begin{array}{l}u=f_{x} x_{\\text {distorted }}+c_{x} \\\\v=f_{y} y_{\\text {distorted }}+c_{y}\\end{array}\\right. $$ 去畸变（undistort）的方式有两种，对整张图去畸变，然后就可以用针孔模型，第二种从畸变图像上的某个点出发，根据畸变方程还原。实际上第一种更好用。 总结 ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:2:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"双目相机模型 由于用了归一化平面（z=1），所以散失了深度，怎么求像素平面上每个像素的深度？ 用双目相机 $$ \\frac{z-f}{z}=\\frac{b-u_{L}+u_{R}}{b} $$ $$ z=\\frac{f b}{d}, \\quad d=u_{L}-u_{R} $$ UR是负数，b是基线，d是视差 视差d的计算很难，需要知道左边像素点在右边图像中对应哪个。由于计算量，双目深度的估计仍需要使用cpu和fpga ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:3:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"RGB-D模型 红外结构光原理 structured light ：发射光线，根据返回的结构光图案判断 飞行时间原理 time-of-flight ToF ：发射光线，接收，计算时间差 像素的深度信息形成点云（point cloud） RGB-D相机的缺点：红外光容易受到日光或其他传感器发射的红外光干扰，不能在室外使用。同时使用多个RGB-D会互相干扰，透射材质的物体难以反射红外光。 ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:4:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"图像 计算机如何处理图像？ ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:5:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"非线性优化","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"相关知识 主要是对高数、概率论、线性代数、数值计算方法、数学建模的一些复习和补充 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:0","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"矩阵求导 一篇矩阵求导入门的非常好的文章 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:1","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"全概率公式 $$ P(B)=\\sum_{i=1}^{n} P\\left(A_{i}\\right) P\\left(B \\mid A_{i}\\right) $$ ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:2","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"贝叶斯公式 $$ P\\left(B_{i} \\mid A\\right)=\\frac{P\\left(B_{i}\\right) P\\left(A \\mid B_{i}\\right)}{\\sum_{j=1}^{n} P\\left(B_{j}\\right) P\\left(A \\mid B_{j}\\right)} $$ ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:3","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"先验概率、后验概率、似然概率 已知车祸、酒驾、高峰可能造成堵车 先验概率（prior probability） 人通过直觉知道它的概率或通过实验（大数定律）获得它的概率 此处为P(X=车祸)， P(X=酒驾)， P(X=高峰) 似然概率（likelihood probability） 指某种原因下出现某种结果的概率 P(Y=堵车|X=车祸) ， P(Y=堵车|X=酒驾)， P(Y=堵车|X=高峰) 最大似然估计（maximum likelihood estimation）MLE 使似然概率最大的估计 后验概率（posterior probability） 指某种结果下推测由某种原因导致的概率 P(X=车祸|Y=堵车)， P(X=酒驾|Y=堵车)， P(X=高峰|Y=堵车) 最大后验估计（maximum a posterior estimation）MAP 使后验概率最大的估计 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:4","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"正态分布 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:5","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"数学期望 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:6","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"方差 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:7","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"协方差 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:8","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"n维正态分布 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:9","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"二次型 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:10","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"最小二乘法解超定方程组 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:11","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"向量的范数 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:12","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"矩阵的范数 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:13","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"求特征值和特征向量 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:14","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"非线性规划算法 无约束非线性规划：梯度下降法，牛顿法，高斯牛顿法 有约束非线性规划：SUMT外点法（罚函数法）， SUMT内点法（障碍函数法） SUMT=sequential unconstrained minimization technique ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:15","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"梯度下降法 gradient descent ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:16","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"牛顿法 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:17","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"状态估计问题 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:2:0","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"批量状态估计和最大后验估计 考虑经典的slam模型 $$ \\left\\{\\begin{array}{l}\\boldsymbol{x}_{k}=f\\left(\\boldsymbol{x}_{k-1}, \\boldsymbol{u}_{k}, \\boldsymbol{w}_{k}\\right) \\\\\\boldsymbol{z}_{k, j}=h\\left(\\boldsymbol{y}_{j}, \\boldsymbol{x}_{k}, \\boldsymbol{v}_{k, j}\\right)\\end{array}\\right. $$ x是位姿，u是传感器输入，y是路标点，z是产生的观测数据，w，v是噪声 具体地，xk由SE(3)的变换矩阵表示，暂不考虑传感器的输入形式 假设在xk处对路标yj进行了一次观测，对应到图像上的像素位置zk,j，那么观测方程可以表示成 $$ s \\boldsymbol{z}_{k, j}=\\boldsymbol{K}\\left(\\boldsymbol{R}_{k} \\boldsymbol{y}_{j}+\\boldsymbol{t}_{k}\\right) $$ K是相机内参，s是像素点的距离，也是(Rkyj+tk)的第三个分量，如果使用变换矩阵Tk描述位姿，yj必须以齐次坐标描述，计算完后转为非齐次 考虑噪声 一般假设wk，vk,j满足μ=0的正态分布 $$ \\boldsymbol{w}_{k} \\sim \\mathcal{N}\\left(\\mathbf{0}, \\boldsymbol{R}_{k}\\right), \\boldsymbol{v}_{k} \\sim \\mathcal{N}\\left(\\mathbf{0}, \\boldsymbol{Q}_{k, j}\\right) $$ slam的问题变成通过带噪声的z，u来推断位姿x和地图y，这就是状态估计 处理状态估计的方法 incremental 增量/渐近/滤波器 扩展卡尔曼滤波 batch 批量（把数据攒起来，然后处理这段时间的，相当于一段时间一段时间地处理） batch的方法可以在更大的范围内达到最优，incremental只关心当前 batch方法在视觉slam中更常用，或者将两者结合 考虑1到N的所有时刻，假设有M个路标点 位姿和地图表示为 $$ x=\\left\\{x_{1}, \\ldots, x_{N}\\right\\}, \\quad y=\\left\\{y_{1}, \\ldots, y_{M}\\right\\} $$ 从概率学来看就是求 $$ P(\\boldsymbol{x}, \\boldsymbol{y}\\mid \\boldsymbol{z}, \\boldsymbol{u}) $$ 如果只考虑观测方程（即只有一张张图像），则变成 $$ P(\\boldsymbol{x}, \\boldsymbol{y}\\mid \\boldsymbol{z}) $$ 此问题也称sfm（structure from motion）即如何从许多图像中重建三维空间结构 根据bayes rule $$ \\underbrace{P(x, y \\mid z, u)}_{\\text{posterior}}=\\frac{P(z, u \\mid x, y) P(x, y)}{P(z, u)} \\propto \\underbrace{P(z, u \\mid x, y)}_{\\text {likelihood }} \\underbrace{P({x},{y})}_{\\text {prior }} . $$ 直接求后验概率分布是很困难的，但是可以求一个最优估计，由于分母p(z, u)与x，y无关，所以可省略 那么求后验概率就变成 $$ (\\boldsymbol{x}, \\boldsymbol{y})^{*}{ }_{\\mathrm{MAP}}=\\arg \\max P(\\boldsymbol{x}, \\boldsymbol{y} \\mid \\boldsymbol{z}, \\boldsymbol{u})=\\arg \\max P(\\boldsymbol{z}, \\boldsymbol{u} \\mid \\boldsymbol{x}, \\boldsymbol{y}) P(\\boldsymbol{x}, \\boldsymbol{y}) $$ 由上式可知求map就是最大化likelihood和prior的乘积 当不知道位姿和路标大概在什么地方时，就没有了先验 $$ (x, y)_{\\text {MAP }}^{*}=\\arg \\max P(z, u \\mid x, y)=(x, y)_{\\text {MLE }}^{*} $$ 这就变成了直接求最大似然估计 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:2:1","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"最小二乘 观测方程 $$ \\boldsymbol{z}_{k, j}=h\\left(\\boldsymbol{y}_{j}, \\boldsymbol{x}_{k}\\right)+\\boldsymbol{v}_{k, j} $$ 噪声服从正态分布 $$ \\boldsymbol{v}_{k} \\sim N\\left(0, \\boldsymbol{Q}_{k, j}\\right) $$ 所以概率也服从正态分布 $$ P\\left(\\boldsymbol{z}_{j, k} \\mid \\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)=N\\left(h\\left(\\boldsymbol{y}_{j}, \\boldsymbol{x}_{k}\\right), \\boldsymbol{Q}_{k, j}\\right) $$ 考虑单次观测的MLE，使用最小化负对数求正态分布的MLE $$ P(\\boldsymbol{x})=\\frac{1}{\\sqrt{(2 \\pi)^{N} \\operatorname{det}(\\boldsymbol{\\Sigma})}} \\exp \\left(-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right) $$ $$ -\\ln (P(\\boldsymbol{x}))=\\frac{1}{2} \\ln \\left((2 \\pi)^{N} \\operatorname{det}(\\boldsymbol{\\Sigma})\\right)+ \\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu}) $$ 问题变成 $$ \\begin{aligned}\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)^{*} \u0026=\\arg \\max \\mathcal{N}\\left(h\\left(\\boldsymbol{y}_{j}, \\boldsymbol{x}_{k}\\right), \\boldsymbol{Q}_{k, j}\\right) \\\\\u0026=\\arg \\min \\left(\\left(\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\right)^{\\mathrm{T}} \\boldsymbol{Q}_{k, j}^{-1}\\left(\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\right)\\right)\\end{aligned} $$ 这是一个二次型，这个二次型称为马哈拉诺比斯距离（mahalanobis distance），又叫马氏距离，(Qi,j)-1为信息矩阵 考虑批处理，输入和观测、输入和输入、观测和观测之间互相独立 $$ P(z, u \\mid x, y)=\\prod_{k} P\\left(u_{k} \\mid x_{k-1}, x_{k}\\right) \\prod_{k, j} P\\left(z_{k, j} \\mid x_{k}, y_{j}\\right) $$ 这说明z和u可以单独处理 定义误差 $$ \\begin{aligned}e_{u, k} \u0026=\\boldsymbol{x}_{k}-f\\left(\\boldsymbol{x}_{k-1}, \\boldsymbol{u}_{k}\\right) \\\\\\boldsymbol{e}_{\\boldsymbol{z}, j, k} \u0026=\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\end{aligned} $$ 本来的问题是 $$ \\begin{aligned}\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)^{*} \u0026=\\arg \\min \\left(\\left(\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\right)^{\\mathrm{T}} \\boldsymbol{Q}_{k, j}^{-1}\\left(\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\right)\\right)\\end{aligned} $$ 因为加了批处理，问题变成了 $$ \\sum\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)^{*} $$ $$ \\min J(\\boldsymbol{x}, \\boldsymbol{y})=\\sum_{k} e_{\\boldsymbol{u}, k}^{\\mathrm{T}} \\boldsymbol{R}_{k}^{-1} \\boldsymbol{e}_{\\boldsymbol{u}, k}+\\sum_{k} \\sum_{j} \\boldsymbol{e}_{\\boldsymbol{z}, k, j}^{\\mathrm{T}} \\boldsymbol{Q}_{k, j}^{-1} \\boldsymbol{e}_{\\boldsymbol{z}, k, j} $$ 这可以看成是最小二乘问题，解等价于MLE ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:2:2","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"批量状态估计例子 假设运动方程和观测方程是 $$ \\begin{array}{ll}\\boldsymbol{x}_{k}=\\boldsymbol{x}_{k-1}+\\boldsymbol{u}_{k}+\\boldsymbol{w}_{k}, \u0026 \\boldsymbol{w}_{k} \\sim \\mathcal{N}\\left(0, \\boldsymbol{Q}_{k}\\right) \\\\\\boldsymbol{z}_{k}=\\boldsymbol{x}_{k}+\\boldsymbol{n}_{k}, \u0026 \\boldsymbol{n}_{k} \\sim \\mathcal{N}\\left(0, \\boldsymbol{R}_{k}\\right)\\end{array} $$ 这个式子没有y，y是常量，y是世界坐标系的路标点 这可以表示一辆在x轴上行驶的车 取时间k=1, 2, 3，已知u，y，x0（初始状态），进行状态估计 位姿 $$ x=\\left[x_{0}, x_{1}, x_{2}, x_{3}\\right]^{\\mathrm{T}} $$ 观测 $$ z=\\left[ z_{1}, z_{2}, z_{3}\\right]^{\\mathrm{T}} $$ 传感器输入 $$ u=\\left[ u_{1}, u_{2}, u_{3}\\right]^{\\mathrm{T}} $$ 由之前的推导知 $$ \\begin{aligned}x_{\\text {map }}^{*} \u0026=\\arg \\max P(\\boldsymbol{x} \\mid \\boldsymbol{u}, \\boldsymbol{z})=\\arg \\max P(\\boldsymbol{u}, \\boldsymbol{z} \\mid \\boldsymbol{x}) \\\\\u0026=\\prod_{k=1}^{3} P\\left(\\boldsymbol{u}_{k} \\mid \\boldsymbol{x}_{k-1}, \\boldsymbol{x}_{k}\\right) \\prod_{k=1}^{3} P\\left(\\boldsymbol{z}_{k} \\mid \\boldsymbol{x}_{k}\\right)\\end{aligned} $$ $$ P\\left(\\boldsymbol{u}_{k} \\mid \\boldsymbol{x}_{k-1}, \\boldsymbol{x}_{k}\\right)=\\mathcal{N}\\left(\\boldsymbol{x}_{k}-\\boldsymbol{x}_{k-1}, \\boldsymbol{Q}_{k}\\right) $$ $$ P\\left(\\boldsymbol{z}_{k} \\mid \\boldsymbol{x}_{k}\\right)=\\mathcal{N}\\left(\\boldsymbol{x}_{k}, \\boldsymbol{R}_{k}\\right) $$ $$ \\boldsymbol{e}_{\\boldsymbol{u}, k}=\\boldsymbol{x}_{k}-\\boldsymbol{x}_{k-1}-\\boldsymbol{u}_{k}, \\quad \\boldsymbol{e}_{z, k}=\\boldsymbol{z}_{k}-\\boldsymbol{x}_{k}, $$ 最小二乘的目标函数 $$ \\min \\sum_{k=1}^{3} e_{u, k}^{\\mathrm{T}} \\boldsymbol{Q}_{k}^{-1} e_{\\boldsymbol{u}, k}+\\sum_{k=1}^{3} \\boldsymbol{e}_{\\boldsymbol{z}, k}^{\\mathrm{T}} \\boldsymbol{R}_{k}^{-1} \\boldsymbol{e}_{z, k} $$ 定义向量 $$ \\boldsymbol{y}=[\\boldsymbol{u}, \\boldsymbol{z}]^{\\mathrm{T}} $$ $$ y-\\boldsymbol{H} \\boldsymbol{x}=\\boldsymbol{e} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{\\Sigma}) $$ $$ \\boldsymbol{H}=\\left[\\begin{array}{cccc}1 \u0026 -1 \u0026 0 \u0026 0 \\\\0 \u0026 1 \u0026 -1 \u0026 0 \\\\0 \u0026 0 \u0026 1 \u0026 -1 \\\\0 \u0026 1 \u0026 0 \u0026 0 \\\\0 \u0026 0 \u0026 1 \u0026 0 \\\\0 \u0026 0 \u0026 0 \u0026 1\\end{array}\\right] $$ $$ \\Sigma=\\operatorname{diag}\\left(Q_{1}, Q_{2}, Q_{3}, R_{1}, R_{2}, R_{3}\\right) $$ 整个问题可以写成 $$ \\boldsymbol{x}_{\\text {map }}^{*}=\\arg \\min \\boldsymbol{e}^{\\mathrm{T}} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{e} $$ $$ \\boldsymbol{x}_{\\text {map }}^{*}=\\left(\\boldsymbol{H}^{\\mathrm{T}} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{H}\\right)^{-1} \\boldsymbol{H}^{\\mathrm{T}} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{y} $$ 这个公式只针对例子 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:2:3","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"非线性最小二乘 考虑这个问题 $$ \\min _{x} \\frac{1}{2}\\|f(x)\\|_{2}^{2} $$ x是n维向量 一般直观的求法是dF/dx=0，当dF/dx不好求时用迭代法 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:0","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"梯度下降法 见相关知识部分 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:1","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"牛顿法 见相关知识部分 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:2","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"高斯牛顿法 最速下降法和牛顿法虽然直观，但实用当中存在一些缺点 最速下降法会碰到zigzag问题（过于贪婪） 牛顿法迭代次数少，但需要计算复杂的Hessian矩阵 能否回避Hessian的计算？ guass-newton 将f(x)进行一阶的泰勒展开（注意x是n维向量） $$ f(\\boldsymbol{x}+\\Delta \\boldsymbol{x}) \\approx f(\\boldsymbol{x})+\\boldsymbol{J}(\\boldsymbol{x})^{\\mathrm{T}} \\Delta \\boldsymbol{x} $$ J(x)是否转置都可以，取决于求导用的分子布局还是分母布局，不过一般要统一并且灵活应用 J(x)T类似于df(x)/dx，是n*1的列向量，J(x)是Jacobi矩阵 寻找Δx，使得 $\\|f(\\boldsymbol{x}+\\Delta \\boldsymbol{x})\\|^{2}$ 最小 $$\\Delta \\boldsymbol{x}^{*}=\\arg \\min _{\\Delta \\boldsymbol{x}} \\frac{1}{2}\\left\\|f(\\boldsymbol{x})+\\boldsymbol{J}(\\boldsymbol{x})^{\\mathrm{T}} \\Delta \\boldsymbol{x}\\right\\|^{2}$$ 1/2是系数，加与不加无所谓 $$\\begin{aligned}\\frac{1}{2}\\left\\|f(x)+J(x)^{\\mathrm{T}} \\Delta x\\right\\|^{2} \u0026=\\frac{1}{2}\\left(f(x)+J(x)^{\\mathrm{T}} \\Delta x\\right)^{\\mathrm{T}}\\left(f(x)+J(x)^{\\mathrm{T}} \\Delta x\\right) \\\\\u0026=\\frac{1}{2}\\left(\\|f(x)\\|_{2}^{2}+2 f(x) J(x)^{\\mathrm{T}} \\Delta x+\\Delta x^{\\mathrm{T}} J(x) J(x)^{\\mathrm{T}} \\Delta x\\right) \\end{aligned}$$ 求上式对于Δx的导数，并令其为0 $$J(x) f(x)+J(x) J^{\\top}(x) \\Delta x=0$$ $$\\underbrace{\\boldsymbol{J}(\\boldsymbol{x}) \\boldsymbol{J}^{\\mathrm{T}}}_{\\boldsymbol{H}(\\boldsymbol{x})}(\\boldsymbol{x}) \\Delta \\boldsymbol{x}=\\underbrace{-\\boldsymbol{J}(\\boldsymbol{x}) f(\\boldsymbol{x})}_{\\boldsymbol{g}(\\boldsymbol{x})} $$ $$H \\Delta x=g$$ 在牛顿法中 $$\\nabla f\\left(x^{(k)}\\right)+H\\left(x^{(k)}\\right)\\left(x-x^{(k)}\\right)=0$$ $$J+H\\Delta x = 0$$ GN法就是用JJT代替H GN法的迭代步骤如下 给定初值$x_0$ 对于第k次迭代，求$J(x_k)$和误差$f(x_k)$ （因为$H\\Delta x=g$中需要） 求增量方程 $H \\Delta x_k = g$ 若$\\Delta x_k$ 足够小，则停止，否则$x_{k+1}=x_k+\\Delta x$，跳2 可以看出主要是求$H\\Delta x=g$中的$\\Delta x$ 有些GN法的变种为 $$(\\Delta \\boldsymbol{x}, \\alpha)^{*}=\\arg \\min \\left\\| f(x+\\alpha \\Delta x) \\right\\|^{2}$$ 求完Δx后求α ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:3","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"列文伯格-马夸尔特法 levenberg-marquadt GN法只能在展开点附近有较好的近似效果，LM法一定程度上修正了GN法的缺点，收敛速度比GN法慢 LM法给Δx加一个范围，称为信赖域（trust region），这个范围定义了什么情况下近似是有效的，这类方法也叫信赖域法（trust region method） 用ρ来刻画近似好坏程度 $$\\rho=\\frac{f(x+\\Delta x)-f(x)}{J(x)^{T} \\Delta x}$$ 再次声明J的转置取决于求导用的分子布局还是分母布局，其实没有差别 这个式子的分子是实际情况，分母是近似情况 ρ接近1，近似效果好，太小，缩小近似范围，太大，扩大近似范围 所以对GN法改造后的LM法如下 给初值$x_0$和初始优化半径μ 对于第k次迭代，在GN法上增加trust region求解，μ是信赖域半径，D是系数矩阵 $$ \\min _{\\Delta \\boldsymbol{x}_{k}} \\frac{1}{2}\\left\\|f\\left(\\boldsymbol{x}_{k}\\right)+\\boldsymbol{J}\\left(\\boldsymbol{x}_{k}\\right)^{T} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2}, \\quad \\text { s.t. }\\left\\|\\boldsymbol{D} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2} \\leq \\mu $$ 根据它，计算ρ $$\\rho=\\frac{f(x+\\Delta x)-f(x)}{J(x)^{T} \\Delta x}$$ 若ρ\u003e3/4， μ=2μ 若ρ\u003c1/4，μ=0.5μ 若μ大于某阈值，则认为近似可行，$x_{k+1}=x_k+\\Delta x$ 判断算法是否收敛，不收敛跳2，否则结束 近似范围扩大的倍数和阈值都是可调的 对于 $\\left\\|\\boldsymbol{D} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2} \\leq \\mu$ 可以认为Δx限定在半径为μ的球中，带上D之后变成椭球 列文伯格说D取I（单位阵），马夸尔特说D取非负数对角阵（实际通常用$J^TJ$的对角元素平方根，使得在梯度小的维度上约束范围大一点） 对于这个带约束的非线性优化，可用拉格朗日乘数法解（Lagrange Multiplier Method）（另一种方法是罚函数法） $$\\mathcal{L}\\left(\\Delta \\boldsymbol{x}_{k}, \\lambda\\right)=\\frac{1}{2}\\left\\|f\\left(\\boldsymbol{x}_{k}\\right)+\\boldsymbol{J}\\left(\\boldsymbol{x}_{k}\\right)^{\\mathrm{T}} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2}+\\frac{\\lambda}{2}\\left(\\left\\|\\boldsymbol{D} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2}-\\mu\\right)$$ 和GN法一样，令 $$\\frac{d\\mathcal{L}\\left(\\Delta \\boldsymbol{x}_{k}, \\lambda\\right)}{d\\Delta x_k}=0$$ $$\\left(\\boldsymbol{H}+\\lambda \\boldsymbol{D}^{\\mathrm{T}} \\boldsymbol{D}\\right) \\Delta \\boldsymbol{x}_{k}=\\boldsymbol{g}$$ 假设D=I $$(\\boldsymbol{H}+\\lambda \\boldsymbol{I}) \\Delta \\boldsymbol{x}_{k}=\\boldsymbol{g}$$ 总结：初值很重要 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:4","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","courses"],"content":"编译原理小练习","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"随便记录一下 图源 ","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:0:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"词法分析程序设计 import sys\r#种别编码表\r dict = {'begin' : 1, 'if' : 2, 'then' : 3, 'while' : 4, 'do' : 5, 'end' : 6,\r'+' : 13, '-' : 14, '*' : 15, '/' : 16, ':' : 17, ':=' : 18,\r'\u003c' : 20, '\u003c\u003e' : 21, '\u003c=' : 22, '\u003e' : 23, '\u003e=' : 24, '=' : 25, ';' : 26,\r'(' : 27, ')' : 28, '#' : 0}\r#一些关键字\r word = ['begin', 'if', 'then', 'while', 'do', 'end']\r#s是关键字时的处理\r def do_word(s):\rprint('(%d, %s) ' % (dict[s], s), end='')\r#s是id时的处理\r def do_id(s):\rprint('(%d, \\'%s\\') ' % (10, s), end='')\r#s是数字时的处理\r def do_num(s):\rprint('(%d, %s) ' % (11, s), end='')\r#s是符号时的处理\r def do_symbol(s):\rprint('(%d, %s) ' % (dict[s], s), end='')\rdef main():\rwith open('in.txt', 'r') as f:\rtmpio = sys.stdin\rsys.stdin = f\rstr = input()\r#print(str)\r i = 0\rwhile str[i] != '#': # #是结束标志\r ch = str[i]\rif ch == ' ': #空格直接跳过\r i += 1\rcontinue\rif ch.isalpha(): #如果是字母就一直搜素知道非数字和非字母，这样就能取到关键字或标识符\r tmp_str = ''\rwhile ch.isalnum():\rtmp_str += ch\ri += 1\rch = str[i]\rif tmp_str in word: #如果是关键字\r do_word(tmp_str)\relse :\rdo_id(tmp_str) #否则是标识符\r elif ch.isnumeric(): #取得这个数字\r tmp_str = ''\rwhile ch.isnumeric():\rtmp_str += ch\ri += 1\rch = str[i]\rdo_num(tmp_str)\relse: #判断是否是两个字符组成的符号\r tmp_str = ''\rif str[i] == ':' and str[i + 1] == '=':\rtmp_str = ':='\ri += 1\relif str[i] == '\u003c' and str[i + 1] == '\u003e':\rtmp_str = '\u003c\u003e'\ri += 1\relif str[i] == '\u003c' and str[i + 1] == '=':\rtmp_str = '\u003c='\ri += 1\relif str[i] == '\u003e' and str[i + 1] == '=':\rtmp_str = '\u003e='\ri += 1\relse:\rtmp_str = ch #一个字符组成的符号\r do_symbol(tmp_str)\ri += 1\rprint('(0, #)')\rsys.stdin = tmpio\rif __name__ == '__main__':\rmain()\r function func(){\rvar tmp = document.getElementById('qwe');\rvar str = tmp.value;\rvar fstr = '';\r// tmp = document.getElementById('zxc');\r // tmp.value = str;\r\rfunction do_word(s) {\rfstr += '(';\rfstr += dict[s];\rfstr += ', ';\rfstr += s;\rfstr += ') ';\r}\rfunction do_id(s) {\rfstr += '(';\rfstr += 10;\rfstr += ', ';\rfstr += s;\rfstr += ') ';\r}\rfunction do_num(s) {\rfstr += '(';\rfstr += 11;\rfstr += ', ';\rfstr += s;\rfstr += ') ';\r}\rfunction do_symbol(s) {\rfstr += '(';\rfstr += dict[s];\rfstr += ', ';\rfstr += s;\rfstr += ') ';\r}\rfunction contains(arr, obj) {\rvar i = arr.length;\rwhile (i--) {\rif (arr[i] === obj) {\rreturn true;\r}\r}\rreturn false;\r}\rvar dict = {'begin' : 1, 'if' : 2, 'then' : 3, 'while' : 4, 'do' : 5, 'end' : 6,\r'+' : 13, '-' : 14, '*' : 15, '/' : 16, ':' : 17, ':=' : 18,\r'\u003c' : 20, '\u003c\u003e' : 21, '\u003c=' : 22, '\u003e' : 23, '\u003e=' : 24, '=' : 25, ';' : 26,\r'(' : 27, ')' : 28, '#' : 0};\rvar word = new Array('begin', 'if', 'then', 'while', 'do', 'end');\rvar i = 0;\rwhile(str[i] != '#'){\rvar ch = str[i];\rif(ch == ' '){\ri++;\rcontinue;\r}\rif((ch \u003e= 'a' \u0026\u0026 ch \u003c= 'z') || (ch \u003e= 'A' \u0026\u0026 ch \u003c= 'Z')){\rvar tmp_str = '';\rwhile((ch \u003e= 'a' \u0026\u0026 ch \u003c= 'z') || (ch \u003e= 'A' \u0026\u0026 ch \u003c= 'Z') || (ch \u003e= '0' \u0026\u0026 ch \u003c= '9')){\rtmp_str += ch;\ri++;\rch = str[i];\r}\rif(contains(word, tmp_str)){\rdo_word(tmp_str);\r}else do_id(tmp_str);\r}else if(ch \u003e= '0' \u0026\u0026 ch \u003c= '9'){\rvar tmp_str = '';\rwhile (ch \u003e= '0' \u0026\u0026 ch \u003c= '9'){\rtmp_str += ch;\ri++;\rch = str[i];\r}\rdo_num(tmp_str);\r}else{\rvar tmp_str = '';\rif(str[i] == ':' \u0026\u0026 str[i + 1] == '='){\rtmp_str = ':=';\ri++;\r}else if(str[i] == '\u003c' \u0026\u0026 str[i + 1] == '\u003e'){\rtmp_str = '\u003c\u003e';\ri++;\r}else if(str[i] == '\u003c' \u0026\u0026 str[i + 1] == '='){\rtmp_str = '\u003c=';\ri++;\r}else if(str[i] == '\u003e' \u0026\u0026 str[i + 1] == '='){\rtmp_str= '\u003e=';\ri++;\r}else tmp_str = ch;\rdo_symbol(tmp_str);\ri++;\r}\r}\rfstr += '(0, #)';\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\r}\r ","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:1:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"基于语法制导翻译的表达式转换编译器 function func2() {\rvar tmp = document.getElementById('qwe');\rvar str = tmp.value;\rvar fstr = '';\rvar st_lex = [];\rvar st_tok = [];\rconst NUM = 256, DIV = 257, MOD = 258, ID = 259, DONE = 260, NONE = -1, EOSTR = '\\0';\rconst BUF_SIZE = 100, SYM_SIZE = 200;\rvar lookahead, lineno = 1, tokenval = NONE;\rvar lexbuf = '';\rvar I = 0;\rvar eflag = false;\rvar estr = '';\rfunction emit(type, tval) {\rswitch (type) {\rcase '+':\rcase '-':\rcase '*':\rcase '/':\rfstr += type;\rbreak;\rcase DIV:\rfstr += 'div';\rbreak;\rcase MOD:\rfstr += 'mod';\rbreak;\rcase NUM:\rfstr += tval;\rbreak;\rcase ID:\rfstr += st_lex[tval];\rbreak;\rdefault:\rreturn;\r}\r}\rfunction error(s) {\rfstr += 'line ' + lineno + ': ' + s + '\\n';\reflag = true;\restr = fstr;\r//add a teiminate statement\r tmp = document.getElementById('zxc');\rtmp.value = fstr;\r//alert('qqq');\r throw new Error ('error');\r}\rfunction insert(s, num) {\rif(st_lex.length \u003e= SYM_SIZE){\rerror('symbol table full');\r}\rst_lex.push(s);\rst_tok.push(num);\r}\rfunction init() {\rinsert('', 0);\rinsert('div', DIV);\rinsert('mod', MOD);\r}\rfunction lookup(s) {\rfor(var i = 1; i \u003c st_lex.length; ++i){\rif(st_lex[i] == s) return i;\r}\rreturn 0;\r}\rfunction lex() {\rvar tmp;\rwhile(true){\rtmp = str[I];\rI++;\rif(tmp == ' ' || tmp == '\\t') continue;\relse if(tmp == '\\n'){\rlineno++;\r}else if(tmp \u003e= '0' \u0026\u0026 tmp \u003c= '9'){\rI--;\rvar tt = '';\rwhile(tmp \u003e= '0' \u0026\u0026 tmp \u003c= '9'){\rtt += tmp;\rI++;\rtmp = str[I];\r}\rtokenval = parseInt(tt);\rreturn NUM;\r}else if((tmp \u003e= 'a' \u0026\u0026 tmp \u003c= 'z') || (tmp \u003e= 'A' \u0026\u0026 tmp \u003c= 'Z')){\rvar pos, ind = 0;\rlexbuf = '';\rwhile ((tmp \u003e= 'a' \u0026\u0026 tmp \u003c= 'z') || (tmp \u003e= 'A' \u0026\u0026 tmp \u003c= 'Z') || (tmp \u003e= '0' \u0026\u0026 tmp \u003c= '9')){\rlexbuf += tmp;\rtmp = str[I];\rI++;\rind++;\rvar tmps = lexbuf;\rif(tmps == 'DIV' || tmps == 'MOD'){\rbreak;\r}\rif(ind \u003e= BUF_SIZE){\rerror('the length of identifier is too long');\r}\r}\rif(tmp != '#'){\rI--;\r}\rpos = lookup(lexbuf);\rif(pos == 0){\rinsert(lexbuf, ID);\rtokenval = st_lex.length - 1;\rreturn ID;\r}else if(st_lex[pos] == 'div' || st_lex[pos] == 'mod'){\rif(st_lex[pos] == 'div'){\rtokenval = DIV;\rreturn DIV;\r}else {\rtokenval = MOD;\rreturn MOD;\r}\r}else {\rtokenval = pos;\rreturn ID;\r}\r}else if(tmp == '#'){\rreturn DONE;\r}else{\rtokenval = NONE;\rreturn tmp;\r}\r}\r}\rfunction match(x) {\rif(lookahead == x){\rlookahead = lex();\r}else error('syntax error');\r}\rfunction factor() {\rswitch (lookahead) {\rcase '(':\rmatch('(');\rexpress();\rmatch(')');\rbreak;\rcase NUM:\remit(NUM, tokenval);\rmatch(NUM);\rbreak;\rcase ID:\remit(ID, tokenval);\rmatch(ID);\rbreak;\rdefault:\rerror('syntax error');\r}\r}\rfunction term() {\rvar tmp;\rfactor();\rwhile(true){\rswitch (lookahead) {\rcase '*':\rcase '/':\rcase DIV:\rcase MOD:\rtmp = lookahead;\rmatch(lookahead);\rfactor();\remit(tmp, NONE);\rcontinue;\rdefault:\rreturn ;\r}\r}\r}\rfunction express() {\rvar tmp;\rterm();\rwhile (true){\rswitch (lookahead) {\rcase '+':\rcase '-':\rtmp = lookahead;\rmatch(lookahead);\rterm();\remit(tmp, NONE);\rcontinue;\rdefault:\rreturn ;\r}\r}\r}\rfunction parse() {\rlookahead = lex();\rwhile (lookahead != DONE){\rexpress();\rmatch(';');\rfstr += '\\n';\r}\r}\rinit();\rparse();\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\r//if(eflag) tmp.value = estr; else tmp.value = fstr;\r\r}\r ","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:2:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"说明语句的词法分析器 import sys\rind = 0\rid = [] #存标识符名称\r tp = [] #存标识符类型\r val = [] #存标识符的值\r def judge_is_id(s): #是否满足标识符的条件\r if s.count(' ') \u003e 0:\rreturn False\rif not s[0].isalpha():\rreturn False\rreturn True\rdef main():\rwith open('in.txt', 'r') as f:\rtmpio = sys.stdin\rsys.stdin = f\rstr = input()\rint_num = char_num = string_num = float_num = 0 #计数\r i = 0\rwhile str[i] != ';': #分号表示结束\r if str[i] == ' ': #空格跳过\r i += 1\rcontinue\rif str[i] != 'c': #第一个字符不为c，说明不是const\r print('It is not a constant declaration statement!')\rprint('Please input a string again!')\rsys.exit()\relif i + 6 \u003e len(str): #说明不存在const这个单词\r print('It is not a constant declaration statement!')\rprint('Please input a string again!')\rsys.exit()\relif str[i : i + 5] != 'const': #开头是c但是单词不是const\r print('It is not a constant declaration statement!')\rprint('Please input a string again!')\rsys.exit()\relse:\rstr = str[i + 5: -1] #是const，截掉这个单词\r break\ri = 0\rfoo = str.split(',') #按逗号分割\r #print(foo)\r for cnt in foo:\rleft = (cnt.split('=')[0]) #等号左边的量\r right = cnt.split('=')[1] #等号右边的数值\r left = left.strip() #消掉前后的空格\r right = right.strip()\rif not judge_is_id(left): #不是标识符\r id.append(left)\rtp.append('Wrong! It is not an identifier!')\rval.append(' ')\r#print('Wrong! It is not an identifier!')\r #sys.exit()\r else:\rleft.strip()\rid.append(left)\rif right[0] == '\\'' and right[2] == '\\'' : #值所代表的的字符串中有两个单引号，且距离为1，说明是char类型\r tp.append('char')\rval.append(right[1])\relif right.count('\\'') == 2: #有两个单引号，但是其中的字符大于1\r tp.append('more than one character in \\'')\rval.append(' ')\r#print('more than one character in \\'\\'')\r #sys.exit()\r elif right.count('\\\"') == 2: #有两个双引号是string类型\r tp.append('string')\rval.append(right[1: -1])\relse : #剩下的情况是数字或非法\r if right.count('.') == 1 and right.split('.')[0].isdigit() and right.split('.')[1].isdigit() :\rif right.split('.')[0][0] == '0': #上面的语句说明含有一个小数点，且小数点左右两边都是数字，这可能是个小数\r tp.append('numbers cannot started with zero') #有前导0不行，这里没有考虑0.xxx的情况\r val.append(' ')\r#print('numbers cannot started with zero')\r #sys.exit()\r else: #合法的小数\r tp.append('float')\rval.append(right)\relif not right.isdigit(): #含有非数字成分，说明这不是一个数字\r tp.append('Wrong constant')\rval.append(' ')\r#print('Wrong constant')\r #sys.exit()\r elif right[0] == '0': #是数字但是含有前导0\r tp.append('numbers cannot started with zero')\rval.append(' ')\r#print('numbers cannot started with zero')\r #sys.exit()\r else : #合法的数字\r tp.append('integer')\rval.append(right)\r#print(len(id), len(tp), len(val))\r bar = len(id) #输出\r for i in range(bar):\rprint('%s( %s, %s)' % (id[i], tp[i], val[i]))\rfor i in range(bar): #统计\r if tp[i] == 'integer': int_num += 1\rif tp[i] == 'char': char_num += 1\rif tp[i] == 'string': string_num += 1\rif tp[i] == 'float': float_num += 1\rprint('%s= %d, %s= %d, %s= %d, %s= %d' % ('int_num', int_num, 'char_num', char_num, 'string_num', string_num, 'float_num', float_num) )\rsys.stdin = tmpio\rif __name__ == '__main__':\rmain()\r function func3() {\rvar tmp = document.getElementById('qwe');\rvar str = tmp.value;\rvar fstr = '';\rvar id = [], tp = [], val = [];\rfunction judge_is_id(s) {\rif ((s.split(' ')).length - 1 \u003e 0){\rreturn false;\r}\rif(!((s[0] \u003e= 'a' \u0026\u0026 s[0] \u003c= 'z') || (s[0] \u003e= 'A' || s[0] \u003c= 'Z'))){\rreturn false;\r}\rreturn true;\r}\rvar int_num, char_num, string_num, float_num;\rint_num = char_num = string_num = float_num = 0;\rvar i = 0;\rwhile (str[i] != ';'){\rif(str[i] == ' '){\ri++;\rcontinue;\r}\rif(str[i] != 'c'){\rfstr += 'It is not a constant declaration statement!\\n';\rfstr += 'Please input a string again!';\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\rthrow new Error('error');\r}else if(i + 6 \u003e str.length){\rfstr += 'It is not a constant declaration statement!\\n';\rfstr += 'Please input a string again!';\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\rthrow new Error('error');\r}else if(str.slice(i, i + 5) != 'const'){\rfstr += 'It is not a constant declaration statement!\\n';\rfstr += 'Please input a string again!';\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\rthrow new Error('error');\r}else{\rstr = str.slice(i + 5, str.len","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:3:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"基于预测分析方法的表达式语法 import sys\r#预测分析表\r dict = {\r'S' : {\r'm' : 'AT',\r'(' : 'AT'\r},\r'T' : {\r'+' : '+AT',\r')' : '$',\r'#' : '$',\r},\r'A' : {\r'm' : 'BU',\r'(' : 'BU'\r},\r'U' : {\r'+' : '$',\r'*' : '*BU',\r')' : '$',\r'#' : '$'\r},\r'B' : {\r'm' : 'm',\r'(' : '(S)'\r}\r}\r#非终结符\r no_tm = ['m', '+', '*', '(', ')', '#']\r#输出一行包含序号，分析栈，输入栈，所用产生式\r def PRINT(no, stk, s, pd):\rif stk[-1:] not in no_tm:\rprint('%d\\t%-10s%10s\\t%s-\u003e%s' % (no, stk, s, stk[-1:], pd))\relse :\rprint('%d\\t%-10s%10s\\t%s' % (no, stk, s, pd))\rdef main():\rwith open('in.txt', 'r') as f:\rtmpio = sys.stdin\rsys.stdin = f\rstri = input()\rnum = 1 #序号\r prod = '' #产生式\r ind = 0 #输入串的下标\r stack = '#S' #分析栈\r while len(stack) != 1: #说明只剩#\r if stack[-1:] == stri[ind]: #分析栈的栈顶等于输入串的栈顶，说明非终结符匹配\r PRINT(num, stack, stri, '\\'' + stri[ind] + '\\'match')\rstri = ' ' * (ind + 1) + stri[ind+1:]\rind += 1\rnum += 1\rstack = stack[:-1]\relif stack[-1:] in no_tm: #分析栈的栈顶不等于输入串的栈顶又不是非终结符，说明不匹配\r PRINT(num, stack, stri, '[ERROR] not match')\rsys.exit()\relif stri[ind] not in dict[stack[-1:]].keys(): #在预测分析表中没有填产生式，出错\r PRINT(num, stack, stri, '[ERROR] not match')\rsys.exit()\relse: #利用产生式，出栈和入栈\r prod = dict[stack[-1:]][stri[ind]]\rPRINT(num, stack, stri, prod)\rnum += 1\rstack = stack[:-1]\rif prod != '$':\rstack += prod[::-1]\rPRINT(num, stack, stri, 'acc') #出错的全都中途退出了，能走到这步的都是acc\r sys.stdin = tmpio\rif __name__ == '__main__':\rmain()\r function func4() {\rvar tmp = document.getElementById('qwe');\rvar str = tmp.value;\rvar fstr = '';\rvar dict = {\r'S' : {\r'm' : 'AT',\r'(' : 'AT'\r},\r'T' : {\r'+' : '+AT',\r')' : '$',\r'#' : '$',\r},\r'A' : {\r'm' : 'BU',\r'(' : 'BU'\r},\r'U' : {\r'+' : '$',\r'*' : '*BU',\r')' : '$',\r'#' : '$'\r},\r'B' : {\r'm' : 'm',\r'(' : '(S)'\r}\r};\rno_tm = ['m', '+', '*', '(', ')', '#'];\rfunction PRINT(no, stk, s, pd) {\rvar tchar = stk.slice(stk.length - 1, stk.length);\rif(no_tm.indexOf(tchar) == -1){\rwhile(stk.length \u003c 20){\rstk += ' ';\r}\rwhile (s.length \u003c 20){\rs = ' ' + s;\r}\rfstr += no;\rfstr += ('\\t' + stk + s + '\\t\\t\\t' + tchar + '-\u003e' + pd + '\\n');\r}else{\rwhile(stk.length \u003c 20){\rstk += ' ';\r}\rwhile (s.length \u003c 20){\rs = ' ' + s;\r}\rfstr += no;\rfstr += ('\\t' + stk + s + '\\t\\t\\t' + pd + '\\n');\r}\r}\rvar num = 1;\rvar ind = 0;\rvar stack = '#S';\rwhile (stack.length != 1){\rif(stack.slice(stack.length - 1, stack.length) == str[ind]){\rPRINT(num, stack, str, '\\'' + str[ind] + '\\' match');\rtt_str = str;\rstr = '';\rfor(var j = 0; j \u003c ind + 1; ++j){\rstr += ' ';\r}\rstr += tt_str.slice(ind + 1, tt_str.length);\rind++;\rnum++;\rstack = stack.slice(0, stack.length - 1);\r}else if(no_tm.indexOf(stack.slice(stack.length - 1, stack.length)) != -1){\rPRINT(num, stack, str, '[ERROR] not match');\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\rthrow new Error('error');\r}else if(!(str[ind] in dict[stack.slice(stack.length - 1, stack.length)])){\rPRINT(num, stack, str, '[ERROR] not match');\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\rthrow new Error('error');\r}else{\rvar prod = dict[stack.slice(stack.length - 1, stack.length)][str[ind]];\rPRINT(num, stack, str, prod);\rnum++;\rstack = stack.slice(0, stack.length - 1);\rif(prod != '$'){\rstack += prod.split(\"\").reverse().join(\"\");\r}\r}\r}\rPRINT(num, stack, str, 'acc');\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\r}\r ","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:4:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["problemlist"],"content":"9th hhucpc (Senior)","date":"2020-12-09","objectID":"/9th-hhucpcsenior/","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"u1s1,zyyyyy出的题目真的好好，补题的过程学到了好多（好菜啊o(╥﹏╥)o 题目链接 只贴了代码，题解参考此处 ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:0:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"A ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:1:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"签到 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rint main(){\rint n;\rint a[105];\rcin \u003e\u003e n;\rint s, m, b;\rs = m = b = 0;\rfor(int i = 0; i \u003c n; ++i){\rdouble x;\rcin \u003e\u003e x;\rif(x == 2 or x == 2.5 or x == 3) s++;\relse if(x == 5 or x == 5.5 or x == 6) m++;\relse b++;\r}\rcout \u003c\u003c \"Small: \" \u003c\u003c s \u003c\u003c endl \u003c\u003c \"Medium: \" \u003c\u003c m \u003c\u003c endl \u003c\u003c \"Big: \" \u003c\u003c b \u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:1:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"B ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:2:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"贪心 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll a[100005];\rll b[100005];\rint main(){\rll n;\rll x, y, z;\rcin \u003e\u003e n;\rfor(int i = 1; i \u003c= n; ++i) cin \u003e\u003e a[i];\rcin \u003e\u003e x \u003e\u003e y \u003e\u003e z;\rll mi = 100000000000;\rll ans = n;\rb[0] = x;\rfor(int i = 1; i \u003c= n; ++i) b[i] = b[i - 1] + z;\rbool ok = true;\rfor(int i = n; i \u003e 0; --i){\rif(b[i] \u003c= a[i]){\rok = false;\rbreak;\r}\rif(b[i] - z - y \u003e a[i] and mi \u003e (y + z)){\rans--;\rb[i] = b[i] - z - y;\rmi = min(b[i] - a[i], mi- y - z);\r}\rmi = min(mi, b[i] - a[i]);\r}\rif(!ok) puts(\"HHUTQL\");\relse cout \u003c\u003c ans \u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:2:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"C ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:3:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"线段树 没板子就不写了 o(╥﹏╥)o ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:3:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"D ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:4:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"状态压缩 / dfs暴搜 #include \"bits/stdc++.h\"\r using namespace std;\rtypedef long long ll;\rll n, m, c;\rll w[25];\rll v[25];\rvector\u003cpair\u003cll, ll\u003e\u003e conflict;\rll ind[1005];\rll to_ind(ll x){\rreturn ind[x];\r}\rbool ok(ll x){\rfor(auto i : conflict){\rll l = i.first;\rll r = i.second;\rif((x \u003e\u003e l \u0026 1) and (x \u003e\u003e r \u0026 1)) return false;\r}\rreturn true;\r}\rll cal(ll x){\rll sumw = 0;\rll sumv = 0;\rfor(ll i = 0; i \u003c n; ++i){\rif(x \u003e\u003e i \u0026 1){\rsumw += w[i];\rsumv += v[i];\rif(sumw \u003e m) return 0;\r}\r}\rreturn sumv;\r}\rint main() {\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\rconflict.clear();\rcin \u003e\u003e n \u003e\u003e m \u003e\u003e c;\rfor(ll i = 0; i \u003c n; ++i){\rll x, y, z;\rcin \u003e\u003e x \u003e\u003e y \u003e\u003e z;\rw[i] = y;\rv[i] = z;\rind[x] = i;\r}\rfor(ll i = 0; i \u003c c; ++i){\rll x, y;\rcin \u003e\u003e x \u003e\u003e y;\rconflict.emplace_back(to_ind(x), to_ind(y));\r}\rll ans = 0;\rfor(ll i = 0; i \u003c (1 \u003c\u003c n); ++i){\rif(ok(i)){\rans = max(ans, cal(i));\r}\r}\rcout \u003c\u003c ans \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:4:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"E ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:5:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"打表 矩阵快速幂 #include \"bits/stdc++.h\"\r\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1000000007;\rtypedef vector\u003cll\u003e vec;\rtypedef vector\u003cvector\u003cll\u003e\u003e mat;\rmat mul(mat \u0026A , mat \u0026B){\rmat C(A.size() , vec(B[0].size()));\rfor(ll i = 0; i \u003c A.size() ; ++i){\rfor(ll k = 0 ; k \u003c B.size() ; ++k){\rfor(ll j = 0 ; j \u003c B[0].size() ; ++j){\rC[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod;\r}\r}\r}\rreturn C;\r}\rmat pow_mat(mat A , ll n){\rmat B(A.size() , vec(A.size()));\rfor(ll i = 0 ; i \u003c A.size() ; ++i){\rB[i][i] = 1;\r}\rwhile(n \u003e 0){\rif(n \u0026 1) B = mul(B , A);\rA = mul(A , A);\rn \u003e\u003e= 1;\r}\rreturn B;\r}\rint main() {\r// ll n = 1;\r// ll ans = 0;\r// vector\u003cll\u003e vt;\r// vector\u003cll\u003e tt;\r// for(ll i = 0; i \u003c n; ++i){\r// tt.push_back(i % 3);\r// }\r// for(ll i = 0; i \u003c (1 \u003c\u003c n); ++i){\r// vt.clear();\r// for(ll j = 0; j \u003c n; ++j){\r// if(i \u003e\u003e j \u0026 1){\r// vt.push_back(j % 3);\r// }\r// }\r// bool ok = true;\r// for(ll j = 0; j \u003c vt.size(); ++j){\r// if(vt[j] != tt[j]){\r// ok = false;\r// break;\r// }\r// }\r// if(ok) ans++;\r// }\r// cout \u003c\u003c ans - 1 \u003c\u003c endl;\r\rll g1 = 1, g2 = 2, g3 = 3;\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\r//此处有md渲染有bug，所以这样写\r mat core = {{1, 0, 1, 1}}, {1, 0, 0, 0}, {0, 1, 0, 0}, {{0, 0, 0, 1}};\rll n;\rcin \u003e\u003e n;\rif(n \u003c= 3){\rcout \u003c\u003c n \u003c\u003c endl;\rcontinue;\r}\rn -= 3;\rcore = pow_mat(core, n);\rll ans = 0;\rans += core[0][0] * g3;\rans %= mod;\rans += core[0][1] * g2;\rans %= mod;\rans += core[0][2] * g1;\rans %= mod;\rans += core[0][3];\rans %= mod;\rcout \u003c\u003c ans \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:5:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"F ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:6:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"分治 01背包 二分 前缀 #include \"bits/stdc++.h\"\r\rusing namespace std;\rtypedef long long ll ;\rint n, c;\rconst int maxn = 1005;\rconst int maxm = 32007;\rint dp1[maxm];\rint dp2[maxm];\rint n1;\rint n2;\rint W;\rvector\u003cint\u003e w1, v1, w2, v2;\rconst int limit = (1 \u003c\u003c 10);\rvector\u003cpair\u003cint, int\u003e\u003e vt1;\rvector\u003cint\u003e vt2;\rint premax[maxm];\r// 1 for big , 2 for small\rint main() {\rcin \u003e\u003e n \u003e\u003e c;\rmemset(premax, -1, sizeof(premax));\rW = maxm - 3;\r// for test\r w1.push_back(0);\rw2.push_back(0);\rv1.push_back(0);\rv2.push_back(0);\rfor(int i = 0; i \u003c n; ++i){\rint x, y;\rcin \u003e\u003e x \u003e\u003e y;\rif(x \u003e= limit){\r++n1;\rw1.push_back((x \u003e\u003e 10));\rv1.push_back(y);\r}else {\r++n2;\rw2.push_back(x);\rv2.push_back(y);\r}\r}\rfor(int i = 1; i \u003c= n1; ++i)\rfor(int j = W; j \u003e= w1[i]; --j)\rdp1[j] = max(dp1[j], dp1[j - w1[i]] + v1[i]);\rfor(int i = 1; i \u003c= n2; ++i)\rfor(int j = W; j \u003e= w2[i]; --j)\rdp2[j] = max(dp2[j], dp2[j - w2[i]] + v2[i]);\rfor(int i = 0; i \u003c= W; ++i){\rvt1.emplace_back((i \u003c\u003c 10), dp1[i]);\r}\rpremax[0] = dp2[0];\rfor(int i = 1; i \u003c= W; ++i){\rpremax[i] = max(premax[i - 1], dp2[i]);\r}\rint ans = 0;\rfor(int i = 0; i \u003c W; ++i){\rint cnt = vt1[i].first;\rint rem = c - cnt;\rif(rem \u003e= 0 and rem \u003c W) ans = max(ans, vt1[i].second + premax[rem]);\r}\rcout \u003c\u003c ans \u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:6:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"G ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:7:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"图论 dfs #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rint V;\rconst int maxv = 1e5 + 10;\rvector\u003cint\u003e G[maxv];\rint od[maxv];\rbool ok ;\rvoid dfs(int x, int f, int d){\rfor(int i = 0; i \u003c G[x].size(); ++i){\rint to = G[x][i];\rif(to == f) continue;\rif(od[to] != 0){\rif((d + 1 - od[to]) \u0026 1){\rok = true;\rbreak;\r}\r}else {\rod[to] = d + 1;\rdfs(to, x, d + 1);\r}\r}\r}\rint main(){\rint m;\rcin \u003e\u003e V \u003e\u003e m;\rfor(int i = 0; i \u003c m; ++i){\rint u, v;\rcin \u003e\u003e u \u003e\u003e v;\rG[u].push_back(v);\rG[v].push_back(u);\r}\rif(m \u003e= V){\rfor(int i = 1; i \u003c= V; ++i){\rif(od[i] == 0){\rdfs(i, -1, 1);\rod[i] = 1;\r}\r}\r}else ok = false;\rif(ok) puts(\"yes\"); else puts(\"NO\");\rreturn 0;\r}\r ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:7:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"H ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:8:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"欧拉降幂 快速幂 快速乘 #include \"bits/stdc++.h\"\r using namespace std;\rtypedef long long ll ;\rinline ll qmul(ll x, ll y, ll mod)\r{\rreturn ( x * y - (ll) ( (long double) x / mod*y )*mod + mod ) % mod;\r}\rll qpow(ll x, ll n, ll mod){\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=qmul(res, x, mod)%mod;\rx=qmul(x, x, mod)%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll phi(ll n)\r{\rll res=n;\rfor(ll i=2;i*i\u003c=n;i++)\r{\rif(n%i==0)\r{\rres=res/i*(i-1);\rwhile(n%i==0) n/=i;\r}\r}\rif(n!=1) res=res/n*(n-1);\rreturn res;\r}\rchar n[100005];\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rll ans ;\rll m;\rscanf(\"%s\", n);\rscanf(\"%lld\", \u0026m);\rll tmpn = 0;\rll tmp_phi = phi(m);\rll len = strlen(n);\rif(len \u003c= 16){\rll tmp_mul = 1;\rfor(int i = len - 1; i \u003e= 0; --i){\rtmpn += (n[i] - '0') * tmp_mul;\rtmp_mul *= 10;\r}\rll tmp_ans = qpow(3, tmpn, m);\rans = tmp_ans;\rans -= 2;\rans += m;\rans %= m;\r}else {\rfor(int i = 0; i \u003c len; ++i){\rtmpn = tmpn * 10 + (n[i] - '0');\rtmpn %= tmp_phi;\r}\rtmpn += tmp_phi;\rll tmp_ans = qpow(3, tmpn, m);\rans = tmp_ans;\rans -= 2;\rans += m;\rans %= m;\r}\rcout \u003c\u003c ans \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:8:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"I ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:9:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"二分 贪心 #include \"bits/stdc++.h\"\r\rusing namespace std;\rtypedef long long ll ;\rconst int maxn = 1e5 + 10;\rint a[maxn];\rint b[maxn];\rint n, m;\rbool check(int x){\rint i = 0, j = 0;\rwhile(i \u003c n and j \u003c m){\rif(abs(a[i] - b[j]) \u003c= x){\r++i, ++j;\r}else {\r++j;\r}\r}\rreturn i == n;\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rcin \u003e\u003e n \u003e\u003e m;\rfor(int i = 0; i \u003c n; ++i){\rcin \u003e\u003e a[i];\r}\rfor(int i = 0; i \u003c m; ++i){\rcin \u003e\u003e b[i];\r}\rsort(a, a + n);\rsort(b, b + m);\rint l = 0, r = 5 * 1e8 + 3;\rint mid;\rwhile (l \u003c= r){\rmid = (l + r) \u003e\u003e 1;\rif(check(mid)){\rr = mid - 1;\r}else {\rl = mid + 1;\r}\r}\rcout \u003c\u003c l \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:9:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["codeforces"],"content":"Codeforces Round #688 (Div. 2) A~D","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Cancel the Trains ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:1:0","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一个铁路网，和每个火车所在的铁路（都在起点），每一时刻走一格，问有几辆车会相撞 ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:1:1","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 编号相同的横向和列向火车会相撞 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint a[105];\rint b[105];\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n, m;\rcin \u003e\u003e n \u003e\u003e m;\rfor(int i = 0; i \u003c n; ++i){\rcin \u003e\u003e a[i];\r}\rfor(int i = 0; i \u003c m; ++i){\rcin \u003e\u003e b[i];\r}\rint num = 0;\rfor(int i = 0; i \u003c n; ++i){\rfor(int j = 0; j \u003c m; ++j){\rif(a[i] == b[j]) num++;\r}\r}\rcout \u003c\u003c num \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:1:2","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"B. Suffix Operations ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:2:0","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一个数组，刚开始时可以选择将一个数改成任何数，也可以不改，做以下操作直到每个数相等 将某一后缀都加1或减1 求最小该操作数 ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:2:1","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 如果没有刚开始的操作，那么操作数是固定的，是前一个数减后一个数再求和 然后再尝试修改每个数，中途求操作数的最小值 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll a[200005];\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rll n;\rcin \u003e\u003e n;\rfor(int i = 0; i \u003c n; ++i) cin \u003e\u003e a[i];\rll ans = 0;\rfor(int i = 0; i \u003c n - 1; ++i){\rans += abs(a[i] - a[i + 1]);\r}\rll tmp = ans;\rfor(int i = 1; i \u003c n - 1; ++i){\rll tt = tmp - abs(a[i - 1] - a[i]);\rtt -= abs(a[i] - a[i + 1]);\rtt += abs(a[i - 1] - a[i + 1]);\rans = min(ans, tt);\r}\rll tt = tmp - abs(a[n - 2] - a[n - 1]);\rans = min(ans, tt);\rtt = tmp - abs(a[0] - a[1]);\rans = min(ans, tt);\rcout \u003c\u003c ans \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:2:2","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"C. Triangles ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:3:0","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一个正方形，每个格子都填数字0~9，对于每个数字，求对应数字的最大面积的三角形，该三角形满足以下条件 顶点可重合 顶点必须在该数字的格子上 允许将其中一个格子改成任何数字（也可以不改） 至少有一条边竖直或水平 如果这条边由两个重合的点组成，则这条边竖直且水平 ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:3:1","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 模拟 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rchar a[2005][2005];\rchar b[2005][2005];\rint origin[10][2005];\rint dynamic[10][2005];\rint low[10];\rint hi[10];\rint ans[10];\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rmemset(origin, -1, sizeof(origin));\rmemset(dynamic, -1, sizeof(dynamic));\rmemset(low, 0x3f, sizeof(low));\rmemset(hi, -1, sizeof(hi));\rmemset(ans, 0, sizeof(ans));\rint n;\rcin \u003e\u003e n;\rfor(int i = 0; i \u003c n; ++i) cin \u003e\u003e a[i];\rfor(int i = 0; i \u003c n; ++i){\rvector\u003cint\u003e x[10];\rfor(int j = 0; j \u003c n; ++j){\rlow[a[i][j] - '0'] = min(low[a[i][j] - '0'], i);\rhi[a[i][j] - '0'] = max(hi[a[i][j] - '0'], i);\rdynamic[a[i][j] - '0'][i] = max(dynamic[a[i][j] - '0'][i], abs(0 - j));\rdynamic[a[i][j] - '0'][i] = max(dynamic[a[i][j] - '0'][i], abs(n - 1 - j));\rx[a[i][j] - '0'].push_back(j);\r}\rfor(int p = 0; p \u003c 10; ++p){\r//sort(x[p].begin(), x[p].end());\r if(x[p].size() \u003c 2) continue;\rorigin[p][i] = *max_element(x[p].begin(), x[p].end()) - *min_element(x[p].begin(), x[p].end());\r}\r}\rfor(int i = 0; i \u003c 10; ++i){\rint tmp = 0;\r//origin\r for(int j = 0; j \u003c n; ++j){\rif(origin[i][j] == -1) continue;\rtmp = max(tmp, origin[i][j] * max(abs(j - 0), abs(n - 1 - j)));\r}\r//dynamic\r if(low[i] == 0x3f3f3f3f or hi[i] == -1) continue;\rfor(int j = 0; j \u003c n; ++j){\rif(dynamic[i][j] == -1) continue;\rtmp = max(tmp, dynamic[i][j] * max(abs(j - low[i]), abs(j - hi[i])));\r}\rans[i] = tmp;\r}\r//cout \u003c\u003c hi[2] \u003c\u003c endl;\r for(int i = 0; i \u003c n; ++i){\rfor(int j = 0; j \u003c n; ++j){\rb[i][j] = a[j][i];\r}\r}\rfor(int i = 0; i \u003c n; ++i){\rfor(int j = 0; j \u003c n; ++j){\ra[i][j] = b[i][j];\r}\r}\rmemset(origin, -1, sizeof(origin));\rmemset(dynamic, -1, sizeof(dynamic));\rmemset(low, 0x3f, sizeof(low));\rmemset(hi, -1, sizeof(hi));\rfor(int i = 0; i \u003c n; ++i){\rvector\u003cint\u003e x[10];\rfor(int j = 0; j \u003c n; ++j){\rlow[a[i][j] - '0'] = min(low[a[i][j] - '0'], i);\rhi[a[i][j] - '0'] = max(hi[a[i][j] - '0'], i);\rdynamic[a[i][j] - '0'][i] = max(dynamic[a[i][j] - '0'][i], abs(0 - j));\rdynamic[a[i][j] - '0'][i] = max(dynamic[a[i][j] - '0'][i], abs(n - 1 - j));\rx[a[i][j] - '0'].push_back(j);\r}\rfor(int p = 0; p \u003c 10; ++p){\r//sort(x[p].begin(), x[p].end());\r if(x[p].size() \u003c 2) continue;\rorigin[p][i] = *max_element(x[p].begin(), x[p].end()) - *min_element(x[p].begin(), x[p].end());\r}\r}\rfor(int i = 0; i \u003c 10; ++i){\rint tmp = 0;\r//origin\r for(int j = 0; j \u003c n; ++j){\rif(origin[i][j] == -1) continue;\rtmp = max(tmp, origin[i][j] * max(abs(j - 0), abs(n - 1 - j)));\r}\r//dynamic\r if(low[i] == 0x3f3f3f3f or hi[i] == -1) continue;\rfor(int j = 0; j \u003c n; ++j){\rif(dynamic[i][j] == -1) continue;\rtmp = max(tmp, dynamic[i][j] * max(abs(j - low[i]), abs(j - hi[i])));\r}\rans[i] = max(ans[i], tmp);\r}\rfor(int i = 0; i \u003c 10; ++i){\rprintf(\"%d%c\", ans[i], i == 9 ? '\\n' : ' ');\r}\r}\rreturn 0;\r}\r ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:3:2","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"D. Checkpoints ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:4:0","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 有n个阶段，有些阶段有检查点，每次有一半的概率通过阶段，如果没有通过，则返回到之前最近的一个检查点（保证第一个阶段是检查点）（如果该阶段是检查点且没通过，则不动（即返回自身）），直到通过所有阶段 给定k为通过所有阶段的期望尝试值，求一种可能的阶段数和检查点设置情况（1为设置检查点，0为没有检查点） ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:4:1","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 构造 奇数一定无解 考虑10000。。。的情况，如果是10，则需要6次，第一阶段的时刻是[1,2,4,5]第二个阶段的时刻是[3,6] 如果是100，则需要14次，第一阶段的时刻是[1,2,4,5,8,9,11,12]第二个阶段的时刻是[3,6,10,13]，第三个阶段的时刻是[7,14]，经过分析和找规律发现如果10000的长度为i，则答案为2^i - 2，这样问题就转化成对k求变形二进制，然后将1000序列接在一起 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rvector\u003cint\u003e ans;\rll n;\rcin \u003e\u003e n;\rif(n \u0026 1) {\rputs(\"-1\");\rcontinue;\r}\rfor(ll i = 60; i \u003e= 1; --i){\rll tmp = (2ll \u003c\u003c i) - 2;\rwhile (n \u003e= tmp){\rn -= tmp;\rans.push_back(1);\rans.insert(ans.end(), i - 1, 0);\r}\r}\rcout \u003c\u003c ans.size() \u003c\u003c endl;\rfor(int i = 0; i \u003c ans.size(); ++i){\rcout \u003c\u003c ans[i] \u003c\u003c \" \\n\"[i == ans.size() - 1];\r}\r}\rreturn 0;\r}\r ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:4:2","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["abc"],"content":"abc184","date":"2020-12-02","objectID":"/abc184/","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"A - Determinant ","date":"2020-12-02","objectID":"/abc184/:1:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 求二阶行列式 ","date":"2020-12-02","objectID":"/abc184/:1:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rint a, b, c, d;\rcin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d;\rcout \u003c\u003c a * d - c * b \u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-12-02","objectID":"/abc184/:1:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"B - Quizzes ","date":"2020-12-02","objectID":"/abc184/:2:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 给n个问题，和答题情况，答对加1，答错减1（为0不扣分），初始分数x，求最终分数 ","date":"2020-12-02","objectID":"/abc184/:2:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rint n, k;\rcin \u003e\u003e n \u003e\u003e k;\rfor(int i = 0; i \u003c n; ++i){\rchar ch;\rcin \u003e\u003e ch;\r//cout \u003c\u003c ch;\r if(ch == 'o') k++;\rif(ch == 'x' and k \u003e 0) k--;\r}\rcout \u003c\u003c k \u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-12-02","objectID":"/abc184/:2:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"C - Super Ryuma ","date":"2020-12-02","objectID":"/abc184/:3:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 对于题目给定的图（点击标题转到原题），小黄点可以到达以它为中心的红色领域，已知小黄点的位置和目标，求最少几步能到达目标 ","date":"2020-12-02","objectID":"/abc184/:3:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 感觉这题比传统的C难 最多只需要三步，如果小黄点和目标重合，0步，目标在小黄点的领域内，1步 最难的就是判断2步，满足这几种情况就是2步，其余就是3步 以小黄点为中心的领域和目标为中心的领域相交（坐标和奇偶） 两个点的曼哈顿距离不大于6 以小黄点为中心的领域的斜线部分和目标的曼哈顿距离不大于3（其实就是和目标为中心的领域的中间那一块）（此处斜线部分有两条，所以分两种情况） #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rint a, b, c, d;\rcin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d;\rint ans = 3;\rif(a == c and b == d) ans = 0;\relse if(a + b == c + d or a - b == c - d or abs(a - c) + abs(b - d) \u003c= 3) ans = 1;\relse if(abs(c + d - (a + b)) \u003c= 3 or abs(c - d + b - a) \u003c= 3 or (a + b) % 2 == (c + d) % 2 or abs(a - c) + abs(b - d) \u003c= 6) ans = 2;\rcout \u003c\u003c ans \u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-12-02","objectID":"/abc184/:3:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"D - increment of coins ","date":"2020-12-02","objectID":"/abc184/:4:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 三个袋子放着a b c数量的金币、银币、铜币(a,b,c \u003c 100)，做以下操作直到有一个袋子数量满100 从某个袋子中拿走一个币，再放回两个相同的币 问操作次数的期望值 ","date":"2020-12-02","objectID":"/abc184/:4:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 概率dp（没怎么做过） dp[i][j][k] 表示袋子中分别剩下i j k个时的概率 所有100*100*100种情况求和就是答案（从样例2可以分析得到） 初始化 dp[a][b][c] = 1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rdouble dp[110][110][110];\rint main(){\rint a, b, c;\rcin \u003e\u003e a \u003e\u003e b \u003e\u003e c;\rdp[a][b][c] = 1;\rdouble ans = 0;\rfor(int i = 0; i \u003c 100; ++i){\rfor(int j = 0; j \u003c 100; ++j){\rfor(int k = 0; k \u003c 100; ++k){\rif(i + j + k == 0) continue;\rans += dp[i][j][k];\rdp[i + 1][j][k] += dp[i][j][k] * i / (i + j + k);\rdp[i][j + 1][k] += dp[i][j][k] * j / (i + j + k);\rdp[i][j][k + 1] += dp[i][j][k] * k / (i + j + k);\r}\r}\r}\rprintf(\"%.9f\\n\", ans);\rreturn 0;\r}\r ","date":"2020-12-02","objectID":"/abc184/:4:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"E - Third Avenue ","date":"2020-12-02","objectID":"/abc184/:5:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 给一个网格，上面有障碍，起点，终点和小写字母，从起点出发，对于当前这个没有障碍的格子，可以选择走一步（相邻四个格子），如果这个格子是小写字母就可以传送到另一个小写字母上，问最少需要几步到达终点 ","date":"2020-12-02","objectID":"/abc184/:5:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 基础bfs #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint dist[2010][2010];\rchar maze[2010][2010];\rint h, w;\rvector\u003cpair\u003cint, int\u003e\u003e a[26];\rint dir[4][2] ;\rint main(){\rmemset(dist, 0x3f, sizeof(dist));\rcin \u003e\u003e h \u003e\u003e w;\rint sx, sy, gx, gy;\rfor(int i = 1; i \u003c= h; ++i){\rcin \u003e\u003e maze[i] + 1;\r}\rfor(int i = 1; i \u003c= h; ++i){\rfor(int j = 1; j \u003c= w; ++j){\rif(maze[i][j] == 'S'){\rsx = i, sy = j;\r}\rif(maze[i][j] == 'G'){\rgx = i, gy = j;\r}\r}\r}\r// for(int i = 1; i \u003c= h; ++i){\r// for(int j = 1; j \u003c= w; ++j) // {\r// cout \u003c\u003c maze[i][j];\r// }\r// cout \u003c\u003c '\\n';\r// }\r\rfor(int i = 1; i \u003c= h; ++i){\rfor(int j = 1; j \u003c= w; ++j){\rif(isalpha(maze[i][j]) and maze[i][j] != 'S' and maze[i][j] != 'G'){\ra[maze[i][j] - 'a'].emplace_back(i, j);\r}\r}\r}\rdist[sx][sy] = 0;\rqueue\u003cpair\u003cint, int\u003e\u003e q;\rq.push({sx, sy});\rbool got = false;\rwhile(!q.empty() and !got){\rauto tmp = q.front();\rq.pop();\rint tx = tmp.first;\rint ty = tmp.second;\rfor(int i = 0; i \u003c 4; ++i){\rint fx = tx + dir[i][0];\rint fy = ty + dir[i][1];\rif(fx \u003e= 1 and fy \u003e= 1 and fx \u003c= h and fy \u003c= w and maze[fx][fy] != '#' and dist[fx][fy] \u003e dist[tx][ty] + 1){\rdist[fx][fy] = dist[tx][ty] + 1;\rif(fx == gx and fy == gy){\rgot = true;\rbreak; }\rq.push({fx, fy});\r}\r}\rif(isalpha(maze[tx][ty]) and maze[tx][ty] != 'S' and maze[tx][ty] != 'G') {\rfor(auto i : a[maze[tx][ty] - 'a']){\rauto cx = i.first ;\rauto cy = i.second;\rif(cx == tx and cy == ty) continue;\rif(dist[cx][cy] \u003e dist[tx][ty] + 1){\rdist[cx][cy] = dist[tx][ty] + 1;\rif(cx == gx and cy == gy){\rgot = true;\rbreak; }\rq.push({cx, cy});\r}\r}\r} }\rif(got) cout \u003c\u003c dist[gx][gy] \u003c\u003c endl;\rif(!got){\rputs(\"-1\");\r}\rreturn 0;\r}\r ","date":"2020-12-02","objectID":"/abc184/:5:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"F - Programming Contest ","date":"2020-12-02","objectID":"/abc184/:6:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 给n（n=40）个数，选择其中0个或几个使得和不大于t，求最大可能的和 ","date":"2020-12-02","objectID":"/abc184/:6:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 经典问题 由于n=40，枚举超时，考虑折半枚举，集合大小为2^20，然后对于一个集合中的每个数，二分查找另一个集合满足条件的最大值 以下代码手写二分，也可以用内置函数，主要是想练一下手写二分 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a[45];\rvector\u003cll\u003e vt1;\rvector\u003cll\u003e vt2;\rvector\u003cll\u003e foo1;\rvector\u003cll\u003e foo2;\rll n;\rll t;\rbool check(ll x, ll tp){\rreturn foo2[x] + tp \u003c= t;\r}\rint main(){\rcin \u003e\u003e n \u003e\u003e t;\rfor(ll i = 1; i \u003c= n; ++i){\rcin \u003e\u003e a[i];\r}\rfor(ll i = 1; i \u003c= n / 2; ++i){\rvt1.push_back(a[i]);\r}\rfor(ll i = n / 2 + 1; i \u003c= n; ++i){\rvt2.push_back(a[i]);\r}\rll len1 = n / 2;\rll len2 = n - n / 2;\rfor(ll i = 0; i \u003c (1 \u003c\u003c len1); ++i){\rll tmp = 0;\rfor(ll j = 0; j \u003c len1; ++j){\rif(i \u003e\u003e j \u0026 1){\rtmp += vt1[j];\r}\r}\rfoo1.push_back(tmp);\r}\rfor(ll i = 0; i \u003c (1 \u003c\u003c len2); ++i){\rll tmp = 0;\rfor(ll j = 0; j \u003c len2; ++j){\rif(i \u003e\u003e j \u0026 1){\rtmp += vt2[j];\r}\r}\rfoo2.push_back(tmp);\r}\rfoo1.push_back(0);\rfoo2.push_back(0);\rsort(foo1.begin(), foo1.end());\rsort(foo2.begin(), foo2.end());\rvector\u003cll\u003e::iterator it;\rit = unique(foo1.begin(), foo1.end());\rfoo1.erase(it, foo1.end());\rit = unique(foo2.begin(), foo2.end());\rfoo2.erase(it, foo2.end());\r//for(ll i : foo2) cout \u003c\u003c i \u003c\u003c \" \";\r\rlen1 = foo1.size();\rlen2 = foo2.size();\rll mx = -1;\rfor(ll i = 0; i \u003c len1; ++i){\rll tmp = foo1[i];\rll l = 0, r = len2 - 1;\rwhile(l \u003c= r){\rll mid = (l + r) \u003e\u003e 1;\rif(check(mid, tmp)){\rmx = max(mx, tmp + foo2[mid]);\rl = mid + 1;\r}else r = mid - 1;\r}\r}\rcout \u003c\u003c mx \u003c\u003c endl;\r//cout \u003c\u003c qq1 \u003c\u003c \" \" \u003c\u003c qq2 \u003c\u003c endl;\r //cout \u003c\u003c foo2[6];\r return 0;\r}\r ","date":"2020-12-02","objectID":"/abc184/:6:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["note","courses"],"content":"8086指令系统","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"8086寄存器 mem 存储器操作数 acc 累加器操作数 dest 目标操作数 src 源操作数 disp 8位或16位偏移量，可用符号地址表示 DATA 8位或16位数据 port 输入输出端口 ( ) 表示寄存器的内容 [ ] 表示存储器的内容或偏移地址 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:0:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"数据传送 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"传送数据 MOV move 指令格式：MOV dst, src; 操作：dest src WORD PTR 字长度标记 BYTE PTR 字节长度标记 DWORD PTR 双字长度标记 （伪指令） IP不能作目的寄存器； 不允许 mem2 ← mem1（存储器）； 不允许 segreg ← segreg（段寄存器）； 立即数不允许作为目的操作数； 源操作数与目的操作数类型要一致。 MOV AL, BL;\rMOV [DI], AX;\rMOV CX, [1000H]; MOV BL, 40\rMOV WORD PTR[SI], 01H;\r 几种不允许传送的解决办法： 用寄存器如AX作桥梁。 存储器←存储器： MOV AX，MEM1 MOV MEM2，AX\r 段寄存器←段寄存器： MOV AX，DS MOV ES，AX\r 段寄存器←立即数： MOV AX，DATA MOV DS，AX\r PUSH/POP 由SS指示堆栈段的段基址； 堆栈指针SP始终指向堆栈的顶部； SP的初值规定了所用堆栈区的大小； 堆栈的最高地址叫栈底。 PUSH src ; src为16位操作数 PUSH reg ； PUSH mem/reg PUSH segreg 例如： PUSH AX； PUSH [BX]； PUSH DS ；\r PUSH AX ；将AX内容压栈 执行操作： [(SP)-1]←高字节(AH) [(SP)-2]←低字节(AL) (SP) ← (SP) - 2 POP dest 例： POP BX ；\r 将栈顶内容弹至BX 执行操作： (BL) ←[SP] (BH) ← [(SP)+ 1] (SP) ← (SP) + 2 XCHG exchange 格式：XCHG reg，mem/reg 功能：交换两操作数的内容。 要求：两操作数中必须至少有一个在寄存器中； 操作数不能为段寄存器和立即数； 源和目地操作数类型要一致。 举例： XCHG AX，BX\rXCHG [2000]，CL\r XLAT translate 执行的操作：AL←[(BX)+(AL)] 又叫查表转换指令，它可根据表项序号查出表中对应代码的内容。执行时先将表的首地址（偏移地址）送到BX中，表项序号存于AL中。 XLAT是一条隐含寻址的指令。使用前要给隐含操作数赋初值。 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:1","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"传送地址 LEA load effective address 用途：用于传送操作数的偏移地址 传送偏移地址：LEA reg，mem ； 将指定内存单元的偏移地址送到指定寄存器 要求： 源操作数必须是一个存储器操作数； 目的操作数必须是一个16位的通用寄存器。 例： LEA BX，[SI+10H]\r 设：（SI）=1000H 则执行该指令后，（BX）=1010H 注意以下指令差别： LEA BX，[2000H] ;将存储单元的偏移地址取到 BX\rMOV BX， [2000H] ;将存储单元中的内容取到 BX\r LDS LES ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:2","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"输入输出 只限于用累加器AL或AX来传送信息。 功能: (累加器)←→I/O端口 IN 格式: IN acc, port ；port端口号0～255H IN acc, DX；DX表示的端口范围达64K 例: IN AL，80H ；(AL）←(80H端口)\rIN AL，DX ；(AL）←((DX))\rIN AX，DX ； (AL）←((DX))，(AH）←((DX+1)) OUT 格式：OUT port, acc OUT DX, acc 例： OUT 68H，AX ；(68H）←（AL）\r；(69H）←（AH）\rOUT DX，AL ；((DX))←(AL)\r 在使用间接寻址的IN/OUT指令时，要事先用传送指令把I/O端口号设置到DX寄存器，如： MOV DX，220H\rIN AL，DX ;将220H端口内容读入AL\r ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:3","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"例子 例2.5 内存中自TABLE开始的16个单元连续存放着自然数0到15的平方值(构成一个平方表)，任给一整数M在XX单元中(该数为0≤M≤15)，查表求M的平方值，并将结果存入YY单元中。 解: LEA BX，TABLE\rMOV AL，XX XLAT MOV YY，AL\r ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:4","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"算术运算 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"加法 ADD 不带进位的加法指令ADD 格式： ADD acc, data ADD mem/reg, data ADD mem/reg1, mem/reg2 实例： ADD AL，30H ADD SI，[BX+20H]\rADD CX，SI\rADD [DI]，200H\r ADD指令对6个状态标志均产生影响。 例：已知(BX)=E75FH，指令 ADD BX, 8046H 执行后，状态标志各是多少？ E75FH = 1 1 1 0 0 1 1 1 0 1 0 1 1 1 1 1 8046H = 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 0 1 1 0 0 1 1 1 1 0 1 0 0 1 0 1 结果：CF=1, ZF=0, PF=1, AF=1, OF=1, SF=0 PF：低8位中1的个数是否为偶数！ ADC add with carry 带进位位的加法指令ADC ADC指令在形式上和功能上与ADD类似，只是相加时还要包括进位标志CF的内容，例如： ADC AL，68H ;AL←(AL)+68H+(CF) ADC AX，CX ;AX←(AX)+(CX)+(CF)\r ADC BX，[DI] ; BX←(BX)+[DI+1][DI]+(CF)\r ADC指令用于多字节加法运算中 ADD/ADC对条件标志位的影响： SF = 1 结果为负，否则为0 ZF = 1结果为0 CF = 1 和的最高有效位有向高位的进位 OF = 1 两个操作数符号相同，而结果符号与之相反 CF位表示无符号数相加的溢出。 OF位表示带符号数相加的溢出。 INC increase 1 加1指令INC（单操作数指令） 格式：INC reg/mem 功能：类似于C语言中的++操作：对指定的操作数加1。 例： INC AL\rINC SI INC BYTE PTR[BX+4]\r 注：本指令不影响CF标志。 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:1","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"减法 SUB substract 不带借位的减法指令SUB 格式： SUB dest, src 操作： dest←(dest)-(src) 注：1.源和目的操作数不能同时为存储器操作数 2.立即数不能作为目的操作数 例： SUB AL，60H\rSUB [BX+20H]，DX\rSUB AX，CX\r SBB substract with borrow 带借位的减法指令SBB SBB指令主要用于多字节的减法。 格式： SBB dest, src 操作： dest←(dest)-(src)-(CF) 例： SBB AX，CX\rSBB WORD PTR[SI]，2080H\rSBB [SI],DX\r DEC decrease 1 作用类似于C语言中的”－－”操作符。 格式：DEC opr 操作：opr←(opr)-1 例： DEC CL\rDEC BYTE PTR[DI+2]\rDEC SI NEG negative 求补(负)指令NEG 格式： NEG opr ;补码表示的带符号数 操作： opr← 0-(opr) 对一个操作数取补码相当于用0减去此操作数，故利用NEG指令可得到负数的绝对值。 例：若(AL)=0FCH（ -4的补码）， 则执行 NEG AL， (AL)=04H，CF=1。 即得到4(-4的绝对值)。 CMP compare 比较指令CMP 格式： CMP dest, src 操作： (dest)-(src) CMP也是执行两个操作数相减，但结果不送目标操作数，其结果只反映在标志位上。 例： CMP AL，0AH\rCMP CX，SI\rCMP DI，[BX+03]\r 根据标志位来判断比较的结果 根据ZF判断两个数是否相等。若ZF=1，则两数相等。 若两个数不相等,则分两种情况考虑: ①比较的是两个无符号数 若CF=0，则dest＞src; 若CF=1，则dest＜src。 ②比较的是两个有符号数 若OF⊕SF=0，则dest＞src; 若OF⊕SF=1，则dest＜src。 比较指令在使用时，一般在其后紧跟一条条件转移指令，判断比较结果的转向。 举例：比较AL、BL、CL中带符号数的大小，将 最小数放在AL中。 程序： CMP AL,BL ；AL和BL比较\rJNG BBB ；若AL≤BL,则转\rXCHG AL,BL ；若AL＞BL,则交换\rBBB: CMP AL,CL ；AL和CL比较\rJNG CCC ；若AL≤CL,则转\rXCHG AL,CL ；若AL＞CL,则交换\rCCC: HLT\r ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:2","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"乘除法 进行乘法时： 8位× 8位→16位乘积 16位× 16位→32位乘积 进行除法时： 16位/8位→8位商 32位/16位→16位商 对被除数、商及余数存放有如下规定： 被除数 商 余数 字节除法 AX AL AH 字除法 DX:AX AX DX MUL multiplication 无符号数的乘法指令MUL(mem/reg) 格式： MUL src；src的长度确定乘法类型 操作：字节操作数 (AX) ← (AL) × (src) 字操作数 (DX, AX) ← (AX) × (src) 指令例子： MUL BL ；(AL)×(BL),乘积在AX中\rMUL CX ；(AX)×(CX),乘积在DX,AX中\rMUL BYTE PTR[BX]\r 乘法指令对CF/OF的影响： CF/OF = 0/0 乘积的高一半为零，否则1/1 高一半为有效数字 例：(AL) = A5H，(BL) = 11H (1) MUL BL ; (AX) ← (AL)×(BL) ; A5×11= 0AF5 ; (AX) = 0AF5H CF=OF=1 IMUL integer multiplication DIV 无符号数除法指令DIV 格式： DIV src； src的长度确定除法类型 操作：字节操作 (AL) ← (AX) / (SRC) 的商 (AH) ← (AX) / (SRC) 的余数 字操作 (AX) ← (DX, AX) / (SRC) 的商 (DX) ← (DX, AX) / (SRC) 的余数 指令例子： DIV CL\rDIV WORD PTR[BX]\r 注：若除数为零或AL中商大于FFH,(或AX中商大于FFFFH)，则CPU产生一个类型0的内部中断。 IDIV ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:3","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"例子 例 下列程序段完成S=(a×b+c)/a的运算，其中变量a、b、c和S均为带符号的字数据,结果的商存入S，余数则不计，填空完成下列程序。 MOV AX，a ;取得被乘数a\r IMUL b ;a×b在DX:AX中\r MOV CX，DX\rMOV BX，AX\rMOV AX，c\rCWD ;c扩展为双字节，在DX:AX中\r ADD AX，BX ;a×b+c在DX:AX中\r ADC DX，CX ；高位相加\rIDIV a ;(a×b+c)/a,商存入S\r MOV S，AX\r ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:4","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"逻辑 逻辑运算指令 运算规则：按位操作，无进/借位 对标志位的影响(除NOT指令外)： CF OF SF ZF PF AF 0 0 * * * 无定义 * 根据运算结果设置 AND 逻辑”与” AND 对两个操作数进行按位逻辑“与”操作。 格式：AND dest, src 用途：保留操作数的某几位，清零其他位。 例1： 保留AL中低4位，高4位清0。 AND AL, 0FH\r 例2：测试AL的bit7, bit5, bit2是否都是1。 AND AL, 10100100B\rCMP AL, 10100100B\rJZ YES\r… … ；不全为1时的处理\rYES: OR 逻辑”或” OR 对两个操作数进行按位逻辑”或”操作。 格式：OR dest, src 用途：对操作数的某几位置1； 对两操作数进行组合。 例：把AL的第5位置为1 OR AL, 00100000B\r NOT 逻辑“非”(取反) NOT 对操作数进行按位逻辑”非”操作。 格式：NOT mem/reg 例： NOT CX\rNOT BYTE PTR[DI]\r XOR 逻辑”异或” XOR 对两个操作数按位进行”异或”操作。 格式：XOR dest, src 用途：对reg清零(自身异或) 把reg/mem的某几位变反(与’1’异或) 例1：把AX寄存器清零。 XOR AX, AX MOV AX, 0\rAND AX, 0\rSUB AX, AX 例2：把DH的bit4,3变反 XOR DH,18H\r TEST 测试指令TEST 操作与AND指令类似,但不将”与”的结果送回,只影响标志位。 TEST指令常用于位测试,与条件转移指令一起用。 例：测试AL的内容是否为负数。 TEST AL, 80H ；检查AL中D7=1？ JNZ MINUS ；是1(负数)，转MINUS … … ；否则为正数\rMINUS: …\r 例子 例 已知寄存器DX：AX的内容为32位带符号数，编写一段程序使DX：AX的内容成为原来数据的绝对值。 解: TEST DX，8000H ;测试符号位，产生状态\r JZ EXIT ;符号位=0，结束\r NEG DX ;求绝对值\r NEG AX\rSBB DX，0\rEXIT:HLT\r ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:3:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"移位 SHL/SHR/SAR 非循环移位指令 算术左移指令 SAL(Shift Arithmetic Left) 算术右移指令 SAR(Shift Arithmetic Right) 逻辑左移指令 SHL(Shift Left) 逻辑右移指令 SHR(Shift Right) 这4条指令的格式相同,以SAL为例： SAL mem/reg, CL（移位位数大于1） 1（移位位数等于1） 算术移位——把操作数看做有符号数； 逻辑移位——把操作数看做无符号数。 移位位数放在CL寄存器中，如果只移1位,也 可以直接写在指令中。例如： MOV CL, 4 SHR AL, CL ；AL中的内容右移4位 影响C, P, S, Z, O标志。 结果未溢出时： 左移1位≡操作数×2 右移1位≡操作数 / 2 ROL/ROR/RCL/RCR rotate left rotate left with carry 循环移位指令 不含进位位的循环左移指令 ROL 不含进位位的循环右移指令 ROR 含进位位的循环左移指令 RCL 含进位位的循环右移指令 RCR 格式同非循环移位指令。 移位位数放在CL寄存器中，如果只移1位, 也可以直接写在指令中。 循环移位指令只影响标志位CF和OF。 例1：将AL的高4位与低4位互换。 MOV CL, 4\rROL AL, CL\r ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:4:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"串操作 串：顺序放在内存中的一组相同类型的数据。 串操作：对串中的元素进行相同的操作。 串操作的寻址方式： 源操作数指针———DS:SI(DS可超越) 目的操作数指针——ES:DI 每次串操作后： 串操作指令自动修改SI和DI——字节:±1，字:±2。DF标志决定±。注意：退出串操作后，指针指向最后操作的元素的下一个元素。 可完成存储单元到存储单元的传送、比较（也仅是串指令可以） 有的串操作指令前面可加重复前缀。当使用重复前缀时，操作重复次数由CX决定(CX自动减量)。该指令重复执行,直至(CX)=0为止。 执行串指令之前，应先进行如下设置： 源串首地址（末地址）→ SI 目的串首地址（末地址）→ DI 串长度 → CX 建立方向标志（CLD使DF=0(增)，STD使DF=1 (减) ） 重复前缀 REP ；无条件重复 REPE/REPZ ；当相等/为零时重复 REPNE/REPNZ ；当不相等/不为零时重复 MOVS move string 串传送指令MOVSB / MOVSW 指令执行的操作为： MOVSB ； ((ES):(DI))←((DS):(SI)) SI±1, DI±1 MOVSW ； ((ES):(DI+1)(DI))←((DS):(SI+1)(SI)) SI±2, DI±2 注意： src用DS:SI寻址, dest用ES:DI寻址 例 编写将数据段中自AREA1开始的100个字数据搬到附加段中以AREA2开始的数据区中的程序段。 解： ① 用基本串传送指令 LEA SI，AREA1\rLEA DI，AREA2\rMOV CX，100\rCLD\rDONE: MOVSW\rLOOP DONE 用重复串传送指令 LEA SI， AREA1\rLEA DI， AREA2\rMOV CX， 100\rCLD\rREP MOVSW\r STOS store string 串存储指令STOSB / STOSW 写指令的操作为： 对字节：((ES):(DI))←(AL) DI±1 对字：((ES):(DI+1)(DI))←(AX) DI±2 本指令用于把一块存储区域填充成某一 初始值(即对存储区进行初始化)。 LODS load string 串读取指令LODSB / LODSW 执行的操作为： 对字节：(AL)←((DS):(SI)) SI±1 对字：(AX)←((DS):(SI+1)(SI)) SI±2 串读取指令通常不加重复前缀。 LODSB等价于: MOV AL,[SI］ INC SI\r LODSW等价于: MOV AX,[SI] INC SI\rINC SI CMPS compare string 串比较指令CMPSB / CMPSW 指令执行的操作为： CMPSB ；((DS):(SI))-((ES):(DI)) SI±1, DI±1 CMPSW ；((DS):(SI+1)(SI))-((ES):(DI+1)(DI)) SI±2, DI±2 比较的结果只反映在标志位上，串本身无变化。 本指令可用来检查两个串是否相等。 与重复前缀REPZ/REPE、REPNZ/REPNE结合使用。 SCAS scan string 串扫描SCASB / SCASW 执行的操作： 对字节：(AL)－((ES):(DI)) DI±1 对字： (AX)－((ES):(DI＋1)(DI)) DI±2 搜索指令执行的仍是比较(减法)操作,结果只影响标志位。 要搜索的关键字放在AL(字节)或AX(字)中。 本指令用于在串中查找指定的信息。 与重复前缀REPZ/REPE、REPNZ/REPNE结合使用。 SCAS指令加上重复前缀后,可对串进行连续扫描比较： 若前缀为REPZ，则表示比较结果相等(ZF=1)且串未结束(CX≠0)，则继续比较。 若前缀为REPNZ，则表示比较结果不相等(ZF=0)且串未结束(CX≠0)，就继续比较。 REP ；无条件重复 REPE/REPZ ；当相等/为零时重复 REPNE/REPNZ ；当不相等/不为零时重复 CMPS、SCAS与REPE/REPZ的使用： 满足下列两个条件时，重复扫描和比较： （1）CX≠0；重复次数还未完成； （2）ZF=1；目的操作数等于源操作数或扫描值。 CMPS、SCAS与REPNE/REPNZ的使用： 满足下列两个条件时，重复扫描和比较： （1）CX≠0；表示重复次数还未完成； （2）ZF=0；目的操作数不等于源操作数或扫描值。 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:5:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"控制操作 控制类指令包括程序转移指令和处理机控制指令 程序控制转移指令 转移指令（JMP, JNZ） 调用和返回指令（Call/RET） 循环控制指令(LOOP) 中断指令 这类指令的共同特点是可改变程序的正常执行顺序,使之转移。而改变程序的执行顺序,本质上就是要改变CS:(E)IP的内容这类指令对标志位无影响。 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"转移指令 转移指令的实质：改变IP(或CS)的内容。 所有转移指令不会影响标志位。 分为无条件转移和条件转移两种。 JMP jump 无条件转移指令 – JMP 本指令无条件转移到指定的目标地址,以执行从该地址开始的程序段。 ① 段内直接转移（相对转移） 转移的目标地址由指令直接给出。指令中直接给出的目标地址实际上是一个相对于IP的位移量。 位移量 转移范围 汇编语言中格式 8位 -128～+127 JMP SHORT OPRD 16位 -32768～+32767 JMP NEAR PTR OPRD 例： JMP 0120H ；直接转向0120H JMP SHORT LPI ；转向LPI JMP NEAR PTR BBB ；转向BBB\r 由于是段内转移,故转移后CS内容保持不变。 ②段内间接转移 转移的目标地址(偏移量)由寄存器或存储单元的内容给出。 例1： JMP SI\r 若指令执行前(SI)=1200H，则指令执行后，(IP)=1200H,于是转向代码段的偏移地址1200H处执行。 注意：目标地址以段内偏移的形式给出，而不是相对于IP的位移量，所以它是一个16位的操作数。 例2： JMP [BX+DI]\r 设指令执行前: (DS)=3000H, (BX)=1300H, (DI)=1200H, (32500H)=2350H； 则指令执行后:(IP)=2350H 在汇编语言中,段内间接寻址通常写成： JMP WORD PTR[BX+DI]\r 表示所取得的目标地址是一个字。 ③段间直接转移 在指令中直接给出要转移到的目的段地址和偏移地址。 例： JMP 2000:1000H\r 执行时,(IP)←1000H,(CS)←2000H 注：直接地址为符号地址时，段间直接转移指令中的符号地址前应加操作符FAR PTR。 例： JMP FAR PTR far_label 其中的far_label为远类型的标号。 ④段间间接转移 转移的目的地址(段和偏移)在两个相邻的字存储单元中。 例如： JMP DWORD PTR [SI]\r 设指令执行前:(DS)=4000H，(SI)=1212H, (41212H)=1000H，(41214H)=4A00H 则指令执行后:(IP)=1000H，(CS)=4A00H，于是转到4B000H处开始执行指令。 例中的DWORD PTR表示转移地址是一个双字。 判断无符号数的大小 JXX 条件转移指令 - JXX 条件转移指令可实现程序的条件分支。 条件转移指令根据标志位的状态来决定是否进行分支转移。 格式： JXX label ；xx为条件名称缩写 条件转移指令只能是段内直接转移，且指令的转移范围为指令所在位置的-128～+127字节。 判断无符号数的大小 JA/JNBE ；高于/不低于且不等于，则转移(A＞B) 条件为: CF=0∧ZF=0 JAE/JNB ；高于或等于/不低于，则转移(A≥B) 条件为: CF=0∨ZF=1 JB/JNAE ；低于/不高于且不等于，则转移(A\u003cB) 条件为: CF=1∧ZF=0 JBE/JNA ； 低于或等于/不高于，则转移(AB) 条件为: CF=1∨ZF=1 Not, Above, Bellow, Equal 判断有符号数的大小 JG/JNLE ；大于/不小于且不等于，则转移(A＞B) 条件为: (SF⊕OF=0)∧ZF=0 JGE/JNL ；大于或等于/不小于，则转移(A≥B) 条件为: (SF⊕OF=0)∨ZF=1 JL/JNGE ；小于/不大于且不等于，则转移(A＜B) 条件为: (SF⊕OF=1)∧ZF=0 JLE/JNG ；小于或等于/不大于，则转移(A≤B) 条件为: (SF⊕OF=1)∨ZF=1 Not, larGe , Little, Equal 根据单个标志位设置的条件转移指令 JC ；CF=1,则转移 JNC ；CF=0,则转移 JE/JZ ；结果为零(ZF=1),则转移 JNZ/JNE ；结果不为零(ZF=0),则转移 JP/JPE ；奇偶标志PF=1(偶),则转移 JNP/JPO ；奇偶标志PF=0(奇),则转移 JS ；SF=1,则转移 JNS ；SF=0,则转移 JO ；OF=1,则转移 JNO ；OF=0,则转移 根据CX内容来决定是否转移的转移指令 JCXZ label 若(CX)=0, 则转移到label处开始执行。 例子 例：在8000H开始的长度为1000字节的字符串中查找’S’，若找到，把其偏移地址记录在ADDR中，否则ADDR单元置为0FFFFH。 MOV DI, 8000H\rMOV CX, 1000\rMOV AL, ’S’\rMOV ADDR, 0FFFFH GOON: SCASB\rLOOPNZ GOON ; (CX)≠0∧ZF=0时，循环。\r JNZ DONE ；ZF=0，转移。\rDEC DI ；找到\rMOV ADDR, DI\rDONE: HLT\r ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:1","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"循环控制指令 用在循环程序中以确定是否要继续循环。 循环次数通常置于CX中。 转移的目标应在距离本指令-128～+127的范围之内。 循环控制指令不影响标志位。 LOOP (1)LOOP 格式：LOOP label 操作：(CX)-1→CX； 若(CX)≠0,则转至label处执行； 否则退出循环,执行LOOP后面的指令。 LOOP指令与下面的指令段等价： DEC CX\rJNZ label\r (2) LOOPZ (LOOPE) 格式：LOOPZ label 操作：(CX)-1→CX； 若(CX)≠0∧ZF=1,则转至label处继续循环； 否则退出循环,执行LOOP后面的指令。 (3) LOOPNZ (LOOPNE) 格式：LOOPNZ label 操作：(CX)-1→CX； 若(CX)≠0∧ZF=0,则转至label处继续循环； 否则退出循环,执行LOOP后面的指令。 例子 例1：给1A000H开始的256个内存单元均减去1，若发现某个单元减为0则立即退出循环，其后的单元不再减1。 MOV AX, 1A00H\rMOV DS, AX ；段基址\rMOV DI, 0 ；偏移量\rMOV CX, 256 ；循环次数\rGOON: DEC BYTE PTR[DI] ；减1\rINC DI ；移动指针\rCMP BYTE PTR[DI-1],0\rLOOPNZ GOON\rHLT ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:2","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"过程调用和返回指令 过程(子程序) 一段具有特定功能的，供其它程序调用的公用程序。 特点 调用子程序时，IP(CS)的内容被压入堆栈栈顶。从子程序返回时，栈顶的内容又被弹出到IP(CS)。 子程序执行结束后一般均要返回调用程序。 一次定义，可多次调用； 可带参数调用，以完成不同的功能。 优点 程序代码短, 结构清晰, 便于编程、调试、修改和阅读。 两条相关指令： 子程序调用指令 CALL 子程序返回指令 RET CALL 调用指令CALL 一般格式：CALL sub ;sub为子程序的入口。 根据子程序入口的寻址方式，子程序调用有四类。 ① 段内直接调用 子程序的偏移地址直接由CALL指令给出。 格式：CALL near_proc CALL执行时，它首先将IP内容压栈，然后把指令中给出的位移量加到IP上。 注：经汇编后的调用地址是相对于CALL的下一条指令的位移量。 例： CALL 0120H ;子程序偏移地址由指令给出\r 程序可能浮动，所以只记相对位移量。 RET return 返回指令RET 段内返回指令RET的操作为： IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2 段间返回指令RET的操作为： IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2 CS←((SP)+1,(SP)) ;栈顶内容弹出到CS SP←(SP)+2 另有一种带立即数返回指令：RET n 其中n为偶数，表示从栈顶弹出地址后另外丢弃的字节数。 例： RET 4 ;返回后再丢弃栈顶的4个字节\r ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:3","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"中断指令 8086/8088 CPU在程序中允许安排一条中断指令来引起一个中断过程,这种中断叫内部中断,或叫软中断。 中断指令共有三条： (1) INT n 执行类型n的中断服务程序，N=0～255 (2) INTO 执行溢出中断的中断服务程序； (3) IRET 从中断服务程序返回调用程序。 INT interrupt 1、INT n ;n=0～255,为中断类型号 本指令的操作步骤为： ①((SP)-1,(SP)-2)←(FLAGS)，SP←(SP)-2 保护标志寄存器的内容 ②IF←0,TF←0 中断服务程序中禁止外部INTR中断和单步中断 ③((SP)-1,(SP)-2)←(CS)，SP←(SP)-2，CS←(n4+2) 中断服务程序的段地址送入CS。n4为向量地址。该向量地址中的内容即为中断服务程序入口地址。 ④((SP)-1,(SP)-2)←(IP)，SP←(SP)-2，IP←(n*4) 中断服务程序的偏移地址送IP。 INT指令只影响IF和TF, 对其余标志位无影响。 INT指令可用于调用系统服务程序，如INT 21H。 INFO interrupt overflow 溢出中断INTO INTO检查溢出标志OF, 如果OF=1, 则启动一个类型4的中断过程；如果OF=0,不做任何操作。 通常INTO指令安排在有符号数算术运算指令后面。如： IMUL DX INTO ;若溢出，则启动INT 4,否则继续 MOV RESULT, AX MOV RESULT+2, DX ……\r IRET interrupt return 中断返回指令IRET 用于从中断服务程序返回到被中断的程序。任何中断服务程序不管是外部中断引起的, 还是内部中断引起的, 最后都要用IRET返回。 该指令执行的操作为 IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2 CS←((SP)+1,(SP)) ;栈顶内容弹出到CS SP←(SP)+2 FLAGS←((SP)+1,(SP)) ;栈顶内容弹出到FLAG SP←(SP)+2 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:4","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"标志位操作指令 1.标志操作指令：用来设置标志位的状态。 （1）CF设置指令 CLC 0→CF STC 1→CF CMC CF变反 （2）DF设置指令 CLD 0→DF (串操作的指针移动方向从低到高) STD 1→DF (串操作的指针移动方向从高到低) （3）IF设置指令 CLI 0→IF (禁止INTR中断) STI 1→IF (开放INTR中断) ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:5","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","slam"],"content":"李群与李代数","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"群 与视觉slam有关的群 三维旋转矩阵构成了特殊正交群(special orthogonal group) $$S O(3)=\\left\\{R \\in \\mathbb{R}^{3 \\times 3} \\mid R R^{T}=I, \\operatorname{det}(R)=1\\right\\}$$ 三维变换矩阵构成了特殊欧氏群（special euclidean group） $$SE(3)=\\left\\{T=\\left[\\begin{array}{cc}R \u0026 t \\\\0^{T} \u0026 1\\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4} \\mid R \\in SO(3), t \\in \\mathbb{R}^{3}\\right\\} $$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:1:0","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"群的定义 群（group）是一种集合加上一种运算的代数结构 记集合为A，运算为·，那么当运算满足以下性质时，称（A，·）成群 $$ \\begin{array}{ll}\\text { 1. 封闭性: } \\quad \\forall a_{1}, a_{2} \\in A, \\quad a_{1} \\cdot a_{2} \\in A \\text { . }\\end{array} \\\\ \\text { 2. 结合律: } \\quad \\forall a_{1}, a_{2}, a_{3} \\in A, \\quad\\left(a_{1} \\cdot a_{2}\\right) \\cdot a_{3}=a_{1} \\cdot\\left(a_{2} \\cdot a_{3}\\right) \\text { . } \\\\ \\begin{array}{llll}\\text { 3. 幺元: } \u0026 \\exists a_{0} \\in A, \u0026 \\text { s.t. } \\quad \\forall a \\in A, \u0026 a_{0} \\cdot a=a \\cdot a_{0}=a \\text { . }\\end{array} \\\\ \\begin{array}{llll}\\text { 4. 逆: } \u0026 \\forall a \\in A, \u0026 \\exists a^{-1} \\in A, \u0026 \\text { s.t. } \u0026 a \\cdot a^{-1}=a_{0} \\text { . }\\end{array} $$ 如果满足交换律，就是交换群，矩阵很少有交换群 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:1:1","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李群与李代数 李群与李代数在wiki上的定义 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:0","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李群的定义 李群是指具有光滑（连续）性质的群，SO(3)和SE(3)表示的空间的旋转和变换，它一定是连续的，所以是李群。 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:1","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数的引出 对于任意旋转矩阵 $R$ $$\\boldsymbol{R} \\boldsymbol{R}^{T}=\\boldsymbol{I}$$ 它是对时间的函数 $$\\boldsymbol{R}(t) \\boldsymbol{R}(t)^{T}=\\boldsymbol{I}$$ 等式两边对时间求导 （矩阵对标量求导就是每个entry求导后转置） $$\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}+\\boldsymbol{R}(t) \\dot{\\boldsymbol{R}}(t)^{T}=0$$ $$\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}=-\\left(\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}\\right)^{T}$$ 引入向量与反对称矩阵的转换标志 $$\\boldsymbol{a}^{\\wedge}=\\boldsymbol{A}=\\left[\\begin{array}{ccc}0 \u0026 -a_{3} \u0026 a_{2} \\\\a_{3} \u0026 0 \u0026 -a_{1} \\\\-a_{2} \u0026 a_{1} \u0026 0\\end{array}\\right], \\quad \\boldsymbol{A}^{\\vee}=\\boldsymbol{a}$$ 由于 $\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}$ 是一个反对称矩阵，所以有 $$\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}=\\phi(t)^{\\wedge}$$ $$\\dot{\\boldsymbol{R}}(t)=\\phi(t)^{\\wedge} \\boldsymbol{R}(t)$$ 可以看出对 $R$ 求导就是左乘一个 $\\phi(t)^{\\wedge}$ 在原点处 $t_0 = 0$ ，假设 $R(0) = I$，在原点处泰勒展开 $$\\begin{aligned}\\boldsymbol{R}(t) \u0026 \\approx \\boldsymbol{R}\\left(t_{0}\\right)+\\dot{\\boldsymbol{R}}\\left(t_{0}\\right)\\left(t-t_{0}\\right) \\\u0026=\\boldsymbol{I}+\\boldsymbol{\\phi}\\left(t_{0}\\right)^{\\wedge}(t)\\end{aligned}$$ 可以看出 $\\phi$ 反应了 $R$ 导数的性质，故称它为 $SO(3)$ 原点附近的正切空间（tangent space），设 $\\phi(t_0) = \\phi_0$ $$\\dot{\\boldsymbol{R}}(t)=\\phi\\left(t_{0}\\right)^{\\wedge} \\boldsymbol{R}(t)=\\boldsymbol{\\phi}_{0}^{\\wedge} \\boldsymbol{R}(t)$$ 将它看成一阶线性齐次微分方程，解得 $$\\boldsymbol{R}(t)=\\exp \\left(\\boldsymbol{\\phi}_{0}^{\\wedge} t\\right)$$ 此处并不是传统意义上的 $e^{\\phi_0^{\\wedge} t}$ 该式说明对于任意 $t$ 都可以找到 $R$ 和 $\\phi$ 的对应关系，这称为指数映射（exponential map） $\\phi$ 就是 $SO(3)$ 对应的李代数 $so(3)$ 每个李群都有对应的李代数，李代数描述了李群的局部性质，准确地说，是单位元附近的正切空间 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:2","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数的定义 李代数由一个集合 $\\mathbb{V}$ ，一个数域 $\\mathbb{F}$ ，和一个二元运算 $[,]$ 组成。如果它们满足以下几条性质，称 $(\\mathbb{V}, \\mathbb{F},[,])$ 为一个李代数 $\\mathfrak{g}$ $$\\begin{array}{ll}\\text { 1. 封闭性 } \\quad \\forall \\boldsymbol{X}, \\boldsymbol{Y} \\in \\mathbb{V},[\\boldsymbol{X}, \\boldsymbol{Y}] \\in \\mathbb{V} \\text { . }\\end{array}$$ $$\\text { 2. 叉线性 } \\quad \\forall \\boldsymbol{X}, \\boldsymbol{Y}, \\boldsymbol{Z} \\in \\mathbb{V}, a, b \\in \\mathbb{F}, \\text { 有: }$$ $$[a \\boldsymbol{X}+b \\boldsymbol{Y}, \\boldsymbol{Z}]=a[\\boldsymbol{X}, \\boldsymbol{Z}]+b[\\boldsymbol{Y}, \\boldsymbol{Z}], \\quad[\\boldsymbol{Z}, a \\boldsymbol{X}+b \\boldsymbol{Y}]=a[\\boldsymbol{Z}, \\boldsymbol{X}]+b[\\boldsymbol{Z}, \\boldsymbol{Y}]$$ $$\\text { 3. 自反性 } \\quad \\forall \\boldsymbol{X} \\in \\mathbb{V},[\\boldsymbol{X}, \\boldsymbol{X}]=\\mathbf{0} \\text { . }$$ $$\\text { 4. 雅可比等价 } \\quad \\forall X, Y, Z \\in \\mathbb{V},[X,[Y, Z]]+[Z,[Y, X]]+[Y,[Z, X]]=0$$ 二元运算被称为李括号（lie bracket），表达了两个元素的差异 李代数的例子，集合是三维向量，数域是实数，二元运算是叉积 $$\\mathfrak{g} = (\\mathbb{R}^3, \\mathbb{R}, ×)$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:3","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数so(3) $$\\mathfrak{s} \\mathfrak{o}(3)=\\left\\{\\boldsymbol{\\phi} \\in \\mathbb{R}^{3}, \\boldsymbol{\\Phi}=\\boldsymbol{\\phi}^{\\wedge} \\in \\mathbb{R}^{3 \\times 3}\\right\\}$$ $$\\Phi=\\phi^{\\wedge}=\\left[\\begin{array}{ccc}0 \u0026 -\\phi_{3} \u0026 \\phi_{2} \\\\\\phi_{3} \u0026 0 \u0026 -\\phi_{1} \\\\-\\phi_{2} \u0026 \\phi_{1} \u0026 0\\end{array}\\right] \\in \\mathbb{R}^{3 \\times 3}$$ $$\\left[\\phi_{1}, \\phi_{2}\\right]=\\left(\\Phi_{1} \\Phi_{2}-\\Phi_{2} \\Phi_{1}\\right)^{\\vee}$$ 它们是一个由三维向量组成的集合，每个向量对应一个反对称矩阵，可以用于表达旋转矩阵的导数 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:4","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数se(3) $$\\mathfrak{s e}(3)=\\left\\{\\boldsymbol{\\xi}=\\left[\\begin{array}{c}\\rho \\\\\\phi\\end{array}\\right] \\in \\mathbb{R}^{6}, \\boldsymbol{\\rho} \\in \\mathbb{R}^{3}, \\boldsymbol{\\phi} \\in \\mathfrak{s} \\mathfrak{o}(3), \\boldsymbol{\\xi}^{\\wedge}=\\left[\\begin{array}{cc}\\phi^{\\wedge} \u0026 \\rho \\\\0^{T} \u0026 0\\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4}\\right\\}$$ 前三维为平移，后三维为旋转，就是so(3)中的元素，此处 ^ 不再表示反对称 可以简单地理解成se(3)就是由一个平移加上一个so(3)元素构成的向量，虽然此处并不是直接平移 $$\\boldsymbol{\\xi}^{\\wedge}=\\left[\\begin{array}{cc}\\phi^{\\wedge} \u0026 \\rho \\\\0^{T} \u0026 0\\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4}$$ $$\\left[\\xi_{1}, \\xi_{2}\\right]=\\left(\\xi_{1}^{\\wedge} \\xi_{2}^{\\wedge}-\\xi_{2}^{\\wedge} \\xi_{1}^{\\wedge}\\right)^{\\vee}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:5","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"指数映射和对数映射 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:0","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"SO(3)上的指数映射 指数映射 $$R=\\exp \\left(\\phi^{\\wedge}\\right)$$ 有泰勒展式得 $$\\exp \\left(\\phi^{\\wedge}\\right)=\\sum_{n=0}^{\\infty} \\frac{1}{n !}\\left(\\phi^{\\wedge}\\right)^{n}$$ 由于幂次太多不好计算，考虑将 $\\phi$ 分解成 $\\theta a$ ，因为 $\\phi$ 是三维向量，可以分解成方向和模长，此处 $||a|| =1$，这样又如下两条性质 $$\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}=\\boldsymbol{a} \\boldsymbol{a}^{T}-\\boldsymbol{I}$$ $$\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}=-\\boldsymbol{a}^{\\wedge}$$ 这样就可以对泰勒展式进行化简 $$ \\begin{aligned}\\exp \\left(\\phi^{\\wedge}\\right) \u0026=\\exp \\left(\\theta \\boldsymbol{a}^{\\wedge}\\right)=\\sum_{n=0}^{\\infty} \\frac{1}{n !}\\left(\\theta \\boldsymbol{a}^{\\wedge}\\right)^{n} \\\\\u0026=\\boldsymbol{I}+\\theta \\boldsymbol{a}^{\\wedge}+\\frac{1}{2 !} \\theta^{2} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\frac{1}{3 !} \\theta^{3} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\frac{1}{4 !} \\theta^{4}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{4}+\\ldots \\\\\u0026=\\boldsymbol{a} \\boldsymbol{a}^{T}-\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\theta \\boldsymbol{a}^{\\wedge}+\\frac{1}{2 !} \\theta^{2} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}-\\frac{1}{3 !} \\theta^{3} \\boldsymbol{a}^{\\wedge}-\\frac{1}{4 !} \\theta^{4}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{2}+\\ldots \\\\\u0026=\\boldsymbol{a} \\boldsymbol{a}^{T}+\\left(\\theta-\\frac{1}{3 !} \\theta^{3}+\\frac{1}{5 !} \\theta^{5}-\\ldots\\right) \\boldsymbol{a}^{\\wedge}-\\left(1-\\frac{1}{2 !} \\theta^{2}+\\frac{1}{4 !} \\theta^{4}-\\ldots\\right) \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\\\\u0026=\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\boldsymbol{I}+\\sin \\theta \\boldsymbol{a}^{\\wedge}-\\cos \\theta \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\\\\u0026=(1-\\cos \\theta) \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\boldsymbol{I}+\\sin \\theta \\boldsymbol{a}^{\\wedge} \\\\\u0026=\\cos \\theta \\boldsymbol{I}+(1-\\cos \\theta) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\sin \\theta \\boldsymbol{a}^{\\wedge}\\end{aligned} $$ 最终结果 $$\\exp \\left(\\theta \\boldsymbol{a}^{\\wedge}\\right)=\\cos \\theta \\boldsymbol{I}+(1-\\cos \\theta) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\sin \\theta \\boldsymbol{a}^{\\wedge}$$ 这与罗德里格斯公式一致，说明so(3)实际上就是由所谓的旋转向量组成的空间。这样so(3)中任意一个向量对应到了SO(3)中的旋转矩阵 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:1","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"so(3)上的对数映射 反过来可以定义对数映射，表示SO(3)到so(3) $$\\phi=\\ln (R)^{\\vee}=\\left(\\sum_{n=0}^{\\infty} \\frac{(-1)^{n}}{n+1}(R-I)^{n+1}\\right)^{\\vee}$$ 但实际不应该这样求，更简单的方法是 $$\\theta=\\arccos \\left(\\frac{\\operatorname{tr}(\\boldsymbol{R})-1}{2}\\right)$$ $$\\boldsymbol{R} \\boldsymbol{n}=\\boldsymbol{n}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:2","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"总结 指数映射是满射，不是单射，这意味着可能存在多个so(3)对应同一个SO(3)。但是，把旋转角固定在[-π,+π]之间，就是一一对应的 旋转矩阵的导数可以由旋转向量指定。总结一下就是 $R$ 对时间求导后的 $\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}$ 是个反对称矩阵，那就有个 $\\phi$ 它是个三维向量，变成旋转向量，指数映射刚好可以从罗德里格斯公式求出 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:3","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"SE(3)上的指数映射 求解过程与so(3)相似 $$\\begin{aligned}\\exp \\left(\\boldsymbol{\\xi}^{\\wedge}\\right) \u0026=\\left[\\begin{array}{ccc}\\sum_{n=0}^{\\infty} \\frac{1}{n !}\\left(\\phi^{\\wedge}\\right)^{n} \u0026 \\sum_{n=0}^{\\infty} \\frac{1}{(n+1) !}\\left(\\phi^{\\wedge}\\right)^{n} \\rho \\\\\u0026 0^{T} \u0026 1\\end{array}\\right] \\\\\u0026 \\triangleq\\left[\\begin{array}{cc}R \u0026 J \\rho \\\\0^{T} \u0026 1\\end{array}\\right]=T\\end{aligned}$$ $$\\begin{aligned}\\sum_{n=0}^{\\infty} \\frac{1}{(n+1) !}\\left(\\phi^{\\wedge}\\right)^{n} \u0026=I+\\frac{1}{2 !} \\theta \\boldsymbol{a}^{\\wedge}+\\frac{1}{3 !} \\theta^{2}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{2}+\\frac{1}{4 !} \\theta^{3}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{3}+\\frac{1}{5 !} \\theta^{4}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{4} \\ldots \\\\\u0026=\\frac{1}{\\theta}\\left(\\frac{1}{2 !} \\theta^{2}-\\frac{1}{4 !} \\theta^{4}+\\cdots\\right)\\left(\\boldsymbol{a}^{\\wedge}\\right)+\\frac{1}{\\theta}\\left(\\frac{1}{3 !} \\theta^{3}-\\frac{1}{5} \\theta^{5}+\\cdots\\right)\\left(\\boldsymbol{a}^{\\wedge}\\right)^{2}+\\boldsymbol{I} \\\\\u0026=\\frac{1}{\\theta}(1-\\cos \\theta)\\left(\\boldsymbol{a}^{\\wedge}\\right)+\\frac{\\theta-\\sin \\theta}{\\theta}\\left(\\boldsymbol{a} \\boldsymbol{a}^{\\mathrm{T}}-\\boldsymbol{I}\\right)+\\boldsymbol{I} \\\\\u0026=\\frac{\\sin \\theta}{\\theta} \\boldsymbol{I}+\\left(1-\\frac{\\sin \\theta}{\\theta}\\right) \\boldsymbol{a} \\boldsymbol{a}^{\\mathrm{T}}+\\frac{1-\\cos \\theta}{\\theta} \\boldsymbol{a}^{\\wedge} \\stackrel{\\text { def }}{=} \\boldsymbol{J}\\end{aligned}$$ $$\\boldsymbol{J}=\\frac{\\sin \\theta}{\\theta} \\boldsymbol{I}+\\left(1-\\frac{\\sin \\theta}{\\theta}\\right) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\frac{1-\\cos \\theta}{\\theta} \\boldsymbol{a}^{\\wedge}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:4","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"se(3)上的对数映射 由以下两条可以求出 $\\phi$ $$\\theta=\\arccos \\left(\\frac{\\operatorname{tr}(\\boldsymbol{R})-1}{2}\\right)$$ $$\\boldsymbol{R} \\boldsymbol{n}=\\boldsymbol{n}$$ 由 $\\phi$ 可以求出 $J$，$\\rho$ 可以通过解线性方程求得 $$t=J \\rho$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:5","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"总结 转换关系 (image)\"\r转换关系 (image)\r ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:6","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数求导与扰动模型 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:0","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"BCH公式与近似形式 由于李群上无加法，所以很难对李群求导，有两个思路。利用李代数上加法定义李群元素的导数？利用指数映射和对数映射完成转换 要解决的基本问题：李代数上的加法是否等价于李群上的乘法？即下式是否成立？ $$\\exp \\left(\\phi_{1}^{\\wedge}\\right) \\exp \\left(\\phi_{2}^{\\wedge}\\right)=\\exp \\left(\\left(\\phi_{1}+\\phi_{2}\\right)^{\\wedge}\\right) ?$$ $$\\ln{(\\exp{(A)} \\exp{(B)})} = A + B ?$$ 答案是不成立，计算公式是BCH公式 $$\\ln (\\exp (\\boldsymbol{A}) \\exp (\\boldsymbol{B}))=\\boldsymbol{A}+\\boldsymbol{B}+\\frac{1}{2}[\\boldsymbol{A}, \\boldsymbol{B}]+\\frac{1}{12}[\\boldsymbol{A},[\\boldsymbol{A}, \\boldsymbol{B}]]-\\frac{1}{12}[\\boldsymbol{B},[\\boldsymbol{A}, \\boldsymbol{B}]]+\\cdots$$ 当其中一个为小量时，bch拥有线性近似表示（分为左乘模型和右乘模型） $$\\ln \\left(\\exp \\left(\\phi_{1}^{\\wedge}\\right) \\exp \\left(\\phi_{2}^{\\wedge}\\right)\\right)^{\\vee} \\approx\\left\\{\\begin{array}{ll}J_{l}\\left(\\phi_{2}\\right)^{-1} \\phi_{1}+\\phi_{2} \u0026 \\text { if } \\phi_{1} \\text { is small } \\\\J_{r}\\left(\\phi_{1}\\right)^{-1} \\phi_{2}+\\phi_{1} \u0026 \\text { if } \\phi_{2} \\text { is small }\\end{array}\\right.$$ $$\\boldsymbol{J}_{l}=\\boldsymbol{J}=\\frac{\\sin \\theta}{\\theta} \\boldsymbol{I}+\\left(1-\\frac{\\sin \\theta}{\\theta}\\right) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\frac{1-\\cos \\theta}{\\theta} \\boldsymbol{a}^{\\wedge}$$ $$\\boldsymbol{J}_{l}^{-1}=\\frac{\\theta}{2} \\cot \\frac{\\theta}{2} \\boldsymbol{I}+\\left(1-\\frac{\\theta}{2} \\cot \\frac{\\theta}{2}\\right) \\boldsymbol{a} \\boldsymbol{a}^{T}-\\frac{\\theta}{2} \\boldsymbol{a}^{\\wedge}$$ $$J_{r}(\\phi)=J_{l}(-\\phi)$$ 这样就解决了李群乘法和李代数加法的问题 SO(3)上的BCH近似 $$\\exp \\left(\\Delta \\phi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right)=\\exp \\left(\\left(\\phi+J_{l}^{-1}(\\phi) \\Delta \\phi\\right)^{\\wedge}\\right)$$ $$\\exp \\left((\\phi+\\Delta \\phi)^{\\wedge}\\right)=\\exp \\left(\\left(J_{l} \\Delta \\phi\\right)^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right)=\\exp \\left(\\phi^{\\wedge}\\right) \\exp \\left(\\left(J_{r} \\Delta \\phi\\right)^{\\wedge}\\right)$$ SE(3)上的BCH近似 $$\\begin{array}{l}\\exp \\left(\\Delta \\xi^{\\wedge}\\right) \\exp \\left(\\xi^{\\wedge}\\right) \\approx \\exp \\left(\\left(\\mathcal{J}_{l}^{-1} \\Delta \\xi+\\xi\\right)^{\\wedge}\\right) \\\\\\exp \\left(\\xi^{\\wedge}\\right) \\exp \\left(\\Delta \\xi^{\\wedge}\\right) \\approx \\exp \\left(\\left(\\mathcal{J}_{r}^{-1} \\Delta \\xi+\\xi\\right)^{\\wedge}\\right)\\end{array}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:1","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"问题引出 假设机器人的位姿为 $T$ ，它观测到一个世界坐标系位于 $p$ 的点，产生一个观测数据 $z$ ，假设噪声是 $w$ $$z = Tp + w$$ 误差 $$e = z - Tp$$ 假设一共有 $N$ 个这样的路标点和观测，就有 $N$ 个式子。那么对机器人进行位姿估计相当于寻找一个最优的 $T$ ，使得误差最小化 $$\\min _{\\boldsymbol{T}} J(\\boldsymbol{T})=\\sum_{i=1}^{N}\\left\\|\\boldsymbol{z}_{i}-\\boldsymbol{T} \\boldsymbol{p}_{i}\\right\\|_{2}^{2}$$ 求解类似问题都要用到导数，由于$SO(3)$ $SE(3)$上没有很好地定义加法，所以求导很麻烦 它们的李代数上定义了良好的加法，所以用李代数求导 这样就有两种思路： 对 $R$ 对应的李代数加上小量，求相对于小量的变化率（导数模型） 对 $R$ 左乘或右乘一个小量，求相对于小量的李代数的变化率（扰动模型） ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:2","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"求导模型 考虑 $SO(3)$ 上的情况，假设对一个空间点 $p$ 进行旋转，得到 $Rp$ 现在要计算旋转之后的点的坐标相对于旋转的导数，非正式地记为 $$\\frac{\\partial(\\boldsymbol{R} \\boldsymbol{p})}{\\partial \\boldsymbol{R}}$$ 由于它在李群上不好计算，所以转成李代数 设 $R$ 对应的李代数为 $\\phi$ $$ \\begin{aligned}\\frac{\\partial\\left(\\exp \\left(\\phi^{\\wedge}\\right) p\\right)}{\\partial \\phi} \u0026=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\exp \\left((\\phi+\\delta \\phi)^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\delta \\phi} \\\\\u0026=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\exp \\left(\\left(J_{l} \\delta \\phi\\right)^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\delta \\phi} \\\\\u0026 \\approx \\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\left(I+\\left(J_{l} \\delta \\phi\\right)^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\delta \\phi} \\\\\u0026=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\left(J_{l} \\delta \\phi\\right)^{\\wedge} \\exp \\left(\\phi^{\\wedge}\\right) p}{\\delta \\phi} \\\\\u0026=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{-\\left(\\exp \\left(\\phi^{\\wedge}\\right) p\\right)^{\\wedge} J_{l} \\delta \\phi}{\\delta \\phi}=-(R p)^{\\wedge} J_{l}\\end{aligned} $$ 这样就推导出旋转后的点相对于李代数的导数 $$\\frac{\\partial(\\boldsymbol{R} \\boldsymbol{p})}{\\partial \\boldsymbol{\\phi}} = -(\\boldsymbol{R} p)^{\\wedge} \\boldsymbol{J}_{l}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:3","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"扰动模型(左乘） 对 $R$ 左乘一个扰动 $\\Delta R$ ，设左扰动对应的李代数为 $\\varphi$，对 $\\varphi$ 求导 $$\\begin{aligned}\\frac{\\partial(R p)}{\\partial \\varphi} \u0026=\\lim _{\\varphi \\rightarrow 0} \\frac{\\exp \\left(\\varphi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\varphi} \\\\\u0026 \\approx \\lim _{\\varphi \\rightarrow 0} \\frac{\\left(1+\\varphi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\varphi} \\\\\u0026=\\lim _{\\varphi \\rightarrow 0} \\frac{\\varphi^{\\wedge} R p}{\\varphi}=\\lim _{\\varphi \\rightarrow 0} \\frac{-(R p)^{\\wedge} \\varphi}{\\varphi}=-(R p)^{\\wedge}\\end{aligned}$$ SE(3)上的扰动模型 $$\\frac{\\partial(T p)}{\\partial \\delta \\xi}=\\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\exp \\left(\\delta \\xi^{\\wedge}\\right) \\exp \\left(\\xi^{\\wedge}\\right) p-\\exp \\left(\\xi^{\\wedge}\\right) p}{\\delta \\xi} \\\\ \\approx \\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\left(I+\\delta \\xi^{\\wedge}\\right) \\exp \\left(\\xi^{\\wedge}\\right) p-\\exp \\left(\\xi^{\\wedge}\\right) p}{\\delta \\xi} \\\\ =\\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\delta \\boldsymbol{\\xi}^{\\wedge} \\exp \\left(\\boldsymbol{\\xi}^{\\wedge}\\right) \\boldsymbol{p}}{\\delta \\boldsymbol{\\xi}} \\\\ =\\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\left[\\begin{array}{cc}\\delta \\phi^{\\wedge} \u0026 \\delta \\rho \\\\0^{T} \u0026 0\\end{array}\\right]\\left[\\begin{array}{c}R p+t \\\\1\\end{array}\\right]}{\\delta \\xi} \\\\=\\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\left[\\begin{array}{c}\\delta \\phi^{\\wedge}(\\boldsymbol{R} p+\\boldsymbol{t})+\\delta \\boldsymbol{\\rho} \\\\0\\end{array}\\right]}{\\delta \\boldsymbol{\\xi}}=\\left[\\begin{array}{cc}\\boldsymbol{I} \u0026 -(\\boldsymbol{R} \\boldsymbol{p}+\\boldsymbol{t})^{\\wedge} \\\\\\mathbf{0}^{T} \u0026 \\mathbf{0}^{T}\\end{array}\\right] \\triangleq(\\boldsymbol{T} \\boldsymbol{p})^{\\odot}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:4","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"三维空间的刚体运动","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"内积与外积 内积 外积 定义 ^ 符号 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:1:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"欧氏变换 euclidean transform ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"单次欧氏变换 同一个向量在两个坐标系中的表示，坐标系的变换包括一次旋转和一次平移 旋转 R为旋转矩阵（rotation matrix），它是一个行列式为1的正交矩阵（又叫特殊正交矩阵）（正交矩阵即逆为自身转置的矩阵）。反之，行列式为1的正交矩阵也是一个旋转矩阵，所以可以将n维旋转矩阵的集合定义为 SO(n) 是特殊正交群 （special orthogonal group） $$ a{}‘=R^{-1}a=R^Ta $$ R的逆矩阵或转置矩阵刻画了相反的旋转 平移 $$ a{}‘=Ra+t $$ $$ a_1=R_{12}a_2+t_{12} $$ t12表示2到1的变换 注意 t12 != -t21 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:1","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"多次欧氏变换 由于这种形式在多次变换之后会显得很冗长，所以采取以下措施 其中T是变换矩阵（transform matrix），a转变成齐次坐标 这样多次转换就变成 （约定之后的Ta，a就是齐次坐标化的，而Ra，a就是原来的） 对于变换矩阵T，满足该形式的矩阵可以构成特殊欧氏群（special euclidean group） T的逆表示相反的变换 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:2","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"旋转向量 由于旋转矩阵用16个量来表达6个自由度的变换显得很多余，为了减少变量，引入旋转向量 实际上，任意的旋转都可以有旋转轴和旋转角度来刻画 假设旋转轴为一个单位长度的向量n，旋转角度为θ 根据罗德里格斯公式（rodrigues’s formula） 对等式两边求迹（trace）得到角度的表示 由于旋转轴上的向量在旋转后不发生变化，所以 n是R在特征值为1时的特征向量 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:3:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"欧拉角 由于旋转向量和旋转矩阵不够直观，所以引入欧拉角 欧拉角把旋转分解成绕三个轴各自的旋转，由于分解方式很多，这里介绍最著名的rpy角 yaw-pitch-roll 绕物体的z轴旋转，得到yaw 绕旋转之后的y轴旋转，得到pitch 绕旋转之后的x轴旋转，得到roll 欧拉角的重大缺点就是万向锁问题（gimbal lock），当某个轴旋转90度时，第一次旋转和第三次旋转将使用同一个轴，这样就散失了一个自由度（这被称为奇异性问题），理论上可以证明，只要想用3个实数来表达三维旋转，都会出现奇异性问题，所以很少在slam中使用欧拉角，只用来验证自己的算法 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:4:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数 四元数可视化的网站 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"复数 欧拉公式 把复平面的向量旋转x度，相当于乘上e^(ix) ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:1","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数的定义 它有1个实部，3个虚部，虚部分别对应空间坐标系的三个坐标轴 自己和自己的运算像复数，自己和别人的运算像叉乘 乘以i相当于绕轴旋转180度，i^2=-1意味着绕i轴旋转360度后得到一个相反的东西（这是个定义） 补充 ijk = -1 四元数也可以这样表示 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:2","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数的运算 加减法 乘法 向量形式 模长 共轭 四元数共轭与其本身相乘会得到一个实四元数，其实部为模长的平方 $$ q^*q=qq*=[s_a ^ 2 + v^Tv, 0]^T $$ 逆 如果q为单位四元数，其逆和共轭就是同一个量 $$ qq^{-1}=q^{-1}q=1 $$ 乘法的逆类似于矩阵 $$ (q_aq_b)^{-1} = q_b^{-1}q_a^{-1} $$ 数乘 点乘 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:3","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数表示旋转 假设点p = [x, y, z] 是最初的点，旋转后变成 p’ 先将p变成虚四元数 $$ p = [0, x, y, z]^T = [0, v]^T $$ p'可以这样求得 $$ p{}‘=qpq^{-1} $$ 这里的乘法均为四元数乘法，结果也是四元数。最后把p'的虚部取出，就是旋转后的坐标。可以验证，计算后的实部为0 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:4","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数到其他旋转表示的变换 假设 $$ q=[s,v]^T $$ $$ q=[q_0, q_1,q_2, q_3]^T $$ 从四元数得到旋转矩阵 $$ R=vv^T + s^2I+2sv^{\\wedge}+(v^{\\wedge})^2 $$ 从四元数得到旋转向量 从旋转向量到四元数 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:5","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"今天你也要来点cmake吗","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"前言 很早就想写cmake，但是一直懒得写 今天也随便写点cmake 官方对cmake的解释 CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK. 按我的理解，cmake就是工程构建工具（多用于c++） ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:1:0","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"实践 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:0","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"预备 以一道题目来介绍cmake最基本的用法，这个例子不会用到任何ide，实际上用ide应该更好 实验环境 ubuntu 16.04 LTS cmake的安装见此处 题目如下，由于题意不清，仅供参考，实际的构建和题目有点差别 这个实验分成两部分，编写共享库并安装，使用库和头文件 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:1","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"编写共享库并安装 编写静态库的操作和它差不多 首先建立tt文件夹，作为工程的总文件夹 在tt文件夹下建立build文件夹作为存放外部编译的中间文件，lib文件夹存放生成的库，CMakeLists.txt（按我的理解，这个文件就像cpu里的控制器，MakeFile文件夹之于CMakeLists.txt就像低级语言之于高级语言），src 文件夹放置该工程的源代码 文章最后有文件结构，看得更直观 tt/CMakeLists.txt tt文件夹下的CMakeLists.txt cmake_minimum_required(VERSION 3.5)\rproject(sayHello)\radd_subdirectory(lib)\radd_subdirectory(src)\r 解释一下，cmake_minimum_required 声明版本，不加构建的时候会报不是很严重的错 project 声明该工程的名字 add_subdirectory 关联子目录 如果是add_subdirectory(aaa bbb) 就是当外部编译时本该在build/aaa下生成的目标二进制文件，现在生成到了build/bbb下 tt/lib lib文件夹放三个文件，与库有关 hello.c #include \"hello.h\"\r#include \u003cstdio.h\u003e\rvoid sayHello(){printf(\"hello slam\\n\");}\r hello.h #pragma once\rvoid sayHello();\r CMakeLists.txt （为了追踪，这几乎每个文件夹都有） add_library(hello SHARED hello.c)\rset(CMAKE_INSTALL_PREFIX /usr/local)\rinstall(TARGETS hello LIBRARY DESTINATION lib)\rinstall(FILES hello.h DESTINATION include)\r 解释一下 add_library(hello SHARED hello.c) 第一个参数指库的名字，如果是hello，库的名字会自动变成libhello 第二个参数指代库的类型（共享库（动态库），静态库） ，分别对应 SHARED STATIC ，如果是动态库则生成 libhello.so 如果是静态库，则生成 libhello.a ，第三个参数是库的源代码 set(CMAKE_INSTALL_PREFIX /usr/local) CMAKE_INSTALL_PREFIX这是一个cmake变量，安装时路径是\u003cprefix\u003e/\u003ccustom\u003e install(TARGETS hello LIBRARY DESTINATION lib) 安装路径，第一个参数是静态库、动态库、目标二进制专用，hello指代库的名称（add_library时已指定），最后一个参数就是自定义相对路径，所以它会被装在/usr/local/lib 下 install(FILES hello.h DESTINATION include) 第一个参数表明待安装的是文件，它将被装在 /usr/local/include 下 构建 在build文件夹下 sudo cmake ..\rsudo make\rsudo make install\r 解释一下，这是cmake的最常用、最基本的命令， ..表示用上一级的CMakeLists.txt install是安装命令，构建之后，会在build文件夹下生成与tt文件夹下类似的文件（注意这句话） (忽略tt前面的前缀） 可以看到库和头文件已经按照题目要求成功安装（安装的目的在于可以使用） ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:2","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"使用库 tt/src 在src文件夹编写要使用库的源代码 useHello.c （注意hello.h要用双引号，不能用尖括号） #include \"hello.h\"\rint main(int argc, char** argv){sayHello();}\r CMakeLists.txt add_executable(sayHello useHello.c)\rinclude_directories(/usr/local/include)\rlink_directories(/usr/local/lib)\rtarget_link_libraries(sayHello hello)\r 解释一下，add_executable(sayHello useHello.c) 第一个参数是程序名（自定义），第二个参数是程序源文件，这条指令的作用就是它的名字所描述的 include_directories(/usr/local/include) 注意，这条语句并不是包含了哪些目录的库（这么理解似乎也没什么问题），而是在包含库之后，它应该在哪个路径下搜索，由于hello.h是相对路径，如果装在/usr/include就没事了，因为它是默认的搜索路径，但是现在装在了 /usr/local/include 所以就要增加搜索路径（导向作用） link_directories(/usr/local/lib) 这条语句和上一条是相似的，我一直觉得它写成 library_directories 应该更好理解（其实没有这条指令，又想到include是动词，link也是动词就没事了），所以这条命令就是增加库的搜索路径（是的，不仅要搜索头文件，还要搜索库，因为头文件里什么也没有，只有一堆函数的空壳，实际的内容在源文件里(hello.c)，它和头文件一起生成了 libhello.so)，这也就是为什么有下一条指令的原因 target_link_libraries(sayHello hello) 用来连接目标二进制和库，至于为什么是 sayHello ，第一条指令已经给出 在build文件夹下构建，看到build文件夹下也有个 src文件夹，正如之前 build文件夹下有了lib一样 运行tt/build/src/sayHello 可以看到终端输出 hello world ，表明使用库成功 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:3","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"文件结构 tt ---------------------------\r|\r| build -------------------\r| 。。。\r| 。。。\rlib ----------------------\r| hello.c\r| hello.h\r| CMakeLists.txt\rsrc -----------------------\r| useHello.c\r| CMakeLists.txt\rCMakeLists.txt ------------\r cmake好难，还有很多想写。。。下次一定 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:3:0","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["codeforces"],"content":"Codeforces Round #672 (Div. 2) A~D","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Cubes Sorting ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:1:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数列，每次操作交换相邻的两个数，问是否需要达到n(n-1)/2次操作才可以让数列递增 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:1:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 判断数列是否严格单调递减 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rvector\u003cint\u003e vt;\rint n;\rcin \u003e\u003e n;\rfor(int i = 0; i \u003c n; ++i){\rint u;\rcin \u003e\u003e u;\rvt.push_back(u);\r}\rbool ok = false;\rfor(int i = 0; i \u003c n - 1; i ++){\rif(vt[i] \u003e vt[i + 1]) continue;\relse {\rok = true;\rbreak;\r}\r}\rif(ok) puts(\"YES\"); else puts(\"NO\");\r}\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:1:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"B. Rock and Lever ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:2:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数列，判断有多少对数满足 x \u0026 y \u003e= x ^ y ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:2:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 根据位运算的定义，两个数的最高位（1）互相对齐就行，即二进制位数相等 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\rll n;\rcin \u003e\u003e n;\rmap\u003cll, ll\u003e mp;\rfor(ll i = 0; i \u003c n; ++i){\rll u;\rcin \u003e\u003e u;\rll v = u;\rll tmp = 0;\rwhile(v != 0){\rv \u003e\u003e= 1;\rtmp++;\r}\rmp[tmp]++;\r}\rll ans = 0;\rfor(auto i : mp){\rans += i.second * (i.second - 1) / 2;\r}\rcout \u003c\u003c ans \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:2:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"C1. Pokémon Army (easy version) ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:3:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数列，选择一些数，按顺序执行加减交替操作，求可得到的最大值（第一个是加） ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:3:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 dp #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll dp[300005][2];\rll a[300005];\rint main() {\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\rmemset(dp, 0, sizeof(dp));\rll n, q;\rcin \u003e\u003e n \u003e\u003e q;\rfor(ll i = 1; i \u003c= n; ++i){\rcin \u003e\u003e a[i];\r}\rdp[1][0] = a[1];\rdp[1][1] = 0;\rfor(ll i = 2; i \u003c= n; ++i){\rdp[i][0] = max(dp[i-1][0], dp[i-1][1] + a[i]);\rdp[i][1] = max(dp[i-1][1], dp[i-1][0] - a[i]);\r}\rcout \u003c\u003c max(dp[n][0], dp[n][1]) \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:3:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"C2. Pokémon Army (hard version) ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:4:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 在C1的基础上，增加q次操作，每次操作交换两个位置的数值，每次操作询问可得到的最大值 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:4:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 对于数列中的数值大小，波峰一定是加操作，波谷一定是减操作，对于每次的交换操作， 先消去这两个数（和它左右两个数）的影响，因为左右两个数决定了它是波峰还是波谷还是其他，交换后的数可能会影响原来左右的两个数 再加上交换数值后的影响（即该点和左右是否是波峰、波谷） #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxn = 300005;\rll a[maxn];\rint pos[maxn];\rint n, q;\rll ans;\rvoid init(){\ra[0] = a[n + 1] = 0;\rpos[0] = pos[n + 1] = -1;\rfor(int i = 1; i \u003c= n; ++i){\rif(a[i] \u003e a[i - 1] and a[i] \u003e a[i + 1]) {\rpos[i] = 1;\rans += a[i];\r}else if(a[i] \u003c a[i - 1] and a[i] \u003c a[i + 1]){\rpos[i] = -1;\rans -= a[i];\r}else{\rpos[i] = 0;\r}\r}\r}\rvoid did(int x){\rif(x \u003c= 0 or x \u003e n) return;\rif(pos[x] == 1){\rpos[x] = 0;\rans -= a[x];\r}else if(pos[x] == -1){\rpos[x] = 0;\rans += a[x];\r}\r}\rvoid update(int x){\rif(x \u003c= 0 or x \u003e n) return ;\rif(pos[x] == 0 and a[x] \u003e a[x + 1] and a[x] \u003e a[x - 1]) {\rpos[x] = 1;\rans += a[x];\r}else if(pos[x] == 0 and a[x] \u003c a[x + 1] and a[x] \u003c a[x - 1]){\rpos[x] = -1;\rans -= a[x];\r}\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rans = 0;\rcin \u003e\u003e n \u003e\u003e q;\rfor(int i = 1; i \u003c= n; ++i) cin \u003e\u003e a[i];\rinit();\rcout \u003c\u003c ans \u003c\u003c endl;\rwhile(q--){\rint l, r;\rcin \u003e\u003e l \u003e\u003e r;\rdid(l); did(l - 1); did(l + 1); did(r); did(r - 1); did(r + 1);\rswap(a[l], a[r]);\rupdate(l); update(l - 1); update(l + 1); update(r); update(r - 1); update(r + 1);\rcout \u003c\u003c ans \u003c\u003c endl;\r}\r}\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:4:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"D. Rescue Nibel! ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:5:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 有n盏灯，每盏灯有打开的时间和关闭的时间l，r，选择其中k盏，满足存在某一时刻这k盏灯同时亮，求选择方案数 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:5:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 离散化，枚举每个时间点，查看有多少盏灯之前就亮着，多少盏灯加入到亮的行列，排列组合 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll n, k;\rll ans;\rset\u003cll\u003e L;\runordered_map\u003cll, vector\u003cll\u003e \u003e R;\rpriority_queue\u003cll, vector\u003cll\u003e, greater\u003c\u003e \u003e pq;\rconst ll maxn = 300005;\rll inv[maxn];\rll fac[maxn];\rll cnt;\rll tmp;\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinline ll A(ll m,ll n){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rfor(ll i=0;i\u003cmaxn;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u003cmaxn;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!!\r for(ll i=2;i\u003cmaxn;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003cmaxn;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rcin \u003e\u003e n \u003e\u003e k;\rfor(int i = 0; i \u003c n; ++i){\rll l, r;\rcin \u003e\u003e l \u003e\u003e r;\rR[l].push_back(r);\rL.insert(l);\r}\rfor(auto i : L){\rtmp = 0;\rcnt = pq.size();\rwhile(!pq.empty()){\rif(pq.top() \u003c i){\rpq.pop();\rcnt--;\r}else break;\r}\rfor(auto j : R[i]){\rpq.push(j);\rtmp++;\r}\rif(tmp + cnt \u003c k) continue;\rfor(ll e = 1; e \u003c= min(k, tmp); ++e){\rif(tmp \u003e= e and cnt \u003e= k - e) ans += C(e, tmp) * C(k - e, cnt) % mod;\r}\r}\rcout \u003c\u003c ans % mod \u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:5:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["algorithm"],"content":"FFT \u0026 NTT","date":"2020-09-24","objectID":"/fft-ntt/","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"前言 一篇没什么用的文章，记录一下FFT和NTT的板子 fft和ntt的原理参考FFT \u0026 NTT ","date":"2020-09-24","objectID":"/fft-ntt/:1:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"概述 fft和ntt差不多，基础用法就是加速多项式乘法，把多项式从系数表示转成点值表示来方便计算，而要转成点值表示，不能选择任意点。有些点的若干次方是1（实际上可以是-1,+i,-i等等），这样不需要做所有的次方运算，而这些点在复平面单位圆上。在ntt中是拿原根替换fft的单位根。 它们的时间复杂度都是O(nlgn) ","date":"2020-09-24","objectID":"/fft-ntt/:2:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"优缺点 ntt能取模，没有浮点精度误差，但是系数必须是整数，模数通常是998244353，原根是3 fft和ntt还有很多扩充的技巧和应用 以多项式乘法为例 ","date":"2020-09-24","objectID":"/fft-ntt/:3:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"模板 ","date":"2020-09-24","objectID":"/fft-ntt/:4:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"fft typedef complex\u003cdouble\u003e cp ;\rconst double pi = acos(-1);\rint m, n;\rconst int maxn = 4 * 1e6 + 2; //记得开大点 因为2的幂次，最好乘4\rcp a[maxn], b[maxn]; // a表示第一个多项式的系数（按幂次递增）\rint rev[maxn];\rint bt; // 扩展成2的次幂后的二进制位数\rint mn; //相乘后的最高次幂即mn = m + n，m和n分别是最高次幂\rint fmn; //扩展成2的次幂的最高次幂\rvoid fft(cp* x, int len, int sign){ //sign表示共轭复数的符号\r for(int i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(int i = 1; i \u003c len; i \u003c\u003c= 1){\rcp tmp(cos(pi / i), sign * sin(pi / i));\rfor(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){\rcp omega(1, 0);\rfor(int l = 0; l \u003c i; l++, omega *= tmp){\rcp p = x[j + l], q = omega * x[j + l + i];\rx[j + l] = p + q, x[j + l + i] = p - q;\r}\r}\r}\r}\r ","date":"2020-09-24","objectID":"/fft-ntt/:4:1","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"ntt const ll mod = 998244353; //一般意义下的模数\rconst ll g = 3; //998244353对应的原根\rll m, n;\rconst ll maxn = 4 * 1e6 + 2; //记得开大点\rll a[maxn], b[maxn];\rll rev[maxn];\rll bt;\rll mn;\rll fmn;\rll qpow(ll x, ll nn){\rll res = 1;\rwhile(nn \u003e 0){\rif(nn \u0026 1) res = res * x % mod;\rx = x * x % mod;\rnn \u003e\u003e= 1;\r}\rreturn res;\r}\rvoid ntt(ll x[], ll len, int type){\rfor(ll i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(ll i = 1; i \u003c len; i *= 2){\rll tmp = qpow(g, (mod - 1) / (i * 2) );\rif(type == -1) tmp = qpow(tmp, mod - 2);\rfor(ll j = 0; j \u003c len; j += i * 2){\rll omega = 1;\rfor(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){\rll p = x[j + k], q = omega * x[j + k + i] % mod;\rx[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod;\r}\r}\r}\r}\r ","date":"2020-09-24","objectID":"/fft-ntt/:4:2","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"模板题 ","date":"2020-09-24","objectID":"/fft-ntt/:5:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"多项式乘法 题目 fft实现 #include \"bits/stdc++.h\"\rusing namespace std;\rtypedef long long ll ;\rtypedef complex\u003cdouble\u003e cp ;\rconst double pi = acos(-1);\rint m, n;\rconst int maxn = 4 * 1e6 + 2; //记得开大点\rcp a[maxn], b[maxn];\rint rev[maxn], ans[maxn];\rint bt;\rint mn;\rint fmn;\rvoid fft(cp* x, int len, int sign){\rfor(int i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(int i = 1; i \u003c len; i \u003c\u003c= 1){\rcp tmp(cos(pi / i), sign * sin(pi / i));\rfor(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){\rcp omega(1, 0);\rfor(int l = 0; l \u003c i; l++, omega *= tmp){\rcp p = x[j + l], q = omega * x[j + l + i];\rx[j + l] = p + q, x[j + l + i] = p - q;\r}\r}\r}\r}\rint main() {\rscanf(\"%d%d\", \u0026m, \u0026n);\rfor(int i = 0; i \u003c= m; ++i){\rscanf(\"%lf\", \u0026a[i]);\r}\rfor(int i = 0; i \u003c= n; ++i){\rscanf(\"%lf\", \u0026b[i]);\r}\rmn = m + n;\rfor(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++;\rfor(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1));\rfft(a, fmn, 1);\rfft(b, fmn, 1);\rfor(int i = 0; i \u003c= fmn; ++i) a[i] = a[i] * b[i];\rfft(a, fmn, -1);\rfor(int i = 0; i \u003c= mn; ++i) printf(\"%d \", (int)(a[i].real()/fmn + 0.5));\rreturn 0;\r}\r ntt实现 #include \"bits/stdc++.h\"\rusing namespace std;\rtypedef long long ll ;\rconst ll mod = 998244353;\rconst ll g = 3;\rll m, n;\rconst ll maxn = 4 * 1e6 + 2; //记得开大点\rll a[maxn], b[maxn];\rll rev[maxn], ans[maxn];\rll bt;\rll mn;\rll fmn;\rll qpow(ll x, ll nn){\rll res = 1;\rwhile(nn \u003e 0){\rif(nn \u0026 1) res = res * x % mod;\rx = x * x % mod;\rnn \u003e\u003e= 1;\r}\rreturn res;\r}\rvoid ntt(ll x[], ll len, int type){\rfor(ll i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(ll i = 1; i \u003c len; i *= 2){\rll tmp = qpow(g, (mod - 1) / (i * 2) );\rif(type == -1) tmp = qpow(tmp, mod - 2);\rfor(ll j = 0; j \u003c len; j += i * 2){\rll omega = 1;\rfor(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){\rll p = x[j + k], q = omega * x[j + k + i] % mod;\rx[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod;\r}\r}\r}\r}\rint main() {\rscanf(\"%d%d\", \u0026m, \u0026n);\rfor(int i = 0; i \u003c= m; ++i){\rscanf(\"%lld\", \u0026a[i]);\ra[i] += mod;\ra[i] %= mod;\r}\rfor(int i = 0; i \u003c= n; ++i){\rscanf(\"%lld\", \u0026b[i]);\rb[i] += mod;\rb[i] %= mod;\r}\rmn = m + n;\rfor(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++;\rfor(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1));\rntt(a, fmn, 1);\rntt(b, fmn, 1);\rfor(ll i = 0; i \u003c= fmn; ++i) a[i] = (a[i] * b[i]) % mod;\rntt(a, fmn, -1);\rll inv_fmn = qpow(fmn, mod - 2);\rfor(ll i = 0; i \u003c= mn; ++i){\rprintf(\"%lld \", a[i] * inv_fmn % mod);\r}\rreturn 0;\r}\r ","date":"2020-09-24","objectID":"/fft-ntt/:5:1","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"高精度乘法 fft实现 #include \"bits/stdc++.h\"\rusing namespace std;\rtypedef complex\u003cdouble\u003e cp ;\rconst double pi = acos(-1);\rint m, n;\rconst int maxn = 4 * 1e6 + 2; //记得开大点\rcp a[maxn], b[maxn];\rint rev[maxn];\rint ans[maxn];\rint bt;\rint mn;\rint fmn;\rvoid fft(cp* x, int len, int sign){\rfor(int i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(int i = 1; i \u003c len; i \u003c\u003c= 1){\rcp tmp(cos(pi / i), sign * sin(pi / i));\rfor(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){\rcp omega(1, 0);\rfor(int l = 0; l \u003c i; l++, omega *= tmp){\rcp p = x[j + l], q = omega * x[j + l + i];\rx[j + l] = p + q, x[j + l + i] = p - q;\r}\r}\r}\r}\rint main() {\rstring s1, s2;\rcin \u003e\u003e s1 \u003e\u003e s2;\rm = s1.size() - 1;\rn = s2.size() - 1;\rfor(int i = 0; i \u003c= m; ++i){\ra[i] = (double) (s1[m - i] - '0');\r}\rfor(int i = 0; i \u003c= n; ++i){\rb[i] = (double) (s2[n - i] - '0');\r}\rmn = m + n;\rfor(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++;\rfor(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1));\rfft(a, fmn, 1);\rfft(b, fmn, 1);\rfor(int i = 0; i \u003c= fmn; ++i) a[i] = a[i] * b[i];\rfft(a, fmn, -1);\rfor(int i = 0; i \u003c= mn; ++i){\rans[i] += (int) (a[i].real() / fmn + 0.5); // 注意+= 不是 =\r ans[i + 1] += ans[i] / 10 ;\rans[i] %= 10;\r}\rif((mn == 0 and ans[0] == 0) or (mn \u003e 0 and ans[1] == 0)) {\rputs(\"0\");\rexit(0);\r}\rfor(int i = mn + 1; i \u003e= 0; --i){ //进位\r if(ans[i] == 0 and i == mn + 1)\rcontinue;\rcout \u003c\u003c ans[i];\r}\rreturn 0;\r}\r ntt实现 #include \"bits/stdc++.h\"\rusing namespace std;\rtypedef long long ll ;\rconst ll mod = 998244353;\rconst ll g = 3;\rll m, n;\rconst ll maxn = 4 * 1e6 + 2; //记得开大点\rll a[maxn], b[maxn];\rll rev[maxn];\rll ans[maxn];\rll bt;\rll mn;\rll fmn;\rll qpow(ll x,ll nn){\rll res = 1;\rwhile(nn \u003e 0){\rif(nn \u0026 1) res = res * x % mod;\rx = x * x % mod;\rnn \u003e\u003e= 1;\r}\rreturn res;\r}\rvoid ntt(ll x[], ll len, int type){\rfor(ll i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(ll i = 1; i \u003c len; i *= 2){\rll tmp = qpow(g, (mod - 1) / (i * 2));\rif(type == -1) tmp = qpow(tmp, mod - 2);\rfor(ll j = 0; j \u003c len; j += i * 2){\rll omega = 1;\rfor(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){\rll p = x[j + k], q = omega * x[j + k + i] % mod;\rx[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod;\r}\r}\r}\r}\rint main() {\rstring s1, s2;\rcin \u003e\u003e s1 \u003e\u003e s2;\rm = s1.size() - 1;\rn = s2.size() - 1;\rfor(int i = 0; i \u003c= m; ++i){\ra[i] = s1[m - i] - '0';\r}\rfor(int i = 0; i \u003c= n; ++i){\rb[i] = s2[n - i] - '0';\r}\rmn = m + n;\rfor(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++;\rfor(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1));\rntt(a, fmn, 1);\rntt(b, fmn, 1);\rfor(ll i = 0; i \u003c= fmn; ++i) {\ra[i] = a[i] * b[i] % mod;\r}\rntt(a, fmn, -1);\rll inv_fmn = qpow(fmn, mod - 2);\rfor(ll i = 0; i \u003c= fmn; ++i){\rans[i] += a[i] * inv_fmn % mod;\rans[i + 1] = ans[i] / 10;\rans[i] %= 10;\r}\rif((mn == 0 and ans[0] == 0) or (mn \u003e 0 and ans[1] == 0)) {\rputs(\"0\");\rexit(0);\r}\rfor(int i = mn + 1; i \u003e= 0; --i){ //进位\r if(ans[i] == 0 and i == mn + 1)\rcontinue;\rcout \u003c\u003c ans[i];\r}\rreturn 0;\r}\r 接下来了解下trie树，国庆做点dp题 ","date":"2020-09-24","objectID":"/fft-ntt/:5:2","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["problemlist"],"content":"无聊的做题记录","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数学公式 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 错排公式 Dn = floor(n!/e + 0.5) = (n - 1) * (Dn-1 + Dn-2) D1 = 0 , D2 = 1 //457ms/1000ms 488k/32768k\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint main() {\rll n;\rcin \u003e\u003e n;\rll one = 0, to = 1;\rll ans = 0;\rfor(int i = 2; i \u003c n; ++i){\rans = i * (one + to);\rans %= mod;\rone = to;\rto = ans;\r}\rcout \u003c\u003c ans ;\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"贪心 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 最优策略一定是捕鱼和炖鱼并行，但是捕鱼的过程不能中断，所以就有时间浪费，分两种，1.在炖鱼结束前停止捕鱼，2.炖鱼结束前，捕一条鱼，炖鱼结束，捕鱼还没结束 对每一次炖鱼选择哪一种？2优于1在于同样是浪费时间，2可以多收获一条生鱼 所以每次都选择2策略，捕鱼顺序会影响时间，为了让浪费时间尽可能少，应该求出每一次炖鱼的“浪费时间”，然后从小到大排序，选择前“浪费时间的次数”个 //436ms/1000ms 4024kb/65536kb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll a[100005];\rvector\u003cll\u003e b;\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rb.clear();\rint n, k;\rcin \u003e\u003e n \u003e\u003e k;\rll ans = 0;\rll sum = 0;\rfor(int i = 0; i \u003c n; ++i) {\rcin \u003e\u003e a[i];\rans += a[i];\rsum += a[i] / k;\rb.push_back(k - a[i] % k);\r}\rsort(b.begin(), b.end());\rfor(int i = 0; i \u003c n - sum - 1; ++i){\rans += b[i];\r}\rans += k;\rcout \u003c\u003c ans \u003c\u003c endl;\r}\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"树形dp dfs 数论 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 dp[i][j] 表示以 i 为根的树，i节点为j时的方案数 dp[i][j] = 每个子节点满足条件的方案数相乘（满足的条件是gcd(i,j) != w） 子节点又要求子节点所以形成dfs 由于求j满足gcd(i,j) = w比较好求（枚举w的倍数），所以满足条件的方案数是所有方案数减不满足条件方案数 所有方案数即dp[i][1] + dp[i][2] + … + dp[i][m] 这可以每次求完所有的dp[i][x] 之后求和，用sum[i]维护 整体过程就是先dfs子节点，处理完毕后遍历m，然后遍历每个子节点，算出该子节点对dp[i][j]的贡献（满足的方案数），最后求积，赋值给dp[i][j]，然后再遍历一遍m在线预处理sum[i] 时间复杂度 O(m^2logm) 如果m是1e5，可能需要莫比乌斯反演 注意这不是一棵树，是无向图 //537ms/1000ms 8192kb/262144kb\r #include \"bits/stdc++.h\"\r using namespace std;\rusing ll = long long;\rconst int maxn = 1005;\rll sum[maxn];\rconst ll mod = 1e9 + 7;\rll n, m;\rll dp[maxn][maxn];\rstruct edge{\rint to , next;\rll w;\r}e[2*maxn];\rint tot,head[maxn];\rll gcd(ll a, ll b){\rreturn b ? gcd(b, a%b) : a;\r}\rvoid add_edge(int u, int v, ll w){\re[tot].to = v;\re[tot].w = w;\re[tot].next = head[u];\rhead[u] = tot++;\r}\rvoid dfs(int x, int p){\rfor(int i = head[x]; ~i; i = e[i].next){\rint v = e[i].to;\rif(v != p) dfs(v, x);\r}\rfor(ll i = 1; i \u003c= m; ++i){\rll cnt = 1;\rfor(int j = head[x]; ~j; j = e[j].next){\rint v = e[j].to;\rll w = e[j].w;\rif(v == p) continue;\rll rem = sum[v];\rfor(ll k = w; k \u003c= m; k += w){\rif(gcd(i, k) == w){\rrem -= dp[v][k];\rrem += mod;\rrem %= mod;\r}\r}\rcnt *= rem;\rcnt %= mod;\r}\rdp[x][i] = cnt;\rdp[x][i] %= mod;\r}\rfor(ll i = 1; i \u003c= m; ++i){\rsum[x] += dp[x][i];\rsum[x] %= mod;\r}\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(nullptr);\rcout.tie(nullptr);\rmemset(head , -1 , sizeof(head));\rcin \u003e\u003e n \u003e\u003e m;\rfor(int i = 0; i \u003c n - 1; ++i){\rint u, v, w;\rcin \u003e\u003e u \u003e\u003e v \u003e\u003e w;\radd_edge(u, v, w);\radd_edge(v, u, w);\r}\rdfs(1, 0);\rcout \u003c\u003c sum[1] \u003c\u003c endl;\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp 乘法原理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 用dp处理排列组合问题，对于子序列的数量，考虑对前缀的依赖 dp[3] 表示扫描到当前abc的数量，dp[2]表示扫描到当前ab的数量，dp[1]表示扫描到当前a的数量，dp[0]表示扫描到当前单纯排列组合的数量 转移方程 dp[3] = dp[3] + dp[2] [ch[i] == 'c'] dp[2] = dp[2] + dp[1] [ch[i] == 'b'] dp[1] = dp[1] + dp[0] [ch[i] == 'a'] 当前字符是？时，它有三种情况a, b, c所以对于dp[0], dp[1], dp[2], dp[3]都乘以3 然后再分a, b, c三种情况 对于c，dp[3] += dp[2] （这是未扫描到当前的dp[2]）其他同理 初始化 dp[0] = 1 //61ms/1000ms 208kb/256mb\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9 + 7;\rchar a[200005];\rll dp[4];\rint main(){\rint n;\rcin \u003e\u003e n;\rcin \u003e\u003e a;\rdp[0] = 1;\rfor(int i = 0; i \u003c n; ++i){\rif(a[i] == 'a'){\rdp[1] = (dp[1] + dp[0]) % mod;\r}else if(a[i] == 'b'){\rdp[2] = (dp[2] + dp[1]) % mod;\r}else if(a[i] == 'c'){\rdp[3] = (dp[3] + dp[2]) % mod;\r}else{\rdp[3] = (3ll * dp[3] + dp[2]) % mod;\rdp[2] = (3ll * dp[2] + dp[1]) % mod;\rdp[1] = (3ll * dp[1] + dp[0]) % mod;\rdp[0] = (3ll * dp[0]) % mod;\r}\r}\rcout \u003c\u003c dp[3] \u003c\u003c endl;\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp bf 预处理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给定一个大写的字符串，每个大写的字母都代表三个字母的组合（qwe），每次释放一个qwe中的技能就会获得这个字母，至多只能获得三个，如果在已有三个字母的情况下获得释放技能，第一个字母将会被挤掉（类似于队列）当集齐该大写字母的三个字母组合时，释放r技能就能成功点亮这个大写字母，这时候字母队列中不会有任何变化，问最少需要释放几个技能把所有的大写字母按顺序点亮 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 按顺序暴力，由于大写字母对应的是技能的组合，总共有6种，所以求出前6种组合对后6种组合的影响，然后对每个都取最小值，这样就形成dp dp[i][j] 表示扫描完第 i 个大写字母时，对应的第 j 种组合（至多6种）的答案 初始化 dp[0][i] = 3 [0 \u003c= i \u003c 6] 状态转移方程 dp[i][j] = min(dp[i][j], dp[i - 1][k] + cot(string s[i - 1][k], string s[i][j]) 最后的答案就是 min(dp[s.len - 1][i]) [0 \u003c= i \u003c 6] 如果不做优化会超时，优化的方法就是两处预处理（在代码中标注） //358ms/1000ms 2772kb/1024mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxn = 100005;\r//string s;\rchar s[maxn];\runordered_map\u003cchar, int\u003e mp;\r//括号不匹配\rchar ch[11][7][4] =\r{{\"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\"}},\r{\"QQW\", \"QWQ\", \"QQW\", \"QWQ\", \"WQQ\", \"WQQ\"},\r{\"QQE\", \"QEQ\", \"QQE\", \"QEQ\", \"EQQ\", \"EQQ\"},\r{\"WWW\", \"WWW\", \"WWW\", \"WWW\", \"WWW\", \"WWW\"},\r{\"QWW\", \"QWW\", \"WQW\", \"WWQ\", \"WQW\", \"WWQ\"},\r{\"WWE\", \"WEW\", \"WWE\", \"WEW\", \"EWW\", \"EWW\"},\r{\"EEE\", \"EEE\", \"EEE\", \"EEE\", \"EEE\", \"EEE\"},\r{\"QEE\", \"QEE\", \"EQE\", \"EEQ\", \"EQE\", \"EEQ\"},\r{\"WEE\", \"WEE\", \"EWE\", \"EEW\", \"EWE\", \"EEW\"},\r{{\"QWE\", \"QEW\", \"WQE\", \"WEQ\", \"EQW\", \"EWQ\"}};\rint dp[maxn][6];\rint did(string s1, string s2){\rif(s1 == s2) return 0;\rif(s1[1] == s2[0] and s1[2] == s2[1]) return 1;\rif(s1[2] == s2[0]) return 2;\rreturn 3;\r}\rconst int inf = 0x3f3f3f3f;\r//int get_id(char x){\r// if(x == 'Y') return 0;\r// if(x == 'V') return 1;\r// if(x == 'G') return 2;\r// if(x == 'C') return 3;\r// if(x == 'X') return 4;\r// if(x == 'Z') return 5;\r// if(x == 'T') return 6;\r// if(x == 'F') return 7;\r// if(x == 'D') return 8;\r// return 9;\r//}\rint cot[11][7][11][7];\rint main() {\rmp['Y'] = 0;\rmp['V'] = 1;\rmp['G'] = 2;\rmp['C'] = 3;\rmp['X'] = 4;\rmp['Z'] = 5;\rmp['T'] = 6;\rmp['F'] = 7;\rmp['D'] = 8;\rmp['B'] = 9;\rfor(int i = 0; i \u003c 10; ++i){\rfor(int j = 0; j \u003c 6; ++j){\rfor(int k = 0; k \u003c 10; ++k){\rfor(int m = 0; m \u003c 6; ++m){\rstring s1 = ch[i][j];\rstring s2 = ch[k][m];\rcot[i][j][k][m] = did(s1, s2);\r}\r}\r}\r}\r//cin \u003e\u003e s;\r scanf(\"%s\", s);\rint len = strlen(s);\rfor(int i = 0; i \u003c= len; ++i)\rfor(int j = 0; j \u003c 6; ++j)\rdp[i][j] = inf;\r//cout \u003c\u003c len \u003c\u003c endl;\r for(int i = 0; i \u003c 6; ++i){\rdp[0][i] = 3;\r}\rfor(int i = 1; i \u003c len; ++i){\rint id1 = mp[s[i - 1]]; //在外层循环得到\r int id2 = mp[s[i]];\rfor(int j = 0; j \u003c 6; ++j){\rfor(int k = 0; k \u003c 6; ++k){\rdp[i][j] = min(dp[i][j], dp[i - 1][k] + cot[id1][k][id2][j]); //!!!此处预处理\r //dp[i][j] = min(dp[i][j], dp[i - 1][k] + did(ch[id1][k], ch[id2][j]));\r }\r}\r}\rint ans = 0x3f3f3f3f;\rfor(int i = 0; i \u003c 6; ++i){\rans = min(ans, dp[len - 1][i]);\r}\rcout \u003c\u003c ans + len \u003c\u003c endl;\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dfs 图论 乘法原理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给一个森林，每个连通块都是仙人掌图，每次删除一些边，使得它变成一个森林且每个连通块都是一棵树，问有多少种删边方法 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 根据仙人掌图的定义，对于每个环，至少删除一条边就能满足条件，所以计算每个环的边数 对于不在环上的边，可以任意删除或保留，假设每个环的边数为ci，不在环上的边数是r $$ ans = 2^r*\\prod (2^{c_i} - 1) $$ 对于找环的边数，可以用tarjan算法的思想，用dfs序来判断是否遍历过这个点，如果遍历过就说明形成环，dfs序相减就是环的长度 //358ms/1000ms 138640kb/1048576kb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxv = 300005;\rconst ll mod = 998244353;\rconst int maxn = 2000005;\rstruct edge{\rint to, nxt;\r}e[maxn];\rint tot,head[maxn];\rvoid add_edge(int u,int v){\re[tot].to = v;\re[tot].nxt = head[u];\rhead[u] = tot++;\r}\rvector\u003cll\u003e res;\rint dfn[maxv],low[maxv];\rbool in_stack[maxv];\rstack\u003cint\u003e s;\rint tim;\rll qpow(ll x,ll n){\rll res =1;\rwhile(n\u003e0){\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rvoid tarjan_dfs(int x, int p){\rfor(int i = head[x]; ~i; i = e[i].nxt){\rint v = e[i].to;\rif(v == p) continue;\rif(dfn[v] != 0){\rres.push_back(dfn[x] + 1 - dfn[v]);\r}else{\rdfn[v] = dfn[x] + 1;\rtarjan_dfs(v, x);\r}\r}\r}\rint main() {\rint n, m;\rwhile(scanf(\"%d%d\", \u0026n, \u0026m) != EOF){\r//reset\r res.clear();\rtim = 0;\rmemset(dfn, 0, sizeof(dfn));\rmemset(low, 0, sizeof(low));\rmemset(in_stack, 0, sizeof(in_stack));\rwhile(!s.empty()) s.pop();\rtot = 0;\rmemset(head , -1 , sizeof(head));\rfor(int i = 0; i \u003c m; ++i){\rint u, v;\rscanf(\"%d%d\", \u0026u, \u0026v);\radd_edge(u, v);\radd_edge(v, u);\r}\rfor(int i = 1; i \u003c= n; ++i){\rif(!dfn[i]){\rdfn[i] = 1;\rtarjan_dfs(i, 0);\r}\r}\rll rem = 0;\rfor(ll i : res) {\rif(i \u003e 0) rem += i;\r}\rrem = m - rem;\rll ans = 1;\rfor(ll i : res){\rif(i \u003c= 0) continue;\rans *= qpow(2, i) - 1;\rans += mod;\rans %= mod;\r}\rans *= qpow(2, rem);\rans += mod;\rans %= mod;\rprintf(\"%lld\\n\", ans);\r//for(ll i : res) cout \u003c\u003c i \u003c\u003c \" \";\r //for(int i = 1; i \u003c 6; ++i) cout \u003c\u003c dfn[i] \u003c\u003c \" \";\r }\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp lis 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 在一个网格上有n个明星，他们出现的时间是0~ti，从(1,1)出发，每走一格消耗一个时间单位，问最多能碰见几个明星 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 注意一个重要条件：时间是按严格升序排的，r\u003c=500 类似于lis的dp，dp[i]表示最后碰见第i个人时的答案 ans = max(ans, dp[i]) [1 \u003c= i \u003c= n] dp[i] = max(dp[i], dp[j] + 1) 在lis中更新的条件是后面的数比前面的大，在这里条件是曼哈顿距离不大于时间差（已排好序） 这样时间复杂度就是O(n^2) 对于当前明星，它存活到ti，由于网格大小的限制，所以ti - 2r之前消失的明星一定可达，而(ti-2r, ti)这段时间的明星就需要一个一个判断 接下来有一个很巧妙的将时间复杂度降到O(nr)的优化 由于[0, ti-4r]已经用来更新过（更新到ti-2r）所以这段区间将不再使用（因为它的影响已经叠加在了[ti-4r,ti-2r]这段区间上了），所以只需要看[ti-4r,ti-2r]这段区间，加上需要一个一个判断的[ti-2r,ti)这段区间。最后只需要遍历[ti-4r,ti) 时间之所以能转化成明星的个数，就是因为时间是严格有序的 //702ms/2000ms 1572kb/256mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint r, n;\rconst int maxn = 100005;\rint dp[maxn];\rtuple\u003cint, int, int\u003e cel[maxn];\rint dist(int i, int j){\rreturn abs(get\u003c1\u003e(cel[i]) - get\u003c1\u003e(cel[j])) + abs(get\u003c2\u003e(cel[i]) - get\u003c2\u003e(cel[j]));\r}\rint main() {\rmemset(dp, -1, sizeof(dp));\rscanf(\"%d%d\", \u0026r, \u0026n);\rget\u003c0\u003e(cel[0]) = 0;\rget\u003c1\u003e(cel[0]) = 1;\rget\u003c2\u003e(cel[0]) = 1;\rfor(int i = 1; i \u003c= n; ++i){\rint t, x, y;\rscanf(\"%d%d%d\", \u0026t, \u0026x, \u0026y);\rget\u003c0\u003e(cel[i]) = t;\rget\u003c1\u003e(cel[i]) = x;\rget\u003c2\u003e(cel[i]) = y;\r}\rdp[0] = 0;\rfor(int i = 1; i \u003c= n; ++i){\rfor(int j = max(0, i - 4 * r); j \u003c i; ++j){\rif(dp[j] == -1) continue;\rif(dist(i, j) \u003c= get\u003c0\u003e(cel[i]) - get\u003c0\u003e(cel[j])) dp[i] = max(dp[i], dp[j] + 1);\r}\r}\rint ans = 0;\rfor(int i = 1; i \u003c= n; ++i){\rans = max(ans, dp[i]);\r}\rprintf(\"%d\\n\", ans);\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给俩数p,q，求最大的x满足p%x=0，x%q!=0 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 如果p%q!=0，x=p 否则对于pq相同的因子m，假设q中有n个m，那么就让p中m的个数减到n-1，得到一个tmp，这样就能保证p%tmp=0,tmp%q!=0，对于所有的因子产生的tmp取最大值 //46ms/1000ms 12kb/512mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rvector\u003cpair\u003cll, ll\u003e\u003e vt;\rll p, q;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rll ans = -1;\rcin \u003e\u003e p \u003e\u003e q;\rif(p % q != 0) ans = p;\relse{\rvt.clear();\rfor(ll i = 2; i * i \u003c= q; ++i){\rif(q % i == 0){\rll cot = 0;\rwhile(q % i == 0) {\rq /= i;\rcot++;\r}\rvt.emplace_back(i, cot);\r}\r}\rif(q \u003e 1) vt.emplace_back(q, 1);\rfor(auto i : vt){\rll x = i.first;\rll y = i.second;\rll tmp = p;\rwhile(tmp % x == 0){\rtmp /= x;\r}\rfor(ll j = 0; j \u003c y - 1; ++j) tmp *= x;\rans = max(ans, tmp);\r}\r}\rcout \u003c\u003c ans \u003c\u003c endl;\r}\r//for(auto i : vt){\r// cout \u003c\u003c i.first \u003c\u003c \" \" \u003c\u003c i.second \u003c\u003c endl;\r//}\r return 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dfs 剪枝 回溯 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 重点在于剪枝，还有如何把dfs写得好看点和回溯 此处做的两个剪枝是：如果当前最小不兼容性的和大于等于ans，剪枝。如果当前要处理的集合为空，则不进行下一个集合的处理（因为下一个集合也为空（按顺序放的），这时候放哪个空集无所谓） //308ms 32.6Mb\rclass Solution {\rpublic:\rint m ;\rint ans;\rint n;\rint K;\rvoid dfs(vector\u003cint\u003e\u0026 nums, int index, vector\u003cset\u003cint\u003e\u003e\u0026 sts, int cnt){\rif(index \u003e= n) {\rans = min(ans, cnt);\rreturn ;\r}\rfor(int i = 0; i \u003c K; ++i){\rif(sts[i].empty()){\rsts[i].insert(nums[index]);\rdfs(nums, index + 1, sts, cnt);\rsts[i].erase(nums[index]);\rreturn ;\r}\rif(sts[i].size() \u003c m and sts[i].find(nums[index]) == sts[i].end()){\rint tmp_cnt = cnt + nums[index] - *sts[i].rbegin();\rif(tmp_cnt \u003e= ans) continue;\rsts[i].insert(nums[index]);\rdfs(nums, index + 1, sts, tmp_cnt);\rsts[i].erase(nums[index]);\r}\r}\r}\rint minimumIncompatibility(vector\u003cint\u003e\u0026 nums, int k) {\rvector\u003cset\u003cint\u003e\u003e vt(k);\rsort(nums.begin(), nums.end());\rK = k;\rans = 0x3f3f3f3f;\rn = nums.size();\rm = n / k;\rdfs(nums, 0, vt, 0);\rif(ans == 0x3f3f3f3f) ans = -1;\rreturn ans;\r}\r};\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"状态压缩dp 预处理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 和上面那题一样 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 第二种方法是状态压缩dp，（完全不会(╥╯^╰╥) ） 假设n是nums的长度，m是每个集合中的元素个数 foo[i]表示集合为i时的不兼容性，只需对集合中有m个元素时处理，其他情况都是inf，注意foo[0] = 0 dp[i]表示前i个数的最小不兼容性，ans = dp[(1«n) - 1] 对于每个集合i，枚举子集，对于子集大小为m的 dp[i] = min(dp[i], foo[sub] + dp[i ^ sub]) 注意初始化为dp = inf foo = inf dp[0] = 0 foo[0] = 0 //1128ms 13.4Mb\rclass Solution {\rpublic:\rint minimumIncompatibility(vector\u003cint\u003e\u0026 nums, int k) {\rint n = nums.size();\rint m = n / k;\rvector\u003cint\u003e cnt;\rvector\u003cint\u003e dp((1 \u003c\u003c n) + 5, 0x3f3f3f3f);\rvector\u003cint\u003e foo((1 \u003c\u003c n) + 5, 0x3f3f3f3f);\rdp[0] = 0;\rfoo[0] = 0;\rfor(int i = 0; i \u003c (1 \u003c\u003c n); ++i){\rcnt.clear();\rif(__builtin_popcount(i) == m){\rfor(int j = 0; j \u003c n; ++j){\rif(i \u003e\u003e j \u0026 1){\rcnt.push_back(nums[j]);\r}\r}\rsort(cnt.begin(), cnt.end());\rbool ok = true;\rfor(int j = 1; j \u003c m; ++j){\rif(cnt[j] == cnt[j - 1]){\rok = false;\rbreak;\r}\r}\rif(ok) foo[i] = cnt[m - 1] - cnt[0];\r}\r}\rfor(int i = 0; i \u003c (1 \u003c\u003c n); ++i){\rint sub = i;\rdo{\rif(__builtin_popcount(sub) == m){\rdp[i] = min(dp[i], foo[sub] + dp[sub ^ i]);\r}\rsub = (sub - 1) \u0026 i;\r}while(sub != i);\r}\rint ans = dp[(1 \u003c\u003c n) - 1];\rif(ans == 0x3f3f3f3f) ans = -1;\rreturn ans;\r}\r};\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"博弈 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 在平面坐标系里，有一个token，初始在原点，两人轮流操作，直到不能操作判胜负，操作是将token向上或向右移k个单位，每次移动后token离原点的距离都不能超出d ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 记录一下看错题目，浪费一小时的惨痛经历 移动k个单位是沿一个方向 //46ms/2000ms 0kb/256mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\rll d, k;\rcin \u003e\u003e d \u003e\u003e k;\rll n = 0;\rwhile((n + k) * (n + k) * 2 \u003c= d * d){\rn += k;\r}\rll tmp = n + k;\rif(tmp * tmp + n * n \u003c= d * d) {\rn /= k ;\rn *= 2;\rn++;\r}else{\rn /= k;\rn *= 2;\r}\rif(n \u0026 1) puts(\"Ashish\"); else puts(\"Utkarsh\");\r}\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"树形dp dfs 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给一棵树，每个节点有若干个人，从根节点开始，每个人可以选择去往一个子节点，直到这个节点没人，最后所有人都来到了叶子节点。将叶子节点的最大人数最小化 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 画了几下图，第一感觉是贪心+搜索，如果一直这样做的话，就有可能变成一个结论题，但是细节还是很难具体化，又有点像dp，树形dp应该是逻辑最清晰的 dp[i]表示以i为根的答案，最后输出dp[1] 初始化全为0 考虑转移方程，这个节点的答案一定不小于子节点的答案 dp[i] = max{dp[ch]} 考虑把该节点的人数转移到子树上（子树的叶子节点上），贪心地选择叶子人数少的，这样不会改变最大值，答案还是max{dp[ch]} 如果叶子人数少的被填满了，也就是现在每个叶子都均匀分配了，那就对剩下的人数继续均分 这样答案就大于max{dp[ch]}，答案更新为floor(sum[i] / leaf[i])，其中sum[i]表示i为根的树的总人数，leaf[i]表示i为根的树的叶子数 所以转移方程 dp[i] = max(max{dp[ch]}, floor(sum[i] / leaf[i])） //623ms/1000ms 30668kb/256mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rvector\u003cll\u003e G[200005];\rll a[200005];\rll sum[200005];\rll leaf[200005];\rll dp[200005];\rvoid dfs(ll x){\rif(G[x].size() == 0) leaf[x] = 1;\rsum[x] = a[x];\rfor(ll i : G[x]){\rdfs(i);\rsum[x] += sum[i];\rleaf[x] += leaf[i];\rdp[x] = max(dp[x], dp[i]);\r}\rdp[x] = max(dp[x], ll(ceil((double)sum[x] / leaf[x])));\r}\rint main() {\rll n;\rcin \u003e\u003e n;\rfor(ll i = 2; i \u003c= n; ++i){\rll x;\rcin \u003e\u003e x;\rG[x].push_back(i);\r}\rfor(ll i = 1; i \u003c= n; ++i){\rcin \u003e\u003e a[i];\r}\rdfs(1);\rcout \u003c\u003c dp[1] \u003c\u003c '\\n';\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 有一排木板，无限多个，给r的倍数涂红色，b的倍数涂蓝色，r和b的倍数随便选一种颜色涂，将涂色的木板取出来，按原来的顺序排，问是否存在不少于k个连续的颜色相同的木板 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 假设r \u003e b，r和b共同的倍数一定染红色（因为红色间隔比较大），问题转化成两个红色木板间最多有几个蓝色木板，在这个区间里，第一个蓝色木板一定是所有长度为r的区间内离该区间左边红色木板最近的，由扩展欧几里得可知ax+by=c，x，y有整数解当c | gcd(a,b)，所以这个最近距离是gcd(r,b)，然后就可以求出最多的蓝色木板 31ms/2000ms 0kb/256mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint r, b, k;\rcin \u003e\u003e r \u003e\u003e b \u003e\u003e k;\rif(r \u003c b) swap(r, b);\rif(floor((r - 1 - __gcd(r, b)) / (double) b) + 1 \u003c k) puts(\"OBEY\"); else puts(\"REBEL\");\r}\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 前缀 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 在环上有n个数字，可以对每个数字进行+1或-1的操作，问最少需要几次操作使得环中存在一个长度为n的步长为1的顺时针的递增序列 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 最关键的思路是其中一个数肯定不变 对于每个从环中任一位置开始的数列，假设其中一个数不变，求出操作数，再对所有操作数取min，这样时间复杂度为O(n*n*n)，考虑到对其他位置开始的序列，假设不变的数有可能是相同的，这样求别的数需要的操作数时就重复计算了 所以直接假设每个数为不变的数，然后遍历一遍2n个数，用前缀数组求出到这个数的操作数，对于长度为n的序列，操作数为pre[j] - pre[j - n] #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint a[4005];\rint pre[4005];\rint ans;\rint main(){\rint _;\rcin \u003e\u003e _;\rwhile(_--){\rint n;\rcin \u003e\u003e n;\rans = 0x3f3f3f3f;\rfor(int i = 1; i \u003c= n; ++i){\rcin \u003e\u003e a[i];\ra[i + n] = a[i];\r}\rfor(int i = 1; i \u003c 2 * n; ++i){\rint tmp = a[i] - i;\rfor(int j = 1; j \u003c 2 * n; ++j){\rpre[j] = pre[j - 1] + abs(a[j] - j - tmp);\rif(j \u003e= n){\rans = min(ans, pre[j] - pre[j - n]);\r}\r}\r}\rcout \u003c\u003c ans \u003c\u003c '\\n';\r}\rreturn 0；\r}\r ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["Python web"],"content":"hhu_spider","date":"2020-08-11","objectID":"/hhu_spider/","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"hhu健康打卡脚本（返校版） ","date":"2020-08-11","objectID":"/hhu_spider/:1:0","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"环境 必装环境 python， requests 推荐环境 anaconda, pycharm ","date":"2020-08-11","objectID":"/hhu_spider/:1:1","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"功能说明 定时打卡、同时多人打卡、发邮件反馈打卡信息、失败重新打卡 （为什么不用发信息，国内手机号在twilio上不能用了） ","date":"2020-08-11","objectID":"/hhu_spider/:1:2","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"使用方法 在#**xxx** 中按xxx提示填入自己的相关信息 运行 关于定时打卡 将脚本传到服务器上，用cronb（linux系统）实现定时，可以选择发邮件反馈打卡情况 ","date":"2020-08-11","objectID":"/hhu_spider/:1:3","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"代码 import requests\rimport sys\rimport datetime\rimport smtplib\rfrom email.mime.text import MIMEText\rfrom email.header import Header\rdef send_email(status, email, abbr, now_time):\rmail_host = \"smtp.qq.com\" #现在是qq邮箱\r mail_user = \"xxxxxxx\" #**发送打卡信息的邮箱**\r mail_pass = \"xxxxxxx\" #**邮箱授权码**\r sender = 'xxxxxxx' #**邮件发送方的邮箱**\r receivers = [] # 接收邮件方\r receivers.append(email)\rif status: text = '打卡成功！！！'\relse : text = '打卡失败 T_T，请手动打卡'\rmessage = MIMEText(text + '今天是' + now_time + '\\n如有信息变动，请即时反馈\\n如果有一天没收到邮件请手动打卡', 'plain', 'utf-8')\rmessage['From'] = Header(\"xxxxxxx\", 'utf-8') #**邮件发送方的名字（自定义）**\r message['To'] = Header(abbr, 'utf-8')\rsubject = text\rmessage['Subject'] = Header(subject, 'utf-8')\rtry:\rsmtpObj = smtplib.SMTP_SSL()\rsmtpObj.connect(mail_host, 465) #在阿里云上要用465端口和ssl\r smtpObj.login(mail_user, mail_pass)\rsmtpObj.sendmail(sender, receivers, message.as_string())\rprint(\"邮件发送成功\")\rexcept smtplib.SMTPException:\rprint(\"Error: 无法发送邮件\")\rdef daka(user_data):\rsession = requests.Session()\rheaders = {\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rlogin_url = 'http://ids.hhu.edu.cn/amserver/UI/Login'\ruser = user_data['user_name']\rpassword = user_data['password']\rdata = {\r'Login.Token1': user,\r'Login.Token2': password,\r'goto': 'http://my.hhu.edu.cn/loginSuccess.portal',\r'gotoOnFail': 'http://my.hhu.edu.cn/loginFailure.portal'\r}\rlogin_response_text = session.post(url=login_url, headers=headers, data=data).text\rif 'handleLoginSuccessed' in login_response_text:\rprint('登录成功')\relse:\rprint('登录失败，请修改用户名和密码重新登录')\rsys.exit()\rui_url = 'http://form.hhu.edu.cn/pdc/form/list'\rsession.get(url=ui_url, headers=headers)\rform_url = 'http://form.hhu.edu.cn/pdc/formDesignApi/initFormAppInfo'\rdata = {\r'selfFormWid': 'A335B048C8456F75E0538101600A6A04'\r}\rform_response = session.post(url=form_url, data=data, headers=headers)\rprint('获得表单界面状态码', form_response.status_code)\rpost_url = 'http://form.hhu.edu.cn/pdc/formDesignApi/dataFormSave?wid=A335B048C8456F75E0538101600A6A04\u0026userId=' + user\rnow_time = datetime.datetime.now().strftime('%Y/%m/%d')\rdata = {\r'DATETIME_CYCLE': now_time,\r'XGH_336526': user_data['XGH_336526'],\r'XM_1474': user_data['XM_1474'],\r'SFZJH_859173': user_data['SFZJH_859173'],\r'SELECT_941320': user_data['SELECT_941320'],\r'SELECT_459666': user_data['SELECT_459666'],\r'SELECT_814855': user_data['SELECT_814855'],\r'SELECT_525884': user_data['SELECT_525884'],\r'SELECT_125597': user_data['SELECT_125597'],\r'TEXT_950231': user_data['TEXT_950231'],\r'TEXT_937296': user_data['TEXT_937296'],\r'RADIO_853789': '否',\r'RADIO_43840': '否',\r'RADIO_579935': '健康',\r'RADIO_138407': '是',\r'RADIO_546905':'',\r'RADIO_314799':'',\r'RADIO_209256':'',\r'RADIO_836972':'',\r'RADIO_302717':'',\r'RADIO_701131':'',\r'RADIO_438985':'',\r'RADIO_467360':'',\r'PICKER_956186':'',\r'TEXT_434598':'',\r'TEXT_515297':'',\r'TEXT_752063':''\r}\rpost_response = session.post(url=post_url, data=data, headers=headers)\rprint('提交表单后状态码', post_response.status_code)\rfinal_text = post_response.text\rprint(final_text)\rif 'true' in final_text:\rprint('今天是: ', now_time)\rprint('打卡成功!!!')\rsend_email(True, user_data['email'], user_data['abbr'], now_time)\rreturn True\relse:\rprint('打卡失败')\rreturn False\rif __name__ == '__main__':\rusers = []\ruser2 = {\r'name' : 'xxxxxxx', #**打卡者姓名（为了区分不同打卡者）**\r 'user_name' : 'xxxxxxx', #**用户名（一般是学号）**\r 'password' : 'xxxxxxx', #**密码**\r 'XGH_336526': 'xxxxxxx', #**学号**\r 'XM_1474': 'xxxxxxx', #**姓名**\r 'SFZJH_859173': 'xxxxxxx', #**身份证号**\r 'SELECT_941320': 'xxxxxxx', #**学院（只能是选择列表中的值，比如：计信院）**\r 'SELECT_459666': 'xxxxxxx', #**年级（只能是选择列表中的值，比如：2019级）**\r 'SELECT_814855': 'xxxxxxx', #**专业（只能是选择列表中的值，比如：计算机）**\r 'SELECT_525884': 'xxxxxxx', #**班级（只能是选择列表中的值，比如：计算机19_2）**\r 'SELECT_125597': 'xxxxxxx', #**宿舍楼（只能是选择列表中的值，比如：江宁校区教学区25舍）**\r 'TEXT_950231': 'xxxxxxx', #**宿舍号，比如205**\r 'TEXT_937296': 'xxxxxxx', #**手机号码**\r 'email' : 'xxxxxxx', #**将打卡信息发送至这个邮箱**\r 'abbr' : 'xxxxxxx' #**名字缩写（用作邮件接受者的名字）**\r }\ruser1 = {\r'name' : 'xxxxxxx', #**打卡者姓名（为了","date":"2020-08-11","objectID":"/hhu_spider/:1:4","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"hhu查成绩脚本（新版教务系统） ","date":"2020-08-11","objectID":"/hhu_spider/:2:0","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"环境 必装环境 python , chaojiying_api , selenium , chromedriver , requests 推荐环境 anaconda , pycharm ","date":"2020-08-11","objectID":"/hhu_spider/:2:1","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"功能说明 查本学期成绩（可以通过修改源码变成查所有成绩）、查绩点排名 ","date":"2020-08-11","objectID":"/hhu_spider/:2:2","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"使用方法 把#**XXXX**按XXXX提示改成自己的信息 在chaojiying.py中填写自己的账号和密码 在主程序中可以修改要查成绩的学年学期，按{}中的值填写，对应关系如下 2020-2021学年1 {2020-2021-1-1} 2019-2020学年2 {2019-2020-2-1} 2019-2020学年1 {2019-2020-1-1} 2018-2019学年2 {2018-2019-2-1} 2018-2019学年1 {2018-2019-1-1} 运行 ","date":"2020-08-11","objectID":"/hhu_spider/:2:3","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"代码 chaojiying_Python/chaojiying.py #!/usr/bin/env python\r # coding:utf-8\r import requests\rfrom hashlib import md5\rclass Chaojiying_Client(object):\rdef __init__(self, username, password, soft_id):\rself.username = username\rpassword = password.encode('utf-8')\rself.password = md5(password).hexdigest()\rself.soft_id = soft_id\rself.base_params = {\r'user': self.username,\r'pass2': self.password,\r'softid': self.soft_id,\r}\rself.headers = {\r'Connection': 'Keep-Alive',\r'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)',\r}\rdef PostPic(self, im, codetype):\r\"\"\"\rim: 图片字节\rcodetype: 题目类型 参考 http://www.chaojiying.com/price.html\r\"\"\"\rparams = {\r'codetype': codetype,\r}\rparams.update(self.base_params)\rfiles = {'userfile': ('ccc.jpg', im)}\rr = requests.post('http://upload.chaojiying.net/Upload/Processing.php', data=params, files=files, headers=self.headers)\rreturn r.json()\rdef ReportError(self, im_id):\r\"\"\"\rim_id:报错题目的图片ID\r\"\"\"\rparams = {\r'id': im_id,\r}\rparams.update(self.base_params)\rr = requests.post('http://upload.chaojiying.net/Upload/ReportError.php', data=params, headers=self.headers)\rreturn r.json()\rdef main():\rchaojiying = Chaojiying_Client('xxxxxx', 'xxxxxx', '912462') #用户中心\u003e\u003e软件ID 生成一个替换 96001\r im = open('chaojiying_Python/captcha.png', 'rb').read() #本地图片文件路径 来替换 a.jpg 有时WIN系统须要//\r return chaojiying.PostPic(im, 1902)['pic_str'] #1902 验证码类型 官方网站\u003e\u003e价格体系 3.4+版 print 后要加()\r 主程序 import requests\rimport chaojiying_Python.chaojiying as cjy\rfrom selenium import webdriver\rfrom time import sleep\rfrom PIL import Image\rfrom lxml import etree\rimport sys\rimport re\rfrom selenium.webdriver.chrome.options import Options\rdef main():\rid = 'xxxxxxx' #**学号**\r pwd = 'xxxxxxx' #**密码**\r chrome_options = Options()\rchrome_options.add_argument('--headless')\rchrome_options.add_argument('--disable-gpu')\rproxy_ip = {\"http\": '183.166.70.155:9999'}\rbrowser = webdriver.Chrome(executable_path='chromedriver.exe', chrome_options=chrome_options)\r#chrome \u003e 79\r browser.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", {\r\"source\": \"\"\"\rObject.defineProperty(navigator, 'webdriver', {\rget: () =\u003e undefined\r})\r\"\"\"\r})\rbrowser.maximize_window()\rlogin_url = 'http://202.119.114.197/login'\rbrowser.get(url=login_url)\rsleep(2)\r# browser.quit()\r browser.save_screenshot('login_interface.png')\rcaptcha_img_ele = browser.find_element_by_xpath('//*[@id=\"captchaImg\"]')\rlocation = captcha_img_ele.location # 左上角\r size = captcha_img_ele.size\rscale = 1\rcaptcha_coordinates = (\rint(location['x']) * scale, int(location['y']) * scale, int(location['x'] + size['width']) * scale,\rint(location['y'] + size['height']) * scale)\ri = Image.open('login_interface.png')\rframe = i.crop(captcha_coordinates)\rframe.save('chaojiying_Python/captcha.png')\rcaptcha_val = cjy.main()\r# print(captcha_val)\r id_input = browser.find_element_by_xpath('//*[@id=\"input_username\"]')\rid_input.send_keys(id)\rpwd_input = browser.find_element_by_xpath('//*[@id=\"input_password\"]')\rpwd_input.send_keys(pwd)\rcaptcha_input = browser.find_element_by_xpath('//*[@id=\"input_checkcode\"]')\rcaptcha_input.send_keys(captcha_val)\rlogin_button = browser.find_element_by_xpath('//*[@id=\"loginButton\"]')\rlogin_button.click()\rif 'errorCode=badCredentials' in browser.current_url:\rprint('用户名或密码错，请重新登录')\rbrowser.quit()\rsys.exit()\rif 'errorCode=badCaptcha' in browser.current_url:\rprint('验证码错，请重新登录')\rbrowser.quit()\rsys.exit()\rcookies = browser.get_cookies()\rquery_url = 'http://202.119.114.197/student/integratedQuery/scoreQuery/allTermScores/data'\rdata = {\r'zxjxjhh': '2020-2021-1-1', #**此处可以修改要查成绩的学年学期**\r 'kch': '',\r'kcm': '',\r'pageNum': '1',\r'pageSize': '30'\r}\rheaders = {\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.146 Safari/537.36'\r}\rsession = requests.Session()\rfor cookie in cookies:\rsession.cookies.set(cookie['name'], cookie['value'])\rreports = session.post(url=query_url, data=data, headers=headers).json()['list']['records']\r# print(reports)\r gpa_url = 'http://202.1","date":"2020-08-11","objectID":"/hhu_spider/:2:4","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"Python爬虫","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"urllib模块 不使用 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:1:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"requests模块 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"获得网页源码 import requests\rurl = 'https://dyhgo.fun'\rresponse = requests.get(url)\rprint(response.text)\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"带参数的url和UA伪装 #测试一下带参数的url和ua伪装\r import requests\rurl = 'https://www.baidu.com/s'\rname = input('输入您要搜索的内容，我们将返回百度搜索该信息的网页源码')\rparams = {\r'wd' : name\r}\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.get(url=url, params=params, headers=headers)\rprint(response.text)\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：有道翻译查词 #有道翻译的结果获取，查询look单词并将结果存储\r import requests\rimport json\rparams = {\r'i': 'look',\r'from': 'AUTO',\r'to': 'AUTO',\r'smartresult': 'dict',\r'client': 'fanyideskweb',\r'salt': '16119129043609',\r'sign': '288cdf16af5fa68411381ba3c9f7f874',\r'lts': '1611912904360',\r'bv': '44a53b4124e8b822ebfd881c5a599938',\r'doctype': 'json',\r'version': '2.1',\r'keyfrom': 'fanyi.web',\r'action': 'FY_BY_REALTlME'\r}\rurl = 'http://fanyi.youdao.com/translate_o?smartresult=dict\u0026smartresult=rule'\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.post(url=url, data=params, headers=headers)\rf = open('look.json', 'w', encoding='utf-8')\rjson.dump(response.json(), fp=f, ensure_ascii=False)\rf.close()\rprint(response.json())\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:3","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：获取豆瓣影单 网站链接 #获取豆瓣影单\r import requests\rimport json\rurl = 'https://movie.douban.com/j/chart/top_list'\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rparams = {\r'type': '24',\r'interval_id': '100:90',\r'action':'',\r'start': '1',\r'limit': '2'\r}\rresponse = requests.get(url=url, params=params, headers=headers)\rlist_data = response.json()\rf = open('douban.json', 'w', encoding='utf-8')\rjson.dump(list_data, fp=f, ensure_ascii=False)\rf.close()\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:4","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：kfc餐厅信息 网站链接 #kfc餐厅信息\r import requests\rurl = 'http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword'\rparams = {\r'cname':'',\r'pid':'',\r'keyword': '上海',\r'pageIndex': '1',\r'pageSize': '10'\r}\rheaders = {\r'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.post(url=url, data=params, headers=headers)\rprint(response.text)\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:5","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：药监局相关信息 注意数据由ajax加载 网站链接 #药监局相关数据\r import requests\rimport json\rurl1 = 'http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsList'\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rdata = {\r'on': 'true',\r'page': '1',\r'pageSize': '15',\r'productName':'',\r'conditionType': '1',\r'applyname':'',\r'applysn':''\r}\rid_list = []\rresponse = requests.post(url=url1, data=data, headers=headers).json()['list']\rfor i in response:\rid_list.append(i['ID'])\r#print(id_list)\r detail_list = []\rurl2 = 'http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById'\rfor id in id_list:\rdata = {\r'id' : id\r}\rresponse = requests.post(url=url2, data=data, headers=headers).json()\rdetail_list.append(response)\r#print(response)\r with open('yaojianju.json', 'w', encoding='utf-8') as f:\rjson.dump(detail_list, fp=f, ensure_ascii=False, indent=True)\rprint('over')\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:6","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"数据解析 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:3:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"正则 基础用法参考此处 案例：下载糗事百科图片 网站链接 #下载糗事百科的图片\r import requests\rurl = 'https://pic.qiushibaike.com/system/pictures/12402/124029001/medium/J8FFRWUK30TM3X79.jpg'\rheader = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.get(url=url, headers=header)\rimage = response.content\rwith open('qiutu.jpg', 'wb') as f:\rf.write(image)\rprint('over')\r 案例：批量下载糗事百科图片 网站链接 #用正则表达式下载图片（可批量下载）\r # \u003cdiv class=\"thumb\"\u003e\r #\r # \u003ca href=\"/article/124031033\" target=\"_blank\"\u003e\r # \u003cimg src=\"//pic.qiushibaike.com/system/pictures/12403/124031033/medium/V35P60R0KM4YCY3Q.jpg\" alt=\"糗事#124031033\" class=\"illustration\" width=\"100%\" height=\"auto\"\u003e\r # \u003c/a\u003e\r # \u003c/div\u003e\r import requests\rimport re\rurl = 'https://www.qiushibaike.com/imgrank/'\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.get(url=url, headers=headers).text\r#print(response)\r regex = '\u003cdiv class=\"thumb\"\u003e.*?\u003cimg src=\"(.*?)\" alt.*?\u003c/div\u003e'\rimg_list = re.findall(regex, response, re.S)\r#print(img_list)\r img_url = 'https:' + img_list[0]\r#print(img_url)\r response = requests.get(url=img_url, headers=headers).content\r#print(type(response))\r with open('qiutu2.jpg', 'wb') as f :\rf.write(response)\rprint('download successfully')\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:3:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"bs4 BeautifulSoup解析本地html #beautifulsoup解析本地html\r from bs4 import BeautifulSoup\rimport requests\rwith open('test.html', 'r', encoding='utf-8') as f:\rbs = BeautifulSoup(f, 'lxml')\rprint(bs)\r BeautifulSoup解析当前获得的html源码 #beautifulsoup解析当前获得的html源码\r from bs4 import BeautifulSoup\rimport requests\rurl = 'https://dyhgo.fun'\rprint(BeautifulSoup(requests.get(url=url).text, 'lxml'))\r BeautifulSoup的使用 #beautifulsoup的使用，挺复杂的\r from bs4 import BeautifulSoup\rwith open('forbsfor.html', 'r', encoding='utf-8') as f:\rbs = BeautifulSoup(f, 'lxml')\rprint(bs)\rprint(bs.a) #print fitst a tag\r print(bs.div)\rprint(bs.find('div')) #same as bs.div\r print(bs.find('div', class_='header-title')) #find tag by attribute, notice class\r print(bs.find('div', id = 'menu-toggle-mobile'))\rprint(bs.find_all('a')) #get a list of all 'a' tags\r #css selector\r print(bs.select('.page-item')) #a list of tags which of class is 'page-item'\r print(bs.select('.header-wrapper \u003e .header-title \u003e a[0]')) #wrong statement\r print(bs.select('.header-wrapper \u003e .header-title \u003e a')[0]) #means level, return a list of all 'a' tags\r print(bs.select('.header-wrapper a')[0]) #space means cross level\r #get context or attribute\r print(bs.select('.header-wrapper a')[0].text)\rprint(bs.select('.header-wrapper a')[0].get_text())\rprint(bs.select('.header-wrapper a')[0].string)\rprint(bs.select('.header-title')[0].text) #get all text between this tag\r print(bs.select('.header-title')[0].get_text())\rprint(bs.select('.header-title')[0].string) #get direct text between this tag\r print(bs.select('.header-wrapper \u003e .header-title \u003e a')[0]['title'])\r 案例：爬取《三国演义》内容 网站链接 #爬取三国演义的内容\r import requests\rfrom bs4 import BeautifulSoup\rurl = 'https://www.shicimingju.com/book/sanguoyanyi.html'\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.get(url=url, headers=headers).text\rbs = BeautifulSoup(response, 'lxml')\r#mulu = bs.find('div', class_='book-mulu')\r a_list = bs.select('.book-mulu \u003e ul \u003e li \u003e a')\r#print(a_list)\r f = open('sanguo.txt', 'a', encoding='utf-8')\rfor a in a_list[:3]:\rtitle = a.string.encode('iso-8859-1').decode('utf-8')#.encode('iso-8859-1')\r #print(title)\r url_detail = 'https://www.shicimingju.com/' + a['href']\r#print(url_detail)\r #response_detail = requests.get(url=url_detail, headers=headers).text.encode('iso-8859-1')\r # ！！！！！！notice this statement is more common\r response_detail = requests.get(url=url_detail, headers=headers)\rresponse_detail.encoding = response_detail.apparent_encoding\rresponse_detail = response_detail.text\rbs = BeautifulSoup(response_detail, 'lxml')\rcontent_detail = bs.find('div', class_='chapter_content').text#.encode('iso-8859-1') # !!!!!text not string\r #print(type(content_detail))\r f.write(title + ':' + content_detail + '\\n')\r#print(content_detail)\r print(title + 'download successfully')\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:3:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"xpath 很常用 基本用法 from lxml import etree\rimport requests\rparser = etree.HTMLParser()\rurl = 'https://dyhgo.fun'\rresponse = requests.get(url=url).text\rtree = etree.HTML(response) #without etree.HTMLParser\r print(tree.xpath('/html/head/title/text()'))\r xpath语法 from lxml import etree\rparser = etree.HTMLParser()\rtree = etree.parse('forbsfor.html', parser=parser)\rr = tree.xpath('/html/head/meta') #return a list\r r = tree.xpath('/html//meta') # // means cross level\r r = tree.xpath('//div') # means all tags named div\r r = tree.xpath('//div[@class = \"header-wrapper\"]') #with condition\r r = tree.xpath('(//div[@class = \"header-wrapper\"])[2]') #second div which of class is header-wrapper !!! notice the index is started from 1\r r = tree.xpath('(//div[@class = \"header-wrapper\"])[1]/div/a/text()') #get DYH but doesn't work if replace '/div/' with '//'\r r = tree.xpath('(//div[@class = \"header-title\"])[1]//text()') # get ['\\r\\n ', 'DYH', '\\r\\n '] ok ! so '//text()' means all text and '/text()' means direct text\r r = tree.xpath('(//div[@class = \"header-title\"])[1]/a/@title') # get attribute of \u003ca\u003e\r print(r)\r 案例：获取58同城二手房信息 网站链接 #爬取58信息 notice : the info on website is random\r import requests\rfrom lxml import etree\rurl = 'https://bj.58.com/ershoufang/'\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.get(url=url, headers=headers).text\rtree = etree.HTML(response)\rdiv_list = tree.xpath('(//section[@class = \"list\"])[1]/div')\r#print(div_list)\r for div in div_list:\rtitle = div.xpath('./a/div[@class = \"property-content\"]//h3/@title')[0] # '..' means upper level\r print(title)\r xpath或运算（案例：获取所有城市名称） 网站链接 #所有城市 xpath 与或运算\r import requests\rfrom lxml import etree\rurl = 'https://www.aqistudy.cn/historydata/'\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.get(url=url, headers=headers).text\rtree = etree.HTML(response)\ra_list = tree.xpath('//div[@class = \"bottom\"]/ul/li/a | //div[@class = \"bottom\"]/ul/div[2]/li/a')\rcity_name = []\rfor a in a_list:\rcity_name.append(a.xpath('./text()')[0])\rprint(city_name, len(city_name))\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:3:3","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"验证码识别 使用超级鹰api 链接 点击此处下载Python版api 使用示例如下 import requests\rfrom lxml import etree\rimport chaojiying_Python.chaojiying as rec\rurl = 'https://so.gushiwen.cn/user/login.aspx?from=http://so.gushiwen.cn/user/collect.aspx'\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rresponse = requests.get(url=url, headers=headers).text\rtree = etree.HTML(response)\rimg_url = 'https://so.gushiwen.cn/' + tree.xpath('//*[@id=\"imgCode\"]/@src')[0]\rresponse = requests.get(url=img_url, headers=headers).content\rwith open('chaojiying_Python/b.png', 'wb') as f:\rf.write(response)\rprint(rec.main())\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:4:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"cookie(模拟登录） 案例：登录牛客竞赛网 #session can keep cookie\r import requests\rurl = 'https://www.nowcoder.com/nccommon/login/do?token='\rsession = requests.Session()\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36',\r}\rdata = {\r'email': 'xxxxxxx', #登录账号（手机或邮箱）\r 'remember': 'false',\r'cipherPwd': 'xxxxxxxxx' #加密后的密码（可通过抓包获取）\r }\rresponse = session.post(url=url, headers=headers, data=data)\rprint(response.status_code)\rpage_src = response.text\rprofile_url = 'https://ac.nowcoder.com/sns/message/90625985/conversation-list?#/'\rprofile_resopnse = session.get(url=profile_url, headers=headers)\rprint(profile_resopnse.status_code)\rprofile_src = profile_resopnse.text\rwith open('wangye2.html', 'w', encoding='utf-8') as f:\rf.write(profile_src)\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:5:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"代理ip 代理ip的网站（大多数不好用） 代理ip池的github仓库 #use proxy ip\r import requests\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36',\r}\rsrc = requests.get(url='http://www.baidu.com/s?wd=ip', headers=headers, proxies={\"https\" : '183.166.102.222:9999'}).text\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:6:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"异步爬虫 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:7:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"进程池 from multiprocessing.dummy import Pool\rimport time\rdef tst(str):\rprint(str, 'doing')\rtime.sleep(2)\rprint(str, 'done')\rpool = Pool(3)\rsta = time.time()\rlis = ['aa', 'bb', 'cc', 'dd']\rpool.map(tst, lis)\red = time.time()\rprint(ed - sta) #4s\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:7:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：爬取梨视频网站视频 网站链接 #https://video.pearvideo.com/mp4/third/20210201/cont-1718821-15765543-134934-hd.mp4\r #https://video.pearvideo.com/mp4/third/20210201/1612279360957-15765543-134934-hd.mp4\r #pearvideo\r import requests\rfrom lxml import etree\rimport random\rfrom multiprocessing.dummy import Pool\rheaders = {\r'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'\r}\rurl = 'https://www.pearvideo.com/category_5'\rpage_src = requests.get(url=url, headers=headers).text\rtree = etree.HTML(page_src)\rli_list = tree.xpath('//ul[@id = \"listvideoListUl\"]/li')\rvd_list = []\rfor li in li_list:\rif li == li_list[0]:\rcontinue\r#detail_url = 'https://www.pearvideo.com/' + li.xpath('./div/a/@href')[0]\r video_id = li.xpath('./div/a/@href')[0][6:]\rvideo_name = li.xpath('./div/a/div[@class = \"vervideo-title\"]/text()')[0] + '.mp4'\r#print(video_id, video_name)\r detail_url = 'https://www.pearvideo.com/videoStatus.jsp'\rparams = {\r'contId' : video_id,\r'mrd' : str(random.random())\r}\rnew_headers = {\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36',\r'Referer' : 'https://www.pearvideo.com/video_' + video_id\r}\rvideo_dict = requests.get(url=detail_url, headers=new_headers, params=params).json()\rraw_url = video_dict['videoInfo']['videos']['srcUrl']\r#print(raw_url, video_name)\r left = raw_url.rfind('/')\rright = raw_url.find('-')\rtrue_url = raw_url.replace(raw_url[left + 1 : right], 'cont-' + video_id)\r#print(true_url, video_name)\r vd = {\r'name' : video_name,\r'url' : true_url\r}\rvd_list.append(vd)\rdef store(vd):\rurl = vd['url']\rname = vd['name']\rdat = requests.get(url=url, headers=headers).content\rprint(name, 'downloading')\rwith open(name, 'wb') as f:\rf.write(dat)\rprint(name, 'done')\rpool = Pool(4)\rpool.map(store, vd_list)\rpool.close()\rpool.join()\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:7:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"selenium模块 以chrome为例 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"安装驱动 根据chrome的版本安装相应的chromedriver 链接 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"基本用法 windows系统 from selenium import webdriver\rfrom lxml import etree\rimport time\rbrowser = webdriver.Chrome(executable_path='chromedriver.exe')\rbrowser.get(url='http://scxk.nmpa.gov.cn:81/xk/')\rpage_src = browser.page_source\rtree = etree.HTML(page_src)\rli_list = tree.xpath('//ul[@id=\"gzlist\"]/li')\rfor li in li_list:\rname = li.xpath('./dl/@title')[0]\rprint(name)\rtime.sleep(5)\rbrowser.quit()\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"一些操作 from selenium import webdriver\rimport time\rbrowser = webdriver.Chrome(executable_path='chromedriver.exe')\rbrowser.maximize_window()\rbrowser.get(url='https://www.taobao.com/')\rtime.sleep(1)\rsearch_input = browser.find_elements_by_id('q')[0]\rsearch_input.send_keys('ipad')\rtime.sleep(1)\rbtn = browser.find_elements_by_css_selector('.btn-search')[0]\rbtn.click()\rtime.sleep(1)\rbrowser.execute_script('window.scrollTo(0, document.body.scrollHeight)')\rtime.sleep(2)\rbrowser.get('https://dyhgo.fun')\rtime.sleep(5)\rbrowser.back()\rtime.sleep(2)\rbrowser.forward()\rtime.sleep(2)\rtime.sleep(3)\rbrowser.quit()\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:3","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"无头浏览器 #phantomJs also works\r from selenium import webdriver\rimport time\rfrom selenium.webdriver.chrome.options import Options\rchrome_options = Options()\rchrome_options.add_argument('--headless')\rchrome_options.add_argument('--disable-gpu')\rbrowser = webdriver.Chrome(executable_path='chromedriver.exe', chrome_options=chrome_options)\rbrowser.get(url='https://dyhgo.fun')\rpage_src = browser.page_source\rtime.sleep(2)\rprint(page_src)\rbrowser.quit()\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:4","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"规避检测 版本chrome \u003c= 79 from selenium import webdriver\rimport time\rfrom selenium.webdriver import ChromeOptions\roption = ChromeOptions()\roption.add_experimental_option('excludeSwitches', ['enable-automation'])\rbrowser = webdriver.Chrome(executable_path='chromedriver.exe', options=option)\rbrowser.get(url='https://dyhgo.fun')\rpage_src = browser.page_source\rtime.sleep(2)\rprint(page_src)\rbrowser.quit()\r 版本chrome \u003e 79 from selenium import webdriver\rimport time\rbrowser = webdriver.Chrome(executable_path='chromedriver.exe')\rbrowser.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", {\r\"source\": \"\"\"\rObject.defineProperty(navigator, 'webdriver', {\rget: () =\u003e undefined\r})\r\"\"\"\r})\rbrowser.get(url='https://dyhgo.fun')\rpage_src = browser.page_source\rtime.sleep(2)\rprint(page_src)\rbrowser.quit()\r ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:5","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"scrapy框架 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:9:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"hhu爬虫 （已停止维护） ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:10:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"hhu健康打卡脚本（假期版） ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:10:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"hhu查成绩脚本（新版教务系统） 点击此处 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:10:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["abc"],"content":"abc173","date":"2020-07-06","objectID":"/abc173/","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"A - Payment ","date":"2020-07-06","objectID":"/abc173/:0:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std;\rint main(){\rint n;\rcin\u003e\u003en;\rint i=1000;\rwhile(i\u003cn){\ri+=1000;\r}\rcout\u003c\u003ci-n;\rreturn 0;\r}\r B - Judge Status Summary ","date":"2020-07-06","objectID":"/abc173/:1:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std;\rconst int maxn = 1e5+2;\rint wa,tle,ac,re;\rint main(){\rint n;\rcin\u003e\u003en;\rwhile(n--){\rstring s;\rcin\u003e\u003es;\rswitch(s[0]){\rcase 'A':{\rac++;\rbreak;\r}\rcase 'W':{\rwa++;\rbreak;\r}\rcase 'T':{\rtle++;\rbreak;\r}\rdefault:{\rre++;\rbreak;\r}\r}\r}\rcout\u003c\u003c\"AC x \"\u003c\u003cac\u003c\u003cendl\u003c\u003c\"WA x \"\u003c\u003cwa\u003c\u003cendl\u003c\u003c\"TLE x \"\u003c\u003ctle\u003c\u003cendl\u003c\u003c\"RE x \"\u003c\u003cre\u003c\u003cendl;\rreturn 0;\r}\r C - H and V ","date":"2020-07-06","objectID":"/abc173/:2:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std;\rchar a[7][7];\rchar b[7][7];\rint n,m;int k;\rvoid row(int x){\rfor(int i=0;i\u003cm;i++){\rb[x][i] = '.';\r}\r}\rvoid col(int x){\rfor(int i=0;i\u003cn;i++){\rb[i][x] = '.';\r}\r}\rvoid sol(int x,int y){\rfor(int i=0;i\u003cn;i++){\rif(x\u003e\u003ei\u00261){\rrow(i);\r}\r}\rfor(int j=0;j\u003cm;j++){\rif(y\u003e\u003ej\u00261){\rcol(j);\r}\r}\r}\rint cal(){\rint ans =0;\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003cm;j++){\rif(b[i][j] == '#') ans++;\r}\r}\rreturn ans;\r}\rint main(){\rcin\u003e\u003en\u003e\u003em;cin\u003e\u003ek;\rchar c;\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003cm;j++){\rcin\u003e\u003ea[i][j];\r}\r}\rint ans = 0;\rfor(int i=0;i\u003c(1\u003c\u003cn);i++){\rfor(int j=0;j\u003c(1\u003c\u003cm);j++){\rmemcpy(b,a,sizeof(a));\rsol(i,j);\rif (cal() == k) ans++;\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - Chat in a Circle ","date":"2020-07-06","objectID":"/abc173/:3:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std;\rusing ll = long long;\rll a[200005];\rll n;\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\rsort(a,a+n,[](int a,int b){return a\u003eb;});\rif(n==2) {\rcout\u003c\u003ca[0]\u003c\u003cendl;\rexit(0);\r}\rn--;\rll t;\rll q = n;\rif(n\u00261){\rt = (n-1)/2;\rt++;\r}\relse{\rn++;\rt = (n-1)/2;\rt++; }\rll ans = a[0];\rfor(ll i=1;i\u003ct;i++){\rans += 2LL * a[i];\r}\rif(q%2 == 0){\rans -= a[t-1];\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - Multiplication 4 ","date":"2020-07-06","objectID":"/abc173/:4:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll a[200005];\rll n,k;\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\rsort(a,a+n);\rint L = 0,R = n-1;\rif(k\u00261){\rif(a[n-1] \u003c 0){\rll ans = 1;\rfor(int i=n-1;i\u003e=n-k;i--){\rans *= a[i];\rans %= mod;\r}\rif(ans \u003c 0) cout\u003c\u003cans+mod\u003c\u003cendl;else cout\u003c\u003cans\u003c\u003cendl;\rexit(0);\r}\rR--,k--;\r}\rwhile(k){\rll lv = a[L] * a[L+1];\rll rv = a[R] * a[R-1];\rif(lv \u003c rv){\rR -= 2;\r} else L += 2;\rk -= 2;\r}\rll ans = 1;\rfor(int i=0;i\u003cL;i++){\rans *= a[i];\rans %= mod;\r}\rfor(int i=R+1;i\u003cn;i++){\rans *= a[i];\rans %= mod;\r}\rif(ans \u003c 0) cout\u003c\u003cans+mod\u003c\u003cendl;\relse cout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F - Intervals on Tree ","date":"2020-07-06","objectID":"/abc173/:5:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 对于一个森林，点和边对连通图个数的贡献是每个点+1，每条边-1 所以计算点被遍历几次，边被遍历几次 这与区间的左右数字个数有关 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint n;\rint main(){\rll ans = 0;\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++){\rans += (ll)i * (n-i+1);\r}\rint _ = n;\r_--;\rwhile(_--){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rif(a \u003e b) swap(a,b);\rans -= (ll)a * (n-b+1);\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-07-06","objectID":"/abc173/:6:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["problemlist"],"content":"某不科学的暑假做题记录","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"简单思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 直接法，注意数组大小爆long long #include\u003cbits/stdc++.h\u003e\rusing ll = long long;\rconst ll mod = 1e6+3;\rll fac[mod+2];\rint main(){\rfac[0] = 1LL;\rfac[1] = 1LL;\rfor(ll i=2;i\u003cmod+2;i++){\rfac[i] = i*fac[i-1];\rfac[i] %= mod;\r}\rll n;\rwhile(std::cin\u003e\u003en){\rif(n\u003e=mod) puts(\"0\");else\rstd::cout\u003c\u003cfac[n]\u003c\u003cstd::endl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 排列组合 容斥原理 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 并查集模拟操作 每次的答案依赖于上一次的答案 对于当前给出的两个数 如果在一个集合内，则 ans = ans 如果不在一个集合内，假设一个在A集合，一个在B集合 num(S) 表示满足条件S的方案数 四元组为 Q 并查集的集合为 U 设合并A、B后的集合为C ans -= num(∃q ∈ Q , (q∈A) ∧ (Q\\q ∈ U\\(A , B) ) ) ans -= num(∃q ∈ Q , (q∈B) ∧ (Q\\q ∈ U\\(A , B) ) ) ans -= num(∃q1,q2 ∈ Q , (q1 ∈ A) ∧ (q2 ∈ B) ∧ (Q\\(q1 , q2) ∈ U\\(A , B) ) ans += num(∃q ∈ Q , (q ∈ C) ∧ (Q\\q ∈ U\\C) ) 由于12式和4式相抵消，所以实际只要操作3式 由于3式需要在并查集中选两个的方案数，所以维护两个变量 ans two (在并查集中选两个元素的方案数，选的元素可重复) 利用容斥原理和排列组合 num(∃q1,q2 ∈ Q , (q1 ∈ A) ∧ (q2 ∈ B) ∧ (Q\\(q1 , q2) ∈ U\\(A , B) ) = size(A) * size(B) * (two - (size(A) * (n - size(A)) - (size(B) * (n - size(B)) + size(A) * size(B) ) 更新完ans后更新two 初始化 ans = C(n,4) two = C(n,2) 数据规模大，用unsigned long long 注意这样初始化 ll ans = n*(n-1)/4*(n-2)/3*(n-3)/2; 而不是 ll ans = n*(n-1)*(n-2)*(n-3)/24; #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = unsigned long long;\r//using ld = long double;\rconst int maxn = 1e5+3;\rll n,m;\rll par[maxn]; ll rankk[maxn]; ll sizz[maxn];\rvoid init(ll n) {\rfor(ll i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\rfill(sizz,sizz+n,1);\r} ll find(ll x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); } void unite(ll x,ll y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y,sizz[y]+=sizz[x]; else\r{\rpar[y]=x;\rsizz[x]+=sizz[y];\rif(rankk[x]==rankk[y]) rankk[x]++; } } bool same(ll x,ll y)\r{\rreturn find(x)==find(y);\r}\rint main(){\rcin\u003e\u003en\u003e\u003em;\rll two = n*(n-1)/2;\rll ans = n*(n-1)/4*(n-2)/3*(n-3)/2; cout\u003c\u003cans\u003c\u003cendl;\rinit(n);\rfor(ll i=0;i\u003cm;i++){\rll x,y;\rcin\u003e\u003ex\u003e\u003ey;\rx--,y--;\rif(!same(x,y)){\rll szx = sizz[find(x)];\rll szy = sizz[find(y)];\rans -= (szx * szy * (two - szx * (n - szx) - szy * (n - szy) + szx * szy));\rtwo -= szx * szy;\runite(x,y);\rcout\u003c\u003cans\u003c\u003cendl;\r}else cout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"kmp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 先找既是前缀又是后缀的最长子串 这可以利用kmp的next数组 然后去掉原串的头尾作为匹配串，由next数组得到的作为模式串 再进行kmp匹配，如果匹配不成功，则在模式串中取前next[len]的长度 不断重复，直到与匹配串匹配 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rchar s[100005],p[100005],pp[100005],ppp[100005];\rint n,m;\rint nextt[100005];\rvoid get_next(){\rint i=0,j=-1;\rnextt[0]=-1;\rwhile(i\u003cm){\rif(j==-1 || p[i]==p[j]) nextt[++i]=++j;\relse j=nextt[j]; //!!!\r }\r}\rint kmp(){\rint i=0,j=0;\rwhile(1){\rif(s[i]==p[j]) i++,j++;\relse{\rint t=nextt[j];\rif(t==-1) i++,j=0;\relse j=t;\r}\rif(j\u003e=m) return i-m; if(i\u003e=n) return -1;\r}\r}\rint main(){\rcin\u003e\u003ep;\rm = strlen(p);\rget_next();\rint len = nextt[m];\rstrncpy(pp,p,len);\rlen = strlen(p) - 2;\rstrncpy(s,p+1,len);\rstrcpy(p,pp);\rm = strlen(p);\rn = strlen(s);\rwhile(1){\rif(kmp()!=-1){\rcout\u003c\u003cp\u003c\u003cendl;\rbreak; }//else if(nextt[strlen(p)] == -1) break;\r else{\rstrncpy(ppp,p,nextt[strlen(p)]); //不能拷贝给自身\r strcpy(p,ppp);\rm = strlen(p);\r//cerr\u003c\u003cp\u003c\u003cendl;\r }\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"换根dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 dpd[u] 表示以u为根的子树的连通块数 dpu[u] 表示u之上的连通块数 ans[u] 表示包含u的连通块数 假设 v 是 u 的子节点，p 是 u 的父节点 ，s 是 u 的兄弟节点 dpd[u] = (dpd[v1] + 1) * (dpd[v2] + 1) * (dpd[v3] + 1) * ... ans[u] = dpd[u] * (dpu[u] + 1) dpu[u] = ans[p] / (dpd[u] + 1) 当 (dpd[u] + 1) % mod = 0 时，模数无效，所以这种情况要特殊处理 dpu[u] = (dpu[p] + 1) * (dpd[s1] + 1) * (dpd[s2] + 1) * ... 两次dfs，一次求dpd，一次求dpu并更新ans #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9 + 7;\rconst int maxn = 1e6 + 5;\rstruct edge{\rint to , next;\r}e[maxn\u003c\u003c1];\rll tot,head[maxn\u003c\u003c1];\rvoid add_edge(int u,int v){\re[tot].to = v;\re[tot].next = head[u];\rhead[u] = tot++;\r}\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll dpu[maxn],par[maxn],dpd[maxn],ans[maxn];\rll V;\rvoid dfs1(int u,int p){\rdpd[u] = 1;\rpar[u] = p;\rfor(int i=head[u]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == p) continue;\rdfs1(v,u);\rdpd[u] *= (dpd[v] + 1);\rdpd[u] %= mod;\r}\r}\rvoid dfs2(int u,int p){\rif(u != 1){\rif((dpd[u] + 1) % mod){\rdpu[u] = ans[p] * qpow(dpd[u] + 1 , mod - 2);\rdpu[u] %= mod;\rans[u] = dpd[u] * (dpu[u] + 1);\rans[u] %= mod;\r}\relse{\rll tmp = dpu[p] + 1;\rfor(int i=head[p]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == par[p] or v == u) continue;\rtmp *= dpd[v] + 1;\rtmp %= mod;\r}\rdpu[u] = tmp;\rans[u] = dpd[u] * (dpu[u] + 1);\rans[u] %= mod;\r}\r}\rfor(int i=head[u]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == p) continue;\rdfs2(v,u);\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rmemset(head,-1,sizeof(head));\rcin\u003e\u003eV;\rfor(int i=0;i\u003cV-1;i++){\rll x,y;\rcin\u003e\u003ex\u003e\u003ey;\radd_edge(x,y);\radd_edge(y,x);\r} dfs1(1,0);\rans[1] = dpd[1];\rdfs2(1,0);\rfor(int i=1;i\u003c=V;i++){\rcout\u003c\u003cans[i]\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"贪心 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把L大的放左边，把R大的放右边 假设L大的有a个，R大的有b个 可以把他们分开放置 先处理前a个位置（这些都放置L大的数） 再处理后b个位置（这些都放置R大的数） 对于前a个位置 遍历L大的集合（L大的排前面） 对于当前数，贪心地把它放在不超过k的最右边 如果不满足条件，就放在区间的最右边（此时放哪里，贡献都一样，为了给别的数腾出位置，贪心地放在最右边） 对于后b个位置 遍历R大的集合（R大的排前面） 对于当前数，贪心地把它放在超过k的最左边 如果不满足条件，就放在区间的最左边（此时放哪里，贡献都一样，为了给别的数腾出位置，贪心地放在最左边） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rvector\u003cpair\u003cint,int\u003e\u003e vL;\rvector\u003cpair\u003cint,int\u003e\u003e vR;\rint t;\rint n;\rset\u003cint\u003e sL;\rset\u003cint\u003e sR;\r#define fi first\r#define se second\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rll ans = 0;\rcin\u003e\u003en;\rvL.clear();\rvR.clear();\rfor(int i=0;i\u003cn;i++){\rint k,l,r;\rcin\u003e\u003ek\u003e\u003el\u003e\u003er;\rif(l\u003cr) vR.push_back({l-r,k});\relse vL.push_back({l-r,k});\rans += r;\r}\rfor(int i=1;i\u003c=vL.size();i++) sL.insert(i);\rfor(int i=vL.size()+1;i\u003c=n;i++) sR.insert(i);\rsort(vL.begin(),vL.end(),greater\u003cpair\u003cint,int\u003e\u003e());\rsort(vR.begin(),vR.end());\rfor(auto i:vL){\rauto tmp = sL.upper_bound(i.se);\rif(tmp == sL.begin()){\rsL.erase(--sL.end());\r}else{\rans += i.fi;\rsL.erase(--tmp);\r}\r}\rfor(auto i:vR){\rauto tmp = sR.upper_bound(i.se);\rif(tmp == sR.end()) {\rsR.erase(sR.begin());\rans += i.fi;\r}\relse{\rsR.erase(tmp);\r} }\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"栈 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 栈的经典应用 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a[10005];\rstack\u003cint\u003e sk;\rint ans[10005];\rint main(){\rll n;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003ea[i];\r}\rint i = 0;\rwhile(i \u003c n){\rif(sk.empty() or a[i] \u003c= a[sk.top()]){\rsk.push(i);\ri++;\r}\relse{\rans[sk.top()] = i;\rsk.pop();\r}\r}\rwhile(!sk.empty()){\rans[sk.top()] = -1;\rsk.pop();\r}\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cans[i]+1\u003c\u003c\" \"; cout\u003c\u003c\"\\n\";\rreturn 0;\r}\r ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"树链剖分 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 树链剖分裸题 线段树需支持区间平方和操作 这道题用int不能过 注意细节 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 1e5+10;\rstruct edge{ ll to,nxt;\r}e[maxn\u003c\u003c1]; struct tnode{ ll w,l,r,siz,alazy;\rll sq,mlazy=1LL;\r}tn[maxn\u003c\u003c2]; ll wch[maxn],sz[maxn],head[maxn],wt[maxn],dep[maxn],dfn[maxn],par[maxn],top[maxn],rdfn[maxn];\rll n,q;\rconst ll mod = 23333;\rll cnt_e; ll cnt_d; void add_edge(ll u,ll v){ e[++cnt_e].to = v; e[cnt_e].nxt = head[u]; head[u] = cnt_e;\r}\rvoid dfs1(ll u,ll p){ sz[u] = 1;\rfor(ll i = head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p){\rdep[t] = dep[u] + 1;\rpar[t] = u;\rdfs1(t,u);\rsz[u] += sz[t];\rif(sz[t] \u003e sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid dfs2(ll u,ll p,ll tp){ top[u] = tp;\rdfn[u] = ++cnt_d; rdfn[cnt_d] = u; if(wch[u]){ dfs2(wch[u],u,tp);\r}\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch[u]){\rdfs2(t,u,t); }\r}\r}\rvoid pushup(ll u){ tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod;\rtn[u].sq = (tn[u\u003c\u003c1].sq + tn[u\u003c\u003c1|1].sq) % mod;\r}\rvoid build(ll u,ll l,ll r){ tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[rdfn[l]]; tn[u].sq = wt[rdfn[l]] * wt[rdfn[l]];\rreturn ;\r}\rll mid = (l+r) \u003e\u003e 1;\rbuild(u\u003c\u003c1 , l , mid); build(u\u003c\u003c1|1 , mid+1 , r);\rpushup(u); }\rvoid pushdown(ll u){ if(tn[u].alazy != 0 or tn[u].mlazy != 1){\rtn[u\u003c\u003c1].sq = ((tn[u\u003c\u003c1].sq + 2LL * tn[u\u003c\u003c1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1].siz % mod) % mod; tn[u\u003c\u003c1|1].sq = ((tn[u\u003c\u003c1|1].sq + 2LL * tn[u\u003c\u003c1|1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1|1].siz % mod) % mod;\rtn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1].siz * tn[u].alazy % mod) % mod;\rtn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1|1].siz * tn[u].alazy % mod) % mod;\rtn[u\u003c\u003c1].alazy = (tn[u\u003c\u003c1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u003c\u003c1|1].alazy = (tn[u\u003c\u003c1|1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod;\rtn[u\u003c\u003c1].mlazy = (tn[u\u003c\u003c1].mlazy * tn[u].mlazy) % mod;\rtn[u\u003c\u003c1|1].mlazy = (tn[u\u003c\u003c1|1].mlazy * tn[u].mlazy) % mod;\rtn[u].alazy = 0; tn[u].mlazy = 1;\r}\r}\rll query(ll u,ll l,ll r,ll t){ if(l\u003c=tn[u].l and r\u003e=tn[u].r) {\rif(t == 1) return tn[u].w;\rif(t == 2) return tn[u].sq;\r} ll ans = 0;\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1;\rif(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r , t)) % mod;\rif(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r , t)) % mod;\rreturn ans;\r}\rvoid update(ll u,ll l,ll r,ll wa,ll wm){ if(l\u003c=tn[u].l and r\u003e=tn[u].r){ tn[u].sq = ((tn[u].sq + 2LL * tn[u].w * wa % mod) % mod + wa * wa % mod * tn[u].siz % mod) % mod;\rtn[u].w = (tn[u].w * wm % mod + tn[u].siz * wa % mod) % mod;\rtn[u].alazy = (tn[u].alazy * wm % mod + wa) % mod;\rtn[u].mlazy = (tn[u].mlazy * wm) % mod;\rreturn ;\r}\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1; if(l\u003c=mid) update(u\u003c\u003c1, l , r , wa , wm);\rif(r\u003emid) update(u\u003c\u003c1|1, l , r , wa , wm);\rpushup(u); }\rint main(){\rcin\u003e\u003en\u003e\u003eq;\rfor(ll i=1;i\u003c=n;i++){\rscanf(\"%lld\",\u0026wt[i]);\r}\rfor(ll i=0;i\u003cn-1;i++){\rll x,y;\rscanf(\"%lld %lld\",\u0026x,\u0026y);\radd_edge(x,y);\radd_edge(y,x);\r}\rdfs1(1,0);\rdfs2(1,0,1);\rbuild(1,1,n);\rfor(ll i=0;i\u003cq;i++){\rll t;\rscanf(\"%lld\",\u0026t);\rif(t==1){\rll x,y;\rscanf(\"%lld %lld\",\u0026x,\u0026y);\rupdate(1,dfn[x],dfn[x]+sz[x]-1,y%mod,1LL);\r}\relse{\rll x;\rscanf(\"%lld\",\u0026x);\rprintf(\"%lld\\n\", query(1,dfn[x],dfn[x]+sz[x]-1,2));\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"计算几何 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 两两求圆心，圆心相同表示能在同一个圆上 求最多的圆心数量 需要固定一个点，每次换点时求一次max，如果在遍历完所有点对求max，就变成排列组合 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing db = double;\rstruct point{\rdb x,y;\r}ps[2005];\rmap\u003cpair\u003cdb,db\u003e,int\u003e mp;\rdb X,Y;\rinline db out(point a,point b,point c) {\rreturn (c.x - a.x) * (c.y - b.y) - (c.y - a.y) * (c.x - b.x); }\rbool circle_center(point a,point b,point c){\rif(out(a,b,c) == 0 ) return false;\rdb a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;\rdb a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;\rdb d = a1 * b2 - a2 * b1;\rX = a.x + (c1 * b2 - c2 * b1) / d , Y = a.y + (a1 * c2 - a2 * c1) / d;\rreturn true;\r}\rint main(){\rint n;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003eps[i].x;\rcin\u003e\u003eps[i].y;\r}\rint ans = 0;\rfor(int i=0;i\u003cn;i++){\rmp.clear();\rfor(int j=i+1;j\u003cn;j++){\rif(circle_center((point){0,0} , ps[i] , ps[j]))\rmp[{X,Y}]++;\r}\rint tmp = 0;\rfor(auto i:mp) tmp = max(tmp , i.second);\rans = max(ans , tmp);\r}\rcout\u003c\u003cans+1\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 并查集模改 细节参考官方题解 并查集模拟操作，链表维护相同颜色的节点 注意要记录初始的状态（debug好久） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst int maxn = 8e5 + 10;\rvector\u003cint\u003e G[maxn];\rlist\u003cint\u003e ls[maxn];\rint par[maxn]; void init(int n) {\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rls[i].push_back(i);\r}\r} int find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); }\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\r//reset\r for(int i = 0;i\u003c=n;i++) {\rG[i].clear(); ls[i].clear();\r}\rfor(int i = 0;i\u003cm;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\rG[x].push_back(y);\rG[y].push_back(x);\r}\rinit(n);\rint q;\rcin\u003e\u003eq;\rwhile(q--){\rint x;\rcin\u003e\u003ex;\rif(x != par[x]) continue;\rint sz = ls[x].size(); //记录初始的链表大小\r int px = find(x); //记录初始的根节点\r while(sz--){\rint cnt = ls[x].front();\rls[x].pop_front();\rfor(int i:G[cnt]){\rint pi = find(i); //记录初始的根节点\r if(px == pi) continue;\rpar[pi] = px; //这样合并\r ls[x].splice(ls[x].end() , ls[pi]); }\r}\r}\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cfind(i)\u003c\u003c\" \";\rputs(\"\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 1和大于n/2的质数都不能匹配 先处理质因子稀有的数，就是从大到小遍历质数 然后把含有这个质因子的数两两匹配 如果含有这个质因子的数的个数是奇数个 就不匹配 2*p 这个数，留给下一个质因子，因为2是最多的质因子 #include \"bits/stdc++.h\"\rusing namespace std;\rconst int maxnn = 2e5+10;\rbool isprime[maxnn];\rvoid e_sieve(int n = maxnn){\rfor(int i = 1;i\u003cn;i++){\risprime[i] = true;\r}\risprime[0] = isprime[1] = false;\rfor(int i = 2;i \u003c n;i++){\rif(isprime[i]){\rfor(int j = 2 * i ; j \u003c n ; j += i){\risprime[j] = false;\r}\r}\r}\r}\rint use[maxnn] ;\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\re_sieve();\rint t;\rcin\u003e\u003et;\rwhile (t--){\rint n;\rcin\u003e\u003en;\rfor(int i = 1; i \u003c= n ; i++) use[i] = 0;\rvector\u003cpair\u003cint,int\u003e\u003e ans;\rfor(int i = n/2 ; i \u003e= 2 ; --i){\rif(isprime[i]){\rvector\u003cint\u003e tmp;\rfor(int j = i; j \u003c= n ; j += i){\rif(use[j] == 0){\rtmp.push_back(j);\r}\r}\rif(tmp.size() \u0026 1){\rfor(int x = 0 ; x \u003c tmp.size() ; ++x){\rif(tmp[x] == i * 2) tmp.erase(tmp.begin() + x);\r}\r}\rfor(int i = 0 ; i \u003c tmp.size() - 1 ; i += 2){\rans.push_back({tmp[i] , tmp[i+1]});\ruse[tmp[i]] = 1;\ruse[tmp[i+1]] = 1;\r}\r}\r}\r//for(int i = 2; i \u003c 20 ; i++) cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cisprime[i]\u003c\u003c\"\\n\";\r cout\u003c\u003cans.size()\u003c\u003cendl;\rfor(auto i : ans){\rcout\u003c\u003ci.first\u003c\u003c\" \"\u003c\u003ci.second\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 如果没有 d\u003cb f\u003cb 的条件直接让 d = f = b 如果 a/b 能约分成 a’ / b’ 则 d = f = b’ e = 1 , c = a‘+1（随便赋值） 如果 a/b不能约分 就把b分解质因数（预处理每个数最小的质因子） 设b分解成 p1 p2 如果p1 p2 有1 无解 否则根据通分公式 d = p1 , f = p2 cf - de = a 因为d f是b的因子 ，b 和 a 互质 ，所以gcd(f/a , d/a) = 1 -(d/a)e + c(f/a) = 1 用扩展欧几里得公式求出 c e e = -e 如果 e c有负数 ，正数化 然后 e c 都乘上 a #include \"bits/stdc++.h\"\r\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 2e6+10;\rll gcd(ll a , ll b){\rreturn b == 0 ? a : gcd(b , a % b);\r}\rbool isprime[maxn+1]; //is i a prime number\rll minp[maxn+1];\rvoid e_sieve(int n = maxn)\r{\rfor(int i=0;i\u003c=n;i++) isprime[i]=true; //initialize\r isprime[0]=isprime[1]=false;\rfor(int i=2;i\u003c=n;i++)\r{\rif(isprime[i])\r{\rfor(int j=2*i;j\u003c=n;j+=i) isprime[j]=false;\r}\r}\rfor(ll i = 2 ; i \u003c= n; i++){\rif(isprime[i]){\rfor(ll j = i; j \u003c= n; j += i){\rif(minp[j] == 0) minp[j] = i;\r}\r}\r}\r}\rll ex_gcd(ll a,ll b,ll\u0026 x,ll\u0026 y)\r{\rll t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"r\", stdin);\rfreopen(\"out1.txt\", \"w\", stdout);\r#endif\r\re_sieve();\r//for(int i = 2; i\u003c 100;i++) cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cminp[i]\u003c\u003cendl;\r int _;\rcin \u003e\u003e _;\rwhile (_--) {\rll a, b;\rcin \u003e\u003e a \u003e\u003e b;\rll c , d , e , f;\rll t = gcd(a , b);\rif(t != 1){\ra /= t;\rb /= t;\rd = f = b;\re = 1;\rc = a + 1;\rcout\u003c\u003cc\u003c\u003c\" \"\u003c\u003cd\u003c\u003c\" \"\u003c\u003ce\u003c\u003c\" \"\u003c\u003cf\u003c\u003cendl;\rcontinue;\r}\rll p1 = 1,p2 = b,p = minp[b];\rif(p == 0) {\rcout\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003cendl;\rcontinue;\r}\rwhile(p2 % p == 0){\rp2 /= p;\rp1 *= p;\r}\rif(p2 == 1){\rcout\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003cendl;\rcontinue;\r}\rd = p1;\rf = p2;\rex_gcd(d, f, e, c);\re = -e;\rif(e \u003c= 0 or c \u003c= 0){\rll et = (e % f + f) % f;\rll ct = (c % d + d) % d;\rll mm = max(0ll , max((et - e) / f , (ct - c) / d));\re += f * mm;\rc += d * mm;\r}\re *= a;\rc *= a;\rcout\u003c\u003cc\u003c\u003c\" \"\u003c\u003cd\u003c\u003c\" \"\u003c\u003ce\u003c\u003c\" \"\u003c\u003cf\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"计算几何 区间dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 很难的一道题 由于切割的方案数太多，所以考虑dp dp[i][j] 表示点 i 到点 j 的答案 转移方程 dp[i][j] = min(dp[i][j] , max( max (dp[i][k] , dp[k][j]) , area(ps[i] , ps[j] , ps[k]) ) ) 计算面积直接用外积 1/2 * (A-\u003eB) X (A-\u003eC) 由于题目存在凹多边形的情况 所以当有点在三角形 i j k中，这个区间不可分割（根据面积判断，这个技巧可以用于求一个点是否在凸多边形内） dp的初始化 dp[i][i+2] = area(ps[i] , ps[i+1] , ps[i+2]) dp[i][i] = dp[i][i+1] = 0 dp[i][i+m] = inf [m\u003e2] 几个注意点 用eps ， 初始化只有一类为inf ， 用外积求面积要加绝对值 ， dp的遍历先遍历区间长度（因为从小的先更新，大的区间依赖于小的，这也是很多区间dp要求的） #include \"bits/stdc++.h\"\r\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int maxn = 105;\rdouble eps = 1e-10;\rstruct point{\rdouble x,y;\r}ps[maxn];\rdouble dp[maxn][maxn];\rint n;\r//a-\u003ec X b-\u003ec\rdouble area(point a,point b,point c) {\rreturn fabs((c.x - a.x) * (c.y - b.y) - (c.y - a.y) * (c.x - b.x)) / 2;\r}\rbool judge(int a,int b,int c){\rdouble s = area(ps[a], ps[b], ps[c]);\rfor(int i =1;i\u003c=n;i++){\rif(i == a or i == b or i == c) continue;\rdouble t = area(ps[i],ps[a],ps[b]) + area(ps[i],ps[a],ps[c]) + area(ps[i],ps[b],ps[c]);\rif(fabs(t - s) \u003c eps) return false;\r}\rreturn true;\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"r\", stdin);\rfreopen(\"out1.txt\", \"w\", stdout);\r#endif\r ios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rwhile(cin\u003e\u003en){\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003eps[i].x\u003e\u003eps[i].y;\rif(i\u003e=3){\rdp[i-2][i] = area(ps[i] , ps[i-1] , ps[i-2]);\r}\r}\rfor(int len = 3 ; len \u003c= n ; len++){\rfor(int i = 1,j = i+len;j\u003c=n;i++,j++){\rdp[i][j] = inf;\rfor(int k = i + 1 ; k \u003c j ; k++){\rif(judge(i,j,k)){\rdp[i][j] = min(dp[i][j] , max(max(dp[i][k] , dp[k][j]) , area(ps[i] , ps[j] , ps[k])));\r}\r}\r}\r}\rprintf(\"%.1lf\\n\", dp[1][n]);\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 选择权值不为0的极大连通块，全部-1，不断重复，并记录操作次数 由于点变成0后要从连通块中分裂出来很麻烦，所以考虑倒着来，即单个点合并成连通块 权值从大到小处理，对于u先假设它是单点，ans+=该点的权值，标记为访问 对于它相邻的点v，如果访问过（表示v比u权值大）但不在一个集合内，则合并，然后减去u的权值 因为u和v在一个集合内，v和u共享了u的权值次操作 注意用scanf //#include \"bits/stdc++.h\"\r#include \"iostream\"\r#include \"algorithm\"\r#include \"vector\"\r\rusing namespace std;\rusing ll = long long;\rconst int maxn = 100005;\rpair\u003cint,int\u003e b[maxn];\rvector\u003cint\u003e G[maxn];\r//union find\rint par[maxn];\rint rankk[maxn];\rint sz[maxn];\rint used[maxn];\rvoid init(int n)\r{\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ;\rif(rankk[x]\u003crankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"r\", stdin);\rfreopen(\"out1.txt\", \"w\", stdout);\r#endif\r\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n,m;\rscanf(\"%d%d\",\u0026n,\u0026m);\rfor(int i=0;i\u003c=n;i++) G[i].clear();\rfor(int i=1;i\u003c=n;i++) {\rscanf(\"%d\",\u0026b[i].first);\rb[i].second = i;\r}\rfor(int i=0;i\u003cm;i++){\rint u,v;\rscanf(\"%d%d\",\u0026u,\u0026v);\rG[u].push_back(v);\rG[v].push_back(u);\r}\rsort(b+1,b+n+1,[](pair\u003cint,int\u003e a,pair\u003cint,int\u003e b){return a.first\u003eb.first;});\rinit(n+1);\rfor(int i=0;i\u003c=n;i++) used[i] = 0;\rll ans = 0;\rfor(int i=1;i\u003c=n;i++){\rans += b[i].first;\rused[b[i].second] = 1;\rfor(int j:G[b[i].second]){\rif(used[j]){\rif(!same(b[i].second,j)){\runite(b[i].second,j);\rans -= b[i].first;\r}\r}\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"哈希 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把问题转化成求 A * B = C + Fk 由于k很大，所以这些数会溢出，用除余法哈希，除数选择不超过ull的数，然后遍历k找到满足C + Fk等于 A * B的k 实际上不哈希也可以，所以数都自然溢出（可以看做是特殊的哈希），也可以找到答案 #include \"bits/stdc++.h\"\r\rusing namespace std;\rusing ull = unsigned long long;\rull fib[2000005];\rull a,b,c;\rint n;\rvoid init(){\rfib[1] = 1;\rfib[2] = 2;\rfor(int i=3;i\u003c2000005;i++){\rfib[i] = fib[i-1] + fib[i-2];\r}\r}\rvoid cal(ull \u0026x,int n){\rx = 0;\rfor(int i=1;i\u003c=n;i++){\rint t;\rscanf(\"%d\",\u0026t);\rif(t){\rx += fib[i];\r}\r}\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"r\", stdin);\rfreopen(\"out1.txt\", \"w\", stdout);\r#endif\r init();\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\ra = b = c = 0;\rscanf(\"%d\",\u0026n);\rcal(a,n);\rscanf(\"%d\",\u0026n);\rcal(b,n);\rscanf(\"%d\",\u0026n);\rcal(c,n);\ra *= b;\rfor(int i=1;i\u003c=n;i++){\rif(fib[i] + c == a){\rprintf(\"%d\\n\",i);\rcontinue; //应该是break 但这样也不会超时\r }\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"置换群 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:15:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 求排列中每个循环的长度，对它们求lcm 注意大数（可不必取模） 贴一份队友的代码 def gcd(a, b):\rreturn a if b == 0 else gcd(b, a % b)\rdef dfs(i):\rglobal vis\ru = i\rans = 1\rwhile p[i] != u:\rans += 1\rvis[i] = 1\ri = p[i]\rreturn ans\rn = int(input())\rMOD = pow(10, n)\rvis = [0] * 100007\rp = [0] * 100007\rpp = list(map(int, input().split()))\rfor i in range(1, n + 1):\rp[i] = pp[i-1]\rans = 1\rfor i in range(1, n + 1):\rif vis[i] == 1:\rcontinue\rk = dfs(i)\rans = ((ans * k) // gcd(ans, k)) % MOD\rprint(ans)\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:15:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 LIS 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:16:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 invert操作不会改变数的相对位置，drop2操作会改变数的相对位置 drop2操作是把最后一个数之前的数往数列头部移动 由于这两种操作的性质，把数列看成一个环 那么invert操作就是旋转环，drop2操作就是把最后一个数（在环里就是任意一个数）插到任意位置上 所以问题转化成对于一个数列（排列），最少有多少次“将任意数插入到任意位置上”的操作，使得数列递增 操作数 = n - len(LIS) , 对于环的不同起始位置求LIS，取最大值 时间复杂度 O(n*n*logn) #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint dp[505];\rconst int inf = 0x3f3f3f3f;\rint a[1010];\rint main() {\rint n;\rint ma = -1 ;\rscanf(\"%d\",\u0026n);\rfor(int i=0;i\u003cn;++i){\rcin\u003e\u003ea[i];\r}\rint i,j;\rfor(i=0;i\u003cn;i++){\rfill(dp,dp+n,inf);\rfor(j=i;j\u003ci+n;j++){\r*lower_bound(dp,dp+n,a[j]) = a[j];\r}\rma = max(ma , (int)(lower_bound(dp,dp+n,inf) - dp));\ra[j] = a[i];\r}\rcout\u003c\u003cn-ma\u003c\u003c\"\\n\";\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:16:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数据结构 实现 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:17:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于每个数，判断能否把前min(i,k)个数作为一个排列，即在它的后面放置切割 判断是否是排列，即判断这些数中每个数是否只出现一次，出现次数可以用unordered_map记录(map超时) 想了一个非常复杂的方法，不知道怎么实现，以下是参考了别人的代码，实现效率非常高 #include \"iostream\"\r#include \"unordered_map\"\r#include \"cstring\"\r#pragma GCC optimize(2)\rusing namespace std;\rtypedef long long ll;\rint a[500005],cut[500005];\runordered_map\u003cint,int\u003e mp;\rinline int read()\r{\rint x=0;int f=1;char s=getchar();\rwhile(s\u003c'0' or s\u003e'9')\r{\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u003e='0' and s\u003c='9')\r{\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rint main() {\rint _;\r_ = read();\rwhile (_--) {\rmp.clear();\rint flag = 0;\rint n,k;\rn = read() , k = read();\rfor (register int i = 1; i \u003c= n; ++i) {\ra[i] = read();\rif(a[i] \u003e k) {\rflag = 1;\rbreak;\r}\r}\rif(flag) {\rputs(\"NO\");\rcontinue;\r}\rint dif_num = 0; memset(cut , 0 , sizeof(cut));\rcut[0] = 1;\rfor(register int i=1;i\u003c=n;++i){\rif(i \u003e k) {\rif (mp[a[i - k]] == 1) dif_num-- ; mp[a[i - k]]--;\r}\rif(mp[a[i]] == 0) dif_num++; mp[a[i]]++;\rif(dif_num == k or dif_num == i){\rcut[i] = (i\u003e=k ? cut[i-k] : 1);\r}\r}\rdif_num = 0 ; mp.clear();\rflag = 0;\rfor(register int i=n;i\u003e=max(n-k,0);--i){\rif(dif_num == n-i and cut[i] == 1){\rflag = 1;\rbreak;\r}\rif(mp[a[i]] == 0) dif_num++;\rmp[a[i]]++;\r}\rflag ? puts(\"YES\") : puts(\"NO\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:17:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"状态压缩dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:18:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于铁路线，肯定是过某个点最划算，而且是过不同的点，即一个点一条线穿过 所以枚举即将被穿线的点集，每个点有被特定的一条线穿过，穿过的方式有横线、竖线（对于特定的点集，枚举横线竖线的所有情况） 对于每种情况，更新答案 （两条铁路重合的情况不会影响答案，因为这始终不是最优解） 玄学时间复杂度 O(sum(2^i * C(n,i) * n * n) 应该有千亿计算量 一直以为会超时，想把n*n优化成O(1) 无果，看了别人的做法，居然不会超时？？？ 最后跑了2700+ms ，时限是3000ms 注意long long的强制类型转化 实际上还有更快的暴力方法和dfs，但我不会 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint n,x[16],y[16],d[16],D[16],p[16];\rll ans[16];\rint main() {\rmemset(ans , 0x3f , sizeof(ans));\rcin \u003e\u003e n;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ex[i]\u003e\u003ey[i]\u003e\u003ep[i];\r}\rfor(int i=0;i\u003cn;i++){\rD[i] = min(abs(x[i]) , abs(y[i]));\r}\rans[0] = 0;\rfor(int i=0;i\u003cn;i++){\rans[0] += (ll)D[i]*p[i];\r}\rfor(int i=1;i\u003c(1\u003c\u003cn);i++){\rint j = i;\rdo{\rmemcpy(d,D,sizeof(D));\rfor(int k=0;k\u003cn;k++){\rif(i\u003e\u003ek\u00261){\rif(j\u003e\u003ek\u00261){\rfor(int q=0;q\u003cn;q++){\rd[q] = min(d[q] , abs(x[q] - x[k]));\r}\r}\relse{\rfor(int q=0;q\u003cn;q++){\rd[q] = min(d[q] , abs(y[q] - y[k]));\r}\r}\r}\r}\rll tmp = 0;\rfor(int i=0;i\u003cn;i++) tmp += (ll)d[i] * p[i];\rans[__builtin_popcount(i)] = min(ans[__builtin_popcount(i)] , tmp);\rj = (j-1) \u0026 i;\r}while(j != i);\r}\rfor(int i=0;i\u003c=n;i++) cout\u003c\u003cans[i]\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:18:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"01背包问题 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:19:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 01背包问题模改 dp[i][j][k] 表示前i个从者，前j个装备，容量为k的最大价值 由于从者和装备是平级的，所以分别对它们用01背包问题 但是有约束条件，装备数量不多于从者，从者最多选5个 所以应该这样dp ， dp[a][i][b][j][k] 表示从前i个选a个，从前j个选b个，容量为k的最大价值，其中a，b只需遍历到5 但这样内存超限，由于01背包问题可以从2维降到1维（重复利用，滚动原理），所以这个dp也可以将2维 dp[i][j][k] 表示选i个从者，j个装备，容量为k的最大价值 由于装备数量不多于从者，所以先枚举从者（即j=0），然后枚举不大于从者的装备 最后3重循环求最大值 #include \"bits/stdc++.h\"\r#include \"algorithm\"\rusing namespace std;\rusing ll = long long;\rint dp[6][6][140];\rint a1[305],c1[305],a2[305],c2[305];\rint main() {\rint n,m,c;\rcin\u003e\u003en\u003e\u003em\u003e\u003ec;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003ea1[i]\u003e\u003ec1[i];\rfor(int i=1;i\u003c=m;i++) cin\u003e\u003ea2[i]\u003e\u003ec2[i];\rmemset(dp,0xc0,sizeof(dp));\rdp[0][0][0] = 0;\rfor(int i=1;i\u003c=n;i++){\rfor(int j=c;j\u003e=c1[i];j--){\rfor(int k=1;k\u003c=5;k++){\rdp[k][0][j] = max(dp[k][0][j] , dp[k-1][0][j-c1[i]] + a1[i]);\r}\r}\r}\rfor(int i=1;i\u003c=m;i++){\rfor(int j=c;j\u003e=c2[i];j--){\rfor(int k=1;k\u003c=5;k++){\rfor(int x=1;x\u003c=k;x++){\rdp[k][x][j] = max(dp[k][x][j] , dp[k][x-1][j-c2[i]] + a2[i]);\r}\r}\r}\r}\rint ans = -1;\rfor(int i=1;i\u003c=5;i++){\rfor(int j=0;j\u003c=i;j++){\rfor(int k=0;k\u003c=c;k++){\rans = max(ans , dp[i][j][k]);\r}\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:19:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"容斥原理 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:20:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 考虑特定的k种颜色的染色方案，那么答案就乘上 C(m,k) 如果是选k种颜色涂色，方案数就是 k(k-1)^(n-1) 但这是不多于k种颜色的方案，对于“恰好”的方案，可以考虑用容斥原理 设不多于k种颜色的方案为f(k) exactly(k) = f(k) - ( f(k-1) - ( f(k-2) - ( f(k-3) - ( f(k-4) -… f(1) )))) f(k) - part 锁定了第k个元素必须使用，f(k-1) - part锁定了k-1个元素必须使用，以此类推 把括号打开，就是容斥原理的结构 exactly(k) = f(k) - f(k-1) + f(k-2) - f(k-3) + f(k-4) … f(1) 由于在加减的过程中不断锁定第i个元素，但没有指定在哪个位置锁定这个元素，所以f要乘上所有的方案数 即F(i) = C(k,i)f(i) 所以答案为 $$ C_{m}^{k}\\sum\\limits_{i=0} ^ {k-1} {(-1)^iC_{k}^{k-i}(k-i)(k-i-1)^{n-1}} $$ #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll ans,n,m,k;\rconst int maxn = 1e6+10;\rconst ll mod = 1e9+7;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll inv[maxn];\rll fac[maxn];\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rint main() {\rfor(ll i=0;i\u003cmaxn;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u003cmaxn;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!!\r for(ll i=2;i\u003cmaxn;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003cmaxn;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rll ckm = 1;\rans = 0;\rcin \u003e\u003e n \u003e\u003e m \u003e\u003e k;\rfor(ll i=0;i\u003ck;i++){\rckm *= (m-i);\rckm %= mod;\r}\rckm *= inv[k];\rckm %= mod;\rint sign = 1;\rfor(int i = k; i \u003e0 ; --i){\rll tmp = 1;\rtmp *= C(i,k);\rtmp %= mod;\rtmp *= i;\rtmp %= mod;\rtmp *= qpow(i-1 , n-1);\rtmp %= mod;\rif(sign == 1) ans += tmp ; else ans -= tmp;\rans += mod;\rans %= mod;\rsign = -sign;\r}\rans *= ckm;\rans %= mod;\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:20:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"bfs 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:21:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 问题转化成创建一条路径连通三个国家，使路径长度最短 那么路径一定汇集于一个点 这就是bfs问题，枚举每个点，求它们到每个国家的最小值，然后和的最小值就是答案，但这样会超时 以每个国家为起点，bfs到每个点，这样每个点会得到三个信息（分别到三个国家的最短距离），和的最小值就是答案，不会超时 当这个点是平地时，距离和-2，因为它被创造了三条公路 我的bug：用fill初始化产生错误，用memset初始化正常，bfs时当点是国家时，距离不需要+1 ， 在求距离和时，要将一个数强制类型转化成long long，它才会升级 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint n,m;\rchar maze[1005][1005];\rint dist[1003][1003][4];\rusing pii = pair\u003cint,int\u003e;\rint dir[4][2] = { {0,1} , {1,0} , {-1,0} , {0,-1} };\rconst ll inf = 0x3f3f3f3f;\rvoid bfs(int x){\rqueue\u003cpii\u003e q;\rchar ch = '0' + x;\rfor(int i=0;i\u003cn;i++)for(int j=0;j\u003cm;j++){\rif(maze[i][j] == ch) {\rdist[i][j][x] = 0;\rq.push({i,j});\r}\r}\rwhile(q.size()){\rpii tmp = q.front();\rq.pop();\rfor(int i=0;i\u003c4;i++){\rint xt = tmp.first + dir[i][0];\rint yt = tmp.second + dir[i][1];\rif(maze[xt][yt] == '#') continue;\rif(xt \u003c0 or yt\u003c0 or xt\u003e=n or yt\u003e=m) continue;\rint cost = (maze[xt][yt] == '.');\rif(dist[tmp.first][tmp.second][x] + cost \u003c dist[xt][yt][x]){\rdist[xt][yt][x] = dist[tmp.first][tmp.second][x] + cost;\rq.push({xt,yt});\r}\r}\r}\r}\rint main() {\rcin\u003e\u003en\u003e\u003em;\rmemset(dist , inf , sizeof(dist));\rfor(int i=0;i\u003cn;i++){\rscanf(\"%s\",\u0026maze[i]);\r} bfs(1);bfs(2);bfs(3);\rll ans = inf;\rfor(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++){\rif(maze[i][j] == '#') continue;\rll sum = (ll)dist[i][j][1] + dist[i][j][2] + dist[i][j][3];\rif(maze[i][j] == '.') sum -= 2;\rans = min(ans , sum);\r}\rcout\u003c\u003c(ans == inf ? -1 : ans)\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:21:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dfs 图论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:22:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把问题转化成求在所有简单路径中，每个点被遍历了几次，如果是偶数次，异或和为0，奇数次异或和为本身 这样就是图论中求所有简单路径XX被遍历几次的经典模型，基础的有边和点 如果是边 $$ f(edge) = size[x] * ( n - size[x]) $$ 如果是点，考虑三种情况，以这个点为端点，有n-1条，这个点的子树连到子树外面有 (size[x] - 1) * ( n - size[x]) ， 这个点的子节点的子树连到另外一个子节点的子树有 (sum(size[ch] * (size[x] - 1 - size[ch]))) / 2 除以2因为每个点都作为起点和终点一次，但这样只有一条 $$ f(node) = n-1 + (size[x] - 1) * (n-size[x]) + \\frac{\\sum\\limits_{} ^ {} {size[ch] * (size[x] - 1 - size[ch])} }{2} $$ 还有另一种算法 $$ f(node) = \\frac{\\sum{f(edge) [connected \\ to \\ node]+ n-1} }{2} $$ #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rvector\u003cll\u003e G[500005];\rll sz[500005];\rll a[500005];\rll ans ;\rll n;\rll dfs(ll u,ll p){\rsz[u] = 1;\rfor(ll i:G[u]){\rif(i == p) continue;\rsz[u] += dfs(i,u);\r}\rll sum = 0;\rfor(ll i:G[u]){\rif(i == p) continue;\rsum += sz[i] * (sz[u] - 1 - sz[i]) ;\r}\rsum /= 2;\rsum += (sz[u] - 1) * (n - sz[u]);\rsum += n - 1;\rif(sum\u00261) ans ^= a[u];\rreturn sz[u];\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn-1;i++){\rll x,y; cin\u003e\u003ex\u003e\u003ey;\rG[x].push_back(y); G[y].push_back(x);\r}\rfor(ll i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\rdfs(1,0);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:22:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 高精度 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:23:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 这道题主要是发现高精度，理论上ans会达到 1e9*1e5*1e5 以下是__int128的输入输出模板（支持负数） #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rtypedef __int128 INT ;\rconst INT N=1e5+5;\rINT a[N],b[N],s[N],m[N];\rinline INT read(){\rINT x=0,f=1;\rchar ch=getchar();\rwhile(ch\u003c'0'||ch\u003e'9'){\rif(ch=='-')\rf=-1;\rch=getchar();\r}\rwhile(ch\u003e='0'\u0026\u0026ch\u003c='9'){\rx=x*10+ch-'0';\rch=getchar();\r}\rreturn x*f;\r}\rinline void write(INT x){\rif(x\u003c0){\rputchar('-');\rx=-x;\r}\rif(x\u003e9)\rwrite(x/10);\rputchar(x%10+'0');\r}\rint main(){\rINT t,n;\rt = read();\rfor(int u=1;u\u003c=t;u++){\rn = read();\rfor(int i=1;i\u003c=n;i++) a[i] = read();\rfor(int i=1;i\u003c=n;i++) b[i] = read();\rs[1] = a[1];\rfor(int i=2;i\u003c=n;i++){\rs[i] = s[i-1] + a[i];\r}\rm[1] = b[1];\rfor(int i=2;i\u003c=n;i++){\rm[i] = min(b[i],m[i-1]);\r}\rINT ans = 0;\rINT cnt = a[1];\rfor(int i=2;i\u003c=n;i++){\rif(b[i-1]\u003eb[i]){\rans += cnt * (m[i-1] - m[i]);\r}\rcnt = max(cnt,s[i]);\r}\rans += cnt * m[n];\rcout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": \";\rwrite(b[1]);\rcout\u003c\u003c\" \";\rwrite(ans);\rputs(\"\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:23:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 并查集 离散化 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:24:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于当前的一对数，给它们连一条边，对所有的对数都进行这样的操作，最后会形成很多连通块，如果连通块有环，则这些数都能被选择，否则其中有一个数不能被选择，因为数据大小，用unordered_map离散化 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\runordered_map\u003cint,int\u003e used;\rset\u003cint\u003e rt;\runordered_map\u003cint,int\u003e rel;\runordered_map\u003cint,int\u003e num;\runordered_map\u003cint,int\u003e id;\rconst int maxn = 2e5+10;\rint a[maxn],b[maxn];\r//union find\rint par[maxn];\rint rankk[maxn];\rint sz[maxn];\rvoid init(int n){\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x){\rif(par[x]==x) return x;\relse return par[x]=find(par[x]);\r} void unite(int x,int y){\rx=find(x);\ry=find(y);\rif(x==y) return ;\rif(rankk[x]\u003crankk[y]) par[x]=y;\relse{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r} bool same(int x,int y){\rreturn find(x)==find(y);\r}\rint getid(int u){\rreturn id[u];\r}\rint main() {\rint _;\rcin \u003e\u003e _;\rfor(int q=1;q\u003c=_;q++) {\rused.clear();\rrt.clear();\rrel.clear();\rnum.clear();\rid.clear();\rint n;\rscanf(\"%d\",\u0026n);\rfor(int i=0;i\u003cn;i++){\rscanf(\"%d%d\",\u0026a[i],\u0026b[i]);\r}\rinit(2*n+2);\rint cnt = 0;\rfor(int i=0;i\u003cn;i++){\rif(id[a[i]] == 0) id[a[i]] = ++cnt;\rif(id[b[i]] == 0) id[b[i]] = ++cnt;\r}\rfor(int i=1;i\u003c=cnt;i++){\rrt.insert(i);\r}\rfor(int i=1;i\u003c=cnt;i++){\rnum[i] = 1;\r}\r// for(int i=1;i\u003c=cnt;i++){\r// cout\u003c\u003cid[i]\u003c\u003c\" \";\r// }puts(\"\");\r for(int i=0;i\u003cn;i++){\rint u = a[i],v = b[i];\r//if(used[u] == 1 and used[v] == 1) continue;\r //used[u] = used[v] = 1;\r if(!same(getid(u) , getid(v))){\rint urt = find(getid(u));\rint vrt = find(getid(v));\rint t1 = rel[urt],t2 = rel[vrt];\rint t3 = num[urt],t4 = num[vrt];\rrt.erase(urt);\rrt.erase(vrt);\rint t5 = t1 + t2 + 1;\rint t6 = t3 + t4;\runite(getid(u),getid(v));\rint uvrt = find(getid(u));\rrel[uvrt] = t5;\rnum[uvrt] = t6;\rrt.insert(uvrt);\r}else{\rrel[find(getid(u))]++;\r}\r}\rll ans = 0;\rfor(int i:rt){\rans += (rel[i] \u003e= num[i] ? num[i] : num[i] - 1);\r//cout\u003c\u003crel[i]\u003c\u003c\" \"\u003c\u003cnum[i]\u003c\u003c\" \"\u003c\u003ci;\r //cout\u003c\u003cfind(getid(44));\r }\rcout\u003c\u003c\"Case #\"\u003c\u003cq\u003c\u003c\": \"\u003c\u003cans\u003c\u003cendl；\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:24:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"模拟 枚举 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:25:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 三重循环枚举 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxn = 260;\rstring cards[maxn][4];\rbool check(int i,int j,int k){\rbool flags[4] = {false};\rfor(int q=0;q\u003c4;q++){\rstring s1 = cards[i][q];\rstring s2 = cards[j][q];\rstring s3 = cards[k][q];\rif((s1==\"[*]\" or s2==\"[*]\" or s3==\"[*]\") or (s1 == s2 and s2 == s3) or (s1 != s2 and s2 != s3 and s1 != s3)) flags[q] = true;\r}\rif(flags[0] and flags[1] and flags[2] and flags[3]) return true;\rreturn false;\r}\rint main() {\rint _;\rcin \u003e\u003e _;\rfor(int u=1;u\u003c=_;u++) {\rint n;\rcin\u003e\u003en;\r//reset\r for(int i=0;i\u003c=n;i++){\rfor(int j=0;j\u003c4;j++){\rcards[i][j].clear();\r}\r}\rstring s;\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003es;\rfor(int j=0,k=0;j\u003cs.length();j++){\rcards[i][k].push_back(s[j]);\rif(s[j]==']') k++;\r}\r}\r// for(int i=0;i\u003c4;i++){\r// cout\u003c\u003ccards[0][i]\u003c\u003c\" \";\r// }\r bool ok = false;\rfor(int i=0;i\u003cn;i++){\rif(ok) break;\rfor(int j=i+1;j\u003cn;j++){\rif(ok) break;\rfor(int k=j+1;k\u003cn;k++){\rif(ok) break;\rif(check(i,j,k)){\rcout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": \"\u003c\u003ci+1\u003c\u003c\" \"\u003c\u003cj+1\u003c\u003c\" \"\u003c\u003ck+1\u003c\u003cendl;\rok = true;\r}\r}\r}\r}\rif(!ok) cout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": -1\\n\";\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:25:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:26:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 #include \"bits/stdc++.h\"\rusing namespace std;\rconst int maxn = 1e5 + 5;\rint a[maxn];\rint dp[maxn][2];\rint main() {\rint n;\rcin \u003e\u003e n;\rfor(int i = 0; i \u003c n; i++){\rcin \u003e\u003e a[i];\r}\rif(a[0] == 0) dp[0][0] = 0, dp[0][1] = 1;\rif(a[0] == 1) dp[0][0] = 1, dp[0][1] = 0;\rfor(int i = 1; i \u003c n; i++){\rif(a[i] == 0){\rdp[i][0] = min(dp[i-1][0] , dp[i-1][1] + 1);\rdp[i][1] = min(dp[i-1][0] + 2 , dp[i-1][1] + 1);\r}\rif(a[i] == 1){\rdp[i][0] = min(dp[i-1][0] + 1 , dp[i-1][1] + 2);\rdp[i][1] = min(dp[i-1][0] + 1 , dp[i-1][1]);\r}\r}\rcout \u003c\u003c min(dp[n-1][0] , dp[n-1][1] + 1)\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:26:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"图论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:27:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 暴力O(n^2) ，所以考虑将问题本质化（结论化） 把问题转化成求一个点，使得它到集合中的点的最大距离最小，求值 这样这个点从直观上看应该处在这些点的中间，并且是集合中两个最远的点的中点 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxv = 3e5 + 5;\rconst int max_logv = 20;\rvector\u003cint\u003e G[maxv];\rint root;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v, int p, int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i = 0; i \u003c G[v].size(); i++){\rif(G[v][i] != p) dfs(G[v][i], v, d+1);\r}\r}\rvoid init(int V){\rdfs(root, -1, 0);\rfor(int k = 0; k+1 \u003c max_logv; k++){\rfor(int v = 0; v \u003c V; v++){\rif(parent[k][v] \u003c 0) parent[k+1][v] = -1;\relse parent[k+1][v] = parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u] \u003e depth[v]) swap(u, v);\rfor(int k =0; k \u003c max_logv; k++){\rif((depth[v] - depth[u]) \u003e\u003e k \u0026 1) v = parent[k][v];\r}\rif(u == v) return u;\rfor(int k = max_logv-1; k \u003e= 0; k--){\rif(parent[k][u] != parent[k][v]){\ru = parent[k][u];\rv = parent[k][v];\r}\r}\rreturn parent[0][u];\r}\rint a[1000005];\rint main() {\rint n;\rcin \u003e\u003e n;\rfor(int i = 0; i \u003c n-1; i++){\rint u, v;\rcin \u003e\u003e u \u003e\u003e v;\rG[u].push_back(v);\rG[v].push_back(u);\r}\rroot = 1;\rinit(n+1);\rint num ;\rcin \u003e\u003e num;\rfor(int i = 0; i \u003c num; i++){\rint m;\rcin \u003e\u003e m;\rint est = root;\rfor(int j = 0; j \u003c m; j++){\rcin \u003e\u003e a[j];\rif(depth[a[j]] \u003e depth[est]) est = a[j];\r}\rint ans = -1;\rfor(int j = 0; j \u003c m; j++){\rans = max(ans, depth[est] + depth[a[j]] - 2 * depth[lca(est, a[j])]);\r}\rcout \u003c\u003c ((ans + 1) \u003e\u003e 1) \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:27:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["abc"],"content":"abc172","date":"2020-06-28","objectID":"/abc172/","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"A - Calc ","date":"2020-06-28","objectID":"/abc172/:0:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:1:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rint a;\rcin\u003e\u003ea;\rcout\u003c\u003ca+a*a+a*a*a\u003c\u003cendl;\rreturn 0;\r}\r B - Minor Change ","date":"2020-06-28","objectID":"/abc172/:2:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:3:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rstring s,t;\rcin\u003e\u003es\u003e\u003et;\rint ans = 0;\rfor(int i=0;i\u003cs.length();i++){\rif(s[i]!=t[i])ans++;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - Tsundoku ","date":"2020-06-28","objectID":"/abc172/:4:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:5:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 前缀和+双指针 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a[200005];\rll b[200005];\rint main(){\rll n,m,k;\rcin\u003e\u003en\u003e\u003em\u003e\u003ek;\ra[0] = 0;\rb[0] = 0;\rfor(ll i=1;i\u003c=n;i++){\rll tmp;\rcin\u003e\u003etmp;\ra[i] = a[i-1] + tmp;\r}\rfor(ll j=1;j\u003c=m;j++){\rll tmp;\rcin\u003e\u003etmp;\rb[j] = b[j-1] + tmp;\r}\rll ans = 0;\rll j = m;\rll i;\rfor(i=0;i\u003c=n;i++){\rwhile(a[i] + b[j] \u003e k and j\u003e=0){\rj--;\r}\rif(a[i] + b[j] \u003c= k) {\rans = max(ans , i+j);\r//cerr\u003c\u003cj\u003c\u003cendl;\r }\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - Sum of Divisors ","date":"2020-06-28","objectID":"/abc172/:6:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:7:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 筛法预处理因子个数，O(1)查询 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rll num[10000005];\rvoid init(){\rfor(ll i=1;i\u003c=10000005;i++){\rfor(ll x=i;x\u003c10000005;x+=i){\rnum[x]++;\r}\r}\r}\rint main(){\rinit();\rcin\u003e\u003en;\rll ans = 0;\rfor(ll i=1;i\u003c=n;i++){\rans += i*num[i];\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - NEQ ","date":"2020-06-28","objectID":"/abc172/:8:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:9:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 对于从M个选N个全排列的每一种方案都有对应的若干个情况，它们都是等价的 比如M=4 N=3 ，对于全排列的一种方案 123 与之对应的有第一个数字不能为1、第二个数字不能为2，第三个数字不能为3 第一个数字和第二个数字不能同时为12，第二个和第三个数字不能同时为23，第一个和第三个数字不能同时为13 第一个第二个第三个数字不能同时为123 这样就是基于容斥原理的排列组合 总的方案数是 $$ A_{M}^{N}*\\sum\\limits_{i=0} ^ {n} {C_{N}^{i}A_{M-i}^{N-i}(-1)^n} $$ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rll m;\rconst ll mod = 1e9+7;\rconst ll maxn = 500005;\rll inv[maxn+3];\rll fac[maxn+3];\rinline ll A(ll n,ll m){\rreturn fac[n]*inv[n-m]%mod;\r}\rinline ll C(ll n,ll m){\rreturn A(n,m)*inv[m]%mod;\r}\rint main(){\rcin\u003e\u003en\u003e\u003em;\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u003cmaxn;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=maxn;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=maxn;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rll ans =0;\rfor(ll i=0;i\u003c=n;i++){\rll tmp = C(n,i) * A(m-i,n-i);\rtmp %= mod;\rif(i%2==0){\rans += tmp;\r}else ans -= tmp;\rans += mod;\rans %= mod;\r}\rans *= A(m,n);\rans += mod;\rans %= mod;\rcout\u003c\u003cans\u003c\u003cendl;\r//cout\u003c\u003ctmp\u003c\u003cendl;\r return 0;\r}\r F - Unfair Nim ","date":"2020-06-28","objectID":"/abc172/:10:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:11:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 题解url #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rll n;\rcin\u003e\u003en;\rll q,w;\rcin\u003e\u003eq\u003e\u003ew;\rll x = 0;\rfor(ll i=2;i\u003cn;i++){\rll tmp;\rcin\u003e\u003etmp;\rx ^= tmp;\r}\rll d = (q+w-x) / 2;\rif(d\u003c0 or d\u003eq or (d\u0026x) or (q+w-x)%2==1){\rcout\u003c\u003c-1\u003c\u003cendl;\rexit(0);\r}\rfor(ll i=45;i\u003e=0;i--){\rif(x\u003e\u003ei\u00261LL){\rif(d+(1LL\u003c\u003ci) \u003c= q){\rd += (1LL\u003c\u003ci);\r}\r}\r}\rif(d==0) cout\u003c\u003c-1\u003c\u003cendl;\relse cout\u003c\u003cq-d\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-06-28","objectID":"/abc172/:12:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["linux"],"content":"树莓派入门","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"树莓派官网 树莓派4b图解 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:0:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"烧录系统 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"格式化SD卡 用格式化工具SDFormatter V4.0 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:1","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"烧录镜像 从官网下载最新的镜像 打开Win32DiskImager.exe 选择下载的镜像 后面选择E盘 点击write，等待 完成 安装Linux文件查看工具Linux_Reader.exe，打开 可以看到linux的文件结构 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:2","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"放置空的ssh文件 这样允许树莓派用ssh远程连接 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:3","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"wifi配置 在boot盘中个创建文件wpa_supplicant.conf 在里面写入 country=CN\rctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\rupdate_config=1\rnetwork={\rssid=\"将我替换成第一个WiFi的名字，不删除引号,不能有中文\"\rpsk=\"将我替换成WiFi密码，不删除引号\"\rpriority=将我替换成数字，数字越大代表优先级越高\r}\rnetwork={\rssid=\"将我替换成第二个WiFi的名字，不删除引号,不能有中文\"\rpsk=\"将我替换成WiFi密码，不删除引号\"\rpriority=将我替换成数字，数字越大代表优先级越高\r}\r 拔出u盘 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:4","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"开机 插入sd卡，电源线，就可以通电开机了 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:2:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"获取树莓派ip 如果是ios，可以下载dataplicity软件，在此之前需要到它的官网注册（激活）一下邮箱，然后才可以再软件中登录 确保ios设备和树莓派连同一个wifi，然后用这个软件扫描即可 如果是电脑端，可以让电脑和树莓派连到同一个wifi，然后打开advanced_ip_scanner.exe，扫描即可 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:3:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"远程登录 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:4:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"putty远程登录 打开远程ssh工具 putty.exe输入树莓派ip即可 默认用户名是pi 密码是raspberry ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:4:1","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"vncviewer远程登录 打开vnc viewer软件，输入树莓派ip即可，如果出现cannot currently show the desktop，调整分辨率即可 调整分辨率的方法是先用putty远程登录，然后输入sudo raspi-config 选择 display options 选择非默认的分辨率，最后finish ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:4:2","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"给apt-get换源 在终端输入sudo nano /etc/apt/sources.list 把第一行注释掉，在后面复制 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi\rdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi\r 点击右键和方向键下键粘贴，然后ctrl-o保存 运行sudo apt-get update ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:5:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"安装vim sudo apt-get install vim ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:6:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"给pip换源 sudo mkdir ~/.pip\rcd .pip\rsudo nano pip.conf\r 写入 [global]\rtimeout = 10\rindex-url = http://mirrors.aliyun.com/pypi/simple/\rextra-index-url= http://pypi.douban.com/simple/\r[install]\rtrusted-host=\rmirrors.aliyun.com\rpypi.douban.com\r ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:7:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"树莓派的一些设置 sudo raspi-config 进入到设置界面 选择 advanced options 选择 expand filesystem 可以将根目录扩展到sd卡，充分利用sd卡空间 选择 system options 选择 audio 选择 headphones 可以让声音通过耳机输出 在 display options 中按情况调节分辨率，选择 pixel doubling 可以将像素两倍显示，更清晰 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:8:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"安装中文字体和输入法 安装中文字体 sudo apt-get install fonts-wqy-zenhei 安装中文输入法 sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin 在右上角将google pinyin添加进去 下次开机生效，按 ctrl+space 切换输入法 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:9:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"安装teamviewer 进入官网 选择 armv7_32bits cd /home/pi/Downloads\rsudo dpkg -i 下载的文件名_armhf.deb\rsudo apt-get -f install\rsudo apt-get install gdebi\r 点击右上角的图标即可进入 需要注册账号 teamviewer遇到网络问题，设备可以断掉重连 另外一种内网穿透可以用sunny-ngrok ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:10:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"参考 https://blog.csdn.net/wu693966797/article/details/95936275 https://www.bilibili.com/video/BV1zb411x7yo 资源 百度网盘 提取码 92Mb 推荐淘宝购买店铺 ： 亚博智能科技 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:11:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["nowcoder"],"content":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"挺好的比赛 A-找规律 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:0:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 玄学题，打表找规律或者猜测规则是每次洗牌是将一个位置移动到另一个固定位置 13次洗牌之后所有的位置都占过一遍，所以13次是循环 要求洗牌5次的结果就是求9次两次洗牌的结果 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rstring s[30];\rstring t[30];\rint a[30];\rvoid init_a(){\rfor(int i=0;i\u003c13;i++){\rfor(int j=0;j\u003c13;j++){\rif(s[i] == t[j]){\ra[i] = j;\rbreak;\r}\r}\r}\r}\rvoid sol(){\rfor(int i=0;i\u003c13;i++){\rt[a[i]] = s[i];\r}\rfor(int i=0;i\u003c13;i++){\rs[i] = t[i];\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rwhile(cin\u003e\u003es[0]){\rfor(int i=1;i\u003c13;i++) cin\u003e\u003es[i]; for(int i=0;i\u003c13;i++) cin\u003e\u003et[i]; init_a();\rfor(int i=0;i\u003c9;i++) sol();\rfor(int i=0;i\u003c13;i++) cout\u003c\u003cs[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\r//cout\u003c\u003c\"end\"\u003c\u003cendl;\r }\rreturn 0;\r}\r B-签到题 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:1:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 排列组合 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+9;\rll fac[100005];\rll inv[100005];\rll C(ll n,ll m){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rll A(ll n,ll m){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main(){\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u003c100005;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rinv[0] = 1;\rinv[1] = 1; //inv[0]=1 !!! for(ll i=2;i\u003c=100005;i++){\rinv[i] = (mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=100005;i++){\rinv[i] = (inv[i]*inv[i-1])%mod;\r}\rll n;\rwhile(cin\u003e\u003en){\rcout\u003c\u003cn*C(n,2)%mod*A(n-1,n-2)%mod\u003c\u003cendl;\r}\rreturn 0;\r}\r C-救救AR ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:2:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题意 找规律 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n;\rcin\u003e\u003en;\rif(n==1 or n==2 or n==3){\rcout\u003c\u003c-1\u003c\u003cendl;\r}\relse{\rif(n\u00261){\rcout\u003c\u003c\"ARA\";\rfor(int i=0;i\u003cn/2;i++){\rcout\u003c\u003c\"R\";\r}\rcout\u003c\u003cendl;\r}\relse{\rcout\u003c\u003c\"AA\";\rfor(int i=0;i\u003cn/2;i++) cout\u003c\u003c\"R\";\rcout\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r D-ar采蘑菇 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:3:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 状态压缩dp #include\u003ciostream\u003e\r#include\u003ccstring\u003e\rusing namespace std;\rusing ll = long long;\rint r[7],u[7];\rint dp[105][105][35];\rint main(){\rint t;\rcin\u003e\u003et;\rint n,m,k;\rwhile(t--){\rmemset(r,0,sizeof(r));\rmemset(u,0,sizeof(u));\rmemset(dp,0,sizeof(dp));\rcin\u003e\u003en\u003e\u003em\u003e\u003ek;\rfor(int i=0;i\u003ck;i++){\rstring s;\rcin\u003e\u003es;\rfor(int j=0;j\u003cs.length();j++){\rif(s[j] == 'R') r[i]++; else u[i]++;\r}\r}\rdp[0][0][0] = 1;\rfor(int i=0;i\u003c=n;i++){\rfor(int j=0;j\u003c=m;j++){\rfor(int st=0;st\u003c(1\u003c\u003ck);st++){\rfor(int q=0;q\u003ck;q++){\rint nn = i - r[q];\rint mm = j - u[q];\rif(nn\u003c0 or nn\u003en or mm\u003c0 or mm\u003em) continue;\rif(st\u003e\u003eq\u00261){\rdp[i][j][st] |= dp[nn][mm][st];\rdp[i][j][st] |= dp[nn][mm][st^(1\u003c\u003cq)];\r}\r}\r}\r}\r}\rint ans = 0; //等于0就ac,-1wa\r for(int i=0;i\u003c(1\u003c\u003ck);i++){\rif(dp[n][m][i]){\rans = max(ans , __builtin_popcount(i));\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r E-呼兰河传 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:4:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 最大的lcm为全选取 经典的大数求lcm 暴力超时，且除以gcd无法取模 由于题目的数据规模可以去重 对于每一个因数，求这些数对于它幂次方贡献的最大值 最后遍历所有因数，对于最大贡献求积 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+9;\rll pn[100005];\rset\u003cll\u003e st;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rvoid did(ll x){\rfor(ll i=2;i*i\u003c=x;i++){\rif(x%i==0){\rll num = 0;\rwhile(x%i==0){\rx /= i;\rnum++;\r}\rpn[i] = max(pn[i] , num);\r}\r}\rif(x != 1){\rpn[x] = max(pn[x] , 1LL);\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rll n;\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rll x;\rcin\u003e\u003ex;\rst.insert(x);\r}\rfor(ll i:st){\rdid(i);\r}\rll ans = 1;\rfor(ll i=2;i\u003c=1e5+2;i++){\rans *= qpow(i,pn[i]);\rans %= mod;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F-月出皎兮，佼人僚兮。 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:5:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 对于某一节点u，设子树颜色数最大是 p，颜色总数是sum，如果p*2 \u003e sum 最大匹配数是sum - p，否则都能匹配 sum/2 所以只要求子树颜色最多的数量 暴力dfs超时，所以用树上启发式合并 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 2e5+3;\rstruct edge{\rint to,nxt;\r}e[maxn\u003c\u003c1];\rll sz[maxn],par[maxn],c[maxn],num[maxn],head[maxn],wch[maxn],tot[maxn],ans[maxn];\rll n;\rll cnt;\rll tmax;\rll sum;\rvoid add_edge(ll u,ll v){\re[++cnt].to = v;\re[cnt].nxt = head[u];\rhead[u] = cnt;\r}\rvoid dfs(ll u,ll p){\rsz[u] = 1;\rfor(ll i=head[u]; i ;i=e[i].nxt){\rll t = e[i].to;\rif(t != p){\rdfs(t,u);\rsz[u] += sz[t];\rif(sz[t] \u003e sz[wch[u]]) wch[u] = t;\r}\r}\r}\rvoid cal(ll u,ll p,ll wch,ll val){\rtot[c[u]] += val * num[u];\rsum += val * num[u];\rtmax = max(tmax , tot[c[u]]);\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch){\rcal(t,u,wch,val);\r}\r}\r}\rvoid dsu(ll u,ll p,ll kp){\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch[u]){\rdsu(t,u,0);\r}\r}\rif(wch[u]) dsu(wch[u],u,1);\rcal(u,p,wch[u],1);\rif(2*tmax \u003e sum) ans[u] = sum - tmax;\relse ans[u] = sum / 2; if(!kp) {\rcal(u,p,0,-1);\rtmax = 0;\rsum = 0;\r}\r}\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn-1;i++){\rll x,y;\rcin\u003e\u003ex\u003e\u003ey;\radd_edge(x,y); add_edge(y,x);\r}\rfor(ll i=1;i\u003c=n;i++){\rll x,y;\rcin\u003e\u003ex\u003e\u003ey;\rc[i] = x;\rnum[i] = y;\r}\rdfs(1,0);\rdsu(1,0,1);\rfor(int i=1;i\u003c=n;i++){\rcout\u003c\u003cans[i]\u003c\u003cendl;\r} return 0;\r}\r G-寻找未曾见过的你 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:6:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 不会 H-AR的背包 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:7:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 不会 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:8:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["note"],"content":"正则表达式","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"正则表达式的基础用法 在线测试网站 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"限定符 ？ used? 表示？前面的字符可有可无 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"限定符 * *之前的字符出现0或多次 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"限定符 + +之前的字符出现至少一次 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"出现指定次数 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"字符串重复出现 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:5:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"或运算 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:6:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"指定匹配哪些字符 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:7:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"\\d表示数字（元字符） ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:8:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"\\w表示所有的数字、字符、下划线 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:9:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"\\s表示空格、制表符、换行 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:10:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"其他说明 \\S 是\\s的补集 \\W是\\w的补集 \\D是\\d的补集 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:10:1","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":".表示任意字符（不包括换行符） ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:11:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"^a匹配行首的a ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:12:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"a$匹配行尾的a ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:13:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"贪婪匹配转懒惰匹配 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:14:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"例子：RGB ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:15:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["abc"],"content":"abc171","date":"2020-06-22","objectID":"/abc171/","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"A - αlphabet ","date":"2020-06-22","objectID":"/abc171/:0:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:1:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rchar a;\rcin\u003e\u003ea;\rif(isupper(a)) cout\u003c\u003c'A';else cout\u003c\u003c'a';\rreturn 0;\r}\r B - Mix Juice ","date":"2020-06-22","objectID":"/abc171/:2:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:3:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n,k;\rcin\u003e\u003en\u003e\u003ek;\rint a[n];\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rsort(a,a+n);\rint ans = 0;\rfor(int i=0;i\u003ck;i++) ans+=a[i];\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - One Quadrillion and One Dalmatians ","date":"2020-06-22","objectID":"/abc171/:4:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 类似于十进制转26进制 不同的是27是 aa ","date":"2020-06-22","objectID":"/abc171/:5:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 这个题目没有像正常的转化那样进位 所以对每一位求值前先减1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rll a;\rcin\u003e\u003ea;\rstring s = \"\";\r//a--;\r while(a!=0){\ra--;\rs += (a%26) + 'a';\ra /= 26;\r}\rreverse(s.begin(),s.end());\rcout\u003c\u003cs\u003c\u003cendl;\rreturn 0;\r}\r D - Replacing ","date":"2020-06-22","objectID":"/abc171/:6:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:7:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 模拟 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rlong long a[100005];\rint main(){\rlong long n;\rcin\u003e\u003en;\rlong long sum = 0;\rfor(long long i=0;i\u003cn;i++) {\rlong long x;\rcin\u003e\u003ex;\ra[x]++;\rsum+=x;\r}\rlong long q;\rcin\u003e\u003eq;\rfor(long long i=0;i\u003cq;i++){\rlong long t,y;\rcin\u003e\u003et\u003e\u003ey;\rsum+=((y-t)*a[t]);\rcout\u003c\u003csum\u003c\u003cendl;\ra[y]+=a[t];\ra[t] = 0;\r}\rreturn 0;\r}\r E - Red Scarf ","date":"2020-06-22","objectID":"/abc171/:8:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 对于一个数列，第一个位置的值是原数列其他位置的异或，依此类推 还原数列 ","date":"2020-06-22","objectID":"/abc171/:9:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 利用异或性质 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint a[200005];\rint main()\r{\rint n;\rcin\u003e\u003en;\rint ans = 0;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\rans ^= a[i];\r}\rfor(int i=0;i\u003cn;i++){\rcout\u003c\u003c(ans^a[i])\u003c\u003c\" \";\r}cout\u003c\u003cendl;\rreturn 0;\r}\r F - Strivore ","date":"2020-06-22","objectID":"/abc171/:10:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:11:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 把问题转化成满足长度为n的，包含子序列s的字符串有几个 然后就变成排列组合题 考虑所有情况减去不包含子序列s的字符串 不含子序列s的字符串可以这样构造 目标串T可以包含子序列中的1个，2个，3个。。。s.length() - 1个 这样取子序列只能是前几个，因为取s的中间部分就一定不满足条件 对于其中一种情况，举个例子 s = \" acf” 总长度为8 假设从s中选两个，那这两个就一定是 a c 假设它们被安排在这样的位置 12a45c78 那么1号和2号一定不能选到a，4号和5号一定不能选到c，7号和8号一定不能选到f 这样T就一定没有子序列s 对于除ac外的位置都有25种选择 所以这种情况（选两个）就有 $$ C_{8}^{2} * 25^6 $$ 种方案 所以对于所有情况(n是T的长度，s是子序列的长度)，方案数 $$ 26^{n} - \\sum\\limits_{i=0} ^ {s-1} {C_n^i*25^{n-i}} $$ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll fac[2000005];\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll C(ll n,ll m){\rreturn fac[n]*qpow(fac[m] , mod-2)%mod*qpow(fac[n-m] , mod-2)%mod;\r}\rint main(){\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u003c2000002;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rll k;\rcin\u003e\u003ek;\rstring ss;\rcin\u003e\u003ess;\rll s = ss.size();\rll ans = 0;\rfor(ll i=0;i\u003cs;i++){\rans += C(k+s , i) * qpow(25 , k+s-i);\rans %= mod;\r}\rcout\u003c\u003c(qpow(26 , k+s) - ans + mod) % mod\u003c\u003cendl;\rreturn 0;\r}\r 如果用逆元 inline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=n;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\r ","date":"2020-06-22","objectID":"/abc171/:12:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["Python web"],"content":"Django学习","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"跟着django文档实现投票app ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:0:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"需求 一个让人们查看和投票的公共站点。 一个让你能添加、修改和删除投票的管理站点。 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:1:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"环境 ide： pycharm community（不支持Django代码自动补全） 版本：django 2.1.1 数据库：sqlite ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:2:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"创建项目 django-admin startproject mysite\r 生成的文件结构 mysite/\rmanage.py\rmysite/\r__init__.py\rsettings.py\rurls.py\rwsgi.py\r 开启服务器 python manage.py runserver\r ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:3:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"创建应用 python manage.py startapp polls\r 在polls下生成的文件结构 __init__.py\radmin.py\rapps.py\rmigrations/\r__init__.py\rmodels.py\rtests.py\rviews.py\r 创建polls/urls.py作为视图的路由 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:4:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"数据库配置 sqlite是其自带的数据库，使用其他数据库需要添加配置项 比如mysql，在mysite/settings中DATABASES应该这样写 DATABASES = {\r'default': {\r# 'ENGINE': 'django.db.backends.sqlite3',\r # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\r 'ENGINE' : 'django.db.backends.mysql',\r'NAME' : 'test_django',\r'USER' : 'root',\r'PASSWORD' : '123456',\r'HOST' : 'localhost',\r'PORT' : '3306',\r}\r}\r 在使用mysite/settings中的INSTALLED_APPS之前要在数据库中创建一些表，执行 python manage.py migrate\r ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:5:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"创建模型 在polls/models.py中写 __str__方法在命令行调试时有很好的输出 from django.db import models\rimport datetime\rfrom django.utils import timezone\r# Create your models here.\r class Question(models.Model):\rquestion_text = models.CharField(max_length=200)\rpub_date = models.DateTimeField('date published')\rdef __str__(self):\rreturn self.question_text\rdef was_published_recently(self):\rnow = timezone.now()\rreturn now - datetime.timedelta(days=1) \u003c= self.pub_date \u003c= now\r#更改后台的显示方式\r was_published_recently.admin_order_field = 'pub_date'\rwas_published_recently.boolean = True\rwas_published_recently.short_description = 'Published recently?'\rclass Choice(models.Model):\rquestion = models.ForeignKey(Question, on_delete=models.CASCADE)\rchoice_text = models.CharField(max_length=200)\rvotes = models.IntegerField(default=0)\rdef __str__(self):\rreturn self.choice_text\r ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:6:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"激活模型 polls/apps.py from django.apps import AppConfig\rclass PollsConfig(AppConfig):\rname = 'polls'\r 把polls应用安装到项目中，在mysite/settings.py中 INSTALLED_APPS = [\r'polls.apps.PollsConfig', #可插拔 这么做，项目就会包含应用\r 'django.contrib.admin',\r'django.contrib.auth',\r'django.contrib.contenttypes',\r'django.contrib.sessions',\r'django.contrib.messages',\r'django.contrib.staticfiles',\r]\r 运行如下命令 python manage.py makemigrations polls\r 通过运行 makemigrations 命令，Django 会检测对模型文件的修改，并且把修改的部分储存为一次迁移。 运行如下命令，将会把模型的修改同步到数据库中 python manage.py migrate\r 在之后改模型要做这三步 修改模型 python manage.py makemigrations python manage.py migrate ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:7:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"API 打开python命令行 python manage.py shell\r Python 3.5.6 |Anaconda 4.2.0 (64-bit)| (default, Aug 26 2018, 16:05:27) [MSC v.1900 64 bit (AMD64)]\rType \"copyright\", \"credits\" or \"license\" for more information.\rIPython 5.1.0 -- An enhanced Interactive Python.\r? -\u003e Introduction and overview of IPython's features.\r%quickref -\u003e Quick reference.\rhelp -\u003e Python's own help system.\robject? -\u003e Details about 'object', use 'object??' for extra details.\rIn [1]: from polls.models import Choice, Question\rIn [2]: Question.objects.all()\rOut[2]: \u003cQuerySet [\u003cQuestion: what's up?\u003e]\u003e\rIn [3]: Question.objects.filter(id=1)\rOut[3]: \u003cQuerySet [\u003cQuestion: what's up?\u003e]\u003e\rIn [4]: Question.objects.filter(question_text__startswith='What')\rOut[4]: \u003cQuerySet [\u003cQuestion: what's up?\u003e]\u003e\rIn [5]: Question.objects.get(id=2)\r---------------------------------------------------------------------------\rDoesNotExist Traceback (most recent call last)\r\u003cipython-input-5-e5ad49b3e3e3\u003e in \u003cmodule\u003e()\r----\u003e 1 Question.objects.get(id=2)\rD:\\anaconda\\lib\\site-packages\\django\\db\\models\\manager.py in manager_method(self, *args, **kwargs)\r80 def create_method(name, method):\r81 def manager_method(self, *args, **kwargs):\r---\u003e 82 return getattr(self.get_queryset(), name)(*args, **kwargs)\r83 manager_method.__name__ = method.__name__\r84 manager_method.__doc__ = method.__doc__\rD:\\anaconda\\lib\\site-packages\\django\\db\\models\\query.py in get(self, *args, **kwargs)\r397 raise self.model.DoesNotExist(\r398 \"%s matching query does not exist.\" %\r--\u003e 399 self.model._meta.object_name\r400 )\r401 raise self.model.MultipleObjectsReturned(\rDoesNotExist: Question matching query does not exist.\rIn [6]: q = Question.objects.get(pk=1)\rIn [7]: q.was_published_recently()\rOut[7]: False\rIn [8]: q = Question.objects.get(pk=1)\r...: In [9]: q.choice_set.all()\rOut[9]: \u003cQuerySet [\u003cChoice: not much\u003e, \u003cChoice: the sky\u003e, \u003cChoice: just hacking\u003e]\u003e\rIn [10]: q.choice_set.create(choice_text='Not much', votes=0)\rOut[10]: \u003cChoice: Not much\u003e\rIn [11]: c = q.choice_set.create(choice_text='Just hacking again', votes=0)\rIn [12]: c.question\rOut[12]: \u003cQuestion: what's up?\u003e\rIn [13]: q.choice_set.all()\rOut[13]: \u003cQuerySet [\u003cChoice: not much\u003e, \u003cChoice: the sky\u003e, \u003cChoice: just hacking\u003e, \u003cChoice: Not much\u003e, \u003cChoice: Just hacking again\r\u003e]\u003e\rIn [14]: q.choice_set.count()\rOut[14]: 5\rIn [15]: c = q.choice_set.filter(choice_text__startswith='Just hacking')\rIn [16]: c.delete()\rOut[16]: (2, {'polls.Choice': 2})\rIn [17]: quit()\r ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:8:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"Django管理页面 创建管理员账号 python manage.py createsuperuser\r 启动服务器，转到/admin/路径，进入管理员界面 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:9:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"编写视图 需求 问题索引页——展示最近的几个投票问题。 问题详情页——展示某个投票的问题和不带结果的选项列表。 问题结果页——展示某个投票的结果。 投票处理器——用于响应用户为某个问题的特定选项投票的操作。 使用模板系统，更加灵活 建立polls/templates文件夹 在建立polls文件夹，形成polls/templates/polls，将html文件放此目录下 在polls/views.py下编写视图，使用通用视图，结合request和response from django.shortcuts import render, get_object_or_404\r# Create your views here.\r from django.http import HttpResponse, HttpResponseRedirect\rfrom django.template import loader\rfrom .models import Question, Choice\rfrom django.http import Http404\rfrom django.urls import reverse\rfrom django.views import generic\rfrom django.utils import timezone\r# def index(request):\r # latest_question_list = Question.objects.order_by('-pub_date')[:5]\r # context = {\r # 'latest_question_list' : latest_question_list\r # }\r # return render(request, 'polls/index.html', context)\r class IndexView(generic.ListView):\r#model = Question\r template_name = 'polls/index.html'\rcontext_object_name = 'latest_question_list'\r'''\rQuestion.objects.filter(pub_date__lte=timezone.now()) returns a queryset containing Questions whose pub_date is less than or equal to - that is, earlier than or equal to - timezone.now.\r'''\rdef get_queryset(self):\rreturn Question.objects.filter(\rpub_date__lte = timezone.now()\r).order_by('-pub_date')[:5]\rclass DetailView(generic.DetailView):\rmodel = Question\rtemplate_name = 'polls/detail.html'\rdef get_queryset(self):\rreturn Question.objects.filter(pub_date__lte = timezone.now())\rclass ResultsView(generic.DetailView):\rmodel = Question\rtemplate_name = 'polls/results.html'\r# Leave the rest of the views (detail, results, vote) unchanged\r # def detail(request, question_id):\r # question = get_object_or_404(Question, pk = question_id)\r # return render(request, 'polls/detail.html', {'question': question})\r #\r # def results(request, question_id):\r # question = get_object_or_404(Question, pk=question_id)\r # return render(request, 'polls/results.html', {'question': question})\r def vote(request, question_id):\rquestion = get_object_or_404(Question, pk=question_id)\rtry:\rselected_choice = question.choice_set.get(pk=request.POST['choice'])\rexcept (KeyError, Choice.DoesNotExist):\r# Redisplay the question voting form.\r return render(request, 'polls/detail.html', {\r'question': question,\r'error_message': \"You didn't select a choice.\",\r})\relse:\rselected_choice.votes += 1\rselected_choice.save()\r# Always return an HttpResponseRedirect after successfully dealing\r # with POST data. This prevents data from being posted twice if a\r # user hits the Back button.\r return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))\r# 使用reverse将返回 '/polls/3/results/'\r 设置路由 在polls/urls.py中设置路由，并为应用加上命名空间 from django.urls import path\rfrom . import views\rapp_name = 'polls' #命名空间，防止重名\r urlpatterns = [\rpath('' , views.IndexView.as_view() , name = 'index'),\rpath('\u003cint:pk\u003e/' , views.DetailView.as_view() , name = 'detail'),\rpath('\u003cint:pk\u003e/results/' , views.ResultsView.as_view() , name = 'results'),\rpath('\u003cint:question_id\u003e/vote/' , views.vote , name = 'vote'),\r]\r 编写模板 使用软编码url，在polls/templates/polls中编写 index.html \u003c!DOCTYPE html\u003e\r\u003chtml lang=\"en\"\u003e\r\u003chead\u003e\r\u003cmeta charset=\"UTF-8\"\u003e\r\u003ctitle\u003eTitle\u003c/title\u003e\r{% load static %}\r\u003clink rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'polls/style.css' %}\"\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r{% if latest_question_list %}\r\u003cul\u003e\r{% for question in latest_question_list %}\r\u003cli\u003e\u003ca href=\"{% url 'polls:detail' question.id %}\"\u003e{{ question.question_text }}\u003c/a\u003e\u003c/li\u003e\r{% endfor %}\r\u003c/ul\u003e\r{% else %}\r\u003cp\u003eNo polls are available.\u003c/p\u003e\r{% endif %}\r\u003c/body\u003e\r\u003c/html\u003e\r detail.html 表单验证 \u003c!DOCTYPE html\u003e\r\u003chtml lang=\"en\"\u003e\r\u003chead\u003e\r\u003cmeta charset=\"UTF-8\"\u003e\r\u003ctitle\u003eTitle\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r\u003ch1\u003e{{ question.question_text }}\u003c/h1\u003e\r{% if error_message %}\u003cp\u003e\u003cstrong\u003e{{ error_message }}\u003c/strong\u003e\u003c/p\u003e{% endif %}\r\u003cform action=\"{% url 'polls:vote' question.id %}\" method=\"post\"\u003e\r{% csrf_token %}\r{% for choice in question.choice_set.all %}\r\u003cinput type=\"radio\" name=\"choice\" id=\"choice{{ forloop.counter }}\" value=\"{{ choice.id }}\"\u003e\r\u003clabel for=\"choice{{ forloop.counter }}\"\u003e{{ choice.c","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:10:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"自定义管理员界面 在polls/admin.py中编写 from django.contrib import admin\r# Register your models here.\r from .models import Question, Choice\r#admin.site.register(Question)\r # class QuestionAdmin(admin.ModelAdmin):\r # #fields = ['pub_date' , 'question_text']\r # fieldsets = [\r # (None, {'fields': ['question_text']}),\r # ('Date information', {'fields': ['pub_date']}),\r # ]\r #class ChoiceInline(admin.StackedInline):\r class ChoiceInline(admin.TabularInline):\rmodel = Choice\rextra = 3\rclass QuestionAdmin(admin.ModelAdmin):\rfieldsets = [\r(None, {'fields' : ['question_text']}),\r('Date information' , {'fields' : ['pub_date'],\r'classes' : ['collapse']}),\r]\rinlines = [ChoiceInline]\rlist_display = ('question_text', 'pub_date', 'was_published_recently')\rlist_filter = ['pub_date']\rsearch_fields = ['question_text']\radmin.site.register(Question, QuestionAdmin)\r#admin.site.register(Choice)\r ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:11:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"问题记录 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:12:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"问题描述 把sqlite数据库导入到mysql 参考 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:12:1","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"解决方法 安装mysqldb驱动 pip install --pre MySQLdb -i https://pypi.douban.com/simple\r 出错 安装可执行文件 链接 出错，因为python2才有 mysqldb Python3是pymysql 尝试 pip install pymysql\rpy manage.py makemigrations\r 报错 与工程同名的文件夹下的__init__.py中这样写 import pymysql\rpymysql.version_info = (1, 3, 13, 'final', 0)\rpymysql.install_as_MySQLdb()\r 再执行 py manage.py makemigrations\r 找到对应的错误 定位到这样的代码段 query = getattr(cursor, '_executed', None)\rif query is not None:\rquery = query.decode(errors='replace')\rreturn query\r 把decode改成encode ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:12:2","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["linux"],"content":"install ubuntu in vmware","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装vmware 点击这里 需要注册账号 vmware的安装基本选择默认选项，一直next ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:1:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"准备一个ubuntu镜像文件 点击这里 选择对应版本的ubuntu文件 文件类似于 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:2:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装ubuntu 打开vmware 点击“创建新的虚拟机” 点击“自定义” 点击“下一步” 硬件兼容性选低一点能兼容的比较多 点击“下一步” 选择“稍后安装操作系统” 点击“下一步” 选择linux 选择 ubuntu64位 点击“下一步” 选择”虚拟机名称“和安装的路径 点击“下一步” 根据自身计算机性能来分配处理器数量 点击“下一步” 选择虚拟机内存，一般2G就行 点击“下一步” 选择“桥接网络” 点击“下一步” 选择推荐的那个 点击“下一步” 选择推荐的那个 点击“下一步” 选择“创建新的虚拟磁盘” 点击“下一步” 根据需求选择磁盘空间大小（一般20G以上） 点击“立即分配磁盘空间” 选择“将虚拟磁盘拆分成多个文件” 点击“下一步” 点击“下一步” 点击“完成”，开始创建（需要花很长的时间） 完成之后 先不要开启虚拟机 点击“编辑虚拟机设置” 点击”cd/dvd“ 选择“使用iso影像文件” 点击“浏览” 找到最开始装的iso文件 点击“确定 点击“开启虚拟机” 选择”中文“，点击“安装ubuntu” 点击“继续” 点击“继续” 点击“现在安装” 完成后 点击“继续” 点击“继续” 输入信息 点击“继续”，开始安装 完成后 点击“现在重启” 点击“小圆”，选择”ubuntu2d“ 输入密码，登录 完成 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:3:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"附加 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"鼠标滚轮无法使用的问题 应该只有罗技鼠标会出现这种情况吧 参考此处 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:1","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"chromium无法打开的问题 升级版本，据说chrome不支持ubuntu12及以下 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:2","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"中文输入法无法显示候选词框的问题 莫名其妙可以，如果fcitx不行，尝试安装搜狗输入法，要重启才能启用搜狗，但一般搜狗输入法也无法显示，可能与kde桌面有关，真正的原理未知 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:3","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"创建快捷方式（在启动器中） 在dash中输入，找到后直接拖到启动器中，可调整顺序 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:4","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装flatabulous主题 参考此处 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:5","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装clion 官网下载 tar.gz压缩包 然后 tar -zxvf XXX.tar.gz 解压缩 然后在bin目录下./clion.sh 安装gcc sudo apt-get update sudo apt-get install build-essential gcc --version 如果没有 sudo apt-get install gcc-对应的版本号 安装cmake 参考此处 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:6","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装pycharm 官网下载 tar.gz压缩包 然后 tar -zxvf XXX.tar.gz 解压缩 然后在bin目录下./pycharm.sh ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:7","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装anaconda 去官网下载 bash Anaconda3-2020.11-Linux-x86_64.sh 配置环境变量 vim ~/.bashrc 在最后一行输入 export PATH=\"~/anaconda3/bin:$PATH\" 然后在终端输入 source ~/.bashrc 查看anaconda版本 anaconda --version ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:8","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"初步使用体验 初步使用ubuntu的感想 虽然ubuntu有图形界面，但它不像windows那样丰富，大多数的操作都可以通过点击可视化界面完成 ubuntu类似于万物皆文件，以抽象的形式存在，所以很多操作只能由命令行完成 ubuntu的很多操作都比windows直接，且安全性也比windows高，管理c++工程，比如安装库都要比windows方便，我觉得很大的原因在于windows要服务于大众，而linux更像自娱自乐的工具 使用linux只是使用它的特性，整体上windows还是大大优于linux ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:5:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["database"],"content":"mysql基础","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"基本操作 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"进入数据库 mysql -uroot -p123456;\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看所有数据库 show databases；\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"使用某个数据库 use XXX;\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:3","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看某个数据库中的admin信息 select * from admin;\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:4","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"带条件的查询 select * from admin where id = 1;\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:5","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"mysql数据类型 链家 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:6","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看当前在哪个数据库 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:7","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看数据库中有哪些表 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:8","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"创建数据库 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"创建数据库 create database test2;\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看数据库中的表 show tables;\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"如何创建一个数据表 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:3","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看某个表的详情 或者 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:4","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"往某个表中添加新的记录 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:5","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看表中的记录 select * from person;\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:6","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"增加新字段 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:7","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"对字段的操作 链接 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:8","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"对某一条记录的crud ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:3:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"删除 delete from person where name = 'dyh';\r ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:3:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"更新数据 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:3:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"创建表的约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"主键约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"联合主键 （是 与 逻辑）（不能为null） ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"自增约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:3","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"忘记添加主键约束，之后添加 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:4","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"删除主键约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:5","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"通过修改字段的方式来增加或删除主键约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:6","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"唯一约束（和主键约束的区别就是它可以为空） 失败 这样能成功（猜测和null有关） 还可以直接在创建的时候添加 当重复对一个字段添加unique是key会变成mul ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:7","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"删除唯一约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:8","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"非空约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:9","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"默认约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:10","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"外键约束 要两个表 主表和副表 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:11","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"数据表设计 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:5:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"1NF 字段不可拆分 链接 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:5:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"2NF 链接 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:5:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"3NF 链接 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:5:3","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查询练习","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"数据准备 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:0","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"数据库 test3 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:1","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"建表 学生表 课程表 成绩表 教师表 Student Course Score Teacher 学号 课程号 学号 教师编号 姓名 课程名称 课程号 教师名字 性别 教师编号 成绩 教师性别 出生年月日 出生年月日 所在班级 职称 所在部门 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:2","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"学生表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:3","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"教师表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:4","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"课程表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:5","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"成绩表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:6","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"添加数据 课程表 分数 学生 教师表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:7","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"10个基础查询练习 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:0","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询student中的所有记录 SELECT * FROM student;\r ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:1","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询其中几个字段 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:2","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询教师表中不重复的部门 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:3","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询30到50之间的成绩 或者 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:4","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询成绩是34 32 23 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:5","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询在9001班或者性别为女的同学 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:6","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"按班级降序查询 默认升序 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:7","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"在成绩表中按cnum升序优先，否则snum降序排列 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:8","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"在学生表中查找男有几个 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:9","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询最高分的学生学号和课程号 或者 上面limit第一个数字表示从哪开始，第二个数字表示查询几条 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:10","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"基础查询2 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:3:0","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"计算7-503课程号的平均成绩 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:3:1","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询所有的课程平均分 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:3:2","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"分组与模糊 查询在成绩表中cnum数量大于等于2且cnum以1-开头的成绩平均分（ 要用到模糊查询） ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:3:3","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"多表查询 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:0","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询学生名字、选课序号和成绩 首先可以查两个表观察一下 最后多表联查 注意是单个等号 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:1","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"三表查询 在1的基础上多一个课程名字 查询时起个别名 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:2","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询9001班学生平均分 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:3","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询选修1-797中成绩高于1004号的同学的所有成绩 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:4","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询与1001号和1002号学生同年出生的学生 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:5","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询李雷任课的学生成绩 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:6","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询选修某课程人数\u003e1的任课老师姓名 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:7","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"两表合并 union 先做到这边，还有很多以后再补充 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:8","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["abc"],"content":"abc170","date":"2020-06-15","objectID":"/abc170/","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"A - Five Variables ","date":"2020-06-15","objectID":"/abc170/:0:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 找5个数中值为0的下标 ","date":"2020-06-15","objectID":"/abc170/:1:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 a = list(map(int , input().split()))\rprint(a.index(0) + 1)\r B - Crane and Turtle ","date":"2020-06-15","objectID":"/abc170/:2:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 鸡兔同笼问题 ","date":"2020-06-15","objectID":"/abc170/:3:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 n , m = map(int , input().split())\rprint('Yes') if (m - 2 * n) % 2 == 0 and (m - 2 * n) \u003e= 0 and 4 * n - m \u003e= 0 and (4 * n - m) % 2 == 0 else print('No')\r C - Forbidden List ","date":"2020-06-15","objectID":"/abc170/:4:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一数x 和一数列，找不在数列中离x最近的数 ","date":"2020-06-15","objectID":"/abc170/:5:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 x , n = map(int , input().split())\rb = []\rif n!=0:\rb = list(map(int,input().split()))\rt = 0\rans = 0\rwhile 1:\rif x-t not in b:\rans = x - t\rbreak\rif x+t not in b:\rans = x + t\rbreak\rt += 1\rprint(ans)\r D - Not Divisible ","date":"2020-06-15","objectID":"/abc170/:6:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一数列，对于数列中的每个数，如果都不能被其他数整除，计数器 + 1 求计数器的值 ","date":"2020-06-15","objectID":"/abc170/:7:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 暴力时间复杂度 O(n*√(V)) 好像会超时 可以排序，从小到大遍历，对于当前数，考虑 2*x 3*x 4*x 的值是否在数列里，如果在数列里（只会比当前数大）则移除 这样总共要算 (1/2 + 1/3 + 1/4 + 1/5 + 1/6 + … + 1/n) * V = (ln(n) + 0.578) * V 次 时间复杂度为 O(n*ln(n)) 注意当数列中有重复数，则都不能算 注意特判1个数 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\r//int a[200005];\rset\u003cint\u003e st;\rset\u003cint\u003e stt;\rmultiset\u003cint\u003e ms;\rvoid did(int x){\rfor(int i=2;i*x\u003c=1000005;i++){\rint tmp = i*x;\rif(st.find(tmp)!=st.end()){\rst.erase(tmp);\r}\r}\r}\rint main(){\rcin\u003e\u003en;\r//for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\r for(int i=0;i\u003cn;i++){\rint x;\rcin\u003e\u003ex;\rst.insert(x);\rstt.insert(x);\rms.insert(x);\r}\r//for(int i:st) cout\u003c\u003ci\u003c\u003cendl;\r if(st.size()==1 and n\u003e1) {\rcout\u003c\u003c0\u003c\u003cendl;\rreturn 0;\r}\rif(n==1) { // WA!!!\r cout\u003c\u003c1\u003c\u003cendl;\rreturn 0;\r}\rfor(int i:st){\rdid(i);\r}\r//for(int i:st) cout\u003c\u003ci\u003c\u003cendl;\r int ans = st.size(); // WA !!!!\r for(int i:st){\rif(ms.count(i)\u003e1) ans--;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - Smart Infants ","date":"2020-06-15","objectID":"/abc170/:8:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 每个小朋友都有一个分数和初始的幼儿园 每次转学的操作是 将第 i 个小朋友转到第 j 个幼儿园 对于q次转学 每次输出每个幼儿园中分数最高的最小值 ","date":"2020-06-15","objectID":"/abc170/:9:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 一开始的思路是最小值的更新肯定在有变动的幼儿园和当前最小值之间选择 但这是错的，因为当前最小值被覆盖之后，更新后的最小值可能是之前的次小值（而次小值没有记录） 所以：用集合模拟幼儿园（目的在于log时间内排序） 对于每次操作都用集合模拟，用多重集维护所有的最大值 通过查看幼儿园最大值是否被更换来决定是否对多重集进行增删 一百万个数据错了3个，原因竟然是： 多重集的erase操作是全删而不是删一个 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,q;\rset\u003cpair\u003cint,int\u003e, greater\u003cpair\u003cint,int\u003e \u003e \u003e st[200005];\rmultiset\u003cint\u003e ms;\rint rat[200005];\rint wh[200005];\r//multiset\u003cint , greater\u003cint\u003e\u003e ts[200005];\rint main(){\rcin\u003e\u003en\u003e\u003eq;\rfor(int i=0;i\u003cn;i++){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rb--;\rrat[i] = a;\rwh[i] = b;\rst[b].insert({a,i});\r//ts[b].insert(a);\r }\rfor(int i=0;i\u003c200005;i++){\rif(st[i].empty()) continue;\r//int num = ts[i].count(*ts[i].begin());\r //for(int j=0;j\u003cnum;j++){\r ms.insert(st[i].begin()-\u003efirst);\r//}\r }\rwhile(q--){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\ra--,b--;\rbool ismax = false;\rif(st[wh[a]].begin()-\u003esecond == a) ismax = true;\rif(ismax){\rms.erase(ms.find(rat[a]));\rst[wh[a]].erase({rat[a] , a});\rif(st[wh[a]].empty()) ;\relse ms.insert(st[wh[a]].begin()-\u003efirst);\rwh[a] = b;\rif(st[b].empty()) ;\relse ms.erase(ms.find(st[b].begin()-\u003efirst));\rst[b].insert({rat[a] , a});\rms.insert(st[b].begin()-\u003efirst);\r}\relse{\rst[wh[a]].erase({rat[a] , a});\rwh[a] = b;\rif(st[b].empty()) ;\relse ms.erase(ms.find(st[b].begin()-\u003efirst));\rst[b].insert({rat[a] , a});\rms.insert(st[b].begin()-\u003efirst);\r}\rcout\u003c\u003c*ms.begin()\u003c\u003cendl;\r}\rreturn 0;\r}\r F - Pond Skater ","date":"2020-06-15","objectID":"/abc170/:10:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一个迷宫、起点、终点 对于走的方向，只能是上下左右 对于每一步，最多只能走k格且不能转弯 求是否能到达终点，如果能，最少走几步 ","date":"2020-06-15","objectID":"/abc170/:11:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 bfs 每次沿一个方向，尽可能地走k步 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint h ,w ,k;\rint xs,ys,xt,yt;\rconst int inf = 1e9;\rint dirx[] = {0,-1,1,0};\rint diry[] = {1,0,0,-1};\rint main(){\rcin \u003e\u003e h \u003e\u003e w \u003e\u003e k;\rcin\u003e\u003exs\u003e\u003eys\u003e\u003ext\u003e\u003eyt;\rxs--,ys--,xt--,yt--;\rvector\u003cstring\u003e vt(h);\rfor(int i=0;i\u003ch;i++) cin\u003e\u003evt[i];\rvector\u003cvector\u003cint\u003e\u003e d(h , vector\u003cint\u003e(w,inf));\rqueue\u003cpair\u003cint,int\u003e\u003e q;\rq.push({xs,ys});\rd[xs][ys] = 0;\rwhile(q.size()){\rauto tmp = q.front();\rq.pop();\rint tmpx = tmp.first;\rint tmpy = tmp.second;\rfor(int i=0;i\u003c4;i++){\r// int tox = tmpx + dirx[i];\r// int toy = tmpy + diry[i];\r int ttmpx = tmpx;\rint ttmpy = tmpy;\rint j;\rfor(j=0;j\u003ck;j++){\rttmpx += dirx[i];\rttmpy += diry[i];\rif(ttmpx\u003e=0 and ttmpy\u003e=0 and ttmpx\u003ch and ttmpy\u003cw and vt[ttmpx][ttmpy]!='@' and d[ttmpx][ttmpy] \u003e d[tmpx][tmpy]){\rif(d[ttmpx][ttmpy] \u003e d[tmpx][tmpy] + 1){\rd[ttmpx][ttmpy] = d[tmpx][tmpy] + 1;\rq.push({ttmpx , ttmpy});\r}\r}else break;\r}\r}\r}\rcout\u003c\u003c(d[xt][yt]==1e9 ? -1 : d[xt][yt])\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-06-15","objectID":"/abc170/:12:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["codeforces"],"content":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"A. Shovels and Swords ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:0:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 两个钻石和一个棍子可以造出A，两个棍子和一个钻石可以造出B 每个A或B都可以卖出一块钱，求 x个棍子和y个钻石最多可以卖多少钱 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:1:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 钻石和棍子是等价的，他们一共用了三个，只要贪心地将总数/3即可 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint t;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rcout\u003c\u003cmin({a,b,(a+b)/3})\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Shuffle ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:2:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 初始有n个数，第i个为1，其他为0，给若干个区间，对每个区间，可以选择区间内的数（两个或自身）交换数值 问有多少个数字能在合理选择后达到1 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:3:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 首先前面的区间是否覆盖1，没覆盖全部抛弃，否则从那个区间开始做以下事 判断接下来的区间和这个区间有没有交集，有则用并集刷新当前区间，否则抛弃 最后求集合包含了几个数 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n,x,m;\rint t;\rint l,r;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ex\u003e\u003em;\rint L=-1,R=-1;\rbool ok = false;\rwhile(m--){\rcin\u003e\u003el\u003e\u003er;\rif(ok){\rif(l\u003c=R and L\u003c=r){\rL = min(L,l);\rR = max(R,r);\r}\r}\relse\r{\rif(x\u003cl or x\u003er ) continue;\rL = l,R = r;\rok = true;\r}\r}\rif(L==-1 and R==-1) cout\u003c\u003c1\u003c\u003cendl;\relse cout\u003c\u003cR-L+1\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Palindromic Paths ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:4:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一充满01的矩阵，从左上角走到右下角，只能向右走和向下走 改变矩阵中的若干元素，使得所有路径按序组成的字符串都是回文串 求最小改动数 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:5:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 由于题限，到每个点都走固定的步数，每个步数值与对称的步数值相同（同为0或1） bfs求每格步数，然后对于每一组求0多还是1多，以此决定全是0还是全是1 [WARNING] 以下代码，逻辑低效(懒得改) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n,m;\rint t;\rint a[32][32];\rint d[32][32];\rvector\u003cint\u003e stp[62];\rint used[32][32];\rpriority_queue\u003cpair\u003cint,int\u003e\u003e pq;\rvoid bfs(){\rpq.push({0,0});\rd[0][0] = 0;\rused[0][0] = 1;\rwhile(pq.size()){\rpair\u003cint,int\u003e pii = pq.top();\rpq.pop();\rif(pii.first+1 \u003c n and used[pii.first+1][pii.second]==0) {\rpq.push(make_pair(pii.first+1,pii.second));\rd[pii.first+1][pii.second] = d[pii.first][pii.second] + 1;\rused[pii.first+1][pii.second] = 1;\r}\rif(pii.second+1 \u003c m and used[pii.first][pii.second+1]==0){\rpq.push(make_pair(pii.first,pii.second+1));\rd[pii.first][pii.second+1] = d[pii.first][pii.second] + 1;\rused[pii.first][pii.second+1] = 1;\r}\r}\rfor(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) stp[d[i][j]].push_back(a[i][j]);\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rint ans = 0;\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003c62;i++) stp[i].clear();\rmemset(used,0,sizeof(used));\rfor(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) cin\u003e\u003ea[i][j];\rbfs();\rfor(int i=0,j=n+m-2;i\u003cj;i++,j--){\rif((n+m-2)%2==0 and i==j) continue;\rint zero = count(stp[i].begin(),stp[i].end(),0) + count(stp[j].begin(),stp[j].end(),0);\rint one = count(stp[i].begin(),stp[i].end(),1) + count(stp[j].begin(),stp[j].end(),1);\rans += 2*stp[i].size() - max(zero,one);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r D. Two Divisors ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:6:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一数n，判断n的所有因子中（1除外）是否存在 d1 d2使得 d1+d2与n互质 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:7:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 如果存在，则这组数可以是 d1*d2 = n d1 与d2一定互质 让n一直除以最小因子，除到最后不为1，则剩下的数与之前的除数互质，满足条件 最小因子可以筛法预处理 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n;\rint d1[500005];\rint d2[500005];\rint a[500005];\rint f[10000005];\rvoid preprocess(){\rfor(int i=2;i\u003c10000005;i++)\rif(f[i] == 0)\r{\rf[i] = i;\rfor(int j=i+i;j\u003c10000005;j+=i) f[j] = i;\r}\r}\rvoid did(int x,int ind){\rint foo = f[x];\rint bar = x;\rwhile(x%foo==0) x /= foo;\rif(x==1) d1[ind]=-1,d2[ind]=-1;\relse d1[ind]=x,d2[ind]=bar/x;\r}\rint main(){\rpreprocess();\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rfor(int i=0;i\u003cn;i++) did(a[i] , i);\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cd1[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cd2[i]\u003c\u003c\" \"; cout\u003c\u003cendl; return 0;\r}\r E. Two Arrays ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:8:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给两个数组A B（B为递增），B的大小为m，将A分成m个区间，使得每个区间的最小值与B的每个数相同（按顺序对应），求方案数 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:9:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 隔板法，双指针锁定每个数之间隔板可以移动的范围，最后乘法原理 对于可移动范围，因为B是递增的，从右往左遍历 就是A B数组元素比大小，然后右边的指针贪心地选择可满足数中最右边的数，左指针贪心地选择可满足数中最左边的数 （即右指针左移过程中，碰到可满足数就停下来，左指针要一直移动直到不满足，这样得到最大的区间） 注意特判！！ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll ans = 1;\rint a[200005];\rint b[200005];\rint n,m;\rint l[200005];\rint r[200005];\rint main(){\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rfor(int i=0;i\u003cm;i++) cin\u003e\u003eb[i];\rfor(int i=0;i\u003cm;i++) l[i] = r[i] = -1;\rint ind = m-1;\rfor(int i=n-1;i\u003e=0;i--){\rwhile(ind\u003e=0 and b[ind] \u003e a[i]) ind--;\rif(ind\u003c0) {\rcout\u003c\u003c0\u003c\u003cendl;\rexit(0);\r}\rl[ind] = i;\rif(a[i] == b[ind] and r[ind]==-1){ //greedy\r r[ind] = i;\r}\r}\rif(l[0]==-1 or r[0]==-1) {\rcout\u003c\u003c0\u003c\u003cendl;\rexit(0);\r}\rfor(int i=1;i\u003cm;i++){\rif(l[i]==-1 or r[i]==-1) {\rcout\u003c\u003c0\u003c\u003cendl;\rexit(0); }\rans *= (ll) (r[i] - l[i] + 1);\rans %= mod;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F. Jog Around The Graph ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:10:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:11:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 不会 G. Construct the String ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:12:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:13:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:14:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["Python web"],"content":"Flask-RESTful简单实例","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"Python web的框架有Django Flask Tornado Flask 是一个使用 Python 编写的轻量级 Web 应用程序框架，由werkzeug服务器和jinja2模板引擎组成 RESTful是一个与资源（resource）有关的架构理念 REST全称Representational State Transfer，详细信息参考下面的资料 ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:0","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"功能说明 接下来用Flask-RESTful扩展实现一个非常简单的实例，没有用到数据库，没有用到前端页面（模板），没有表单验证，没有复杂的业务逻辑 只用字典存储数据，实现crud（后期将增加数据库） ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:1","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"实现原理 安装 pip install flask-restful Flask-RESTful最基本的套路 实例化app api 实例化解析器，将待验证的参数加进解析器中 根据路由编写对应的类，在类下面编写需要的函数 将类和对应的路由集成到api中 代码如下 from flask import Flask\rfrom flask_restful import reqparse , abort , Api , Resource\r#实例化\r app = Flask(__name__)\rapi = Api(app)\r#创造初始数据\r PERSONS = {\r'p1' : {'name' : 'qaz' , 'num' : '15'} ,\r'p2' : {'name' : 'wsx' , 'num' : '16'} ,\r'p3' : {'name' : 'edc' , 'num' : '17'} ,\r}\rdef not_exist(ps_id):\rif ps_id not in PERSONS:\rabort(404 , message = 'person {} not exist'.format(ps_id))\r#实例化解析器\r #增加验证参数\r parser = reqparse.RequestParser()\rparser.add_argument('name' , type=str , required=True , help='it is a string') #把它设为必填项\r parser.add_argument('num' , type=int , required=True , help='it is a number') #把它设为必填项\r #对单个人的操作\r class Person(Resource):\rdef get(self , ps_id):\rnot_exist(ps_id)\rreturn PERSONS[ps_id]\rdef delete(self , ps_id):\rnot_exist(ps_id)\rdel PERSONS[ps_id]\rreturn '' , 204\rdef put(self , ps_id):\rnot_exist(ps_id)\rargs = parser.parse_args() #开始数据验证\r info = {'name' : args['name'] , 'num' : args['num']}\rPERSONS[ps_id] = info #更新\r return info , 201\r#对所有人的操作\r class PersonList(Resource):\rdef get(self):\rreturn PERSONS\rdef post(self):\rglobal ps_id\rargs = parser.parse_args()\r#暴力求缺失id\r lis = []\r#求每个键，然后过滤出数字，加进列表中，遍历获得空位置\r for i in PERSONS.keys():\rtmp_filter = filter(str.isdigit , i)\rtmp_list = list(tmp_filter)\rtmp_str = ''.join(tmp_list)\rtmp_int = int(tmp_str)\rlis.append(tmp_int)\rlis.sort()\rflag = False\rfor i,j in range(len(lis)),lis:\rif i+1 != j:\rps_id = i+1\rflag = True\rbreak\rif(not flag): ps_id = len(lis) + 1\rps_id = 'p%d' % (ps_id)\rPERSONS[ps_id] = {'name':args['name'] , 'num':args['num']}\rreturn PERSONS[ps_id] , 201\r#增加对应的路由\r api.add_resource(Person , '/persons/\u003cstring:ps_id\u003e')\rapi.add_resource(PersonList , '/persons')\rif __name__ == '__main__':\rapp.run()\r ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:2","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"测试 查询所有信息 根据ps_id查询单个人的信息 根据ps_id删除某个人的信息 再查看所有人的信息 增加某个人的信息 查看所有人的信息 由于之前删除了2号，所以它占据了2号的位置 改变某个人的信息 现在p3 的name是edc num是17 改成name是uuu，num是27 查看所有人的信息以验证 ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:3","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"参考资料（部分） ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:4","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"Flask学习","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"扩展的地址 flask扩展的地址 ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:1:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"requirement.txt 用来存项目的依赖和版本 ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:2:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"生成requirement.txt pip freeze \u003e requirement.txt\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:2:1","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"安装requirement.txt pip install -r requirement.txt\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:2:2","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"基本框架 from flask import Flask\rapp = Flask(__name__)\r@app.route('/')\rdef index():\rreturn 'hello world'\rif __name__ == '__main__':\rapp.run()\r Flask-RESTful from flask import Flask\rimport flask_restful\rapp = Flask(__name__)\rapi = flask_restful.Api(app)\rclass Hello(flask_restful.Resource):\rdef get(self):\rreturn 'hello world'\rapi.add_resource(Hello , '/')\rif __name__ == '__main__':\rapp.run()\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:3:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"路由 ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:4:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"改变路由请求方式 @app.route('/', methods = ['GET', 'POST'])\rdef index():\rreturn 'hello world'\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:4:1","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"路由参数处理 @app.route('/order/\u003corder_id\u003e')\rdef fun(order_id):\rreturn 'order id is %s' % order_id\r 格式限定 @app.route('/order/\u003cint:order_id\u003e')\rdef fun(order_id):\rreturn 'order id is %s' % order_id\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:4:2","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"Jinja2模板 ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"Jinja2模板引擎渲染网页 from flask import Flask, render_template\rapp = Flask(__name__)\r@app.route('/')\rdef hello_world():\rreturn render_template('index1.html')\rif __name__ == '__main__':\rapp.run()\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:1","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"和模板链接更改数据 from flask import Flask, render_template\rapp = Flask(__name__)\r@app.route('/')\rdef hello_world():\rtmp_url = 'https://dyhgo.fun'\rreturn render_template('index1.html', str_url=tmp_url)\r#此处模板中有str_url\r if __name__ == '__main__':\rapp.run()\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:2","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"变量代码块 {{str_url}}\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:3","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"注释 {# 这是注释 #}\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:4","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"控制代码块 @app.route('/')\rdef hello_world():\rmy_list = [1, 2, 3]\rreturn render_template('index.html', my_list=my_list)\r {% for i in my_list %}\r{% if i \u003e 1 %}\r{{i}} \u003cbr\u003e\r{% endif %}\r{% endfor %}\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:5","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"过滤器 @app.route('/')\rdef hello_world():\r_url = 'aaaB'\rreturn render_template('index.html', _url=_url)\r {{_url | upper}}\u003cbr\u003e\r{{_url | reverse}} \u003cbr\u003e\r{{_url | lower | reverse}}\u003cbr\u003e\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:6","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"Flask表单 from flask import Flask, render_template, request, flash\rapp = Flask(__name__)\rapp.secret_key = 'csfdka'\r@app.route('/' , methods = ['POST','GET'])\rdef fun():\rif request.method == 'POST':\rusername = request.form.get('username')\rpsw = request.form.get('psw')\rpsw2 = request.form.get('psw2')\rprint(username,psw,psw2)\rif not all([username , psw , psw2]):\rflash('有待填项')\relif psw2 != psw:\rflash('两次密码不一致')\relse:\rreturn 'success'\rreturn render_template('index1.html')\r# @app.route('/order/\u003cint:order_id\u003e')\r # def fun2(order_id):\r # return 'order id is %s' % order_id\r if __name__ == '__main__':\rapp.run()\r index1.html \u003c!DOCTYPE html\u003e\r\u003chtml lang=\"en\"\u003e\r\u003chead\u003e\r\u003cmeta charset=\"UTF-8\"\u003e\r\u003ctitle\u003eTitle\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r\u003cform method=\"post\"\u003e\r\u003clabel\u003e用户名\u003c/label\u003e\u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e\r\u003clabel\u003e密码\u003c/label\u003e\u003cinput type=\"password\" name=\"psw\"\u003e\u003cbr\u003e\r\u003clabel\u003e确认密码\u003c/label\u003e\u003cinput type=\"password\" name=\"psw2\" \u003e\u003cbr\u003e\r\u003cinput type=\"submit\" value=\"提交\" \u003e\u003cbr\u003e\r{% for message in get_flashed_messages() %}\r{{message}}\u003cbr\u003e\r{% endfor %}\r\u003c/form\u003e\r\u003c/body\u003e\r\u003c/html\u003e\r ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:6:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"Python学习","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"记录一下第n次学python。。。 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:0:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"打印 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:1:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"转义字符的打印 str = r\"D:\\now\"\rprint(str)\r------------------------------\rD:\\now\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:1:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"数据类型 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:2:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"获得数据类型 print(type(3.14))\rprint(isinstance(15, int))\r-----------------------------------\r\u003cclass 'float'\u003e\r True\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:2:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"运算符 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:3:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"整数除法 幂次 大小关系表达式 print(3//2)\rprint(-3**3)\rprint(3\u003c4\u003c5)\r--------------------------\r1\r-27\rTrue\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:3:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"三目运算符 x = 6 if 2 \u003e 4 else 7\rprint(x)\r--------------------------------\r7\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:3:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"运算符的优先级 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:3:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"列表 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"普通列表 混合列表 空列表 a = [2,3,4]\rprint(a)\ra = ['2',3,True]\rprint(a)\rprint(len(a))\ra = []\rprint(a)\r------------------------------\r[2, 3, 4]\r['2', 3, True]\r3\r[]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"append insert extend a = [1,\"2\",3]\ra.append(\"sss\")\rprint(a)\ra.extend([\"eee\",6])\rprint(a)\ra.insert(1,\"one\")\rprint(a)\r------------------------------\r[1, '2', 3, 'sss']\r[1, '2', 3, 'sss', 'eee', 6]\r[1, 'one', '2', 3, 'sss', 'eee', 6]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"删除元素 a = [1,2,3,3]\ra.remove(1)\rprint(a)\ra.remove(3)\rprint(a)\r-----------------------\r[2, 3, 3]\r[2, 3]\r a = [1,2,3]\rdel a[0]\rprint(a)\rdel a\rprint(a)\r------------------------\r[2, 3]\rTraceback (most recent call last):\rFile \"D:/python/mysources/test2/test2.py\", line 38, in \u003cmodule\u003e\rprint(a)\rNameError: name 'a' is not defined\r a = [1,2,3,4,5]\ra.pop()\rprint(a)\rprint(a.pop())\ra.pop(1)\rprint(a)\r----------------------------\r[1, 2, 3, 4]\r4\r[1, 3]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"slice a = [1,2,3,4]\rprint(a[1:3])\rprint(a[:3])\rprint(a[1:])\rprint(a[:])\rprint(a[:-1])\rprint(a[-3:])\r--------------------------\r[2, 3]\r[1, 2, 3]\r[2, 3, 4]\r[1, 2, 3, 4]\r[1, 2, 3]\r[2, 3, 4]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:4","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"操作符 a = [3,3,1,1,2,4]\rprint(a.count(3))\rprint(a.index(1))\rprint(a.index(3))\rprint(a.index(1,3))\rprint(a.index(1,1,2))#左闭右开\r ------------------------------------\r2\r2\r0\r3\rTraceback (most recent call last):\rFile \"D:/python/mysources/test2/test2.py\", line 60, in \u003cmodule\u003e\rprint(a.index(1,1,2))#左闭右开\r ValueError: 1 is not in list\r a = [3,5,7,1,2]\rb = a[:]\rc = a\ra.reverse()\rprint(a)\ra.sort()\rprint(a)\ra.sort(reverse=True)\rprint(a)\rprint(b)\rprint(c)\r------------------------------------\r[2, 1, 7, 5, 3]\r[1, 2, 3, 5, 7]\r[7, 5, 3, 2, 1]\r[3, 5, 7, 1, 2]\r[7, 5, 3, 2, 1]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:5","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"元组 a = (1,2,'4')\rprint(a)\ra = 1,\rprint(type(a))\ra = (1,)\rprint(type(a))\r-----------------------\r(1, 2, '4')\r\u003cclass 'tuple'\u003e\r \u003cclass 'tuple'\u003e\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:5:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"格式化 s = '{0} {1} {2}'.format(\"aaa\",\"bb\",\"c\")\rprint(s)\rs = '{0:.2f} {1}'.format(3.266,'ww')\rprint(s)\rs = \"%s%c%6.2f\" % ('qqq',98,3.145)\rprint(s)\rprint('%#o' % 10)\rprint('%010d' % 52)\r---------------------------------\raaa bb c\r3.27 ww\rqqq b 3.15\r0o12\r0000000052\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:6:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"序列 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:7:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"一些函数 a = list('abc')\rprint(a)\ra = list((2,3,4))\rprint(a)\ra = list((3,5,1,7,3))\rprint(sorted(a))\rprint(reversed(a)) #没有改变 a\r print(list(reversed(a)))\rprint(sorted(a,reverse=True))\rprint(enumerate(a))\rprint(list(enumerate(a)))\rb = [4,2,6]\rprint(zip(a,b))\rprint(list(zip(a,b)))\r--------------------------------------------\r['a', 'b', 'c']\r[2, 3, 4]\r[1, 3, 3, 5, 7]\r\u003clist_reverseiterator object at 0x000001961A58C400\u003e\r[3, 7, 1, 5, 3]\r[7, 5, 3, 3, 1]\r\u003cenumerate object at 0x000001961A59DA68\u003e\r[(0, 3), (1, 5), (2, 1), (3, 7), (4, 3)]\r\u003czip object at 0x000001961A59E5C8\u003e\r[(3, 4), (5, 2), (1, 6)]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:7:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"函数 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"函数文档 def func(a):\r'it is a doc'\rprint(a)\rfunc(3)\rprint(func.__doc__)\rhelp(func)\r------------------------------\r3\rit is a doc\rHelp on function func in module __main__:\rfunc(a)\rit is a doc\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"函数参数 def func(*params , x = 5):\rprint(x)\rprint(params[1])\rdef fun(*param , x):\rprint(x)\rfunc(2,3,1)\rfun(4,5,2,x=7)\r---------------------------\r5\r3\r7\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"全局变量 a = 5\rdef fun():\ra = 10\rprint(a)\rdef func():\rglobal a\ra = 10\rfun()\rprint(a)\rfunc()\rprint(a)\r10\r5\r10\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"★闭包 def fun1(x):\rdef fun2(y):\rreturn x*y\rreturn fun2\ra = fun1(3)\rprint(type(a))\rb = a(5)\rprint(b)\rprint(fun1(4)(7))\r-------------------------\r\u003cclass 'function'\u003e\r 15\r28\r def fun1():\rx = 3\rdef fun2():\rx *= x\rreturn x\rreturn fun2()\rprint(fun1())\r-------------------------\rTraceback (most recent call last):\rFile \"D:/python/mysources/test2/test2.py\", line 155, in \u003cmodule\u003e\rprint(fun1())\rFile \"D:/python/mysources/test2/test2.py\", line 154, in fun1\rreturn fun2()\rFile \"D:/python/mysources/test2/test2.py\", line 152, in fun2\rx *= x\rUnboundLocalError: local variable 'x' referenced before assignment\r def fun1():\rx = [3]\rdef fun2():\rx[0] *= x[0] #容器化\r return x[0]\rreturn fun2()\rprint(fun1())\r-----------------------------------\r9\r def fun1():\rx = 3\rdef fun2():\rnonlocal x\rx *= x\rreturn x\rreturn fun2()\rprint(fun1())\r---------------------------------------\r9\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:4","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"★lambda表达式 a = lambda x,y : x + y\rprint(a)\rprint(type(a))\rprint(a(3,6))\r------------------------\r\u003cfunction \u003clambda\u003e at 0x000001418C837F28\u003e\r\u003cclass 'function'\u003e\r 9\r print(list(filter(lambda x:x%2,[1,2,3,4,5])))\rprint(list(map(lambda x:x*2+1,[1,2,3,4,7])))\r--------------------------------------------------------\r[1, 3, 5]\r[3, 5, 7, 9, 15]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:5","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"字典 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:9:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"字典化 a = dict((('2','aaa') , (3,'vvv') , ('ss',7)))\rprint(a)\ra = dict(a='222' , sss=99) #key是字符串\r print(a)\r----------------------------------------------\r{'ss': 7, '2': 'aaa', 3: 'vvv'}\r{'a': '222', 'sss': 99}\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:9:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"字典的bif a = {}\rprint(a.fromkeys((1,2,3),'num')) #产生新的但不改变a\r print(a)\rprint(a.fromkeys((1,3,4),('a','b')))\rprint(a.fromkeys((1,3,4),('a','b','d')))\rprint(a.fromkeys(range(4),'s'))\r-------------------------------------------------\r{1: 'num', 2: 'num', 3: 'num'}\r{}\r{1: ('a', 'b'), 3: ('a', 'b'), 4: ('a', 'b')}\r{1: ('a', 'b', 'd'), 3: ('a', 'b', 'd'), 4: ('a', 'b', 'd')}\r{0: 's', 1: 's', 2: 's', 3: 's'}\r a = {}\rb = a.fromkeys((1,3,4),'s')\rprint(b.keys())\rprint(b.values())\rprint(dict(b.items()))\rprint(b.get(7,'x'))\rprint(b.get(3,'x'))\r----------------------------\rdict_keys([1, 3, 4])\rdict_values(['s', 's', 's'])\r{1: 's', 3: 's', 4: 's'}\rx\rs\r a = {1:2}\rb = a\ra = {}\rprint(a)\rprint(b)\rb = a\ra.clear()\rprint(b)\r-----------------------------\r{}\r{1: 2}\r{}\r a = {1:'one' , 2:'to' , 3:'san'}\rb = a\rc = a.copy()\rprint(id(a))\rprint(id(b))\rprint(id(c))\ra.popitem() #随机返回并删除最后一组的键值对\r print(a)\ra.setdefault(4,'for')\rprint(a)\rd = {'5':'five' , 2:'two'}\ra.update(d)\rprint(a)\r----------------------\r2597077552072\r2597077552072\r2597077552200\r{2: 'to', 3: 'san'}\r{2: 'to', 3: 'san', 4: 'for'}\r{2: 'two', 3: 'san', 4: 'for', '5': 'five'}\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:9:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"文件 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:10:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"输入输出重定向 import sys\rstd_out = sys.stdout #备份\r std_in = sys.stdin #备份\r sys.stdout = open('out.txt','w')\rsys.stdin = open('in.txt','r')\rn,m = map(int,input().split())\rprint(n+m)\rsys.stdout.close()\rsys.stdin.close()\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:10:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"异常 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:11:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"捕获异常 try:\rprint(2)\rprint(1+'2')\rexcept (NameError , TypeError) as reason:\rprint(reason)\r------------------------------------------\r2\runsupported operand type(s) for +: 'int' and 'str'\r try:\rprint(2)\rprint(1+'2')\rexcept NameError as reason:\rprint('not defined' + str(reason))\rexcept TypeError as reason:\rprint(reason)\r-----------------------------------------\r2\runsupported operand type(s) for +: 'int' and 'str'\r try:\rprint(2)\rprint(1+'2')\rexcept (NameError, TypeError) as reason:\rprint(reason)\rfinally:\rprint('aaa')\r------------------------------------\r2\runsupported operand type(s) for +: 'int' and 'str'\raaa\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:11:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"异常中的else try:\rprint(2)\rprint(1+'2')\rexcept (NameError , TypeError) as reason:\rprint(reason)\relse:\rprint('no error')\rfinally:\rprint('aaa')\r-------------------\r2\runsupported operand type(s) for +: 'int' and 'str'\raaa\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:11:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"类 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"继承（可以继承多个，但要小心） class Mylist(list):\rpass\rml = Mylist()\rml.append(1)\rml.append(3)\rml.append(2)\rml.sort()\rprint(ml)\r---------------------\r[1, 2, 3]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"基本用法 class Person:\rname = None\rschool = 'hhu'\rdef fun1(self):\rprint(self.name)\rdef fun2(self):\rprint(self.school)\rp = Person()\rp.name = 'qq'\rp.fun1()\rp.fun2()\r---------------------\rqq\rhhu\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"构造函数 class Person:\rdef __init__(self,name,gender):\rself.name = name\rself.gender = gender\rdef doit(self):\rprint(self.name,self.gender)\rp = Person('qq','female')\rp.doit()\r-----------------------------\rqq female\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"私有变量 class Person:\r__name = 'aaa'\rdef getName(self):\rreturn self.__name\rp = Person()\rprint(p.getName())\rprint(p._Person__name)\rprint(p.__name)\rprint(p.name)\r------------------\raaa\raaa\rTraceback (most recent call last):\rFile \"D:/python/mysources/test2/test2.py\", line 282, in \u003cmodule\u003e\rprint(p.__name)\rAttributeError: 'Person' object has no attribute '__name'\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:4","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"类对象、实例对象 class A:\rf = 1\rdef x(self):\rprint('xxx')\ra = A()\rb = A()\rc = A()\rc.f += 1\rprint(c.f)\rprint(a.f)\rA.f += 100\rprint(a.f)\rprint(b.f)\rprint(c.f)\rd = A()\rprint(d.x())\rd.x = 1\rprint(d.x)\rprint(d.x())\r-------------------\rTraceback (most recent call last):\rFile \"D:/python/mysources/test2/test2.py\", line 305, in \u003cmodule\u003e\rprint(d.x())\rTypeError: 'int' object is not callable\r2\r1\r101\r101\r2\rxxx\rNone\r1\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:5","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"构造和析构 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:13:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"杂乱记录 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:14:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"将输入数四舍五入显示 n = float(input())\rprint('%.2f' % (n + 0.001))\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:14:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"多组输入直到文件结束 while True:\rtry:\rpass\rexcept:\rbreak\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:14:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"二维列表的定义 a = [[0] * 5 for i in range(10)]\rprint(a)\r------------------------------\r[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]\r ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:14:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["abc"],"content":"abc169","date":"2020-06-08","objectID":"/abc169/","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"由于事情太多，拖了这么久 A - Multiplication 1 ","date":"2020-06-08","objectID":"/abc169/:0:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入两个数，求积 ","date":"2020-06-08","objectID":"/abc169/:1:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 n,m = map(int,input().split())\rprint(n*m)\r B - Multiplication 2 ","date":"2020-06-08","objectID":"/abc169/:2:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入很多大数，求积是否超过1e18 ","date":"2020-06-08","objectID":"/abc169/:3:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 用 __int128 ， 样例有个情况是前面超过1e18但后面有0 所以遍历一遍数组判断是否有0 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing INT = __int128;\rll a[100005];\rint main(){\rll n;\rcin\u003e\u003en;\rINT ans = 1;\rbool flag = true;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\rif(!a[i]) flag = false;\r}\rif(!flag) {\rcout\u003c\u003c0\u003c\u003cendl;\rexit(0);\r}\rfor(ll i=0;i\u003cn;i++){\rll x = a[i];\rans *= (INT) x;\rif(ans \u003e (INT) 1e18) {\rcout\u003c\u003c-1\u003c\u003cendl;\rexit(0);\r}\r}\rcout\u003c\u003c(ll)ans\u003c\u003cendl;\rreturn 0;\r}\r C - Multiplication 3 ","date":"2020-06-08","objectID":"/abc169/:4:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入两个数，求积 。一个数上限 1e15 ，一个数为小于10的正两位小数 ","date":"2020-06-08","objectID":"/abc169/:5:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 因为精度问题，先 *100 再 /100 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rll a,b,c;\rscanf(\"%lld %lld.%lld\",\u0026a,\u0026b,\u0026c);\rll ans = a*(b*100+c) ;\rans /= 100LL;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - Div Game ","date":"2020-06-08","objectID":"/abc169/:6:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-08","objectID":"/abc169/:7:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 根据唯一分解定理分解，得到质因子和每种质因子的个数 要求次数最多，对于每种质因子，取1次方，2次方，3次方。。。 有个WA点，当无法整除时，ans+1（本身的质数） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rmap\u003cll,ll\u003e mp;\rbool isprime(ll n){\rif(n==1) return false;\rfor(ll i=2;i*i\u003c=n;i++){\rif(n%i==0){\rreturn false;\r}\r}\rreturn true;\r}\rint main(){\rll n;\rcin\u003e\u003en;\rll nn = n;\rfor(ll i=2;i*i\u003c=nn;i++){\rwhile(n%i==0){\rn/=i;\rmp[i]++;\r}\r}\r//cout\u003c\u003cmp[2]\u003c\u003cmp[5];\r ll ans = 0;\rfor(auto i:mp){\r//cout\u003c\u003ci.first\u003c\u003c\" \"\u003c\u003ci.second\u003c\u003cendl;\r ll tmp = i.second;\rll cnt = 0;\rll ct = 1;\rwhile(cnt\u003c=tmp){\rcnt += ct++; }\rct -= 2;\rans += ct;\r}\rif(isprime(n)) ans++; //wa点 做不下去时要判断是不是质数 如果是质数那么z可以等于这个数 即答案+1 cout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - Count Median ","date":"2020-06-08","objectID":"/abc169/:8:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 给 n 个区间，可以在每个区间中选一个数，这样就有 n 个数，对这n个数求中位数，问所有方案中，中位数有几种 ","date":"2020-06-08","objectID":"/abc169/:9:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 数学题 求最小的可能中位数和最大的可能中位数，在此之间的所有数都能取到 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a[200005],b[200005];\rint main(){\rll n;\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rscanf(\"%lld%lld\",\u0026a[i],\u0026b[i]);\r}\rsort(a,a+n);\rsort(b,b+n);\rll low ,hi;\rif(n\u00261){\rlow = a[(n-1)/2];\rhi = b[(n-1)/2];\r}else{\rlow = a[(n-2)/2] + a[(n-2)/2+1] ;\rhi = b[(n-2)/2] + b[(n-2)/2+1];\r}\rcout\u003c\u003chi-low+1\u003c\u003cendl;\rreturn 0;\r}\r F - Knapsack for All Subsets ","date":"2020-06-08","objectID":"/abc169/:10:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 给一堆数，和一个数s 对于这堆数形成的集合，对于它的每个子集 如果该子集中有一个子集的数和为s，计数器加1 求计数器的值 ","date":"2020-06-08","objectID":"/abc169/:11:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 计数dp题 可以考虑其中一种方案是 i 个数加起来等于 s 那么容纳它的所有集合都满足条件 所以计数器加 i*2^(n-i) 要求一堆数中，哪些数加起来能等于s就类似于背包问题 所以考虑dp dp[i][j] 表示前 i 个数和为 j 的答案 对于当前数，可以选择，也可以不选 转移方程 dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]] 根据上面的结论加上dp表示的是答案，所以每多选一个数，就会在前一个的基础上 /2 所以真正的转移方程为 dp[i][j] = dp[i-1][j] + ( dp[i-1][j-a[i]] ) / 2 这样初始条件就是 dp[0][0] = 2^n #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll dp[3005][3005];\rll n,s;\rll a[3005];\rconst ll mod = 998244353;\rll qpow(ll a, ll b, ll m){\rif(b == 0)\rreturn 1;\relse if(b % 2 == 1)\rreturn a * qpow(a, b - 1, m) % m;\relse{\rll num = qpow(a, b/2, m) % m; return num * num % m;\r}\r}\rconst ll inv2 = (mod+1) / 2;\rint main(){\rcin\u003e\u003en;\rcin\u003e\u003es;\rfor(ll i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\rdp[0][0] = qpow(2,n,mod);\rfor(int i=1;i\u003c=n;i++){\rfor(int j=0;j\u003c=s;j++){\r(dp[i][j] += dp[i-1][j]) %= mod;\rif(j\u003e=a[i]) {\r(dp[i][j] += dp[i-1][j-a[i]] * inv2) %= mod;\r}\r}\r}\rcout\u003c\u003cdp[n][s]%mod\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-06-08","objectID":"/abc169/:12:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["problemlist"],"content":"每日一题 (X)","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"堆 贪心 题目 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rstruct p{\rll v,s;\r}ps[100005];\rbool cmp(p a,p b){return a.s\u003eb.s;}\rpriority_queue\u003cll , vector\u003cll\u003e , greater\u003cll\u003e \u003e pq;\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++) cin\u003e\u003eps[i].v\u003e\u003eps[i].s;\rsort(ps,ps+n,cmp);\rll temp=0,ans=0;\rfor(ll i=0;i\u003cn;i++){\rtemp+=ps[i].v;\rpq.push(ps[i].v);\rwhile(pq.size()\u003eps[i].s){\rtemp-=pq.top();\rpq.pop();\r}\rans=max(ans,temp);\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:1:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"区间dp 题目 不会做，看了别人的题解写的 考虑到数据大小 区间dp dp[i][j][k][l] 表示在s1中取i到j区间，在s2中取k到l区间是否能组成回文串 这样它有四种状态转移（分别考虑边界） 对于每一种状态，只要有一种满足就行，用或运算实现 注意一些边界条件，长度从0开始、特判 先枚举长度，对于每一种长度，枚举区间 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rchar s1[52];\rchar s2[52];\rint dp[52][52][52][52];\rint ans=0;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rans=0;\rmemset(dp,0,sizeof(dp)); //没有重置又WA了 scanf(\"%s\",s1+1);\rscanf(\"%s\",s2+1);\rint len1=strlen(s1+1);\rint len2=strlen(s2+1);\rfor(int i=0;i\u003c=len1;i++)\rfor(int j=0;j\u003c=len2;j++)\rfor(int l1=1,r1=i+l1-1;r1\u003c=len1 ;l1++,r1++)\rfor(int l2=1,r2=j+l2-1;r2\u003c=len2 ;l2++,r2++){\rif(i+j\u003c=1) dp[l1][r1][l2][r2]=1;\relse{\rif(s1[l1]==s1[r1] and r1\u003e0) dp[l1][r1][l2][r2] |= dp[l1+1][r1-1][l2][r2]; if(s1[l1]==s2[r2] and r2\u003e0) dp[l1][r1][l2][r2] |= dp[l1+1][r1][l2][r2-1];\rif(s2[l2]==s1[r1] and r1\u003e0) dp[l1][r1][l2][r2] |= dp[l1][r1-1][l2+1][r2];\rif(s2[l2]==s2[r2] and r2\u003e0) dp[l1][r1][l2][r2] |= dp[l1][r1][l2+1][r2-1];\r} if(dp[l1][r1][l2][r2]) ans=max(ans,r2-l2+r1-l1+2);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:2:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"前缀和 区间dp 题目 暴力时间复杂度 O(n^2) dp[i] 表示右区间的右边界为i时的最大值 maxv[i] 表示前 i+1个数区间长度为k的最大值（单区间） 那么 dp[i]=右区间的值+maxv[i] 求 maxv[i] 直接用前缀和预处理，时间复杂度 O(n) 依次遍历数组求答案 据说用st表也可以做，但我不会 思考问题的变形 一：不限制长度——在一个数列里找两个不相交区间使得他们权值和最大 二：区间数目变多——找 m个长度为 k 的不相交区间使得他们的权值和最大 (1≤n≤5000) 三：区间数目变多且不限制长度——找 m 个不相交长度不限的区间使得他们权值和最大(1≤n≤5000) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll t;\rll a[200005];\rll n,k;\rll maxv[200005];\rll sum[200005];\rll ans=0;\rll asn1=0;\rll ans2=0;\rll dp[200005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\r//reset TODO ans=-1e15; //开1e9WA了一发 无语\r cin\u003e\u003en\u003e\u003ek;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\rif(i\u003e0) sum[i]=sum[i-1]+a[i]; else sum[i]=a[i];\r}\r//preprocess\r maxv[k-1]=sum[k-1];\rfor(ll i=k;i\u003cn-k;i++){\rmaxv[i]=max(maxv[i-1],sum[i]-sum[i-k]);\r}\rll temp=0;\rfor(ll i=k;i\u003c2*k;i++) temp+=a[i];\rfor(ll i=2*k-1;i\u003cn;i++){\rdp[i]=temp+maxv[i-k];\rans=max(ans,dp[i]);\rif(i\u003cn-1){\rtemp+=a[i+1];\rtemp-=a[i+1-k];\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:3:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"位运算 题目 模拟位运算 暴力超时 可优化为 (a1+a2+a3...)*(a1+a2+a3...) a为每一位的1 这样只需要计算每一位1的数量 对于每一位，数量平方乘上二次幂系数 最后求和 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rll a[100005];\rll bin[100];\rint main(){\rcin\u003e\u003en;\rll temp;\rfor(ll i=0;i\u003cn;i++){\rll p=0;\rcin\u003e\u003etemp;\rwhile(temp!=0){\rif(temp%2==1) bin[p]++;\rp++;\rtemp/=2;\r}\r}\rll ans=0;\rfor(ll i=0;i\u003c100;i++){\rans+=(bin[i]*bin[i])*(1\u003c\u003ci);\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:4:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"双端队列 （滑动窗口求最值） 题目 经典的滑动窗口求最大最小值问题 经典的做法就是利用双端队列 可以参考此处的讲解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k;\rint num[1000005];\rdeque\u003cint\u003e dq1;\rdeque\u003cint\u003e dq2;\rvector\u003cint\u003e ans1;\rvector\u003cint\u003e ans2;\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003enum[i];\rfor(int i=0;i\u003cn;i++){\rif(!dq2.empty() and dq2.front()\u003c=i-k){\rdq2.pop_front();\r}\rwhile(!dq2.empty() and num[dq2.back()]\u003c=num[i]){\rdq2.pop_back();\r}\rdq2.push_back(i);\rif(i\u003e=k-1){\rans2.push_back(num[dq2.front()]);\r}\r//-----------------华丽的分割线--------------------------- if(!dq1.empty() and dq1.front()\u003c=i-k){\rdq1.pop_front();\r}\rwhile(!dq1.empty() and num[dq1.back()]\u003e=num[i]){\rdq1.pop_back();\r}\rdq1.push_back(i);\rif(i\u003e=k-1){\rans1.push_back(num[dq1.front()]);\r}\r}\rfor(int i:ans1) cout\u003c\u003ci\u003c\u003c\" \"; cout\u003c\u003cendl;\rfor(int i:ans2) cout\u003c\u003ci\u003c\u003c\" \"; cout\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:5:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dp 题目 dp[i] 表示以i为节点的最小费用 则 dp[i]+=min(dp[ch],w) w表示当前i与ch的费用，即不断更新成最小值然后加上去 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,m,s;\rvector\u003cpair\u003cll,ll\u003e \u003e G[100005];\rll dp[100005];\rll deg[100005];\rconst ll inf=0x3f3f3f3f3f3f;\rvoid dfs(ll s,ll p){\rfor(auto i:G[s]){\rll x=i.first;\rll y=i.second;\rif(x!=p){\rdfs(x,s); dp[s]+=min(dp[x],y);\r}\r}\r}\rint main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003es;\rwhile(m--){\rll u,v,w;\rcin\u003e\u003eu\u003e\u003ev\u003e\u003ew;\rG[u].emplace_back(v,w);\rG[v].emplace_back(u,w);\rdeg[u]++;\rdeg[v]++;\r}\rfor(ll i=1;i\u003c=n;i++)\rif(deg[i]==1 and i!=s) dp[i]=inf;\rdfs(s,-1);\rcout\u003c\u003cdp[s]\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:6:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"二分查找 题目 和abc157-E很像 用集合存26个字母对应的下标 依次查找p中字符在s中的位置 每次对集合二分查找 有一个防止集合为空的小技巧 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rchar s[1000005];\rint n;\rchar p[1000005];\rset\u003cint\u003e st[27];\rint main(){\rscanf(\"%s\",s+1);\rint len=strlen(s+1);\r//preprocess\r for(int i=0;i\u003c27;i++){ //防止为空 st[i].insert(len+1);\r}\rfor(int i=1;i\u003c=len;i++){\rst[s[i]-'a'].insert(i);\r}\rcin\u003e\u003en;\rwhile(n--){\rbool ok=true;\rscanf(\"%s\",p+1);\rint lenp = strlen(p+1);\rint foo=1;\rfor(int i=1;i\u003c=lenp;i++){\rauto ind=st[p[i]-'a'].lower_bound(foo);\rif(*ind==len+1){\rok=false;\rbreak;\r} else{\rfoo=(*ind)+1;\r}\r}\rputs(ok?\"Yes\":\"No\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:7:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dfs 题目 对于一个节点，如果以这个节点为根的树的节点（包含自己）是奇数，则这个节点必须与父节点相连，子节点内部自己配对 如果是偶数，则这个节点与子节点一起参与配对 以下代码的缺点是存储数据和求解不够高效 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll t,n;\rvector\u003cll\u003e G[10005];\rll cn[10005];\rll par[10005];\rmap\u003cll,ll\u003e W[10005];\rvoid dfs_par(ll u,ll p){\rpar[u]=p;\rfor(auto i:G[u]){\rif(i!=p){\rdfs_par(i,u);\r}\r}\r}\rvoid dfs_cn(ll u,ll p){\rfor(auto i:G[u]){\rif(i!=p){\rdfs_cn(i,u);\rcn[u]+=cn[i];\r}\r}\rcn[u]++;\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rll t1,t2,w;\rfor(ll i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2\u003e\u003ew;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\rW[t1].insert(make_pair(t2,w));\rW[t2].insert(make_pair(t1,w));\r} dfs_par(1,0);\rdfs_cn(1,0);\rll ans=0;\rfor(ll i=2;i\u003c=n;i++){\rif(cn[i]\u00261){\rans+=W[i][par[i]];\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r//reset TODO\r memset(cn,0,sizeof(cn));\rfor(ll i=0;i\u003c=n;i++){\rG[i].clear();\rW[i].clear();\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:8:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dp 贪心 dfs 题目 主要是树上dp 从子节点向根一直贪心地染色 这样就会出现一个问题，最优解需要染的顶点已经被染过了 所以要不断地更新两个值 dp[i] 现在在i，往根的方向还能染多少个 k[i] 每个点向根方向还能染多少个 那么 dp[i]=max(dp[i],dp[ch]-1) 如果最后 dp[i]==0 那么新的染色点开启 ans++ 否则处理完一个点后k要更新 k[par]=max(k[par],k[i]-1) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cint\u003e c[100005];\rint ans;\rint dp[100005];\rint k[100005];\rint n;\rvoid dfs(int u,int par){\rfor(auto i:c[u]){\rdfs(i,u);\rdp[u]=max(dp[u],dp[i]-1);\r}\rif(dp[u]==0){\r//can't reach next\r ans++;\rdp[u]=k[u];\r}\relse{\r//updata k\r k[par]=max(k[par],k[u]-1);\r}\r}\rint main(){\rcin\u003e\u003en;\rint tmp;\rfor(int i=2;i\u003c=n;i++){\rcin\u003e\u003etmp;\rc[tmp].push_back(i);\r}\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ek[i];\r}\rdfs(1,0);\rcout\u003c\u003cans\u003c\u003c\"\\n\";\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:9:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"堆 （对顶堆求实时中位数） 题目 经典的对顶堆求实时中位数问题 用两个堆存数据 大顶堆存小的一半 小顶堆存大的一半 这样中位数只在大顶堆或小顶堆的顶部 每次存数据需要将它与顶部（中间数）比较 确认放入哪一堆 每次放数后，需要平衡堆的大小，使大小相差不超过1 最后取堆大的顶部即可 plus：几个很坑的点，容易PE，要用快读才能过（还以为算法有问题。。。） #include\u003ciostream\u003e\r#include\u003cqueue\u003e\rusing namespace std;\rint p,n,m;\rint t;\rint main(){\r//ios::sync_with_stdio(0);\r cin\u003e\u003ep;\rwhile(p--){\rpriority_queue\u003cint\u003e q1; //大顶堆 priority_queue\u003cint,vector\u003cint\u003e,greater\u003cint\u003e\u003e q2; //小顶堆 scanf(\"%d%d\",\u0026n,\u0026m);\rif(n!=1) cout\u003c\u003cendl;\rcout\u003c\u003cn\u003c\u003c\" \"\u003c\u003c(m+1)/2\u003c\u003cendl;\rscanf(\"%d\",\u0026t);\rq1.push(t);\rif(m==1) cout\u003c\u003ct; else cout\u003c\u003ct\u003c\u003c\" \";\rfor(int i=2;i\u003c=m;i++){\rscanf(\"%d\",\u0026t);\rif(t\u003eq1.top()) q2.push(t); //比大顶堆大，放入小顶堆\r else q1.push(t);\rif(q1.size()\u003eq2.size()+1){ //平衡两个堆的大小\r q2.push(q1.top());\rq1.pop();\r}\rif(q2.size()\u003eq1.size()+1){\rq1.push(q2.top());\rq2.pop();\r}\rif(i\u00261){ int x;\rif(q1.size()\u003eq2.size()) x=q1.top(); //中位数在堆大的顶部\r else x=q2.top();\rif( ((i+1)/2)%10==0 and m-i\u003e1){\rcout\u003c\u003cx\u003c\u003cendl;\r}\relse if(m-i\u003e1){\rcout\u003c\u003cx\u003c\u003c\" \";\r}\relse cout\u003c\u003cx;\r}\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:10:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"在线区间预处理 前缀 题目 暴力枚举右区间的左右边界，这样时间复杂度就是 O(n^2) 前缀和预处理 对于每个右区间，O(1) 查询这个区间的异或值，然后找前面有几个区间的异或值等于这个区间 这时候只要计算以右区间左边界-1为右边界的区间中每一个的异或，然后与前面计算好的累加即可 最后直接累加到个数上 （注意区间的边界下标） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,a[1005],b[1000005]; //b要开大一点 否则数组越界\rlong long sum; //sum要用long long\rint main(){\rcin\u003e\u003en;\rint tmp;\ra[0]=0;\rfor(int i=1;i\u003c=n;i++) {\rcin\u003e\u003etmp;\ra[i]=a[i-1]^tmp;\r}\rfor(int i=0;i\u003cn;i++){\rfor(int j=i-1;j\u003e=0;j--){\rb[a[i]^a[j]]++;\r}\rfor(int j=i+1;j\u003c=n;j++){\rsum+=b[a[j]^a[i]];\r}\r}\rcout\u003c\u003csum\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:11:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"图论 dfs 题目 奇数层的点到奇数层的点就是偶数路径 偶数同理 注意同一层也可达 还有long long 的转化 还可以树形dp #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rvector\u003cint\u003e G[100005];\rint dep[100005];\rint ln[100005];\rlong long sum=0;\r//int deg[100005];\rvoid dfs(int u,int v){\rfor(auto i:G[u]){\rif(i!=v){\rdep[i]=dep[u]+1;\rdfs(i,u);\r}\r}\r}\rint main(){\rcin\u003e\u003en;\rint t1,t2;\rfor(int i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdep[1]=0;\rdfs(1,0);\rfor(int i=1;i\u003c=n;i++){\rln[dep[i]]++;\r}\rint maxd=*max_element(dep+1,dep+n+1);\rfor(int i=0;i\u003cmaxd+1;i++){\rfor(int j=i;j\u003cmaxd+1;j+=2){\rif(j==i){\rsum+=(long long)ln[i]*(ln[i]-1)/2;\r}\relse{\rsum+=(long long)ln[i]*ln[j];\r}\r}\r}\rcout\u003c\u003csum\u003c\u003cendl;\r//cout\u003c\u003cmaxd\u003c\u003cendl;\r return 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:12:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"排列组合 题目 对于一个长度为n的二进制串 随便选两个数前面放1后面放0 其他随便放 总共有 C(n,2)*2^(n-2) 种 注意对 n 取模 还有一个卡我的点是“特判”！！！ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = unsigned long long;\rll n;\rconst ll mod = 1e9+7;\rll qpow(ll x,ll t){\rll res=1;\rwhile(t\u003e0){\rif(t\u00261) res=res*x%mod;\rx=x*x%mod;\rt\u003e\u003e=1;\r}\rreturn res;\r}\rint main(){\rcin\u003e\u003en;\rif(n==1) cout\u003c\u003c0\u003c\u003cendl;\relse if(n==2) cout\u003c\u003c1\u003c\u003cendl;\relse{\rcout\u003c\u003cqpow(2,n-3)%mod*(n%mod)%mod*((n-1)%mod)%mod\u003c\u003cendl; //记得给n取模\r }\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:13:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"二分法 尺取 题目 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll t;\rll n,a[100005];\rll m,k;\rll k_th(ll x){\rll num=0;\rll sum=0;\rll l=0,r=0;\rif(a[0]\u003ex) num++;\rwhile(r\u003cn and l\u003cn){\rif(num\u003ck){\rr++;\rif( r\u003cn and a[r]\u003ex) num++;\r}\relse{\rsum += n-r; //不小心+1 就错了\r l++;\rif(l\u003cn and a[l-1]\u003ex ) num--; }\r}\rreturn sum;\r}\rbool check(ll x){\rreturn k_th(x) \u003e m-1 ? true : false;\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek\u003e\u003em;\rfor(ll i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rll l = 1,r=1e10,mid;\rwhile(l\u003cr){\rmid = (l+r)\u003e\u003e1;\rif(check(mid)) l = mid+1;\relse r=mid;\r}\rcout\u003c\u003cl\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:14:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"计数dp 题目 不会做，参考了别人的代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll a[100005];\rll dp[100005][12];\rll ls[100005];\rll n,m,k;\rint main(){\rwhile(cin\u003e\u003en\u003e\u003em\u003e\u003ek){ //TODO reset\r memset(dp,0,sizeof(dp));\rmemset(ls,-1,sizeof(ls));\rfor(ll i=1;i\u003c=n;i++){\rcin\u003e\u003ea[i];\r}\r// TODO init 极端情况\r for(ll i=0;i\u003c=n;i++) dp[i][0] = 1;\rfor(ll i=0;i\u003c=11;i++) dp[i][i] = 1;\rfor(ll i=1;i\u003c=n;i++){\rfor(ll j=1;j\u003c=min(i-1 , m);j++){\rdp[i][j] = (dp[i-1][j] + dp[i-1][j-1])%mod;\rll rm = ls[a[i]] - i +j;\rll part = dp[ls[a[i]] - 1][rm];\rif(ls[a[i]]!=-1 and rm\u003e=0) dp[i][j] = (dp[i][j] - part + mod)%mod; //这里也要模\r }\r//update ls[a[i]] = i;\r}\rcout\u003c\u003cdp[n][m]%mod\u003c\u003cendl;\r} return 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:15:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"贪心 堆 题目 贪心 按截至时间从小到大排序 如果按这个顺序选择，则有可能因为当前建筑耗费的时间比别的长，而错过最优解（即选择耗费时间短的，即使它的截至时间更久） 所以我们可以选择耗费时间更短的（相当于有一次反悔的机会），这样ans都加1，但是有更多的选择空间 用一个大顶堆维护当前选中的建筑的耗费时间 遍历所有建筑，如果能在截至时间内完成，就入堆 否则与堆顶比较（耗费时间最长的） 如果堆顶大，则用当前建筑替换堆顶的建筑，使耗费时间尽可能小 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cpair\u003cint,int\u003e\u003e vt;\rint main(){\rint n;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\rvt.emplace_back(x,y);\r}\rsort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return pii1.second\u003cpii2.second;});\rpriority_queue\u003cint\u003e pq;\rint sum = 0;\rfor(auto i:vt){\rif(sum+i.first\u003c=i.second){\rsum+=i.first;\rpq.push(i.first);\r}else if(pq.top()\u003ei.first){\rsum-=pq.top();\rpq.pop();\rsum+=i.first;\rpq.push(i.first);\r}\r}\rcout\u003c\u003cpq.size()\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:16:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"完全背包问题 题目 目标货币系统是子集，所以对于当前数，判断前面的数能否组合到这个数 这就变成完全背包问题，a[i] 表示体积，背包的最大体积是25000，价值就是是否可达到 (dp[i]=0 or 1) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint a[25005];\rint dp[25005];\rint ans;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rmemset(dp,0,sizeof(dp));\rans=0;\rint n;\rcin\u003e\u003en;\rdp[0]=1;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ea[i];\r}\rsort(a+1,a+1+n);\rfor(int i=1;i\u003c=n;i++){ if(!dp[a[i]]) ans++;\rfor(int j=a[i];j\u003c=25000;j++){\rdp[j] = dp[j] |= dp[j-a[i]];\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:17:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"贪心 题目 贪心，只要定排序规则就行 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cpair\u003cint,int\u003e\u003e vt;\rint main(){\rint n;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\rvt.emplace_back(x,y);\r}\rsort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return pii1.first*pii2.second \u003c pii1.second*pii2.first;});\rlong long ans = 0;\rlong long tm = 0;\rfor(auto i:vt){\rans += i.second*tm;\rtm += 2LL*i.first;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:18:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"dp 思维 题目 dp 第一次做真的很难想到 首先题目这么设计肯定是要把式子转换成物理意义 那就是“有两个装置，同时取到相同的排列的方案数，再求和” 设 dp[k][i][j] 表示两个装置都取出k个，第一个装置的上管道取出i个，第二个装置的上管道取出j个 那么第一个装置的下管道取出k-i个，第二个装置的下管道取出 k-j 个 dp 表示进行到此时的 ans 所以 dp 在传导的过程中用 += 最后的结果就是 dp[n+m][n][n] dp 的初始条件是 dp[0][0][0] = 1 dp 的转移方程考虑四种情况 (a[i]==a[j]) dp[k][i][j] += dp[k-1][i-1][j-1] 即两个装置的上管道 各加一个球结果相同 (a[i]==b[k-j]) dp[k][i][j] += dp[k-1][i-1][j] 即第一个装置的上下两个管道各加一个球结果相同 (b[k-i]==a[j]) dp[k][i][j] += dp[k-1][i][j-1] 同上 (b[k-i]==b[k-j]) dp[k][i][j] += dp[k-1][i][j] 同上 由于数据规模，需要用01滚动数组 注意 assert 注意continue 否则超时 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst int mod = 1024523;\rint n,m;\rint dp[2][505][505];\rchar u[505];\rchar d[505];\rint main(){\rcin\u003e\u003en\u003e\u003em;\rcin\u003e\u003e(u+1)\u003e\u003e(d+1);\rdp[0][0][0] = 1;\rfor(int k=1;k\u003c=n+m;k++){\rmemset(dp[k\u00261],0,sizeof(dp[k\u00261]));\rfor(int i=0;i\u003c=n;i++){\rif(k-i\u003c0 or k-i\u003em) continue; //不加这个超时 for(int j=0;j\u003c=n;j++){\rif(k-j\u003c0 or k-j\u003em) continue; //不加这个超时 if(u[i]==u[j] and i and j) {\rdp[k\u00261][i][j] += dp[(k-1)\u00261][i-1][j-1];\rdp[k\u00261][i][j] %= mod;\r}\rif(u[i]==d[k-j] and i and k-j and k-j\u003c=m){\rdp[k\u00261][i][j] += dp[(k-1)\u00261][i-1][j];\rdp[k\u00261][i][j] %= mod;\r}\rif(u[j]==d[k-i] and j and k-i and k-i\u003c=m){\rdp[k\u00261][i][j] += dp[(k-1)\u00261][i][j-1];\rdp[k\u00261][i][j] %= mod;\r}\rif(d[k-i]==d[k-j] and k-i and k-j and k-i\u003c=m and k-j\u003c=m){\rdp[k\u00261][i][j] += dp[(k-1)\u00261][i][j];\rdp[k\u00261][i][j] %= mod;\r}\r}\r}\r}\rcout\u003c\u003cdp[(n+m)\u00261][n][n]%mod\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:19:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"差分 规律 题目 暴力差分 最重要的是所有的点在 log(n) 时间内都会变成 n 此时停机就不会超时 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k;\rint dat[200005];\rint dif[200005];\rbool check(){\rfor(int i=1;i\u003c=n;i++){\rif(dat[i]\u003cn){\rreturn false;\r}\r}\rreturn true;\r}\rvoid did(int x){\rint L = max(1,x-dat[x]);\rint R = min(n , x+dat[x]);\rdif[L]++;\rdif[R+1]--;\r}\rvoid update(){\rfor(int i=1;i\u003c=n;i++){\rdat[i] = dat[i-1] + dif[i];\r}\r}\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003edat[i];\rwhile(1 and k\u003e0){\rfor(int i=1;i\u003c=n;i++) did(i);\rk--;\rif(check()) break;\rupdate();\rmemset(dif,0,sizeof(dif));\r}\rif(k\u003e0) {\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cn\u003c\u003c\" \";\r}\relse for(int i=1;i\u003c=n;i++) cout\u003c\u003cdat[i]\u003c\u003c\" \";\rcout\u003c\u003c'\\n';\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:20:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"分治（01背包问题 + 枚举） 题目 第一次做分治，太妙了 暴力超时 如果在树上用dp预处理，内存超限 解决方法就是分治 完全二叉树有18层，前9层dp预处理所有的点 后9层枚举，然后将两个结果相加。这样将时间复杂度也分开了 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cint\u003e vt;\rint n,q;\rvector\u003cpair\u003cint,int\u003e\u003e info((1\u003c\u003c18) + 3);\rvector\u003cpair\u003cint,int\u003e\u003e res;\r#define fi first\r#define se second\rconst int MAX = 100001;\rint dp[515][MAX];\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rint v,w;\rcin\u003e\u003ev\u003e\u003ew;\rinfo[i] = make_pair(v,w);\r}\r//preprocess\r const int MAX = 100001;\rint lim = min(512,n);\rfor(int j=0;j\u003cMAX;j++){\rdp[0][j] = (j\u003e=info[0].se ? info[0].fi : 0);\r}\rfor(int i=1;i\u003clim;i++){\rint p = (i-1)/2;\rfor(int j=0;j\u003cMAX;j++){\rif(j\u003cinfo[i].se){\rdp[i][j] = dp[p][j];\r}else{\rdp[i][j] = max(dp[p][j] , dp[p][j - info[i].se] + info[i].fi);\r}\r}\r}\rcin\u003e\u003eq;\rwhile(q--){\rint V,L;\rcin\u003e\u003eV\u003e\u003eL;\rV--;\rvector\u003cint\u003e rem;\rwhile(V\u003e=lim){\rrem.push_back(V);\rV = (V-1)/2;\r}\rint ans = 0;\rint sz = rem.size();\rfor(int i=0;i\u003c(1\u003c\u003csz);i++){\rint sv = 0;\rint sw = 0;\rfor(int j=0;j\u003csz;j++){\rif(i\u003e\u003ej\u00261){\rsv += info[rem[j]].fi;\rsw += info[rem[j]].se;\r}\r}\rif(sw \u003c= L){\rans = max(ans , dp[V][L-sw] + sv);\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:21:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"博弈 题目 如果只有一个串，1的个数是奇数，alice必赢 所以只要有1个串1的个数是奇数，alice就对此操作，占据先机 接下来bob怎么操作，alice只要跟着操作就行 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n;\rcin\u003e\u003en;\rbool ok=false;\rfor(int i=0;i\u003cn;i++){\rstring s;\rcin\u003e\u003es;\rbitset\u003c1005\u003e bs(s);\rif(bs.count()\u00261) ok=true;\r}\rif(ok) puts(\"sdzNB\");else puts(\"kgNB\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:22:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"递推 构造 题目 第一个数有两种情况0,1，根据第二例的信息不断往后递推，中途判断格子是否是0或1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rint a[10005];\rint b[10005];\rint sol(int x){\rmemset(b,0,sizeof(b));\rb[0] = 0;\rb[1] = x;\rfor(int i=2;i\u003c=n;i++){\rint tmp = a[i-1] - (b[i-1] + b[i-2]);\rif(tmp == 0 or tmp==1) {\rb[i] = tmp;\r}\relse{\rreturn 0;\r}\rif(i==n){\rif(a[n] == b[n-1] + b[n]){\rreturn 1;\r}\relse{\rreturn 0;\r}\r}\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\rint ans = sol(0) + sol(1);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:23:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"筛法 题目 筛法，注意从 i * i 开始，否则会超时 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 30000005;\rll a[maxn];\rll b[maxn];\rint main(){\rll n;\rcin\u003e\u003en;\r// b[1] = 0;\r// for(ll i = 2; i \u003c maxn;i++){\r// if(a[i] == 0){ // ll q = i;\r// while(q \u003c maxn){\r// if(a[q] == 0){\r// a[q] = i;\r// }q += i;\r// }\r// }\r// b[i] = a[i] + b[i-1]; // }\r ll ans = 0;\rfor(ll i = 2;i \u003c n+1;i++){\rif(a[i] == 0){\rans += i;\rll q = i * i; //从i*i开始，否则会超时 while(q \u003c n+1){\rif(a[q] == 0){\ra[q] = 1;\rans += i;\r}q += i;\r}\r}\r} cout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:24:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"背包问题 dp 题目 由于N=30所以求出所有的方案 类似于完全背包问题 dp[i][k] 表示选 i 个，价值达到 k 的方案数 dp[i][k] = sum(dp[i-1][k-j]) 其中j是每张彩票的面值 最后求 k在 3n 到 4n 之间的方案数 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll dp[35][150];\rint main(){\rint n;\rcin\u003e\u003en;\rdp[0][0] = 1;\rfor(int i=1;i\u003c=n;i++){\rfor(int j=1;j\u003c=4;j++){\rfor(int k=j;k\u003c=4*n;k++){\rdp[i][k] += dp[i-1][k-j];\r}\r}\r}\rll ans = 0;\rfor(int i=3*n;i\u003c=4*n;i++){\rans += dp[n][i];\r}\r//cout\u003c\u003cans\u003c\u003cendl;\r ll tol = pow(4,n);\rll x = __gcd(tol, ans);\rans /= x;\rtol /= x;\rcout\u003c\u003cans\u003c\u003c\"/\"\u003c\u003ctol\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:25:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["codeforces"],"content":"Codeforces Round #644 (Div. 3)","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"可能是最简单的div3（不考dp dfs？） A. Minimal Square ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:0:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给俩相同的长方形，求面积最小的正方形使得容纳两个长方形，且长方形之间不重合 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:1:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 两倍宽或两倍长 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rif(a\u003eb) swap(a,b);\rif(2*a\u003c=b) cout\u003c\u003cb*b\u003c\u003cendl;\relse cout\u003c\u003c4*a*a\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Honest Coach ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:2:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 把一堆数分成两堆，求第一堆最大值和第二堆最小值的差的最小值 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:3:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 排序，求相邻两数差的最小值，以此为分界 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n;\rcin\u003e\u003en;\rint a[55];\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rsort(a,a+n);\rint ans = 1000000000;\rfor(int i=0;i\u003cn-1;i++){\rans = min(ans,a[i+1]-a[i]);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Similar Pairs ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:4:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 定义好数对 (a,b) a,b具有相同的奇偶性或者a,b差为1 给一堆数（偶数个），问是否能被划分成若干个好数对 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:5:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 如果奇数的个数有偶数个就一定可以 否则检测是否有差为1的数对 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n;\rcin\u003e\u003en;\rvector\u003cint\u003e vt1;\rvector\u003cint\u003e vt2;\rfor(int i=0;i\u003cn;i++){\rint x;\rcin\u003e\u003ex;\rif(x\u00261) vt1.push_back(x);else vt2.push_back(x);\r}\rif(vt1.size()%2==0) puts(\"yes\");\relse{\rbool flag=false;\rfor(int i:vt1){\rif(find(vt2.begin(),vt2.end(),i+1)!=vt2.end() || find(vt2.begin(),vt2.end(),i-1)!=vt2.end()){\rflag=true;\rbreak;\r}\r}\rif(flag) puts(\"yes\");\relse puts(\"no\");\r}\r}\rreturn 0;\r}\r D. Buying Shovels ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:6:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 第i种包里有i个铁铲，总共有k种，只能选择一种包，可以买无数个，求最小需要买几包才能获得恰好n个铁铲 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:7:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 k\u003e=n时特判 其他只要遍历到开方，一一检测是否能被整除，不断min #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rll t;\rcin\u003e\u003et;\rwhile(t--){\rll n,k;\rcin\u003e\u003en\u003e\u003ek;\rif(n\u003c=k) cout\u003c\u003c1\u003c\u003cendl;\relse{\rbool flag = false;\rll ans = 1e10;\rfor(ll i=2;i\u003c=(ll)(sqrt(n));i++){\rif(n%i==0 and i\u003c=k){\rans = min(ans , n/i);\rif(n/i\u003c=k) ans = min(ans , i);\rflag=true;\r//break;\r }\r}\rif(!flag) cout\u003c\u003cn\u003c\u003cendl; else cout\u003c\u003cans\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r E. Polygon ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:8:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 判断一个矩阵是否是polygon游戏的产物 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:9:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 对于每一个元素，如果是1就判断右边和下面是否有1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n;\rcin\u003e\u003en;\rchar mat[55][55];\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003emat[i];\r}\rbool ok = true;\rfor(int i=0;i\u003cn;i++)for(int j=0;j\u003cn;j++){\rif(mat[i][j]=='1'){\rif(i==n-1 or j==n-1) continue;\relse{\rif(mat[i+1][j]=='1' or mat[i][j+1]=='1') continue;\relse {\rok = false;\rbreak;\r}\r}\r}\r}\rif(ok) puts(\"yes\");\relse puts(\"no\");\r}\rreturn 0;\r}\r F. Spy-string ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:10:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给一堆长度都是m的字符串，问是否存在一个长度也为m的字符串使得它对每个字符串都有“相同或不同的个数为1” ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:11:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 数据小，暴力枚举 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rvector\u003cstring\u003e vt;\rint n,m;\rbool ck(string q1,string q2){\rint dif = 0;\rfor(int i=0;i\u003cm;i++){\rif(q1[i]!=q2[i]) dif++;\r}\rreturn dif\u003c=1 ? true : false;\r}\rbool check(string ss){\rbool ok = true;\rfor(auto i : vt){\rif(!ck(ss,i)){\rok = false;\rbreak;\r}\r}\rreturn ok;\r}\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em;\rstring s;\rcin\u003e\u003es;\rvt.clear();\rfor(int i=0;i\u003cn-1;i++) {\rstring s1;\rcin\u003e\u003es1;\rvt.push_back(s1);\r}\rbool ok = false;\rstring s3;\rfor(int i=0;i\u003cm;i++){\rfor(int j=0;j\u003c26;j++){\rstring s2 = s;\rs2[i] = 'a' + j;\rif(check(s2)){\rok = true;\rs3 = s2;\rbreak;\r}\r}\r}\rif(ok) cout\u003c\u003cs3\u003c\u003cendl;\relse{\rcout\u003c\u003c-1\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r G. A/B Matrix ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:12:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 是否存在一个n*m的矩阵使得每一行有a个1，每一列有b个1，其他都是0 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:13:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 第一行开头先填a个1，第二行在这个之后填1，然后回到第一个，直到填满a个 第三行以此类推 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n,m,a,b;\rcin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb;\rif(n*a!=m*b) puts(\"no\");\relse{\rint mat[55][55] = {0};\rint one = 0;\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003ca;j++){\rmat[i][one] = 1;\rone++;\rone%=m;\r}\r}\rputs(\"yes\");\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003cm;j++){\rcout\u003c\u003cmat[i][j];\r}puts(\"\");\r}\r}\r}\rreturn 0;\r}\r H. Binary Median ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:14:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给几个长度为m的01串，求对于所有长度为m的01串形成的集合的补集中的中位数（字典序） ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:15:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 将01串转成十进制，最后再转回来 由于数据规模是 2^60 所以不能枚举 以每个给定的数为节点，求补集内比它小的数有几个 求中位数是补集内的第几个 假设是第 i 个，求 i 落在以节点划分的哪个区间内 （几个WA点 要用1LL iota和strtol函数做进制转化时精度太低，是int ） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rll tot;\rll ans;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rll n,m;\rcin\u003e\u003en\u003e\u003em;\rtot = (1LL\u003c\u003cm); // use 1LL ll rem = tot - n;\rrem--;\rll ind = rem / 2;\rvector\u003cpll\u003e vt;\rvector\u003cstring\u003e vts;\rfor(ll i=0;i\u003cn;i++) {\rstring s;\rcin\u003e\u003es;\rvts.push_back(s);\r}\rsort(vts.begin(),vts.end()); //sort first for(ll i = 0;i\u003cvts.size();i++){\rstring st = vts[i];\rll res=0;\rfor(ll j=0;j\u003cm;j++){\rres+=(st[j]=='1' ? (1LL\u003c\u003c(m-j-1)) : 0);\r}\rvt.emplace_back(res,res-i-1LL);\r}\r//sort(vt.begin(),vt.end());\r vt.emplace_back((1LL\u003c\u003cm),(1LL\u003c\u003cm) - n-1LL);\rfor(ll i=0;i\u003cvt.size();i++){\rif(vt[i].second==ind){\rans = vt[i].first - 1;break;\r}else if(vt[i].second\u003eind){\rif(vt.size()==1 or i==0){\rans = ind;break;\r}else{\rans = vt[i-1].first + (ind - vt[i-1].second);break;\r}\r}\r}\rfor(ll i=m-1;i\u003e=0;i--){\rcout\u003c\u003c(ans\u003e\u003ei\u00261);\r}puts(\"\");\r}\rreturn 0;\r}\r ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:16:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["abc"],"content":"abc168","date":"2020-05-19","objectID":"/abc168/","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"A - ∴ (Therefore) ","date":"2020-05-19","objectID":"/abc168/:0:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-19","objectID":"/abc168/:1:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rstring s;\rcin\u003e\u003es;\rchar c=s[s.length()-1];\rswitch(c){\rcase '2' :case '4': case '5': case '7': case '9': cout\u003c\u003c\"hon\\n\";\rbreak;\rcase '3':\rcout\u003c\u003c\"bon\\n\";\rbreak;\rdefault :cout\u003c\u003c\"pon\\n\"; }\rreturn 0;\r}\r B - … (Triple Dots) ","date":"2020-05-19","objectID":"/abc168/:2:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-19","objectID":"/abc168/:3:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint k;\rcin\u003e\u003ek;\rstring s;\rcin\u003e\u003es;\rif(s.length()\u003c=k)cout\u003c\u003cs\u003c\u003cendl;\relse{\rfor(int i=0;i\u003ck;i++){\rcout\u003c\u003cs[i];\r}cout\u003c\u003c\"...\"\u003c\u003cendl;\r}\rreturn 0;\r}\r C - : (Colon) ","date":"2020-05-19","objectID":"/abc168/:4:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 给定时针和分针的长度，起始为12点，问经过h小时m分钟后，时针和分针不连接的端点的距离 ","date":"2020-05-19","objectID":"/abc168/:5:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 用比例求夹角，然后余弦定理 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst double pi = acos(-1);\rusing db = double;\rdouble toRad(double x){\rreturn x/180*pi;\r}\rdb COS(db x,db y,db d){\rreturn sqrt(x*x+y*y-2*x*y*cos(d));\r}\rdb a,b,m,h;\rint main(){\rcin\u003e\u003ea\u003e\u003eb\u003e\u003eh\u003e\u003em;\rdb ma = ((int)(h*60+m)%60)*(db)6;\rdb ha = ((int)(h*60+m)%720)/(db)2;\rdb delta = fabs(ma-ha);\rdb Rdel = toRad(delta);\rdb ans = COS(a,b,Rdel);\rprintf(\"%.10lf\\n\",ans);\rreturn 0;\r}\r D - .. (Double Dots) ","date":"2020-05-19","objectID":"/abc168/:6:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 由n个点组成的边权为1的双向图，每个点一个标志，从这个点开始沿着标志所指向的点（要有边连接）一直走，就可以到达1号点，且是最短路。问对于所有的点是否都存在这样的标志，存在则输出每个标志。 ","date":"2020-05-19","objectID":"/abc168/:7:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 bfs 求前趋 最无脑的做法应该是单源最短路求前趋 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rconst double pi = acos(-1);\rusing db = double;\rconst int max_v = 200005;\rint n,m;\rint prevv[max_v]; struct edge\r{\rint to,cost;\redge(int to,int cost){\rthis-\u003eto = to;\rthis-\u003ecost = cost;\r}\r};\rtypedef pair\u003cint,int\u003e pii; int V;\rvector\u003cedge\u003e G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V,inf);\rfill(prevv,prevv+V,-1); d[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(int i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rprevv[e.to]=v; q.push(pii(d[e.to],e.to));\r}\r}\r} }\rint main(){\rcin\u003e\u003en\u003e\u003em;\rV=n+1;\rfor(int i=0;i\u003cm;i++){\rint t1,t2;\rcin\u003e\u003et1\u003e\u003et2;\rG[t1].push_back(edge(t2,1));\rG[t2].push_back(edge(t1,1));\r}\rdijkstra(1);\rbool ok=true;\rfor(int i=2;i\u003c=n;i++){\rif(prevv[i]==-1) {\rok=false;break;\r}\r}\rif(ok){\rputs(\"Yes\");\rfor(int i=2;i\u003c=n;i++){\rcout\u003c\u003cprevv[i]\u003c\u003cendl;\r}\r}else{\rputs(\"No\");\r}\r//cout\u003c\u003cd[1]\u003c\u003c\" \"\u003c\u003cd[2]\u003c\u003c\" \"\u003c\u003cd[3]\u003c\u003cd[4];\r return 0;\r}\r E - ∙ (Bullet) ","date":"2020-05-19","objectID":"/abc168/:8:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 给n个数对 (ai,bi) 求满足下列条件的集合个数 集合由数对组成，集合中任意两个数对满足 ai*aj + bi*bj != 0 ","date":"2020-05-19","objectID":"/abc168/:9:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 以上的公式是内积形式，把问题转化成给n个向量，找满足任意两个向量不垂直的集合数 由于零向量和任意向量垂直，所以它只能单独在一个集合内 遍历数对，记录每个斜率（用map存出现的次数） 斜率为0和斜率不存在可以特殊处理 遍历每个斜率（出现次数为num），如果没有和它垂直的（找是否有 -1/k） 那么这个斜率的全集就是num个相同的数 子集有 2^num 个 如果有和它垂直的（个数分别为num1,num2），这两种斜率就不能放在一个集合 内，所以要把它们看成一个整体 从两个集合分开选子集，再合并，总的子集个数为 2^num1 -1+ 2^num2 -1 + 1 减去各自的空集加上总体的空集 然后把每个子集数乘起来（乘法原理）（包括斜率为0和不存在） 最后再加上零向量的个数，减去1（除去空集） 照这个方法做是错的 debug半天一直错6个点，看了下数据，都是大数，看了下程序，觉得自己逻辑一点也没有漏洞，模数也没有溢出 直到看到这句话 1E18 long double 精度不够！！所以只能存原始的数对 (ai,bi) 用gcd处理倍数关系 由于 (-a,b) 和 (a,-b) 是一致的，所以让第一个数始终大于0 想想 long double 确实精度不够，但那时真的没想到 发现一个提供atcoder测试数据的网站 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long ;\rll n,x,y;\rusing ld = long double;\rmap\u003cpair\u003cll,ll\u003e,ll\u003e mp;\rconst ll mod = 1000000007;\rll zero;\rll h;\rll v;\rll ans = 1;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ex\u003e\u003ey;\rif(x==0 and y==0) zero++;\relse if(x==0) v++;\relse if(y==0) h++;\relse {\rll g = __gcd(x,y);\rx/=g;\ry/=g;\rif(x\u003c0) x=-x,y=-y;\rmp[{x,y}]++; } }\rfor(auto i:mp){\rll a = i.first.first;\rll b = i.first.second;\rll c = i.second;\rif(c==0) continue;\rll cnt;\rif(-b\u003c0) b=-b,a=-a;\rpair\u003cll,ll\u003e pll = {-b,a};\rif(!mp.count(pll)){\rcnt = qpow(2,c); ans=(ans*cnt)%mod;\r}else{\rcnt = qpow(2,c)-1LL+qpow(2,mp[pll]);\rcnt %= mod;\rans=(ans*cnt)%mod;\rmp[pll]=0;\r}\r}\rif(h!=0 and v!=0){\rll foo = qpow(2,h)-1LL+qpow(2,v);\rfoo %= mod;\rans = (ans*foo)%mod;\r}else if(h==0 and v!=0){\rll foo = qpow(2,v);\rans = (ans*foo)%mod;\r}else if(h!=0 and v==0){\rll foo = qpow(2,h);\rans = (ans*foo)%mod;\r}\rans = (ans+zero)%mod;\rans-=1LL;\rans+=mod;\rans%=mod;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F - . (Single Dot) ","date":"2020-05-19","objectID":"/abc168/:10:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 待补 好像是细节很多的离散化bfs ","date":"2020-05-19","objectID":"/abc168/:11:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["codeforces"],"content":"Codeforces Round #643 (Div. 2) A~D","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Sequence with Digits ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:0:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 看题目 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:1:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 模拟，minDigit(x) 等于0 时打断 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rll t;\rll a,k;\rll maxD(ll n)\r{\rll res=n%10;\rwhile(n)\r{\rres=max(res,n%10);\rn/=10;\r}\rreturn res;\r}\rll minD(ll n)\r{\rll res=n%10;\rwhile(n)\r{\rres=min(res,n%10);\rn/=10;\r}\rreturn res;\r}\rll cal(ll n)\r{\rreturn n+maxD(n)*minD(n);\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ea\u003e\u003ek;\rfor(ll i=1;i\u003ck;i++)\r{\r//cout\u003c\u003ca\u003c\u003c\" \"\u003c\u003ci\u003c\u003c\" \"\u003c\u003cmaxD(a)\u003c\u003c\" \"\u003c\u003cminD(a)\u003c\u003c\" \"\u003c\u003cendl;\r a=cal(a);\rif(minD(a)==0) break;\r}\rcout\u003c\u003ca\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Young Explorers ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:2:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 有一个数组，将它们划分成n组（不用每一个数字都被划分），保证每一组的每个数字都\u003c=这组数字的个数，求最多划分成几组 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:3:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 贪心 方法有很多，其中之一是 排序，对当前数字x，从它开始选x个，如果有不满足的就继续选，直到满足条件 最后一个区间如果不能满足条件则并到前一个区间内 （之前一直以为只要从头到尾或从尾到头贪心地选择数字对应的区间即可） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rint t;\rint n;\rint a[200005];\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\rsort(a,a+n);\rint ans=0;\rfor(int i=0;i\u003cn;){\rint t=a[i];\rint x=i+t-1;\rwhile(t\u003ca[x] and t\u003c=n and x\u003c=n){\rt++;\rx++;\r}\rif(x\u003cn) ans++;\ri+=t;\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Count Triangles ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:4:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给四个数 abcd （从小到大），划分成三个区间，分别从三个区间中选三个数组成三条边，求组成三角形的个数 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:5:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 由于顺序的特殊性，只要检查前两个区间选出来的数之和有没有大于第三个区间选出来的数 对于前两个区间选出来的数之和落在 [a+b , b+c] 然后再判断第三个区间有几个数满足条件 记录一下每个数出现的次数（找规律） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a,b,c,d;\rll ran[1000005];\rint main(){\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed;\rll low=a+b;\rll hi=b+c;\rll num=min(b-a,c-b);\rnum++;\rfor(ll i=1;i\u003c=num;i++){\rran[low]=i;\rlow++;\r}\rfor(ll i=a+b+num;i\u003c=hi-num;i++){\rran[i] = num;\r}\rfor(ll i=hi-num+1;i\u003c=hi;i++){\rran[i] = num;\rnum--;\r}\r//for(ll i=3;i\u003c=5;i++) cout\u003c\u003cran[i]\u003c\u003c\" \";\r ll ans=0;\rfor(ll i=a+b;i\u003c=b+c;i++){\rll mul = ran[i];\rif(i-c-1\u003e=0) {\rif(i-1\u003ed){\rans+=(d-c+1)*mul;\r}else{\rans+=mul*(i-c);\r}\r}\r//cout\u003c\u003cans\u003c\u003cendl;\r }\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D. Game With Array ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:6:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给俩数 n s (n\u003c=s) 问是否存在满足下列条件的数组 数组的长度为 n 元素和为 s 存在k使得任何一个子数组的和都不等于 k或s-k ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:7:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 构造 由于 k 或 s-k 所以当 s/2\u003cn 时不存在 由于数的奇偶性，可以构造全是偶数的数组(2) 这样随便选一个奇数就满足条件 但对于s是奇数时，最后一个元素是奇数，如果把前面全部构造成2，且s/2\u003cn 这样最后一个一定\u003e=3 所以k选择1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n,s;\rcin\u003e\u003en\u003e\u003es;\rif(s/2\u003cn){\rputs(\"no\");\r}\relse{\rputs(\"yes\");\rfor(int i=0;i\u003cn-1;i++){\rcout\u003c\u003c2\u003c\u003c\" \";\r}\rcout\u003c\u003cs-2*n+2\u003c\u003cendl;\rcout\u003c\u003c1\u003c\u003cendl;\r}\rreturn 0;\r}\r ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:8:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"Codeforces Round #641 (Div. 2) A~D","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Orac and Factors ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:0:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数，每一次操作加上他的最小因子（除1外） 问k次操作后，这个数是多少 ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:1:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 奇数找最小因子加一下就变成偶数，偶数最小因子是2 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k,t;\rint ans;\rint f(int x){\rfor(int i=2;i*i\u003c=x;i++){\rif(x%i==0){\rreturn i;\r}\r}\rreturn x;\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek;\rif(n\u00261){\rn+=f(n);\rans = n+(k-1)*2;\r}\relse{\rans = n+k*2; }\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Orac and Models ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:2:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数组，从中选几个数出来，满足严格递增，且对任意相邻下标a,b满足a|b，输出最长子序列的个数 ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:3:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 对于每个数都可以选择x2 x3 x4 x5… 所以对于每个数依次判断x2 x3 x4 x5…是否满足严格递增，由于越大的数越稀疏，所以不会超时 即 if( a[j] \u003e a[i] ) dp[j] = max(dp[j] , dp[i] + 1) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n;\rint dat[100005];\rint dp[100005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003edat[i],dp[i]=1;\rfor(int i=1;i\u003c=n;i++)for(int j=i+i;j\u003c=n;j+=i){\rif(dat[j]\u003edat[i]) dp[j]=max(dp[j],dp[i]+1);\r}\rint ans=-1;\rfor(int i=1;i\u003c=n;i++){\rans=max(ans,dp[i]);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Orac and LCM ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:4:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数组，每两个元素求lcm，把结果放到multi_set中，对multiset求gcd ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:5:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 从a[1]开始依次对后面的数求lcm，然后对结果求gcd gcd(lcm(a1,a2) , lcm(a1,a3) , ... , lcm(a1,an)) = lcm(a1 , gcd(a2,a3, ... , an) 这样就可以利用后缀 最后对所有lcm求gcd #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rll dat[100005];\rvector\u003cll\u003e vt;\rll suf[100005];\rll lcm(ll a,ll b){\rreturn a*b/__gcd(a,b);\r}\rint main(){\rcin\u003e\u003en;\rfor(ll i=1;i\u003c=n;i++) cin\u003e\u003edat[i];\rsuf[n]=dat[n];\rfor(ll i=n-1;i\u003e=2;i--){\rsuf[i]=__gcd(dat[i],suf[i+1]);\r}\rfor(ll i=1;i\u003c=n-2;i++){\rvt.push_back(lcm(dat[i],suf[i+1]));\r}\rvt.push_back(lcm(dat[n-1],dat[n]));\rll gcd=vt[0];\rfor(ll i=1;i\u003cvt.size();i++){\rgcd=__gcd(gcd,vt[i]);\r}\rcout\u003c\u003cgcd\u003c\u003cendl;\rreturn 0;\r}\r D. Orac and Medians ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:6:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数组，可以选择一个区间，将区间内的数变成这个区间的中位数，如果有两个，则选较小，问是否能在若干次操作后把所有数字变成k ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:7:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 特判数组是否有k 对于有k的情况 如果数组中\u003e=k 的个数大于 \u003ck的个数，就可以通过不断选2个数，其中一个是K 同化另一个数，达到同化所有 其他情况如果存在相邻的三个数，满足2个数\u003e=k 就可以实现同化并不断同化 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n,k;\rint dat[100005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rbool ok=false;\rint low=0,hi=0;\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003edat[i];\rif(dat[i]==k) ok=true;\rif(dat[i]\u003ck) low++;\relse hi++;\r}\rif(!ok){\rputs(\"no\");\r}\relse if(hi\u003elow) puts(\"yes\");\relse{\rbool okk = false;\rfor(int i=0;i\u003cn-2;i++){\rint l=0,h=0;\rif(dat[i]\u003ck) l++;else h++;\rif(dat[i+1]\u003ck) l++;else h++;\rif(dat[i+2]\u003ck) l++;else h++;\rif(h\u003el) okk=true;\r}\rif(okk) puts(\"yes\"); else puts(\"no\");\r}\r}\rreturn 0;\r}\r ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:8:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["abc"],"content":"abc167","date":"2020-05-11","objectID":"/abc167/","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"这个比赛尽犯些sb错🙃，先是把 j 写成 i ，然后把2E5写成1E5 A - Registration ","date":"2020-05-11","objectID":"/abc167/:0:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 判断字符串T是不是S后加一个字符 ","date":"2020-05-11","objectID":"/abc167/:1:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rstring s1,s2;\rcin\u003e\u003es1\u003e\u003es2;\rif(s2.substr(0,s2.length()-1)==s1) puts(\"Yes\");\relse puts(\"No\");\rreturn 0;\r}\r 不知道strstr为啥就不行 B - Easy Linear Programming ","date":"2020-05-11","objectID":"/abc167/:2:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 有三种卡片，分别写上数字1，0，-1，选择k张，让数字和最大 ","date":"2020-05-11","objectID":"/abc167/:3:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 贪心 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rint a,b,c,k;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ek;\rint ans=0;\rif(a\u003c=k){\rans+=a;\rk-=a;\rif(b\u003c=k){\rk-=b;\rif(c\u003c=k){\rans-=c;\r}else ans-=k;\r}\relse{\rans+=k;\r}\r}\relse{\rans+=k;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - Skill Up ","date":"2020-05-11","objectID":"/abc167/:4:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 高桥想学m个算法，有n本书，每本书有价格，和对每个算法的提升程度 问高桥想要每个算法都达到X，最少需要花多少钱 ","date":"2020-05-11","objectID":"/abc167/:5:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 数据不是很大，可以暴力模拟，数据大，可以考虑dp #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst long long inf = 0x3f3f3f3f;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r int n,m,x;\rcin\u003e\u003en\u003e\u003em\u003e\u003ex;\rint ans=inf;\rint dat[n+1][m+1+1];\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003edat[i][0];\rfor(int j=1;j\u003c=m;j++) cin\u003e\u003edat[i][j];\r}\rfor(int i=0;i\u003c=(1\u003c\u003cn)-1;i++){\rint e[m+1+1]={0};\rint foo=0;\rfor(int j=0;j\u003cn;j++){\rif(i\u003e\u003ej\u00261){\rfor(int k=1;k\u003c=m;k++){\re[k]+=dat[j][k];\r}\rfoo+=dat[j][0];\r}\r}\rbool ok=true;\rfor(int i=1;i\u003c=m;i++) if(e[i]\u003cx) ok=false;\rif(ok) ans=min(ans,foo);\r//for(int i=1;i\u003c=m;i++) cout\u003c\u003ce[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\r }\rcout\u003c\u003c(ans==inf?-1:ans)\u003c\u003cendl;\rreturn 0;\r}\r D - Teleporter ","date":"2020-05-11","objectID":"/abc167/:6:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 有一个数组（长度最大为2E5），当你在下标为 i 时，可以tp到下标为 a[i] 问 N(N\u003c=1E18) 次tp后在哪里 ","date":"2020-05-11","objectID":"/abc167/:7:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 由于数据很大不能直接算 考虑到数组最大为2E5，所以有最大为2E5的循环节 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rbool vis[200005];\rll tim[200005];\rll ind[2000005];\rll loop=0;\rll a[200005];\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r ll n,k;\rcin\u003e\u003en\u003e\u003ek;\rfor(ll i=1;i\u003c=n;i++){\rcin\u003e\u003ea[i];\r}\rll ans=1;\rvis[1]=true;\rtim[1] = 1;\rind[1] = 1;\rfor(int i=2;i\u003c=k;i++){\rans = a[ans];\rif(vis[ans]){\rloop=i-tim[ans];break;\r}else{\rvis[ans]=true;\rtim[ans]=i;\rind[i]=ans;\r}\r}\rif(loop==0){\rcout\u003c\u003ca[ans]\u003c\u003cendl;\r} else{\rk-=tim[ans];\rk%=loop;\rcout\u003c\u003ca[ind[k+tim[ans]]]\u003c\u003cendl;\r}\r//cout\u003c\u003cloop\u003c\u003cendl;\r return 0;\r}\r E - Colorful Blocks ","date":"2020-05-11","objectID":"/abc167/:8:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 给一排方块涂色，方块有n个，至多m种颜色，要求至多有k对相邻的块涂相同的颜色 求方案数 ","date":"2020-05-11","objectID":"/abc167/:9:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 高中排列组合 $$ ans = \\sum\\limits_{i=0} ^ {k} {m * C_{n-1}^{i} * (m-1)^{n-1-i}} $$ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll n,m,k;\rll fac[200005];\rll ans = 0;\rll qpow(ll x,ll n){\rll res = 1;\rwhile(n\u003e0){\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll C(int n,int m){\rreturn fac[n]%mod*qpow(fac[m],mod-2)%mod*qpow(fac[n-m],mod-2)%mod;\r}\rint main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003ek;\rfor(ll i=0;i\u003cn+2;i++) fac[i] = 1;\rfor(ll i=1;i\u003cn+2;i++) fac[i] = i*fac[i-1]%mod;\rfor(ll i=0;i\u003c=k;i++){\rans = ans + m*C(n-1,i)%mod*qpow(m-1,n-1-i)%mod;\r}\rcout\u003c\u003c(ans+mod)%mod\u003c\u003cendl;\rreturn 0;\r}\r F - Bracket Sequencing ","date":"2020-05-11","objectID":"/abc167/:10:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 给n个由 ‘(’ 和 ‘)’ 组成的字符串，将n个字符串连接，问是否存在一种方案使得连接后的字符串是合法括号序列 ","date":"2020-05-11","objectID":"/abc167/:11:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 很好玩的一道题 一开始想用栈，太麻烦 用计数器，每读入一个open +1 否则 -1 ，这样就得到每个字符串的计数 把计数大的放前面，并且检查计数和是否为0 这样做是错的，样例2不给过 那就对连接后的备选字符串遍历，重新计数，查看中途不能有负数且最后为0 但这样也是错的，因为有可能正确的答案不是按从大到小的顺序排的 这种错误是因为（对于每个字符串）前面有几个close，后面一堆open导致计数变大，但其实是不合法的，因为前面几个close没得匹配 所以应该记录由close影响的“计数的最小值” 合理的排序应该是 对于两个字符串a,b 考虑两种情况 a+b b+a 对于每种连接考虑两种情况 遍历到a时，a的计数最小值 遍历到a+b时，a+b的计数最小值 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rstring s;\rvector\u003cpair\u003cint,int\u003e\u003e vt;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en;\rint sum=0;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003es;\rint cnt=0;int low=0; //int cnt,low=0 WA T_T\r for(char c:s){\rif(c=='('){\rcnt++;\r}else cnt--;\rlow=min(low,cnt);\r}\rvt.emplace_back(cnt,low);\rsum+=cnt;\r}\rif(sum!=0) {\rputs(\"No\");return 0;\r}\rsort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return min(pii1.second,pii1.first+pii2.second) \u003e min(pii2.second,pii2.first+pii1.second);});\rint foo=0;\rfor(pair\u003cint,int\u003e pii:vt){\rif(foo\u003c-pii.second){\rputs(\"No\");\rreturn 0;\r}foo+=pii.first;\r}\rputs(\"Yes\");\rreturn 0;\r}\r ","date":"2020-05-11","objectID":"/abc167/:12:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["nowcoder"],"content":"牛客算法周周练5(部分)","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"C - 序列最小化 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:0:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 贪心，每次选择的长度为k的区间首尾重叠 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing Int = long long;\rint main(){\rInt n,k;\rcin\u003e\u003en\u003e\u003ek; n-=k;\rInt ans = ceil((double)n/(k-1));\rcout\u003c\u003cans+1\u003c\u003cendl;\rreturn 0;\r}\r E - 简单瞎搞题 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:1:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 位dp，dp[i] 表示前i个数能达到的数字集合 加上第 i 个区间的数，遍历一遍这个区间对于其中一个数 j 集合的结果变成 dp[i-1]\u003c\u003c(j*j) 所以 dp[i] |= dp[i-1] \u003c\u003c (j*j) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rbitset\u003c1000005\u003e dp[105];\rint n;\rint l[105];\rint r[105];\rint main(){\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++) dp[i].reset();\r//init\r dp[0][0]=1;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003el[i]\u003e\u003er[i];\r}\rfor(int i=1;i\u003c=n;i++){\rfor(int j=l[i];j\u003c=r[i];j++){\rdp[i] |= (dp[i-1]\u003c\u003c(j*j));\r}\r}\rcout\u003c\u003cdp[n].count();\rreturn 0;\r}\r D - 小雨坐地铁 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:2:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 经典图论题 丁老师说过如果由直线构成的图中，转弯需要花费时间，则可以构造虚点 对于本身耗费的金钱a，可以构造虚点，对应于每个点，从实点到虚点有权为0的边，从虚点到实点有权为a的边 把每条地铁线的点独立，这样就有(m+1)*n个点 对于每条地铁线上的点，在对应的图层上连线，而图层之间由虚点连接 最后跑一遍最短路 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,m,s,t;\rint a,b,c;\rint t1,t2;\rconst int inf = 0x3f3f3f3f;\rconst int max_v = 501505;\rstruct edge\r{\rint to,cost;\redge(int to,int cost){\rthis-\u003ecost = cost;\rthis-\u003eto = to;\r}\r};\rtypedef pair\u003cint,int\u003e pii; int V;\rvector\u003cedge\u003e G[max_v];\rint d[max_v];\rinline void add_edge(int a,int b,int c){\rG[a].push_back(edge(b,c));\r}\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(int i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} } int main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003es\u003e\u003et;\rV=(m+1)*n+1;\rs=n*m+s;\rt=n*m+t;\rfor(int i=0;i\u003cm;i++){\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec;\rfor(int j=0;j\u003cc;j++){\rcin\u003e\u003et1;\rif(j\u003e0){\radd_edge(i*n+t2,i*n+t1,b);\radd_edge(i*n+t1,i*n+t2,b);\r}\radd_edge(i*n+t1,m*n+t1,0);\radd_edge(m*n+t1,i*n+t1,a);\rt2=t1;\r}\r}\rdijkstra(s);\rcout\u003c\u003c(d[t]==inf ? -1 : d[t])\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:3:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["note"],"content":"git","date":"2020-05-05","objectID":"/git/","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"git安装 ","date":"2020-05-05","objectID":"/git/:0:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"用户名和邮箱 初始化或切换用户名和邮箱 git config --global user.name \"XXX\" git config --global user.email \"XXX\" 查看当前用户名和邮箱 git config --global user.name git config --global user.email 查看用户名和邮箱列表 git config --list 删除用户名和邮箱 git config --global --unset user.name \"XXX\" git config --global --unset user.email \"XXX\" ","date":"2020-05-05","objectID":"/git/:1:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"git工作原理 ","date":"2020-05-05","objectID":"/git/:2:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"三种状态 modified staged committed ","date":"2020-05-05","objectID":"/git/:3:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"本地操作 ","date":"2020-05-05","objectID":"/git/:4:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"基本操作 从工作目录移动到暂存区 git add XXX 全部移动 git add . 从暂存区移动到本地仓库 git commit -m \"XXX\" 修改提交信息 git commit --amend 打开vim编辑器 只读状态下的保存退出 [esc] :wq! vim使用 查看状态 git status 查看日志 git log 查看更完全的日志并压缩排版 git reflog --oneline ","date":"2020-05-05","objectID":"/git/:4:1","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"版本回退 从暂存区回退到工作目录 git reset XXX 从本地仓库回退到暂存区(后面带数字可以选择回退几个版本) git reset --soft HEAD~ 从本地仓库回退到工作目录 git reset HEAD~ 从本地仓库回退到工作目录，并撤销在工作目录的操作（可能导致删除文件） git reset --hard HEAD~ 对因回退删除掉的文件还原 git reset --hard \u003cfilename\u003e (这时候已经commit) ","date":"2020-05-05","objectID":"/git/:4:2","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"恢复文件 在工作目录中删除，要恢复(把暂存区的恢复过来) git checkout XXX ","date":"2020-05-05","objectID":"/git/:4:3","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"删除文件 删除工作目录和暂存区的文件，取消跟踪，不纳入版本管理（两个区文件要相同） git rm XXX 此时本地仓库还有该文件 通过回退实现彻底删除 git reset --soft HEAD~ 如果两个区文件不同 全都删除 git rm -f XXX 只删除暂存区 git rm --cached XXX ","date":"2020-05-05","objectID":"/git/:4:4","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"重命名 git mv \u003cbefore\u003e \u003cafter\u003e 然后再添加，提交 ","date":"2020-05-05","objectID":"/git/:4:5","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"文件比较 比较两个历史快照 git diff XXX XXX 比较工作目录和暂存区 git diff XXX 比较工作目录和仓库 git diff XXX 比较暂存区和仓库 git diff --cached XXX ","date":"2020-05-05","objectID":"/git/:4:6","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"分支 创建分支 git branch XXX 进入分支 git checkout XXX 创建并进入分支 git checkout -b XXX 列出所有分支 git branch -a 查看当前分支 git branch 图化所有分支 git log --decorate --oneline --graph --all 与当前分支合并 git merge XXX 合并冲突 打开文件，修改文件，重新添加提交 删除分支 git branch -d XXX 分支名删除，文件仍然存在 ","date":"2020-05-05","objectID":"/git/:4:7","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"远程操作 远程项目拷贝到本地 git clone XXX ","date":"2020-05-05","objectID":"/git/:5:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"push/pull 推到远程分支上 git push 需要输入github账号密码 把远程分支更新的内容拉到本地 git pull 连续两次 git push 内容不一样产生冲突 git pull 文件会自动更新，改文件内容，重新添加提交 ","date":"2020-05-05","objectID":"/git/:5:1","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"其他 git push \u003c远程主机名\u003e \u003c远程分支名\u003e git pull \u003c远程主机名\u003e \u003c远程分支名\u003e e.g git push origin master git pull origin master push需要创建upstream连接本地分支和远程分支 git branch --set-upstreamXXX 更常用的是(建立upstream并push)(本地与远程同名) git push -u origin XXX ","date":"2020-05-05","objectID":"/git/:5:2","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"fetch git pull 类似于 git fetch + git merge 和commitId的改动有关 git fetch 更安全 具体参考 这篇文章 ","date":"2020-05-05","objectID":"/git/:5:3","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"remote 远程添加仓库 git remote add \u003cname\u003e \u003curl\u003e 远程删除仓库 git remote remove XXX 查看远程仓库 git remote 查看有关联的远程仓库 git remote -v ","date":"2020-05-05","objectID":"/git/:5:4","tags":["git"],"title":"git","uri":"/git/"},{"categories":["abc"],"content":"abc166","date":"2020-05-04","objectID":"/abc166/","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"A - A?C ","date":"2020-05-04","objectID":"/abc166/:0:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 abc输出arc反之亦然 ","date":"2020-05-04","objectID":"/abc166/:1:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rstring s;\rcin\u003e\u003es;\rs[1]=s[1]=='B'? 'R': 'B';\rcout\u003c\u003cs\u003c\u003cendl;\rreturn 0; }\r B - Trick or Treat ","date":"2020-05-04","objectID":"/abc166/:2:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 snack_i被snuke_1,snuke_2..拥有 问有多少个snuke没有snack ","date":"2020-05-04","objectID":"/abc166/:3:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rset\u003cint\u003e st;\rint main(){\rint n,k;\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=1;i\u003c=k;i++){\rint x;\rcin\u003e\u003ex;\rwhile(x--){\rint y;\rcin\u003e\u003ey;\rst.insert(y);\r}\r}\rcout\u003c\u003cn-st.size()\u003c\u003cendl;\rreturn 0;\r}\r C - Peaks ","date":"2020-05-04","objectID":"/abc166/:4:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 山上有n个观景台，有一些路连接两个观景台，一个观景台是好的当且仅当从它出发走一条路能到达的观景台海拔都比它低，没有路也算 问有多少个好观景台 ","date":"2020-05-04","objectID":"/abc166/:5:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 用二叉树排序 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rpriority_queue\u003cint\u003e p[100005];\rint a[100005];\rint main(){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rfor(int i=1;i\u003c=n;i++) p[i].push(0);\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\rwhile(m--){\rint t1,t2;\rcin\u003e\u003et1\u003e\u003et2;\rp[t1].push(a[t2]);\rp[t2].push(a[t1]);\r}\rint ans=0;\rfor(int i=1;i\u003c=n;i++){\rif(p[i].top()\u003ca[i]) ans++;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - I hate Factorization ","date":"2020-05-04","objectID":"/abc166/:6:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 给定一个数X，求A，B使得A^5 - B^5 = X,A，B是整数 ","date":"2020-05-04","objectID":"/abc166/:7:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 bf #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll x,a,b;\rbool check(ll a,ll b){\rif(a*a*a*a*a - b*b*b*b*b == x) return true;\rreturn false;\r}\rint main(){\rcin\u003e\u003ex;\rfor(ll i = -500;i\u003c=500;i++) for(ll j=-500;j\u003c=500;j++){\rif(check(i,j)){\ra = i,b = j;\rbreak;\r}\r}\rcout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003cendl;\rreturn 0;\r}\r E - This Message Will Self-Destruct in 5s ","date":"2020-05-04","objectID":"/abc166/:8:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 有一个数列，一对数字是好数对，当且仅当下标差等于数值和，求好数对个数 ","date":"2020-05-04","objectID":"/abc166/:9:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 等式移项 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rmap\u003cll,ll\u003e mp;\rll ans;\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rll x;\rcin\u003e\u003ex;\rans+=mp[i-x];\rmp[i+x]++;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F - Three Variables Game ","date":"2020-05-04","objectID":"/abc166/:10:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 有三个数a,b,c，有n轮抉择，每一轮抉择会给出一个字符串\"ab” “bc” ,“ac” 选择其中一个数加，另一个数减，问是否存在一种方案使得所有数最后都不是负数 ","date":"2020-05-04","objectID":"/abc166/:11:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 这题做错了，因为思维局限在dfs找两个数字相同情况下该选哪个，然后不是WA就是TLE，理论上可以，没写好 其实可以全搜索，然后找到一组解就exit(0) 一定要退出，不能返回，因为真的搜索完全就超时 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,a,b,c;\rstring s[100005];\rchar ans[100005];\rbool ok;\rvoid dfs(int ind,int a,int b,int c){\rif(a\u003c0 || b\u003c0 || c\u003c0) return;\rif(ind==n){\rputs(\"Yes\");\rfor(int i = 0;i \u003c n;i++){\rcout\u003c\u003cans[i]\u003c\u003cendl;\r}\rexit(0);\r}\relse{\rif(s[ind]==\"AB\"){\rans[ind]='A';\rdfs(ind+1,a+1,b-1,c);\rans[ind]='B';\rdfs(ind+1,a-1,b+1,c);\r}\relse if(s[ind]==\"AC\"){\rans[ind]='A';\rdfs(ind+1,a+1,b,c-1);\rans[ind]='C';\rdfs(ind+1,a-1,b,c+1);\r}\relse{\rans[ind]='B';\rdfs(ind+1,a,b+1,c-1);\rans[ind]='C';\rdfs(ind+1,a,b-1,c+1);\r}\r}\r}\rint main(){\rcin\u003e\u003en\u003e\u003ea\u003e\u003eb\u003e\u003ec;\rfor(int i = 0;i\u003cn;i++) cin\u003e\u003es[i];\rdfs(0,a,b,c);\rputs(\"No\");\rreturn 0;\r}\r ","date":"2020-05-04","objectID":"/abc166/:12:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"abc165","date":"2020-05-03","objectID":"/abc165/","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"A - We Love Golf ","date":"2020-05-03","objectID":"/abc165/:0:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 询问在A到B之间是否有C的倍数 ","date":"2020-05-03","objectID":"/abc165/:1:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 特判边界是否满足条件，否则判断左右边界除以C的值是否大于等于1 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rint a,b,c;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec;\rif(b/(double)a == b/a) puts(\"OK\");\relse if(c/(double)a == c/a) puts(\"OK\");\relse if(c/a \u003e b/a){\rputs(\"OK\");\r}\relse puts(\"NG\");\rreturn 0;\r}\r B - 1% ","date":"2020-05-03","objectID":"/abc165/:2:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 初始有100円，每年利息1%，每年结算时将小数部分抛弃，问多久能达到A円 ","date":"2020-05-03","objectID":"/abc165/:3:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 计数器模拟 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rll a;\rcin\u003e\u003ea;\rll dy = 0;\rdouble bs = 100;\rwhile(bs\u003ca){\rbs*=1.01;\rbs = floor(bs);\rdy++; }\rcout\u003c\u003cdy\u003c\u003cendl;\rreturn 0;\r}\r C - Many Requirements ","date":"2020-05-03","objectID":"/abc165/:4:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 构造一个数列A每个数不大于10，数列长度不大于M，且递增 有q个四元组 a b c d 如果Ab - Aa == c，则v+=d 求v的最大值 ","date":"2020-05-03","objectID":"/abc165/:5:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 最开始有两种思路，暴力构造（超时），对q个四元组贪心（会错过最优解） 所以dfs，dfs到最后一个数时求v并更新v 传入下标作为参数，不需要回溯 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint a[55],b[55],c[55],d[55];\rint n,m,q;\rint ans;\rint dat[12];\rvoid dfs(int ind , int pre){\rif(ind == n){\rint cnt = 0;\rfor(int i=0;i\u003cq;i++){\rif(dat[b[i] - 1] - dat[a[i] - 1] == c[i]) cnt+=d[i];\r}\rans = max(ans , cnt);\r}\relse{\rfor(int i = pre;i\u003c=m;i++){\rdat[ind] = i;\rdfs(ind + 1 , i);\r}\r}\r}\rint main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003eq;\rfor(int i=0;i\u003cq;i++) cin\u003e\u003ea[i]\u003e\u003eb[i]\u003e\u003ec[i]\u003e\u003ed[i];\rdfs(0,1);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - Floor Function ","date":"2020-05-03","objectID":"/abc165/:6:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-03","objectID":"/abc165/:7:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 问题转化成在0~N中找一个数x，使得x/B的小数部分最接近0.99999 x = B-1 如果N不允许，找最大N ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rdouble a,b,n;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003en;\rdouble x;\rif(n\u003e=b-1) x =b-1;\relse x=n;\rcout\u003c\u003cfloor(a*x/b) - a*floor(x/b)\u003c\u003cendl;\rreturn 0;\r}\r E - Rotation Matching ","date":"2020-05-03","objectID":"/abc165/:8:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 有N个玩家，M个竞技场（M*2+1\u003c=N） 每个玩家都有一个数字 每个竞技场安排两个数字，不能重复 共有N轮决斗 对于每一轮，每个竞技场中数字对应的两个玩家进行battle 每一轮决斗后，所有玩家的数字都+1 求安排方案使得所有的人都不会和同一个人battle两次 ","date":"2020-05-03","objectID":"/abc165/:9:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 应该是本次比赛最难的题 由于M*2+1\u003c=N 所以合理安排，在进行N轮之后，一定会刚好满足条件 其实就是号码的两两配对 在纸上列出所有的情况，一直尝试、排除 最后会发现，前半段要隔一个对称配对，后半段直接对称配对，这样就能完美错开 ac代码 #include\u003cbits/stdc++.h\u003e\r int dat1[100005],dat2[100005];\rusing namespace std;\rint main(){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rif(!(n\u00261)) n--;\rint mm = (n-1)/2;\rif(mm\u00261){\rfor(int i=1;i\u003c=mm/2;i++){\rdat1[i] = i;\rdat2[i] = (n+1)/2 - i;\r}\rfor(int j=(n+1)/2,i = mm/2+1,k=0;i\u003c=mm;i++,j++,k++){\rdat1[i] = j;\rdat2[i] = n - k;\r}\r}\relse{\rfor(int i=1;i\u003c=mm/2;i++){\rdat1[i] = i;\rdat2[i] = (n+3)/2 - i;\r}\rfor(int i=(n+3)/2,j=n,k=mm/2+1;k\u003c=mm;i++,j--,k++){\rdat1[k] = i;\rdat2[k] = j;\r}\r}\r//for(int i=1;i\u003c=6;i++) cout\u003c\u003cdat1[i]\u003c\u003c\" \"\u003c\u003cdat2[i]\u003c\u003cendl;\r for(int i=1;i\u003c=m;i++) cout\u003c\u003cdat1[i]\u003c\u003c\" \"\u003c\u003cdat2[i]\u003c\u003cendl;\rreturn 0;\r}\r F - LIS on Tree ","date":"2020-05-03","objectID":"/abc165/:10:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 给一棵树，每个点有一个数字属性，求1到X的最短路径中，按1到X的顺序排列数字属性得到的序列中的最长上升子序列（LIS） 对所有的X ","date":"2020-05-03","objectID":"/abc165/:11:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 dfs + lis 注意回溯 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint dp[200005];\rvector\u003cint\u003e G[200005];\rint n;\rint a[200005];\rint ans[200005];\rconst int inf = 0x3f3f3f3f;\rvoid dfs(int u,int p){\rint ind = (int)(lower_bound(dp,dp+n,a[u]) - dp);\rint cnt = dp[ind];\rdp[ind] = a[u];\rans[u] = (int)(lower_bound(dp,dp+n,inf) - dp);\rfor(int i:G[u]){\rif(i!=p){\rdfs(i,u);\r}\r}\r//undo\r dp[ind] = cnt;\r}\rint main(){\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\rfor(int i=0;i\u003cn-1;i++){\rint t1,t2;\rcin\u003e\u003et1\u003e\u003et2;\rt1--,t2--;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rfill(dp,dp+n+2,inf);\rdfs(0,-1);\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cans[i]\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-05-03","objectID":"/abc165/:12:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"abc164","date":"2020-05-02","objectID":"/abc164/","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"A - Sheep and Wolves ","date":"2020-05-02","objectID":"/abc164/:0:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 判断两个数的大小 ","date":"2020-05-02","objectID":"/abc164/:1:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 ac代码 n,m = map(int,input().split())\rif n\u003em:\rprint('safe')\relse :\rprint('unsafe')\r B - Battle ","date":"2020-05-02","objectID":"/abc164/:2:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给定两个人的生命值和攻击力，两个人回合制battle，谁的生命值先小于等于0 ","date":"2020-05-02","objectID":"/abc164/:3:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 模拟 ac代码 a,b,c,d = map(int,input().split())\rwhile a\u003e0 and c\u003e0:\rc=c-b\rif c\u003c=0:\rbreak\ra=a-d\rif a\u003c=0:\rbreak\rif a\u003c=0:\rprint('No')\relse:\rprint('Yes')\r C - gacha ","date":"2020-05-02","objectID":"/abc164/:4:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给一堆字符串，求有多少种 ","date":"2020-05-02","objectID":"/abc164/:5:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n;\rset\u003cstring\u003e st;\rcin\u003e\u003en;\rstring s;\rwhile(n--){\rcin\u003e\u003es;\rst.insert(s);\r}\rcout\u003c\u003cst.size()\u003c\u003cendl;\rreturn 0;\r}\r D - Multiple of 2019 ","date":"2020-05-02","objectID":"/abc164/:6:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给一数字串，求多少个连续子串组成的数字是2019的倍数 ","date":"2020-05-02","objectID":"/abc164/:7:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 后缀，和abc158E几乎一致 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rstring s;\rint a[2020]={0};\rcin\u003e\u003es;\rint ans = 0;\rint t = 1;\rint cnt = 0;\ra[0]++;\rfor(int i=s.length()-1;~i;i--){\rcnt = (cnt+t*(s[i]-'0'))%2019;\rans+=(a[cnt]++);\rt=(t*10)%2019;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - Two Currencies ","date":"2020-05-02","objectID":"/abc164/:8:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 有n个城市，m条路（无向），每条路有两个属性（通过这条路要花费的时间和金 钱），每个城市有两个属性（可以花费时间购买金钱），给初始的金钱数量，求 从1城市到每个城市花费的最少时间 ","date":"2020-05-02","objectID":"/abc164/:9:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 dijkstra算法的变形 把时间当做最短路 当金钱超过最大值时，就不需要考虑是否在每个城市购买金钱 套一个dijkstra算法板子，加上对每个城市是否购买金币的判断 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing tp = tuple\u003cll,ll,ll\u003e;\rll n,m,s;\rll a,b; ll c[55],d[55]; //存获得的银币和消耗的时间 ll dp[55][2505]; //到达i时还有j银币的最小时间 vector\u003ctp\u003e G[55]; //目标点 a b tp info; //时间 目标点 当前的钱 const ll inf = 0x3f3f3f3f3f3f3f3f;\rint main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003es;\rs = min(s,2504LL);\rfor(ll i=0;i\u003cm;i++){\rll ta,tb,tc,td;\rcin\u003e\u003eta\u003e\u003etb\u003e\u003etc\u003e\u003etd;\rG[ta].push_back(tp(tb,tc,td));\rG[tb].push_back(tp(ta,tc,td)); }\rfor(ll i=1;i\u003c=n;i++){\rll tc,td;\rcin\u003e\u003etc\u003e\u003etd;\rc[i] = tc;\rd[i] = td;\r}\rfill(dp[0] , dp[0] + 54*2504 , inf);\rdp[1][s] = 0;\rpriority_queue\u003ctp,vector\u003ctp\u003e,greater\u003ctp\u003e\u003e pq;\rpq.push(tp(0,1,s));\rwhile(!pq.empty()){\rinfo = pq.top();\rpq.pop();\rll t = get\u003c0\u003e(info) , u = get\u003c1\u003e(info) , w = get\u003c2\u003e(info);\rif(dp[u][w] \u003e t) continue;\rfor(auto i:G[u]){\rll v = get\u003c0\u003e(i) , aa = get\u003c1\u003e(i) , bb = get\u003c2\u003e(i);\rif(w\u003e=aa and dp[v][w-aa] \u003e t + bb){\rdp[v][w-aa] = t + bb;\rpq.push(tp(t+bb , v , w-aa));\r}\r}\rif(dp[u][min(w + c[u] , 2504LL)] \u003e t + d[u]){\rdp[u][min(w + c[u] , 2504LL)] = t + d[u];\rpq.push(tp(t + d[u] , u , min(w + c[u] , 2504LL)));\r}\r} for(ll i=2;i\u003c=n;i++){\rll ans = inf;\rfor(ll j=0;j\u003c2504;j++){\rans = min(ans , dp[i][j]);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r F - I hate Matrix Construction 似乎是位运算的构造。。。🤔 ","date":"2020-05-02","objectID":"/abc164/:10:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["nowcoder"],"content":"NC17134","date":"2020-05-02","objectID":"/nc17134/","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"Symmetric Matrix ","date":"2020-05-02","objectID":"/nc17134/:0:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"题目描述 Count the number of n x n matrices A satisfying the following condition modulo m. Ai, j ∈ {0, 1, 2} for all 1 ≤ i, j ≤ n. Ai, j = Aj, i for all 1 ≤ i, j ≤ n. Ai, 1 + Ai, 2 + … + Ai, n = 2 for all 1 ≤ i ≤ n. A1, 1 = A2, 2 = … = An, n = 0. ","date":"2020-05-02","objectID":"/nc17134/:1:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"输入描述 The input consists of several test cases and is terminated by end-of-file. Each test case contains two integers n and m. ","date":"2020-05-02","objectID":"/nc17134/:2:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"输出描述 For each test case, print an integer which denotes the result. ","date":"2020-05-02","objectID":"/nc17134/:3:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"样例输入 3 1000000000 100000 1000000000 ","date":"2020-05-02","objectID":"/nc17134/:4:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"样例输出 1 507109376 ","date":"2020-05-02","objectID":"/nc17134/:5:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"限制 1 ≤ n ≤ 105 1 ≤ m ≤ 109 The sum of n does not exceed 107. ","date":"2020-05-02","objectID":"/nc17134/:6:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"题解 挺好一道题目 这个题分三个步骤 1.根据题意转化成图的邻接矩阵 2.使用dp，找dp递推式 3.化简递推式 1.把题目转化成求n个点的无向图个数满足，没有自环，如果组成圈则边权为1 如果是两个点相连则权值为2（参考下面的图片） 2.f[n] 表示 n 个点时的方案数 那么第 n 个点依赖于前 n-1 个点 考虑两种情况 ① 将 n-1 个点中的一个点拉出来与第 n 个点组成边权为2的点对，对于每一种方 案都有 n-1 个点可选，剩下的 n-2 个点方案数为 f[n-2] 所以 f[n] += (n-1)*f[n-2] ② 把第 n 个点与前 n-1 个点组成圈 考虑选 k 个点出来，那么就有 $$ C_{n-1}^{k} $$ 种选法 对于选出来的 k 个点全排列，有 $$ A_{k}^{k} $$ 种，剩下的情况有 f[n-1-k] 种 由于圈的首位相连，所以 /2 那么所有的方案是 $$ \\frac{1}{2} \\sum\\limits_{k=2} ^ {n-1} {C_{n-1}^{k}A_{k}^{k}f[n-1-k]} $$ 这样并不会重复，因为每次参与形成圈的点数是不同的，这一定互异 3.化简 最终式 f[n] = (n-1) * (f[n-1] + f[n-2]) - 1/2 * (n-1) * (n-2) * f[n-3] ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll ans[100005];\rint main(){\rll n,m;\rans[0] = 1;\rans[1] = 0;\rans[2] = 1;\rans[3] = 1;\rwhile(cin\u003e\u003en\u003e\u003em){\rfor(ll i=4;i\u003c=n;i++){\rans[i] = 0;\r}\rfor(ll i = 4;i\u003c=n;i++){\rans[i] += ((i-1)*((ans[i-1]+ans[i-2])%m)%m);\rans[i] -= (((i-1)*(i-2)/2%m)*ans[i-3])%m;\rans[i] += m;\rans[i] %= m;\r}\rcout\u003c\u003cans[n]%m\u003c\u003cendl;\r}\rreturn 0;\r}\r ","date":"2020-05-02","objectID":"/nc17134/:7:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["codeforces"],"content":"Codeforces Round #636 (Div. 3) A~E","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"A. Candies ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:0:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一个数n，找一个数x，满足 x+2x+4x+8x+… = n ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:1:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 等比数列求和，变成2^m 然后枚举，看哪个能整除 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rlong long n,t;\rint main(){\rcin\u003e\u003et;\rlong long a[32];\rfor(long long i=1;i\u003c=30;i++){\ra[i] = (1\u003c\u003ci) - 1;\r}\rwhile(t--){\rcin\u003e\u003en;\rfor(long long i=2;i\u003c=30;i++){\rif((double)n/a[i] == n/a[i]){\rcout\u003c\u003cn/a[i]\u003c\u003cendl;\rbreak;\r}\r}\r}\rreturn 0;\r}\r B. Balanced Array ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:2:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一数n，问是否可以构造一个数列 数列的个数是偶数 前半部分都是偶数，后半部分都是奇数 前半部分的和等于后半部分 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:3:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 按照样例那样有规律地构造 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,t;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rif((n/2) \u0026 1) puts(\"NO\");\relse {\rputs(\"YES\");\rfor(int i=1;i\u003c=n/2;i++){\rcout\u003c\u003ci*2\u003c\u003c\" \"; }\rfor(int i=1;i\u003c=n/4;i++){\rcout\u003c\u003ci*2-1\u003c\u003c\" \";\r}\rfor(int i=n/4+1;i\u003c=n/2;i++){\rcout\u003c\u003ci*2+1\u003c\u003c\" \";\r}\rcout\u003c\u003c\"\\n\";\r}\r}\rreturn 0;\r}\r C. Alternating Subsequence ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:4:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 在一个数列中找一个子序列（可以不连续）满足奇偶穿插 对于满足这个条件的最长子序列中，求元素和最大值 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:5:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 将数列按奇偶性分割，每一部分取最大值 可以用双指针锁定区间 我的写法需要再最后添一个相反数，否则加不到最后一块区域 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,t,a[200005];\rconst ll inf = 0x3f3f3f3f3f3f3f3f;\rconst ll ninf = 0xc0c0c0c0c0c0c0c0;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rvector\u003cll\u003e ans;\rfor(ll i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rif(a[n-1]\u003e0) a[n]=-1;\relse a[n]=1;\rbool pos;\rif(a[0]\u003e0){\rpos=true;\r}else pos=false;\rll l = 0;\rll r = 0;\rfor(int i=0;i\u003c=n;i++){\rif(pos){\rif(a[i]\u003e0) r++;\relse {\rpos^=1;\rll cnt = *max_element(a+l , a+r);\rans.push_back(cnt);\rl = r;\rr++;\r}\r}\relse{\rif(a[i]\u003c0) r++;\relse{\rpos^=1;\rll cnt = *max_element(a+l , a+r);\rans.push_back(cnt);\rl = r;\rr++;\r}\r}\r}\rll foo = 0;\rfor(ll i:ans){\r//cout\u003c\u003ci\u003c\u003cendl;\r foo+=i;\r}\rcout\u003c\u003cfoo\u003c\u003cendl;\r}\rreturn 0;\r}\r D. Constant Palindrome Sum ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:6:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 对于一个长度为n的数列（n为偶数） 对于数列中的每个数可以进行替换，使得所有的对称的一组数字和相等 且所有数字不超过k 求最小替换数 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:7:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 对于每组数，可以替换1次，2次0次 由于数字不超过k，所以和的范围为[2,2*k] 因为k的数据较小，所以可以枚举，对于每个x 求替换数，然后一直min 如果两个数和为x，则替换数为0 如果替换一个数，则替换之后和的范围是[min(x1,x2)+1 , max(x1,x2)+k] 所以检查x是否落在这个范围内 除此之外要替换2个 所以用一个容器存数字和的个数（目的是求0个） 存左右区间的个数（目的是不断迭代求1个）（如果用这种方法1个的个数会覆盖0个） 剩下就是2个 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n,k;\rint a[200005];\rint eq[2*200005];\rint l[2*200005];\rint r[2*200005];\rint one[2*200005]; //只替换一个 int ans;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ea[i];\r}\rfor(int i=1;i\u003c=n/2;i++){\req[a[i]+a[n-i+1]]++;\rl[min(a[i],a[n-i+1])+1]++;\rr[max(a[i],a[n-i+1])+k]++;\r}\rfor(int i=1;i\u003c=2*k+3;i++){\rone[i] = one[i-1]+l[i]-r[i-1];\r}\rans = n+2;\rfor(int i=1;i\u003c=2*k+3;i++){\rans = min(ans , n - one[i] - eq[i]); //不能用2*eq，因为one会重复计算一个eq所以要再加上一个eq }\rcout\u003c\u003cans\u003c\u003cendl;\r//TODO reset\r\rfor(int i=0;i\u003c2*k+2;i++) { //这里用memeset就会超时 eq[i]=l[i]=r[i]=0;\r}\r}\rreturn 0;\r}\r E. Weights Distributing ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:8:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一没有权值的无向图和权值序列 问怎样给边赋值（一一对应）使得从a到b再到c的权值和最小 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:9:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 由于行走路径会重复的问题 所以可以把问题转化成从a到 i ，从i到b，从b到 I ，从 i 到c 遍历所有的点 i 保证 i 到 b ，a 到 i ， i 到 c 都是最短路径（路径数最少） 将权值最小的部分赋给 b到 i 的路径上，再将较小的权值赋给 a到 i 和 i 到 c 要让路径数最少，直接bfs预处理 然后给权值排序，因为要不断选一段有序的权值，所以前缀和预处理 最后要特判 如果在样例1中，i 在 a 上，那么 i 到 b 和 i 到 c 路径重复，这种情况是绝对不可 能最优的（总能找到反例） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll t,n,m,a,b,c;\rll mm[200005];\rll d[3][200005];\rll spre[200005];\rvector\u003cll\u003e G[200005];\rconst ll inf = 0x3f3f3f3f3f3f3f3f;\rvoid bfs(ll st,ll r){\rqueue\u003cll\u003e q;\rq.push(st);\rwhile(!q.empty()){\rll cnt = q.front();\rq.pop();\rfor(auto i : G[cnt]){\rif(d[r][i] == -1){\rd[r][i] = d[r][cnt]+1;\rq.push(i);\r}\r}\r}\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb\u003e\u003ec;\r//TODO reset\r for(ll i=0;i\u003c3;i++)for(ll j=0;j\u003c=n;j++) d[i][j]=-1;\rfor(ll i=0;i\u003c=n;i++) G[i].clear();\rfor(ll i=1;i\u003c=m;i++){\rcin\u003e\u003emm[i];\r}\rsort(mm+1,mm+m+1);\rspre[1] = mm[1];\rfor(ll i=2;i\u003c=m;i++){\rspre[i]=spre[i-1]+mm[i];\r}\rll t1,t2;\rfor(ll i=1;i\u003c=m;i++){\rcin\u003e\u003et1\u003e\u003et2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rd[0][a]=0;d[1][b]=0,d[2][c]=0;\rbfs(a,0);\rbfs(b,1);\rbfs(c,2);\rll ans = inf;\rfor(ll i=1;i\u003c=n;i++){\rif(d[0][i] + d[1][i] + d[2][i] \u003e m) continue;\rans = min(ans , spre[ d[1][i] ] + spre[ d[0][i] + d[1][i] + d[2][i] ]);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\r// for(ll i=1;i\u003c=7;i++){\r //cout\u003c\u003cd[2][2]\u003c\u003c\" \";\r// }\r\r//for(ll i=1;i\u003c=8;i++) cout\u003c\u003cspre[i]\u003c\u003c\" \";\r //cout\u003c\u003cd[1][1]\u003c\u003cendl;\r //cout\u003c\u003ca\u003c\u003cb\u003c\u003cc;\r return 0;\r}\r ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:10:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["abc"],"content":"abc163","date":"2020-04-22","objectID":"/abc163/","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"A - Circle Pond ","date":"2020-04-22","objectID":"/abc163/:0:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 求圆周长 ","date":"2020-04-22","objectID":"/abc163/:1:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 print(int(input())*2*3.14159265)\r B - Homework ","date":"2020-04-22","objectID":"/abc163/:2:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 给定假期的时间和每一项作业完成的时间，求这个假期能玩几天 ","date":"2020-04-22","objectID":"/abc163/:3:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 n,m = map(int , input().split())\ra = list(map(int , input().split()))\rs = sum(a)\rif n\u003e=s:\rprint(n-s)\relse:\rprint(-1)\r C - management ","date":"2020-04-22","objectID":"/abc163/:4:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 告诉每个员工的老板，询问每个老板有多少个员工 ","date":"2020-04-22","objectID":"/abc163/:5:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 n=int(input())\ra=input().split()\rw=[0]*n\rfor i in a:\rw[int(i)-1]+=1\rfor i in w:\rprint(i)\r D - Sum of Large Numbers ","date":"2020-04-22","objectID":"/abc163/:6:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-22","objectID":"/abc163/:7:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 由于10^100次方的作用，这个题目就转化成求从中选n个数，有几种求和的结果 种数就是最大的n个减最小的n个 再遍历所有的n ac代码 n , k = map(int , input().split())\rsum = 0\rmod = 1e9+7\rdef func(x):\rreturn (2 * n - x + 1) * x / 2 - (x - 1) * x / 2 + 1\rfor i in range(k , n+2):\rsum = (sum + func(i)) % mod\rprint(int(sum))\r E - Active Infants ","date":"2020-04-22","objectID":"/abc163/:8:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-22","objectID":"/abc163/:9:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 贪心策略，尽可能地把值最大的点放到边边上,所以可以按降序排，然后从左到右 遍历 dp[i][j] 表示区间 [ i , j ] 确定的最大值 cnt\u003cvalue,index\u003e 表示当前点，即比它大的点都已安置过 那么 dp[i[[j] = max(dp[i+1][j] + cnt.first * | cnt.second - i| , dp[i][j-1] + cnt.first * |cnt.second - j| ) 对于 dp[i+1][j] 和 dp[i][j-1] 都需要用函数进行计算，就形成dfs ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\r#define fi first\r#define se second\rusing pll = pair\u003cll,ll\u003e;\rll n;\rll ans=0;\rvector\u003cpll\u003e vt; //存value和index ll dp[2005][2005];\rll cal(ll a,ll b,ll cnt){\rif(a\u003eb) return 0;\rif(dp[a][b]!=-1) return dp[a][b];\rreturn dp[a][b] = max(cal(a+1 , b , cnt+1) + vt[cnt].fi*abs(vt[cnt].se-a) , cal(a,b-1,cnt+1) + vt[cnt].fi*abs(vt[cnt].se -b));\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en;\rll t;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003et;\rvt.emplace_back(t,i) ;\r}\rsort(vt.begin() , vt.end() , [](pll x,pll y){if(x.fi != y.fi) return x.fi\u003ey.fi; return x.se\u003ey.se;}); //可以直接用greater\r memset(dp,-1,sizeof(dp));\rcout\u003c\u003ccal(0,n-1,0)\u003c\u003cendl;\rreturn 0;\r}\r F - path pass i ","date":"2020-04-22","objectID":"/abc163/:10:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 一个n个节点的树，每个节点都有一种颜色，可能重复 对于每种颜色，输出包含这种颜色的简单路径数量 ","date":"2020-04-22","objectID":"/abc163/:11:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 挺好一道树上dfs求路径的题 把问题转化成所有路径 - 不包含这种颜色的路径数 所有路径数为 C(2,n)+n 不包含这种颜色 i 的路径可以分成两部分 以颜色 i 作为父节点的子树，任意一条都是满足的（注意子树可能有颜色 i ） 将 i 节点作为父节点的子树切去的剩余部分 如果暴力求连通块的话会超时，所以要dfs（回溯思想） 因为分成两个部分，所以维护两种信息 path_num[i] 以i为颜色的点作为父节点中子树里面不包含此颜色的路径数量 ch_num[i] 以 i 为颜色的点作为父节点中子树的大小，包含 i 颜色 最后 k = n - cn_num[i] ans = all - path_num[i] - k(k+1)/2 对于dfs的细节在代码中标注 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint c[200005];\rvector\u003clong long\u003e G[200005];\rlong long path_num[200005]; //以i为颜色的点作为父节点中子树里面不包含此颜色的路径数量 long long ch_num[200005]; //以i为颜色的点作为父节点中子树的大小，包含i颜色 long long n;\rlong long ans;\rlong long dfs(long long u,long long v){\rlong long pre = ch_num[c[u]]; //dfs到u时，ch_num[i]的大小 long long cnt_ch_num = 1; //记录以u为父节点，子树的大小，包含自己所以起始为1 long long update = ch_num[c[u]]; //每次访问一个子节点就更新，目的是实时地计算路径数（需要用到残差） for(auto i:G[u]){ if(i!=v){\rlong long cntt = dfs(i,u); //返回的是以这个点为父节点的子节点数 cnt_ch_num += cntt; //扩充新的子节点数 long long delta = ch_num[c[u]] - update; //计算下一个子节点对于上一个子节点该颜色子树点的数量差 long long k = cntt - delta; //对于每个点都要更新路径数，路径数就是多出来的剩余部分(切去该颜色的点为父节点的所有子树，因为之前算过一部分\r //所以这里算残差) path_num[c[u]] += (k+1)*k/2; update = ch_num[c[u]]; //为了残差，需要更新 }\r}\rch_num[c[u]] = pre + cnt_ch_num; //子树大小为之前的部分 + 以u为父节点子树的部分 return cnt_ch_num; }\rint main(){\rcin\u003e\u003en;\rfor(long long i=0;i\u003cn;i++) {\rcin\u003e\u003ec[i];\rc[i]--;\r}\rlong long t1,t2;\rfor(long long i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\rt1--;t2--;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdfs(0,-1);\rfor(long long i=0;i\u003cn;i++){\rlong long k=n-ch_num[i];\rans = (n+1)*n/2 - path_num[i] - (k+1)*k/2; //所有路径 - 子树部分 - 剩余部分 cout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r 吃了一发爆long long debug很久发现，“简单路径”居然可以是自己到自己 一直在做android作业，debug快疯掉 debug一天多，发现recyclerview里面没有呈现cardview居然是getItemCount(){return 0;} ","date":"2020-04-22","objectID":"/abc163/:12:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["codeforces"],"content":"Codeforces Round #634 (Div. 3) A~E","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"A. Candies and Two Sisters ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:0:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 将一堆糖果分给两个女孩，其中一个要比另一个多，问有几种分法 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:1:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 可以看出规律 ac代码 t=int(input())\rfor i in range(t):\rn=int(input())\rprint((int)((n-1)/2))\r B. Construct the String ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:2:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 输入a,b,c 构造字符串，使字符串的长度为a，任意b个字符有c个不同字符 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:3:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 如果b=6,c=4就构造类似于aaabcdaaabcd.. 其他同理 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n,a,b;\rchar s[2005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ea\u003e\u003eb;\rfor(int i=0;i\u003ca-b+1;i++){\rs[i]='a';\r}\rchar x;\rfor(int i=a-b+1, x='b';i\u003ca;i++,x++){\rs[i]=x;\r}\rfor(int j=0,i=0;j\u003cn;j++){\rif(i==a) i=0;\rcout\u003c\u003cs[i++];\r}\rcout\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Two Teams Composing ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:4:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 从一个数列中，选一些数组成两个数列，使这两个数列长度相等，一个数列数字 全部相同，一个数列数字全部不同，求最长长度 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:5:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 求数列中出现次数最多的个数和总共有多少种数字，瞎比较一下即可 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rmap\u003cint,int\u003e mp;\rint t,n;\rint num;\rint m;\rint dat[200005];\rint ans;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rset\u003cint\u003e st;mp.clear();\rm=-1;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003edat[i];\rmp[dat[i]]++;\rif(mp[dat[i]]\u003em){\rm=mp[dat[i]];\rnum=dat[i];\r}\rst.insert(dat[i]);\r}\rint rem=n-m;\rif(m\u003c=st.size()-1) ans=m;\relse if(m==st.size()) ans=m-1;\relse ans=st.size();\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r D. Anti-Sudoku ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:6:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 输入一个数独 每行每列每宫格只能改变一个数，使每行每列每宫格有两个数相同 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:7:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 思维题 把所有的1改成2 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rchar s[9][10];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rfor(int i=0;i\u003c9;i++){\rcin\u003e\u003es[i];\r}\rfor(int i=0;i\u003c9;i++){\rfor(int j=0;j\u003c9;j++){\rif(s[i][j]=='1') s[i][j]='2';\r}\r}\rfor(int i=0;i\u003c9;i++){\rputs(s[i]);\r}\r}\rreturn 0;\r}\r E. Three Blocks Palindrome (hard version) ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:8:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 求一个字符串的子串（可以不连续）使得这个子串是三块回文串 三块回文串：字符串被分成三块（长度可以为0），第一块和第三块必须相同 第二块可以和第一块相同也可以不同 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:9:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 简单版的可以暴力枚举中间块的左边界和右边界 然后前缀存每个数字出现的次数 设长度为n，数字最大为m 则时间复杂度O(n*n*m*m) 困难版时间复杂度必须降到O(k*n) 这时候不再遍历两个边界 而是固定一个边界，遍历一个边界，这样时间复杂度为O(k*n) 如此只能遍历第一块的右边界（对应第三块的左边界） 对于一个特定的数 i 假设共有 x 个 第一块含有这个数的个数从1遍历到 x/2 个 这就需要一个容器存储数字 i 出现 j 次对应的下标 确定第一块和第三块后就要找第二块哪种数字出现得最多 这和简单版的一样，用前缀存数字 i 在下标为 j 时出现的次数 遍历一遍所有数字 再总体遍历一遍所有数字 时间复杂度O(m*m*n*lgn) 看起来会超时，但实际不会 (跑了400ms) 本来在存储下标pos时开二维静态数组，MLE(266K) 改成动态map (166K) 对于时间复杂度和空间复杂度都可以再优化 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint n;\rint num[205][200005]; //num[i][j]存数字i在下标为j时出现的次数 map\u003cint,int\u003e pos[205]; //map\u003cj,index\u003e存数字i出现第j次的下标 int main(){\r//freopen(\"in.txt\",\"r\",stdin);\r scanf(\"%d\",\u0026t);\rwhile(t--){\r//TODO reset\r /*for(int i=0;i\u003c202;i++) {\rnum[i][0]=0;\rpos[i][0]=0;\r}*/\rfor (int i=0;i\u003c205;i++) pos[i].clear();\rscanf(\"%d\",\u0026n);\rint tmp;\rfor(int i=1;i\u003c=n;i++){\rscanf(\"%d\",\u0026tmp);\rfor(int j=1;j\u003c=200;j++){\rif(j==tmp){\rnum[j][i]=num[j][i-1]+1;\r}\relse{\rnum[j][i]=num[j][i-1];\r}\r}\rpos[tmp].insert(make_pair(num[tmp][i],i));\r}\rint ans=1;\rfor(int i=1;i\u003c=200;i++){\rfor(int j=1;j\u003c=num[i][n]/2;j++){\rint l=pos[i][j]+1;\rint r=pos[i][num[i][n]-j+1]-1;\rfor(int k=1;k\u003c=200;k++){\rans=max(ans,num[k][r]-num[k][l-1]+2*j);\r}\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r//for(int i=1;i\u003c=4;i++) cout\u003c\u003cnum[i][8]\u003c\u003c\" \";\r //for(int i=1;i\u003c=4;i++) cout\u003c\u003cpos[3][i]\u003c\u003c\" \";\r }\rreturn 0;\r}\r F. Robots on a Grid ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:10:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:11:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:12:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["abc"],"content":"abc162","date":"2020-04-13","objectID":"/abc162/","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"A - Lucky 7 ","date":"2020-04-13","objectID":"/abc162/:0:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 问一个整数中是否含有数字7！ ","date":"2020-04-13","objectID":"/abc162/:1:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 ac代码 s = input()\rif '7' in list(s):\rprint('Yes')\relse:\rprint('No')\r B - FizzBuzz Sum ","date":"2020-04-13","objectID":"/abc162/:2:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 找出不大于n的自然数中不能被3和5整除的数的和 ","date":"2020-04-13","objectID":"/abc162/:3:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 模拟或者集成成公式O(1) ac代码 n = int(input())\rans=0\rfor i in range(1,n+1):\rif i%3==0 or i%5==0:\rcontinue\relse:\rans+=i\rprint(ans)\r C - Sum of gcd of Tuples (Easy) ","date":"2020-04-13","objectID":"/abc162/:4:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:5:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 ac代码 from math import gcd\rk=int(input())\rans=0\rfor i in range(1,k+1):\rfor j in range(1,k+1):\rfor m in range(1,k+1):\rans+=gcd(i,gcd(j,m))\rprint(ans)\r D - RGB Triplets ","date":"2020-04-13","objectID":"/abc162/:6:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:7:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 存rgb对应的下标 每次for循环两个颜色，在第三种颜色的下标中二分查找 时间复杂度O(n^2lgn) 这种方法不是很高效，跑了1600ms 利用乘法原理，跑一遍字符串应该可以O(n) ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rchar s[4005];\rvector\u003cint\u003e c[3];\rlong long ans=0;\rvoid sol(int q,int w,int e){\rfor(int i:c[q]) for(int j:c[w]){\rif(j\u003ei){\rvector\u003cint\u003e::iterator it = upper_bound(c[e].begin(),c[e].end(),j);\rif(it!=c[e].end()){\rans+=(int)(c[e].end()-it);\rint tgt=j+j-i;\rif(find(c[e].begin(),c[e].end(),tgt)!=c[e].end()) ans--;\r}else break;\r}\r}\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003es[i];\rswitch(s[i]){\rcase 'R':c[0].push_back(i);break;\rcase 'G':c[1].push_back(i);break;\rcase 'B':c[2].push_back(i);break;\r}\r}\rsol(0,1,2);\rsol(0,2,1);\rsol(1,2,0);\rsol(1,0,2);\rsol(2,1,0);\rsol(2,0,1);\rcout\u003c\u003cans\u003c\u003cendl;\r//cout\u003c\u003cs+1\u003c\u003cendl;\r return 0;\r}\r E - Sum of gcd of Tuples (Hard) ","date":"2020-04-13","objectID":"/abc162/:8:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 C题的升级版，个人觉得出得很好 官方题解，巧妙易懂 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll =long long;\rll n,k;\rll ans;\rll dp[1\u003c\u003c17];\rconst ll mod = 1e9+7;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(ll i=k;i\u003e0;i--){\rdp[i]=qpow(k/i , n);\rfor(ll j=i+i;j\u003c=k;j+=i){\rdp[i]-=dp[j]; //+mod%mod防溢出 }\r}\rfor(ll i=1;i\u003c=k;i++) ans=(ans+dp[i]*i)%mod;\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r}\r F - Select Half ","date":"2020-04-13","objectID":"/abc162/:9:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:10:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 贪心dp 对于当前数，有两种情况，选和不选 如果前一个数选了，这个数就不能选 如果前一个数不选，这个数可选可不选，取决于选了是否会贡献 对于下标的奇偶性需要分开判断 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll dat[1\u003c\u003c18];\rll sum[1\u003c\u003c18];\rll dp[1\u003c\u003c18];\rll n;\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++) {\rcin\u003e\u003edat[i];\rif(i\u003e=2 and i%2==0) sum[i]=dat[i]+sum[i-2];\relse if(i==0) sum[i]=dat[i];\r}\rfor(ll i=0;i\u003cn;i++){\rif(i\u00261){\rdp[i]=max(dp[i-2]+dat[i] , sum[i-1]);\r}\relse{\rdp[i]=max(dp[i-2]+dat[i] , dp[i-1]);\r}\r}\rcout\u003c\u003cdp[n-1]\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-04-13","objectID":"/abc162/:11:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["algorithm","hduoj"],"content":"hduoj1796","date":"2020-04-11","objectID":"/hduoj1796/","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"How many integers can you find ","date":"2020-04-11","objectID":"/hduoj1796/:0:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Problem Description Now you get a number N, and a M-integers set, you should find out how many integers which are small than N, that they can divided exactly by any integers in the set. For example, N=12, and M-integer set is {2,3}, so there is another set {2,3,4,6,8,9,10}, all the integers of the set can be divided exactly by 2 or 3. As a result, you just output the number 7. ","date":"2020-04-11","objectID":"/hduoj1796/:1:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Input There are a lot of cases. For each case, the first line contains two integers N and M. The follow line contains the M integers, and all of them are different from each other. 0\u003cN\u003c2^31,0\u003cM\u003c=10, and the M integer are non-negative and won’t exceed 20. ","date":"2020-04-11","objectID":"/hduoj1796/:2:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Output For each case, output the number. ","date":"2020-04-11","objectID":"/hduoj1796/:3:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Sample Input 12 2 2 3 ","date":"2020-04-11","objectID":"/hduoj1796/:4:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Sample Output 7 ","date":"2020-04-11","objectID":"/hduoj1796/:5:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Solution 容斥原理 ac代码 几个注意点 data可能为0(这时候可以忽略) 要开long long(一直没想到) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rlong long n,m;\rlong long dat[11];\rlong long ans=0;\rvector\u003clong long\u003e vt;\rlong long mm;\rmain(){\rwhile(~scanf(\"%d%d\",\u0026n,\u0026mm)){\rans=0; vt.clear();\rn--;\rlong long temp;\rfor(long long i=0;i\u003cmm;i++) {\rcin\u003e\u003etemp;\rif(temp!=0)\rvt.push_back(temp);\r}\rm=vt.size();\rlong long x=0;\rfor(auto i:vt){\rdat[x++]=i;\r}\rfor(long long i=1;i\u003c(1\u003c\u003cm);i++){ //i从1开始 long long lcm=1;\rfor(long long j=0;j\u003cm;j++){\rif(i\u003e\u003ej\u00261){\rlcm=(lcm*dat[j])/__gcd(lcm,dat[j]);\r}\rif(lcm\u003en) break;\r}\rif(__builtin_popcount(i)\u00261) ans+=n/lcm;\relse ans-=n/lcm;\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\r}\r ","date":"2020-04-11","objectID":"/hduoj1796/:6:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["nowcoder"],"content":"牛客练习赛61(部分)","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"A . 打怪 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:0:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r int t,a,b,c,d;\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed;\rif(b\u003e=c || d\u003c=0) cout\u003c\u003c-1\u003c\u003cendl;\relse{\rint num=0;\rint cx=c;\rbool me=true;\rwhile(a\u003e0){\rif(me){\rcx-=b; me^=1;\r}\relse{\ra-=d;me^=1;\r}\rif(cx\u003c=0) {\rcx=c;num++;me=true;\r}\r}\rif(num\u003e10000) cout\u003c\u003c-1\u003c\u003cendl;else cout\u003c\u003cnum\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r B . 吃水果 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:1:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 贪心 其实就是找一些操作使两数相等，如果小的数*2比大的数小就*2，否则随着数的 递减，y/x增大，需要乘很多次2才能相等 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rint c=0;\rwhile(n!=m){\rif(n\u003em) swap(n,m);\rif(2*n\u003c=m) {\rn*=2;c++;\r}\relse{\rn--;m--;c++;\r}\r}\rcout\u003c\u003cc+n\u003c\u003cendl;\r}\rreturn 0;\r}\r C . 四个选项 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:2:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 z[12]用来存12道题的选项，每次停留在一道题时，根据剩余选项数进行dfs 每次搜索到末尾时判断是否满足第i题和第j题答案相同，都相同则方案数+1 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint num[5];\rint z[13];\rvector\u003cpair\u003cint,int\u003e\u003e vt;\rint ans=0;\rint m;\rvoid dfs(int ind){\rif(ind==13){\rbool flag=true;\rfor(auto i:vt){\rif(z[i.first]!=z[i.second]) {\rflag=false;break;\r}\r}\rif(flag) {\rans++;return;\r}\r}\rfor(int i=1;i\u003c=4;i++){\rz[ind]=i;\rif(num[i]){\rnum[i]--;\rdfs(ind+1);\rnum[i]++;\r}\r}\r}\rint main(){\rcin\u003e\u003enum[1]\u003e\u003enum[2]\u003e\u003enum[3]\u003e\u003enum[4]\u003e\u003em;\rint t1,t2;\rwhile(m--) {\rcin\u003e\u003et1\u003e\u003et2;\rvt.emplace_back(t1,t2);\r}\rdfs(1);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D . 最短路变短了 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:3:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 设d1[x]是1到x的最短距离 d2[x]是x到n的最短距离 则每次反向一条边（u-\u003ev,w） 如果变短，那么一定是 1-\u003ev-\u003eu-\u003en 所以只需要判断 d1[v]+w+d2[u] \u003c d1[n] 反向边的改变可能会影响d1,d2原始的数值 但不影响结果 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst long long max_v=100005;\rconst long long max_q=200005;\rconst long long max_e=200005;\rconst long long inf=0x3f3f3f3f3f3f3f3f;\rstruct edge\r{\rlong long to,cost;\redge(long long to,long long cost){\rthis-\u003eto=to;\rthis-\u003ecost=cost;\r}\r};\rtypedef pair\u003clong long,long long\u003e pii; vector\u003cedge\u003e G1[max_v];\rvector\u003cedge\u003e rG[max_v];\rlong long V;\rlong long d1[max_v];\rlong long d2[max_v];\rlong long n,m,q;\rlong long t1,t2,t3;\rlong long x;\rlong long dat[max_e][3];\rvoid dijkstra(long long s,long long d[],vector\u003cedge\u003e G[])\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V+2,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rlong long v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(long long i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} } main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em;\rV=n;\rfor(long long i=1;i\u003c=m;i++){\rcin\u003e\u003et1\u003e\u003et2\u003e\u003et3;\redge e(t2,t3);\rG1[t1].push_back(e);\redge e1(t1,t3);\rrG[t2].push_back(e1);\rdat[i][0]=t1,dat[i][1]=t2,dat[i][2]=t3;\r}\rdijkstra(1,d1,G1);\rdijkstra(n,d2,rG);\rcin\u003e\u003eq;\rwhile(q--){\rcin\u003e\u003ex;\rlong long u=dat[x][0],v=dat[x][1],w=dat[x][2];\rif(d1[v]+d2[u]+w\u003cd1[n]) puts(\"YES\"); else puts(\"NO\");\r}\r// for(long long i=1;i\u003c4;i++) cerr\u003c\u003cd1[i]\u003c\u003c\" \"; cerr\u003c\u003c\"\\n\";\r// for(long long i=1;i\u003c4;i++) cerr\u003c\u003cd2[i]\u003c\u003c\" \"; cerr\u003c\u003c\"\\n\";\r}\r E . 相似的子串 F . 苹果树 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:4:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["codeforces"],"content":"Codeforces Round #632 (Div. 2) A~C","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"A. Little Artem ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:0:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 给一网格染色，黑或白。要求满足以下条件的黑方块比白方块少1 如果是黑方块，则至少与一白方块边相邻，否则不计数 反之亦然 ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:1:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 左上角染白，其他全黑 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003cm;j++){\rif(i==0 and j==0){\rcout\u003c\u003c'W';\r}\relse cout\u003c\u003c'B';\r}\rcout\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r B. Kind Anton ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:2:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 两数组a,b a初始时只由{0,-1,1}的子集组成 操作方式：将一个数前面的某一个数加到这个数上 问能否经过一些操作后得到数组b ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:3:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 由于一个数只会被前面的数影响，且前面的数不受影响 再加上0,-1,1的特殊性，只需要考虑b[i]\u003ea[i]时，前面是否有1 或b[i]\u003ca[i]时前面是否有-1 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint n;\rint a[100005];\rint b[100005];\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rbool one=false;\rbool none=false;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rfor(int i=0;i\u003cn;i++) cin\u003e\u003eb[i];\rif(a[0]!=b[0]) {\rcout\u003c\u003c\"NO\\n\"; continue;\r}\rif(a[0]==1) one=true;\rif(a[0]==-1) none=true;\rbool ok=true;\rfor(int i=1;i\u003cn;i++){\rif(b[i]\u003ea[i] and !one) {\rok =false;break;\r}\rif(b[i]\u003ca[i] and !none){\rok=false;break;\r}\rif(a[i]==1) one=true;\rif(a[i]==-1) none=true;\r}\rif(ok) cout\u003c\u003c\"YES\\n\"; else cout\u003c\u003c\"NO\\n\";\r}\rreturn 0;\r}\r C. Eugene and an array ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:4:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 给一数组，问有多少个“好子数组“ 定义，好子数组：这个数组是原数组的子集，元素之和不等于0，其子集都是好子 数组 ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:5:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 类似于依赖前缀和动态规划 从左向右遍历，查看是否有和为0的区间，其中区间的右边界为当前数 查看是否有和为0的区间只需要查看是否有前缀和为当前数的区间 如果有则取最右端（因为好子数组的子集也是好子数组） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long; ll n;ll x;ll sum=0;map\u003cll,ll\u003e pos;ll cp=-1;ll ans=0;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r\rcin\u003e\u003en;\rpos[0]=0;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ex;\rsum+=x;\rif(pos.count(sum)) cp=max(cp,pos[sum]);\rans+=i-cp-1;\rpos[sum]=i;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D. Challenges in school №41 E. Road to 1600 F. Kate and imperfection ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:6:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["nowcoder"],"content":"NC13611","date":"2020-04-06","objectID":"/nc13611/","tags":["cpp","number_theory","dp"],"title":"NC13611","uri":"/nc13611/"},{"categories":["nowcoder"],"content":"题目描述 shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。 输入描述: 第一行两个整数n，k代表点数和颜色数； 接下来n-1行，每行两个整数x,y表示x与y之间存在一条边； 输出描述: 输出一个整数表示方案数（mod 1e9+7）。 sample input 4 3 1 2 2 3 2 4 sample output 39 solution 动态规划 dp[i][j] 表示现在在第 i 个点，用 j 中颜色染色的方案数 那么对于下一个点有两种情况 1.染同一种颜色 dp[i][j]=dp[i-1][j] 2.染不同颜色 dp[i][j]+=dp[i-1][j-1]*(k-j+1) 最后对所有的 dp[n][i] 1\u003c=i\u003c=k 求和 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n,k;\rll dp[305][305];\rconst ll mod = 1e9+7;\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rdp[0][0]=1;\rfor(int i=1;i\u003c=n;i++)\rfor(int j=1;j\u003c=k;j++){\rdp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-j+1))%mod;\r}\rll ans=0;\rfor(int i=1;i\u003c=k;i++){\rans=(ans+dp[n][i])%mod;\r}\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r}\r 排列组合 把问题转化成将树分解成不大于 k 个连通块的方案数 将树分解成 i 个连通块，就要删掉 i-1 条边 总共有 $$\\ C_{n-1}^{i-1}$$ 种方案 对于每一种方案，染 i 中颜色 就有 $$\\ A_{k}^{i}$$ 种方案 所以一共有 $$ \\sum\\limits_{i=1} ^ {min(n,k)} {\\ C_{n-1}^{i-1}\\ A_{k}^{i}} $$ 然后模拟 逆元法 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n,k;\rconst ll mod = 1e9+7;\rll inv[305];\rll fac[305];\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinline ll A(ll m,ll n){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(ll i=0;i\u003c=n;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u003c=n;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\r//for(int i=1;i\u003c=9;i++) cout\u003c\u003cfac[i]\u003c\u003cendl;\r inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=n;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rll ans=0;\rfor(ll i=1;i\u003c=min(n,k);i++){\rans=(ans+C(i-1,n-1)*A(i,k)%mod)%mod;\r}\rcout\u003c\u003cans%mod;\rreturn 0;\r}\r 快速幂法 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n,k;\rconst ll mod = 1e9+7;\rll fac[305];\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rinline ll cal(ll i){\rreturn fac[n-1]*fac[k]%mod*qpow(fac[i-1],mod-2)%mod*qpow(fac[n-i],mod-2)%mod*qpow(fac[k-i],mod-2)%mod;\r}\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(ll i=0;i\u003c=n;i++){ //fac[0]=1!!!\r fac[i]=1;\r}\rfor(ll i=2;i\u003c=n;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rll ans=0;\rfor(ll i=1;i\u003c=min(k,n);i++){\rans=(ans+cal(i))%mod;\r}\rcout\u003c\u003cans%mod;\rreturn 0;\r}\r ","date":"2020-04-06","objectID":"/nc13611/:0:0","tags":["cpp","number_theory","dp"],"title":"NC13611","uri":"/nc13611/"},{"categories":["abc"],"content":"abc161","date":"2020-04-05","objectID":"/abc161/","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"A - ABC Swap ","date":"2020-04-05","objectID":"/abc161/:0:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给三个数a,b,c，交换ab的值，交换ac的值，输出 ","date":"2020-04-05","objectID":"/abc161/:1:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint a,b,c;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec;\rswap(a,b);\rswap(a,c);\rcout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003c\" \"\u003c\u003cc\u003c\u003cendl;\rreturn 0;\r}\r B - Popular Vote ","date":"2020-04-05","objectID":"/abc161/:2:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 有n件商品，每种商品有一价格，给一数m 求能否从中选出m件商品使得它们的价格都不小于商品总价格（n件）/(4*m) ","date":"2020-04-05","objectID":"/abc161/:3:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 对价格求和，求出界限，对商品价格排序，检查前m件商品价格是否都满足这个限 制 ac代码 #include\u003ciostream\u003e\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\r//using ll = long long;\rint n,m;\rint a[1005];\rbool cmp(int a,int b){\rreturn a\u003eb;\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++)cin\u003e\u003ea[i];\rint sum=0;\rfor(int i=0;i\u003cn;i++) sum+=a[i]; int b=ceil((double)sum/(4*m));\r//cout\u003c\u003csum;\r //cout\u003c\u003cb;\r bool ok=true;\rsort(a,a+n,cmp);\r//int ans=0;\r for(int i=0;i\u003cm;i++){\r//ans+=a[i];\r if(a[i]\u003cb){\rok=false;\rbreak;\r}\r}\rputs(ok? \"Yes\":\"No\");\rreturn 0;\r}\r C - Replacing Integer ","date":"2020-04-05","objectID":"/abc161/:4:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给俩数n,k 一直做如右操作，将n替换成|n-k| 求这个过程中n能达到的最小值 ","date":"2020-04-05","objectID":"/abc161/:5:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 找规律，不断地去迎合所有的情况，就会莫名其妙ac 或者用数学方法做 ac代码 #include\u003ciostream\u003e\rusing namespace std;\rusing ll = long long;\rll n,k;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003ek;\rif(n==k){\rcout\u003c\u003c0\u003c\u003cendl;\r}\relse{\rif(n\u003ck) n=k+(k-n);\rcout\u003c\u003cmin((k-n%k)%k,n-k)\u003c\u003cendl;\r}\rreturn 0;\r}\r D - Lunlun Number ","date":"2020-04-05","objectID":"/abc161/:6:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 定义“lunlun数”：对于一个数，相邻两个位数的数字差不大于1 给一数n，求第n个“lunlun数” ","date":"2020-04-05","objectID":"/abc161/:7:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 预处理最大的情况 dfs，dp都行 数字，字符串都行 此处用bfs做 对于一个数，在它的末尾增加新的数字，9和0有两种情况，其他有三种情况 先处理一位数，再处理两位数。。。 用bfs经典方法队列实现 用maxn进行循环退出判断 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cstring\u003e vt;\rint num=0;\rqueue\u003cstring\u003e q;\rbool cmp(string s1,string s2){\rif(s1.length()==s2.length()){\rreturn s1\u003cs2;\r}\relse return s1.length()\u003cs2.length();\r}\rint main(){\rq.push(\"1\");\rq.push(\"2\");\rq.push(\"3\");\rq.push(\"4\");\rq.push(\"5\");\rq.push(\"6\");\rq.push(\"7\");\rq.push(\"8\");\rq.push(\"9\");\rwhile(!q.empty() and num\u003c100005){\rstring s=q.front();\rq.pop();\rvt.push_back(s);\rnum++;\rint len=s.length();\rchar ch=s[len-1];\rif(ch=='9'){\rq.push(s+'8');\rq.push(s+'9');\r}\relse if(ch=='0'){\rq.push(s+'0');\rq.push(s+'1');\r}\relse{\rchar ch1= ch-1,ch2=ch,ch3=ch+1;\rstring s1=s,s2=s,s3=s;\rs1.insert(s1.end(),ch1);\rs2.insert(s2.end(),ch2);\rs3.insert(s3.end(),ch3);\rq.push(s1);\rq.push(s2);\rq.push(s3);\r}\r}\rsort(vt.begin(),vt.end(),cmp);\rint n;cin\u003e\u003en;\rn--;\rcout\u003c\u003cvt[n]\u003c\u003cendl;\rreturn 0;\r}\r cmp可以用lambda表达式写 E - Yutori ","date":"2020-04-05","objectID":"/abc161/:8:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给两个数k,c和一串由ox组成的字符串，表示每一天 从中选k天上班 限制条件：x不能上班，上完一天班后要连续休息c天 求所有可能的上班方案中，哪一天是必须上班的 ","date":"2020-04-05","objectID":"/abc161/:9:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 枚举必超时 其实只要贪心地从第一个开始选k个，从最后开始贪心地往前选k个 查看是否有交集就可 小证明 如果交集为空集，则不存在，因为这两种情况是所有情况的子集 如果存在（数量不大于k，下证），则对于所有中间取的情况一定会和左右两种情 况重叠，左右取产生的交集是最苛刻的满足条件 有几个细节 1.可以特判n==2 2.当从最左边开始选可以选到k+1个，则不存在必须上班的那一天 小证明 如果有k+1天，则随便从中选一天不上班，其余的天数都上班 对于所有的情况，它们的交集为空集，与右边的交集为空集（空集与任何集合 的交集都为空集） 3.同理右边也不能选到k+1个 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k,c;\rchar s[200005];\rset\u003cint\u003e st;\rset\u003cint\u003e st2;\rset\u003cint\u003e st3;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r scanf(\"%d%d%d%s\",\u0026n,\u0026k,\u0026c,s);\rint cnt=0;\rfor(int i=0;i\u003cn;i++){\rif(s[i]=='o') {\rst.insert(i+1);\rcnt++;\ri+=c;\r}\rif(cnt\u003ek) return 0; //一定不存在必须工作的一天 }\rcnt=0;\rfor(int i=n-1;i\u003e=0;i--){\rif(s[i]=='o'){\rst2.insert(i+1);\rcnt++;\ri-=c;\r}\rif(cnt\u003ek) return 0; //一定不存在必须工作的一天 }\rset_intersection(st.begin(),st.end(),st2.begin(),st2.end(),ostream_iterator\u003cint\u003e(cout,\"\\n\"));\rreturn 0;\r}\r F - Division or Substraction ","date":"2020-04-05","objectID":"/abc161/:10:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给俩数n,k（2\u003c=k\u003c=n） 不断进行如下操作 如果k能整除n，则n/=k 否则n-=k 当n\u003ck时停机 问满足最后n==1的k的个数 ","date":"2020-04-05","objectID":"/abc161/:11:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 设置一个计数器，遍历所有的k进行判断 这样会T，所以进行优化 首先只需遍历到√n（下证） 对于每个k 分两种情况 如果n%k==1，则满足条件 且(n-1)/k也满足条件 如果n%k==0则不断进行n/=k 最后判断是否n%k==1 这种情况下只有k满足条件，计数器计数 注意k*k=n-1只能计一个数 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r ll n;\rcin\u003e\u003en;\rif(n==2) {\rcout\u003c\u003c1\u003c\u003cendl;return 0;\r}\rll ans=2; //n和n-1 for(ll i=2;i*i\u003c=n;i++){\rif(n%i==1){\rif(i*i==n-1) ans++; else ans+=2;\r}\relse if (n%i==0){\rll t=n;\rwhile(t%i==0) t/=i;\rif(t%i==1) ans++;\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-04-05","objectID":"/abc161/:12:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["codeforces"],"content":"Codeforces Round #631 (Div. 2) A~D","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Dreamoon and Ranking Collection ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:0:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给n个数和数字k，你可以对数列进行扩充k个数，使得扩充后的数列出现1~m的 数字至少一次，求m的最大值 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:1:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 用计数器对原始数列计数，如果不连续，则k递减，直到k耗光，最后还要判断 原始数列能否再连续下去，直到断开 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,x;\rint a[105];\rint t;\rset\u003cint\u003e s;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\r//reset\r s.clear();\rcin\u003e\u003en\u003e\u003ex;\rfor(int i=0;i\u003cn;i++)\rcin\u003e\u003ea[i];\r//sort(a,a+n);\r for(int i=0;i\u003cn;i++){\rs.insert(a[i]);\r}\rint cnt=1;set\u003cint\u003e::iterator it;\rfor(it =s.begin();it!=s.end();){\rif((*it)!=cnt){\rx--;cnt++;\r}\relse {\rit++;\rcnt++;\r}\rif(x==0) break;\r}\rif(it==s.end() and x!=0){\rcnt+=x;\r}\rwhile(*it==cnt){\rit++;cnt++;\r}\rcout\u003c\u003ccnt-1\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Dreamoon Likes Permutations ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:2:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 定义“排列”为一个长度为n的数列，数列中1~n的数字必须且只能出现一次 给一数列，对数列进行切割，将数列分成两部分，使得两部分都是“排列” 求分割方案数 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:3:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 用两个集合存左右两部分 如果两个集合的最大值都等于数量，则这种分割可以得到排列 遍历数组，同时对俩集合进行增删操作 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint n;\rint a[200005];\rset\u003cint\u003e s1;\rset\u003cint\u003e s2;\rvector\u003cint\u003e ans;\rint num[200005];\rint main(){\rios::sync_with_stdio(0);cin.tie(0);\r// freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\r//TODO reset\r s1.clear();\rs2.clear();\rans.clear();\rmemset(num,0,sizeof(num));\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\r//preprocess\r s1.insert(a[0]);\rfor(int i=1;i\u003cn;i++){\rs2.insert(a[i]);\rnum[a[i]]++;\r}\rfor(int i=1;i\u003cn;i++){\rif(s1.size()==i and s2.size()==n-i and *(--s1.end())==i and *(--s2.end())==n-i){\rans.push_back(i);\r}\rs1.insert(a[i]);\rif(num[a[i]]==1){\rs2.erase(a[i]);\r}\rnum[a[i]]--;\r}\rif(ans.size()!=0)\r{\rcout\u003c\u003cans.size()\u003c\u003cendl;\rfor(auto i:ans){\rcout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cn-i\u003c\u003cendl;\r}\r}\relse cout\u003c\u003c0\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Dreamoon Likes Coloring ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:4:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数列，每次可以对其中连续的li个元素进行染色，每次染的颜色都不相同，问 所有染色结束后，能否使所有数字都染色，且每种颜色都存在 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:5:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 首先特判 如果区间的长度和小于数列长度，则不存在 如果对于第i个长度，区间的起始位置小于i，则不存在 贪心法 让第一个区间从第一个数开始，第二个区间从第二个数开始。。。 这样就能保证至少有一个数染这种颜色 但这样会出现一个问题 当所有区间都用完之后，右边的数可能不会染色 这时候就要将某些区间右移（不能在放在第i个） 判断条件就是，对于这个区间，是否存在右边为空的情况（即n-sum\u003ei） 其中sum为剩余部分长度和 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,m;\rll l[100005];\rll sum=0;\rll ans[100005];\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em;\rbool ok=true;\rfor(int i=0;i\u003cm;i++) {\rcin\u003e\u003el[i];\r//l[i];\r sum+=l[i];\rif(n-l[i]+1\u003c=i){\rok=false;\r}\r}\rif(!ok or sum\u003cn) {\rcout\u003c\u003c-1\u003c\u003cendl;\rreturn 0;\r}\relse{\rfor(int i=0;i\u003cm;i++){\rif(n-sum\u003ei){\rans[i]=n-sum;\r}\relse ans[i]=i;\rsum-=l[i];\r}\rfor(int i=0;i\u003cm;i++) cout\u003c\u003cans[i]+1\u003c\u003c\" \"; cout\u003c\u003cendl;return 0;\r}\r}\r D. Dreamoon Likes Sequences ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:6:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给俩数d,m 求满足下列条件的数列的个数%m 1\u003c= a1 \u003c a2 \u003c… \u003c an \u003c=d a1 XOR a2 \u003e a1 a1 XOR a2 XOR a3 \u003e a1 XOR a2 a1 XOR a2 XOR a3 XOR a4 \u003e a1 XOR a2 XOR a3 ……. ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:7:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 二进制构造 + 动态规划 对于一个数a，构造一个数b，使得b\u003ea ，且 b XOR a \u003e a a的二进制首位为0（可以添加0，没影响） b的二进制首位为1 那么b XOR a 的首位一定为1，满足条件 b的首位为1，其他位随便填 所以dp[i]表示长度为i的个数 那么dp[i] = (2^i) * dp[i-1] + dp[i-1] （加上之前的个数） 但这样一直做可能会超过d 所以要判断条件2^i\u003c=d 剩余的部分不再有2^i种 而是d-2^i+1种 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll d,m,t;\rll dp[30];\rll init=2;\rint main(){\r// freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ed\u003e\u003em;\rif(d==1){\rcout\u003c\u003c1%m\u003c\u003cendl;\r}\relse{\rdp[0]=init;\rint i;\rfor( i=1;(1\u003c\u003ci)\u003c=d;i++){\rdp[i]=(1\u003c\u003ci)*dp[i-1]%m+dp[i-1]%m;\r}\ri--;\rdp[i]=(d-(1\u003c\u003ci)+1)*dp[i-1]%m+dp[i-1]%m;\rcout\u003c\u003c(dp[i]-1+m)%m\u003c\u003cendl; //加m防止溢出 }\r}\rreturn 0;\r}\r ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:8:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["note","courses"],"content":"浮点数加减法","date":"2020-04-03","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/","tags":["cs"],"title":"浮点数加减法","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/"},{"categories":["note","courses"],"content":"#0 0操作数检查 如果有一个数为0，则可以直接得出结果 #1 用补码表示阶码，尾数 阶码的符号位为两位 尾数的个位为符号位 #2 对阶 小阶向大阶对齐（看原码），被对阶的数尾数右移阶差个 #3 尾数加 将两个尾数相加得到新的尾数 #4 溢出处理 太复杂，不作考虑 #4 规格化处理 先检查是否规格化，如果尾数符号位与最高位相同则非规格化 尾数左移直到规格化为止，阶码减少左移的位数（不含符号位） #5 舍入处理 最低有效位为0舍去，为1则尾数+1 #6 还原 将补码还原成原码 E.G. 1.设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y] x= 2^(-011) * (0.100101) y = 2^(-010) * (-0.011110) 解： 第一步，补码表示 x :11 101 , 0.100101 y : 11 110 , 1.100010 第二步 对阶，x阶小，y阶大，x向y对阶，阶差为1，所以x尾数右移一个 x阶码变成与y相同，阶码为 11 110 尾数0.010010(1) 第三步 尾数加 0. 0 1 0 0 1 0 (1)\r1. 1 0 0 0 1 0\r-------------------------\r1. 1 1 0 1 0 0 (1) 结果为 1.110110(1) 符号位与最高位都是1，非规格化 第四步 规格化 尾数左移两位变成 1.010010 阶码减2（符号位不变），变成 11 100 第五步 舍入处理 没得舍入 第六步 还原 x+y = 2^(-4) * (-0.101110) 对于[x-y] 根据[x-y]补码 = [x]补码 + [-y]补码 在第三步尾数加时 0. 0 1 0 0 1 0 (1)\r0. 0 1 1 1 1 0\r-------------------------\r0. 1 1 0 0 0 0 (1) 结果为 0.110000(1) 最高有效位和符号位不同，是规格化 最低有效位为1 尾数+1变成 0.110001 还原 x-y = 2^(-2) * (0.110001) ========================================================= 设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y] x=2^(-101) × （-0.010110） y=2^(-100) × （0.010110） 解： 第一步 补码表示 x : 11 011 , 1.101010 y : 11 100 , 0.010110 第二步 对阶，x阶小，y阶大 x阶码变成y，阶差1，x尾数右移1位 x : 11100 , 1.110101(0) 第三步 尾数加 1. 1 1 0 1 0 1 (0)\r0. 0 1 0 1 1 0\r-------------------------\r0. 0 0 1 0 1 1 (0) 结果为 0.001011(0) 符号位与最高有效位相同，非规格化 第四步 规格化 尾数左移两位，阶码减2 尾数 0.101100 阶码 11 010 第五步 舍入处理 无需舍入 第六步 还原 x+y = 2^(-6) * (0.101100) 同理x-y的尾数加为 1. 1 1 0 1 0 1 (0)\r1. 1 0 1 0 1 0\r-------------------------\r1. 0 1 1 1 1 1 (0) 结果为 1.011111(0) 符号位和最高有效位不同，为规格化 最低有效位为0，全舍弃 还原 x-y = 2^(-4) * (-0.100001) （有缺漏，待改正） ","date":"2020-04-03","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/:0:0","tags":["cs"],"title":"浮点数加减法","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/"},{"categories":["codeforces"],"content":"Codeforces Round #630 (Div. 2) A~E","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"A. Exercising Walk ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:0:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一坐标范围，初始位置，和左右上下移动的步数，问是否会出界 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:1:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 加各种条件判断即可 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint a,b,c,d,x,y,x1,y1,x2,y2;\rbool ok;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rok=true;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed\u003e\u003ex\u003e\u003ey\u003e\u003ex1\u003e\u003ey1\u003e\u003ex2\u003e\u003ey2;\rif( (a-b\u003e=0 and x-x1\u003ca-b) or (b-a\u003e0 and x2-x\u003cb-a) or (c-d\u003e0 and y-y1\u003cc-d) or (d-c\u003e0 and y2-y\u003cd-c) or (a==b and a!=0 and x1==x and x2==x) or (c==d and c!=0 and y1==y and y2==y) )\rok = false;\rif(ok) puts(\"yes\"); else puts(\"no\");\r}\rreturn 0;\r}\r B. Composite Coloring ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:2:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给n个合数上色，要求相同颜色的数字必须不互质，求最小着色数和着色方案 （题目保证着色数不大于11，且值不大于1000） ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:3:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 两个合数不互质，即最小质因子相同 对每个数求最小质因子 相同则染同一种颜色（贪心） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n;\rint a[1005];\rint c[1005];\rint p[]={1,2,3,5,7,11,13,17,19,23,29,31};\rset\u003cint\u003e st;\rbool vi[1005];\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\r//reset\r memset(c,0,sizeof(c));\rst.clear();\rmemset(vi,0,sizeof(vi));\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rfor(int i=0;i\u003cn;i++){\rfor(int j=1;j\u003c=12;j++){\rif(a[i]%p[j]==0){\rc[i]=j;\rst.insert(j);\rbreak;\r}\r}\r}\rint num=st.size();\rint index=0;\rint cnt;\rfor(int i=0;i\u003cn;i++){\rif(!vi[i]){\rcnt=c[i];\rvi[i]=true;\rindex++;\rc[i]=index;\rfor(int j=i+1;j\u003cn;j++){\rif(!vi[j] and c[j]==cnt){\rc[j]=index;\rvi[j]=true;\r}\r}\r}\r}\rcout\u003c\u003cnum\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003cc[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\r}\rreturn 0;\r}\r C. K-Complete Word ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:4:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一字符串和k，要求改其中一些字符，使字符串是回文串且周期为k，求最小改 动数 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:5:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 把字符串分成k个部分，每个部分都是回文串 字符串中的一些字符是相互捆绑的（即要相同），与其他字符相互独立 对于相互捆绑的字符，查询出现次数最多的字符，然后都替换成它 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n,k;\rstring s;\rint kp;\rint z[27];\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek;\rcin\u003e\u003es;\r//reset\r //memset(z,0,sizeof(z));\r kp=0;\rfor(int i=0;i\u003c=k-i-1;i++){\rmemset(z,0,sizeof(z));\rfor(int j=i;j\u003cn;j+=k){\rz[s[j]-'a']++;\r}\rif(i\u003ck-i-1)\r{\rfor(int j=k-i-1;j\u003cn;j+=k){\rz[s[j]-'a']++;\r}\r}\rkp+=*max_element(z,z+27);\r//cout\u003c\u003c*max_element(z,z+27)\u003c\u003cendl;\r }\rcout\u003c\u003cn-kp\u003c\u003cendl;\r}\r}\r D. Walk on Matrix ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:6:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一矩阵，从矩阵的左上角走到右下角，只能往右和往下走 走到一个元素上，则自身的值变为当前自身的值\u0026元素上的值 存在一种走法使得最后得到的值最大 给一dp算法和k，求满足经dp算法算出的值和最大值差k的矩阵 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:7:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 构造矩阵 让最大值为k 经dp算法输出的值为0 根据(m+k)\u0026k=k , (m+k)\u0026m=m , m\u0026k=0 其中m的二进制位1000… 进行构造（不唯一） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint m=(1\u003c\u003c17);\rint k;\rint main(){\rcin\u003e\u003ek;\rcout\u003c\u003c2\u003c\u003c\" \"\u003c\u003c3\u003c\u003cendl;\rcout\u003c\u003cm+k\u003c\u003c\" \"\u003c\u003cm\u003c\u003c\" \"\u003c\u003c0\u003c\u003cendl\u003c\u003ck\u003c\u003c\" \"\u003c\u003cm+k\u003c\u003c\" \"\u003c\u003ck\u003c\u003cendl;\rreturn 0;\r}\r E. Height All the Same ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:8:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一n*m的网格，和L，R 在网格上进行初始化放方块，要求每一格的方块数在L到R之间 有两种操作 1.在两（边相邻）相邻网格上各增加一块 2.在一个网格上增加两块 求能够使所有网格高度相等的初始化方案数 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:9:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 dif=R-L+1 当网格数量为奇数时，随便放，有dif^(n*m)种 当网格数量为偶数时，如果dif为偶数，则有一半情况不满足（每个满足的都对应 一个不满足的），有dif^(n*m)/2 当dif为奇数时，则中间会多出一个没有对应的方案，有(dif^(n*m)+1)/2 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rconst ll mod = 998244353;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r ll n,m,l,r;\rcin\u003e\u003en\u003e\u003em\u003e\u003el\u003e\u003er;\rll ans;\rll dif=r-l+1;\rif((n*m)\u00261) ans=qpow(dif,n*m)%mod;\relse if(dif%2==0) {\rans=qpow(dif,n*m)%mod*qpow(2,mod-2)%mod;\r}\relse{\rans=(qpow(dif,n*m)+1)%mod*qpow(2,mod-2)%mod;\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\r ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:10:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["abc"],"content":"abc160","date":"2020-03-29","objectID":"/abc160/","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"A - Coffee ","date":"2020-03-29","objectID":"/abc160/:0:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 判断一个长度为6的字符串，第3位和第4位是否相等，第5位和第6位是否相等 ","date":"2020-03-29","objectID":"/abc160/:1:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rstring s;\rcin\u003e\u003es;\rif(s[2]==s[3] and s[4]==s[5]) cout\u003c\u003c\"Yes\";\relse cout\u003c\u003c\"No\";\rreturn 0;\r}\r B - Golden Coins ","date":"2020-03-29","objectID":"/abc160/:2:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 高桥有许多钱，可以兑换成各种硬币，每获得一枚500円的硬币，就能获得1000 点快乐值，每获得一枚5円的硬币，就能获得5点快乐值，问最多能获得多少快乐 值 ","date":"2020-03-29","objectID":"/abc160/:3:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 贪心地兑换成500円的硬币，然后再兑换成5円的 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll x;\rll ans=0;\rint main(){\rcin\u003e\u003ex;\rans+=x/500;\rans*=1000;\rx%=500;\rans+=(x/5)*5;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - Traveling Salesman around Lake ","date":"2020-03-29","objectID":"/abc160/:4:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 在一个圆上有n个点，给定每个点的位置，问沿圆周访问所有点的最短长度 ","date":"2020-03-29","objectID":"/abc160/:5:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 访问所有点的路径就是圆周长减去一段隔阂 求隔阂的最大值，依次遍历即可 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k;\rint dist[200005];\rint c;\rint ans=-1;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003ek\u003e\u003en;\rc=k;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003edist[i];\rsort(dist+1,dist+n+1);\rfor(int i=1;i\u003c=n-1;i++){\rans=max(ans,dist[i+1]-dist[i]);\r}\rans=max(ans,c-dist[n]+dist[1]); //n是double不能当作index cout\u003c\u003cc-ans\u003c\u003cendl;\rreturn 0;\r}\r D - Line++ ","date":"2020-03-29","objectID":"/abc160/:6:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 有n个点，依次连线，再把其中两个未连线的点连线 求最短路径长度等于k的路径条数（对于所有的k=1,2,3..） ","date":"2020-03-29","objectID":"/abc160/:7:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 看似是图论题，其实只需要考虑两种情况 枚举所有点对的最短距离 1.直接按顺序走 2.走过特殊的连线 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,x,y;\rmap\u003cint,int\u003e mp;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003ex\u003e\u003ey;\rfor(int i=1;i\u003c=n;i++) for(int j=i+1;j\u003c=n;j++)\rmp[min(j-i,abs(i-x)+abs(j-y)+1)]++;\rfor(int i=1;i\u003cn;i++) cout\u003c\u003cmp[i]\u003c\u003cendl;\rreturn 0;\r}\r E - Red and Green Apples ","date":"2020-03-29","objectID":"/abc160/:8:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 DIO有a个红苹果（X）红面包（√）和b片绿面包，c片白面包 每片面包都有时停时间，聪明的DIO可以将白面包涂成红色或者绿色 现在DIO要吃x片红面包和y片绿面包（！DIO居然记得吃几片面包） DIO的最终目的就是无限时停，问DIO最多能时停几秒 ","date":"2020-03-29","objectID":"/abc160/:9:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 贪心地选取时停时间最多的面包 但是有限制条件就是x和y（白色是不受限制的） 所以从红色中选前x个，绿色中选前y个，与白色混合排序 最后选前x+y个 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll x,y,aa,bb,cc;\rvector\u003cll\u003e a,b,c;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003ex\u003e\u003ey\u003e\u003eaa\u003e\u003ebb\u003e\u003ecc;\rll temp;\rfor(ll i=0;i\u003caa;i++) {\rcin\u003e\u003etemp;\ra.push_back(temp);\r}\rfor(ll i=0;i\u003cbb;i++) {\rcin\u003e\u003etemp;\rb.push_back(temp);\r}\rsort(a.rbegin(),a.rend());\rsort(b.rbegin(),b.rend());\rfor(ll i=0;i\u003cx;i++) c.push_back(a[i]);\rfor(ll i=0;i\u003cy;i++) c.push_back(b[i]);\rfor(ll i=0;i\u003ccc;i++) {\rcin\u003e\u003etemp;\rc.push_back(temp);\r}\rsort(c.rbegin(),c.rend());\rll sum=0;\rfor(ll i=0;i\u003cx+y;i++) sum+=c[i];\rcout\u003c\u003csum\u003c\u003cendl;\rreturn 0;\r}\r F - Distributing Integers ","date":"2020-03-29","objectID":"/abc160/:10:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 给一棵树，对于树上的一个顶点，赋值为1，然后对于已赋值顶点的相邻顶点依次 赋值2,3,4..，求有多少种赋值方案，对于所有的顶点 ","date":"2020-03-29","objectID":"/abc160/:11:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 又是不会做的一题 树的拓扑序计数 + 换根 （感谢出题人和这道题让我认识了“树的拓扑序计数”，然后第二次遇见了“换根”） 对于某个顶点，方案数就是以这个点为根的“树的拓扑序的个数” 树的拓扑序的个数为 $$ {\\frac{n!}{\\prod\\limits_{} ^ {} {num}}} $$ num为每个节点的子节点数（含自己） 小证明： 如果没有限制，则排列组合有n!种 由于子节点要排在父节点的的后面 以根节点为例，它要排在第一个 由于排序是随机的，所以排在第一个的概率为1/num 同理所有的节点作为父节点时都与子节点等概率排序，所以每个都是1/num 全部就是product(num) n!可以直接求 现在要求product(num) 为避免超时，可以用类似于记忆化搜索的思想 先选取一个点为根（以1为例）求每个节点的子节点个数 直接dfs 然后求product(num[1]) 最后换根求不同节点的product(num) 直接dfs 此处换根product(num[i])=product(num[par])*(n-child[i])/child[i] ac代码 //#include\"bits/stdc++.h\"\r#include\u003ciostream\u003e\r#include\u003cvector\u003e\rusing namespace std;\rtypedef long long ll;\r// using pAr = product_as_root;\rconst ll mod = 1e9+7;\rll n;\rll sn[200005];\rll pAr[200005];\rvector\u003cll\u003e G[200005];\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rvoid dfs_sn(ll u,ll v){\rfor(auto i:G[u]){\rif(i!=v){\rdfs_sn(i,u); sn[u]+=sn[i];\r}\r}\rsn[u]++;\r}\rvoid dfs_cr(ll u,ll v){\rfor(auto i:G[u]){\rif(i!=v){\rpAr[i]=pAr[u]*qpow(sn[i],mod-2,mod)%mod*(n-sn[i])%mod;\rdfs_cr(i,u);\r}\r}\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rll t1,t2;\rfor(ll i=0;i\u003cn-1;i++) {\rcin\u003e\u003et1\u003e\u003et2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdfs_sn(1,0);\r//init\r pAr[1]=1;\rfor(ll i=1;i\u003c=n;i++) pAr[1]=pAr[1]*sn[i]%mod;\rdfs_cr(1,0);\r//factorial\r ll fac=1;\rfor(ll i=2;i\u003c=n;i++) fac=fac*i%mod;\rfor(ll i=1;i\u003c=n;i++){\rcout\u003c\u003cfac*qpow(pAr[i],mod-2,mod)%mod\u003c\u003cendl;\r}\r//for(int i=1;i\u003c=8;i++) cout\u003c\u003cpAr[i]\u003c\u003c\" \";\r return 0;\r}\r have a good day ^_^ ","date":"2020-03-29","objectID":"/abc160/:12:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["anime"],"content":"星际牛仔","date":"2020-03-29","objectID":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/","tags":[],"title":"星际牛仔","uri":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/"},{"categories":["anime"],"content":"《星际牛仔》（カウボーイビバップ；Cowboy Bebop），是日本SUNRISE动画 公司制作的原创电视动画，于1998年10月23日-1999年4月23日在东京电视台和 WOWOW播出，同年夺得第三回神户动画奖的年度最佳电视动画奖，并于2000年 获得日本科幻大会星云奖。 –百度百科 故事背景设定在2071 年。随着超光速航行技术的实现，人类得以在太阳系范围 内方便的自由移动，但是由于设计上的失误，这一技术引发了月球的爆炸，无数 月球碎片被吸引向地球，造成了空前绝后的大灾难。存活下来的人类逃离地球， 并开始在太阳系各地建立家园。 由于这次灾难，国家、政府等权力机构都极为不稳定，治安问题也成为了大难 题。 为了在人力资源不足的情况下抓捕罪犯，有些组织开始允许个人抓捕通缉的罪犯 并换取奖金，“赏金猎人”这个职业也就由此诞生了。–百度百科 ","date":"2020-03-29","objectID":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/:0:0","tags":[],"title":"星际牛仔","uri":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/"},{"categories":["codeforces"],"content":"Codeforces Round #629 (Div. 3)","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"A. Divisibility Problem ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:0:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 求一个数加上多少能被另一个数整除 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:1:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果b|(a+k) 则k=b-a%b注意k=0特判 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,a,b;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ea\u003e\u003eb;\rcout\u003c\u003c(b-(a%b)==b?0:b-(a%b))\u003c\u003cendl;\r}\rreturn 0;\r}\r B. K-th Beautiful String ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:2:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 一个长度为n的字符串，由n-2个a组成和2个b组成 求所有按字典序排列组合的第k个 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:3:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 只要定位b的位置就行 b的位置是有规律的，模拟这个规律 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rlong long t,n,k;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek;\rlong long fi=ceil((sqrt(1+8*k)-1)/2);\rlong long se=fi*(fi-1)/2;\rse=k-se;\rse=n-se; fi=n-1-fi;\rfor(long long i=0;i\u003cn;i++) if(i==fi or i==se) cout\u003c\u003c'b'; else cout\u003c\u003c'a';\rcout\u003c\u003cendl;\r}\r}\r 没开long long WA掉一发 C. Ternary XOR ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:4:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 定义一种异或运算 ai XOR bi = (ai+bi)%3 给一数c，求a,b使得(a XOR b)=c，使得max(a,b)尽可能小 c由0,1，2组成，且首位为2 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:5:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 从左到右遍历 以是否出现过1作为判断条件 第一次出现1时，一边为0，一边为1 之后把大的数填到之前填0的那一边 就能保证max最小 如果没有出现1则2分成1和1 出现后2分成0和2 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint n;\rshort up[50005];\rshort down[50005];\rbool one;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rone = false;\rcin\u003e\u003en;\rchar temp1;\rint temp2;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003etemp1;\rtemp2=temp1-'0';\rif(one){\rif(temp2==1){\rup[i]=1;down[i]=0;\r}\rif(temp2==2){\rup[i]=2;down[i]=0;\r}\rif(temp2==0){\rup[i]=0;down[i]=0;\r}\r}\relse{\rif(temp2==1) {\rone=true;up[i]=0;down[i]=1;\r} if(temp2==2){\rup[i]=1;down[i]=1;\r}\rif(temp2==0) {\rup[i]=0;down[i]=0;\r}\r}\r}\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cup[i]; cout\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003cdown[i]; cout\u003c\u003cendl;\r}\rreturn 0;\r}\r D. Carousel ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:6:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 旋转木马的马上有很多图案，给它们涂色，要求相邻不同图案要涂不同的颜色 问最少需要几种颜色，并求涂色方案（注意旋转木马是个环） ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:7:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果所有的图案都相同，只需要一种 如果图案不同则有可能需要2种或3种，但不超过3种 如果必须3种，则涂色可以为1,2,3,1,2,3…（注意最后一个不能与第一个相同）（不一定） 现在验证是否只需要2种 因为不同的图案必须涂不同的颜色 所以以不同的图案为点，用边连起来 判定是否为二分图就行（同种图案涂色不受限，所以不需要考虑同种图案） 还可以通过木马的奇偶性分类讨论 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint q;\rint n;\rint a[200005];\rint color[200005];\rvector\u003cint\u003e G[200005];\rbool dfs(int v,int c)\r{\rcolor[v]=c; for(int i=0;i\u003cG[v].size();i++)\r{\rif(color[G[v][i]]==c) return false; if(color[G[v][i]]==0 \u0026\u0026 !dfs(G[v][i],3-c)) return false; } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=1;i\u003c=n;i++)\r{\rif(color[i]==0) if(!dfs(i,1)) return false; }\rreturn true;\r} int main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003eq;\rwhile(q--){\r//reset TODO\r memset(color,0,sizeof(color));\rfor(int i=0;i\u003c=n;i++) G[i].clear();\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\r//特判\r bool flag=true;\rfor(int i=1;i\u003cn;i++) if(a[i]!=a[i+1]) flag=false; if(a[n]!=a[1]) flag=false;\rif(flag) {\rcout\u003c\u003c1\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003c1\u003c\u003c\" \"; cout\u003c\u003cendl;\r}\relse{\r//preprocess\r for(int i=1;i\u003cn;i++){\rif(a[i]!=a[i+1]) {\rG[i].push_back(i+1);G[i+1].push_back(i);\r}\r}\rif(a[n]!=a[1]) {\rG[n].push_back(1);G[1].push_back(n);\r}\rif(bipartite_graph()){\rcout\u003c\u003c2\u003c\u003cendl;\rfor(int i=1;i\u003c=n;i++) cout\u003c\u003ccolor[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\r}\relse{\rcout\u003c\u003c3\u003c\u003cendl;\rif((n-1)%3==0) {\rfor(int i=1;i\u003cn;i++) cout\u003c\u003c(i%3==0? 3 : i%3 )\u003c\u003c\" \"; cout\u003c\u003c2\u003c\u003cendl; }\relse{\rfor(int i=1;i\u003c=n;i++) cout\u003c\u003c(i%3==0? 3 : i%3 )\u003c\u003c\" \"; cout\u003c\u003cendl; }\r}\r}\r}\rreturn 0;\r}\r E. Tree Queries ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:8:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 给一棵树和几个树上的顶点 问是否存在从根出发的一条简单路径 使得所有的点都在这条路径上或离路径的距离为1 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:9:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果存在，这条路径一定是从根到深度最大的顶点 接下来依次判断这些点是否满足这些条件 对于某个点 求这个点和最深的点的LCA 判断这个点是否是LCA或LCA的子节点 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint V;\rint m;\rconst int maxv=200005;\rconst int max_logv=20;\rint data[maxv];\rint n;\rvector\u003cint\u003e G[maxv];\rint root=0;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i=0;i\u003cG[v].size();i++){\rif(G[v][i]!=p) dfs(G[v][i],v,d+1);\r}\r}\rvoid init(int V){\rdfs(root,-1,0);\rfor(int k=0;k+1\u003cmax_logv;k++){\rfor(int v=0;v\u003cV;v++){\rif(parent[k][v]\u003c0) parent[k+1][v]=-1;\relse parent[k+1][v]=parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u]\u003edepth[v]) swap(u,v);\rfor(int k=0;k\u003cmax_logv;k++){\rif((depth[v]-depth[u])\u003e\u003ek\u00261) v=parent[k][v];\r}\rif(u==v) return u;\rfor(int k=max_logv-1;k\u003e=0;k--){\rif(parent[k][u]!=parent[k][v]){\ru=parent[k][u];\rv=parent[k][v];\r}\r}\rreturn parent[0][u];\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003eV\u003e\u003em;\rint temp1,temp2;\rfor(int i=0;i\u003cV-1;i++){\rcin\u003e\u003etemp1\u003e\u003etemp2;\rG[temp1-1].push_back(temp2-1);\rG[temp2-1].push_back(temp1-1);\r}\rinit(V);\rwhile(m--){\rcin\u003e\u003en;\rint maxdi;\rint maxd=-1e9;\rint temp;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003etemp;\rdata[i]=temp-1;\rif(depth[data[i]]\u003e=maxd) {\rmaxd=depth[data[i]];\rmaxdi=data[i];\r}\r}\r//cout\u003c\u003cmaxdi\u003c\u003cendl;\r bool flag=true;\rfor(int i=0;i\u003cn;i++){\rif(data[i]!=maxdi)\r{\rint foo=lca(maxdi,data[i]);\rif(!(data[i]==foo || foo==parent[0][data[i]])) {\rflag=false;break;\r}\r}\r}\rif(flag) cout\u003c\u003c\"YES\"\u003c\u003cendl; else cout\u003c\u003c\"NO\"\u003c\u003cendl; }\r//cout\u003c\u003clca(2,4)\u003c\u003cendl;\r //for(int i=1;i\u003c=4;i++) cout\u003c\u003cdepth[i]\u003c\u003cendl;\r return 0;\r}\r 因为max_logv开太小，WA了7次，一直停留在第80个测试点（我记得明明还往多了开的，难道是计算失误，还是记忆丧失） F. Make k Equal ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:10:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 给一数列 每次可进行这样的操作 1.把最小的数+1 2.把最大的数-1 求最少需要多少次操作使数列中有k个相等的数 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:11:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 一开始想的是，这个数应该是中位数，然后从它往两边扩散，把两边的数往里压 结果这应该不是最优解 太困了（X）太菜了（√），直接看了别人的题解恍然大悟 最后得到的这k个相同的数一定在数列中（由于两边往里压，中间的数可看成不变，最后的结果一定是压向不变的数） 首先排序 过一遍数列 每次针对一片相同数字域 求以此为目标需要进行的操作数 不断min更新 对于某块相同数字域 遍历过程中维护数字域左边的数量lnum 左边的和lsum 右边的数量rnum 右边的和rsum 这样是便于计算操作数，降低时间复杂度 考虑三种情况 左边压到中间 右边压到中间 两边压到中间 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,k;\rll a[200005];\rmap\u003cll,ll\u003e mp;\rll lsum=0;\rll rsum=0;\rll lnum=0;\rll rnum;\rll re;\rll ans=1e15;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003ek;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\rmp[a[i]]++;\rrsum+=a[i];\r}\r//特判\r for(auto i:mp) if(i.second\u003e=k) {cout\u003c\u003c0\u003c\u003cendl;return 0;}\rrnum=n;\rfor(auto i:mp) {\rrnum-=i.second;\rrsum-=(i.first*i.second); re=k-i.second;\rif(lnum\u003e=re){\rans=min(ans,(i.first-1)*lnum-lsum+re);\r}\rif(rnum\u003e=re){\rans=min(ans,rsum-(i.first+1)*rnum+re);\r}\rif(re\u003e=2){\rans=min(ans,(i.first-1)*lnum-lsum+re+rsum-(i.first+1)*rnum);\r}\rlsum+=(i.first*i.second);\rlnum+=i.second;\r} cout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r} hava a good day ^_^ ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:12:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["GAME"],"content":"杀手2","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["GAME"],"content":"杀手2由IO Interactive开发，2018年发行的潜行刺杀游戏，与羞辱不同的是这是第三人称 杀手2最大的特点是刺杀方法的丰富性 游玩过程中会发现特别多的可能性 里面有一个适合手残党的玩法，就是被敌人盯上时，可以一直藏着，只要等的下去，危险就会解除 剧情很丰富，延续了杀手1 但是剧情太短了 玩一会就完了（指不开辟新的刺杀方式） 地图是分区的，每一块地图也太小了 风景做的很好，但是与NPC的互动太少了 换装式的伪装也是一大特色 通过这种伪装可以派生很多的玩法 吐槽一下一种线下的狙击模式，非常的sb，简直就是4399小游戏搬过来的 ","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/:0:0","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["GAME"],"content":"剧情 游戏剧情衔接《杀手》的剧情，戴安娜为了得到神意秘会的代理人“永恒常量”手中有关47出身来历的一切信息，说服了ICA董事会接受了来自神意秘会的契约：消灭“影子客户”并瓦解他的民兵组织。 根据47曾经在科罗纳多获取的情报，ICA找到了关于民兵组织成员的线索：阿尔玛·雷纳德，肖恩·罗斯的前女友，当过生态恐怖分子并且是一名很有才华的外勤潜入者，目前与她的新搭档奥森·米尔斯躲 藏在新西兰霍克斯湾的一处海滨别墅。 47为搜寻情报而前往调查关于“影子客户”与民兵的线索。 –百度百科 ","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/:1:0","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["android"],"content":"Android Fragment","date":"2020-03-24","objectID":"/android-fragment/","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"生命周期 在containerActivity的布局中放入一个fragment，然后点击按钮，切换成另一个fragment containerActivity的布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".fragment.containerActivity\"\u003e\r\u003cButton\randroid:id=\"@+id/ctnbtn1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"change_fragment\"\randroid:textSize=\"25sp\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.1\" /\u003e\r\u003cFrameLayout\randroid:id=\"@+id/ctn1\"\randroid:layout_width=\"match_parent\"\rapp:layout_constraintTop_toBottomOf=\"@+id/ctnbtn1\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\randroid:layout_height=\"0dp\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r containerActivity.java package com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity {\rprivate Afragment afragment;\rprivate Bfragment bfragment;\rprivate Button ctnbtn1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rctnbtn1 = findViewById(R.id.ctnbtn1);\rctnbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rgetSupportFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).commitAllowingStateLoss();\r}\r});\rafragment = new Afragment();\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment).commitAllowingStateLoss();\r}\r}\r Afragment.java package com.example.test.fragment;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\r}\r}\r fragment_a.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/fatv1\"\randroid:text=\"fragment_a\"\randroid:textSize=\"25sp\"\randroid:gravity=\"center\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.4\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r Bfragment.java和fragment_b.xml与A类似 ","date":"2020-03-24","objectID":"/android-fragment/:1:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"传数据给fragment Afragment.java package com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\"tk\",title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\"tk\"));\r}\r}\r@Override\rpublic void onAttach(Context context) {\rsuper.onAttach(context);\r}\r@Override\rpublic void onDetach() {\rsuper.onDetach();\r}\r}\r 通过这种方法实例化 afragment = Afragment.newInstance(\"hello world\");\r ","date":"2020-03-24","objectID":"/android-fragment/:2:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"fragment的回退栈 fragment_a.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\u003e\r\u003cButton\randroid:id=\"@+id/fabtn1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"change_to_Bfragment\"\randroid:textSize=\"25sp\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.1\" /\u003e\r\u003cButton\randroid:id=\"@+id/fabtn2\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"updata_text\"\randroid:textSize=\"25sp\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.2\" /\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/fatv1\"\randroid:text=\"fragment_a\"\randroid:textSize=\"25sp\"\randroid:gravity=\"center\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.4\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r Afragment.java package com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\"tk\",title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\"Afragment\",\"----------onCreateView--------\");\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\"updated\");\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\"tk\"));\r}\r}\r}\r fragment_b.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/fbtv1\"\randroid:text=\"fragment_b\"\randroid:textSize=\"25sp\"\randroid:gravity=\"center\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.4\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r Bfragment.java package com.example.test.fragment;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rim","date":"2020-03-24","objectID":"/android-fragment/:3:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"传递数据给activity 通过接口回调 Afragment.java package com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate msgclick listener;\rpublic interface msgclick{\rvoid onclick(String s);\r}\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2,fabtn3;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\"tk\",title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Override\rpublic void onAttach(Context context) {\rsuper.onAttach(context);\rlistener = (msgclick) context;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\"Afragment\",\"----------onCreateView--------\");\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn3 = view.findViewById(R.id.fabtn3);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rFragment fragment = null;\rif (getFragmentManager() != null) {\rfragment = getFragmentManager().findFragmentByTag(\"a\");\r}\rif(fragment!=null) {\rgetFragmentManager().beginTransaction().hide(fragment).add(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\relse{\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\"updated\");\r}\r});\rfabtn3.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rlistener.onclick(\"dedsec\");\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\"tk\"));\r}\r}\r}\r containerActivity.java package com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity implements Afragment.msgclick {\rprivate Afragment afragment;\r//private Bfragment bfragment;\r private TextView ctntv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rafragment = Afragment.newInstance(\"hello world\");\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment,\"a\").commitAllowingStateLoss();\rctntv1 = findViewById(R.id.ctntv1);\r}\r@Override\rpublic void onclick(String s) {\rctntv1.setText(s);\r}\r}\r ","date":"2020-03-24","objectID":"/android-fragment/:4:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"Android 属性动画","date":"2020-03-24","objectID":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","tags":["java","xml"],"title":"Android 属性动画","uri":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"},{"categories":["android"],"content":"简单演示 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".anim2Activity\"\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"70dp\"\randroid:id=\"@+id/a2tv1\"\randroid:textSize=\"30sp\"\randroid:text=\"animation_test\"\randroid:gravity=\"center\"\randroid:textColor=\"#FFFFFF\"\randroid:background=\"#AAAAAA\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.widget.TextView;\rpublic class anim2Activity extends AppCompatActivity {\rprivate TextView a2tv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_anim2);\ra2tv1 = findViewById(R.id.a2tv1);\ra2tv1.animate().translationYBy(500).setDuration(2000).start();\r}\r}\r package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.animation.ObjectAnimator;\rimport android.animation.ValueAnimator;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.widget.TextView;\rpublic class anim2Activity extends AppCompatActivity {\rprivate TextView a2tv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_anim2);\ra2tv1 = findViewById(R.id.a2tv1);\r//a2tv1.animate().translationYBy(500).setDuration(2000).start();\r //a2tv1.animate().alpha(0).setDuration(2000).start();\r\r// ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100);\r// valueAnimator.setDuration(2000);\r// valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r// @Override\r// public void onAnimationUpdate(ValueAnimator animation) {\r// Log.d(\"test\",animation.getAnimatedValue()+\"\");\r// Log.d(\"test\",animation.getAnimatedFraction()+\"\");\r// }\r// });\r// valueAnimator.start();\r ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(a2tv1,\"translationY\",1500,200,500,300,1000);\robjectAnimator.setDuration(5000);\robjectAnimator.start();\r}\r}\r ","date":"2020-03-24","objectID":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:0:0","tags":["java","xml"],"title":"Android 属性动画","uri":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"},{"categories":["GAME"],"content":"看门狗2","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["GAME"],"content":"Watch_dogs2是ubisoft于2016年11月发行的角色扮演游戏 骇入系统是其游戏特色 玩了130+小时 看门狗2的这个特色很新颖，但是剧情很平淡，后面的玩法基本与前面重复 难度也不是很高，很快就能通关，dlc就是支线剧情的复制。但是旧金山的风景还是 很不错的，就是地图太小了。线上模式的hack玩的最多，开始被虐，后来找到技巧，虐别人就索然无味了 线上赛车自从玩了GTA5之后真的就无趣了，经常有人莫名其妙退出 经常受到土豆服务器的制约 现在是真的没空玩看门狗3了 ","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/:0:0","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["GAME"],"content":"剧情 《看门狗2》将游戏设定在距离《看门狗》故事发生之后，ctOS由1.0升级成为2.0，同时也获得了许多功能。然而，ctOS并不是像宣传的那样单纯只是为市民服务，它被不法公司，团体和个人用来监视市民，收集并出售他们个人的数据，操纵选举和扰乱社会秩序等等。游戏需要玩家跟随主人公一点一点进入《看门狗2》的庞大电子世界，揭开并粉碎敌人的阴谋。 《看门狗2》的总监表示，游戏开发团队想在这一作上尝试一些新的点子，比如位于旧金山的游戏场景，整体色调更鲜活明亮，再搭配故事的主题、建筑风格、网络世界以及先进科技。在这样的架构中，故事风格不适合艾登‧皮尔斯，因此让马可仕担任主角来叙述故事是很合适的。 –百度百科 ","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/:0:1","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["abc"],"content":"abc159","date":"2020-03-23","objectID":"/abc159/","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"A - The Number of Even Pairs ","date":"2020-03-23","objectID":"/abc159/:0:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (awk语言) $0=$1*--$1/2+$2*--$2/2_\r B - String Palindrome ","date":"2020-03-23","objectID":"/abc159/:1:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) print\u003c\u003e=~/^(.+).\\1$/?Yes:No\r C - Maximum Volume ","date":"2020-03-23","objectID":"/abc159/:2:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) print\u003c\u003e**3/27\r D - Banned K ","date":"2020-03-23","objectID":"/abc159/:3:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) \u003c\u003e;print$.-@$_,$/for grep$.+=++$#$_,glob`dd`\r E - Dividing Chocolate ","date":"2020-03-23","objectID":"/abc159/:4:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题意 一块巧克力由h行w列的方块组成，每个方块为白或黑 你可以对巧克力进行切割，切割只能沿着方块边缘横切或竖切切到底 问最少需要切几刀，使每个独立块都有不多于k个白巧克力方块 ","date":"2020-03-23","objectID":"/abc159/:5:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ","date":"2020-03-23","objectID":"/abc159/:6:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"贪心 枚举 和牛客小白月赛26的A题很像 由于h的数据不大，枚举行的所有可能情况，先考虑横切，横切不够再竖切 考虑竖切时，如果最大的块大于k，就实施竖切 遍历所有情况求最小值 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint h,w,k;\rstring s[12];\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r int coun=0;\rcin\u003e\u003eh\u003e\u003ew\u003e\u003ek;\rfor(int i=0;i\u003ch;i++){\rcin\u003e\u003es[i];\r}\r//特判 //没有特判，用u=0代替 WA for(int i=0;i\u003ch;i++) for(int j=0;j\u003cw;j++) if(s[i][j]=='1') coun++;\rif(coun\u003c=k) cout\u003c\u003c0\u003c\u003cendl;\relse{\rint ans=1e9;\rfor(int u=1;u\u003c(1\u003c\u003c(h-1));u++){\rint x=__builtin_popcount(u);\rint cut_num=x;\rint block[x+1]={0};\rint p=0;\rint mx=0;\rbool flag=true; //没有设置flag WA for(int j=0;j\u003cw;j++){\rfor(int i=0;i\u003ch;i++){\rblock[p]+=s[i][j]-'0';\rmx=max(mx,block[p]);\rif(u\u003e\u003ei\u00261) p++;\r}\r//mx=max(mx,block[p]);\r if(mx\u003ek) {\rif(j==0) { flag=false;break; }\rcut_num++;\rmx=0;\rmemset(block,0,sizeof(block));\rp=0; //没有重置p WA for(int i=0;i\u003ch;i++){ //没有记忆（重新计算） WA block[p]+=s[i][j]-'0';\rmx=max(mx,block[p]);\rif(u\u003e\u003ei\u00261) p++;\r}\r}\rp=0; //没有重置p WA }\rif(flag) ans=min(ans,cut_num);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r 这道题做了快一个小时，WA了特别多次，每次都WA两三个测试点，主要是细节，WA点在代码中已标注 F - Knapsack for All Segments ","date":"2020-03-23","objectID":"/abc159/:6:1","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题意 给一数列，求对每一可能区间，其子区间内的数和等于s的子区间个数 对所有可能区间求和 ","date":"2020-03-23","objectID":"/abc159/:7:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ","date":"2020-03-23","objectID":"/abc159/:8:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"动态规划 奇妙的动态规划 dp[i][j] = sum(f(left,i)) 当和为 j 时 可以的得到递推式 dp[i][j]=dp[i-1][j] dp[i][j]+=dp[i-1][j-data[i]] 有一个很重要的点在代码中标出 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,s;\rll data[3005];\rll dp[3005][3005];\rconst ll mod=998244353;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003es;\rfor(ll i=1;i\u003c=n;i++) cin\u003e\u003edata[i];\rdp[0][0]=1;\rfor(ll i=1;i\u003c=n;i++) for(ll j=0;j\u003c=s;j++)\r{\rdp[i][j]=dp[i-1][j];\rif(j-data[i]\u003e=0) dp[i][j]+=dp[i-1][j-data[i]];\rif(j==0) dp[i][j]++; //当j-data[i]==0时，a[i]这一个也要算上 dp[i][j]%=mod;\r}\rll ans=0;\rfor(ll i=1;i\u003c=n;i++) ans=(ans+dp[i][s])%mod;\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r}\r 一遍过，芜湖~ have a good day ^_^ ","date":"2020-03-23","objectID":"/abc159/:8:1","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["android"],"content":"Android 数据存储","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["android"],"content":"SharedPreferences sharedpreferences的布局 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".datastorage.sharedPreferencesActivity\"\u003e\r\u003cEditText\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/spet1\"\randroid:hint=\"input\"\randroid:textSize=\"25sp\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.1\"\r/\u003e\r\u003cButton\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25sp\"\randroid:text=\"sava\"\rapp:layout_constraintTop_toBottomOf=\"@+id/spet1\"\randroid:layout_marginTop=\"20dp\"\randroid:id=\"@+id/spbtn1\"/\u003e\r\u003cButton\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25sp\"\randroid:text=\"show\"\rapp:layout_constraintTop_toBottomOf=\"@+id/spbtn1\"\randroid:layout_marginTop=\"20dp\"\randroid:id=\"@+id/spbtn2\"/\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/sptv1\"\randroid:textSize=\"25sp\"\rapp:layout_constraintTop_toBottomOf=\"@+id/spbtn2\"\randroid:layout_marginTop=\"20dp\"\r/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r 输入内容，存储到sharedpreferences,并呈现 package com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.Intent;\rimport android.content.SharedPreferences;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class sharedPreferencesActivity extends AppCompatActivity {\rprivate Button spbtn1,spbtn2;\rprivate EditText spet1;\rprivate TextView sptv1;\rprivate SharedPreferences mysp;\rprivate SharedPreferences.Editor myspe;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_shared_preferences);\rspbtn1 = findViewById(R.id.spbtn1);\rspbtn2 = findViewById(R.id.spbtn2);\rspet1 = findViewById(R.id.spet1);\rsptv1 = findViewById(R.id.sptv1);\r//实例化\r mysp = getSharedPreferences(\"data\",MODE_PRIVATE);\rmyspe = mysp.edit();\rspbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rmyspe.putString(\"name\",spet1.getText().toString());\rmyspe.apply(); //相当于提交\r\r}\r});\rspbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsptv1.setText(mysp.getString(\"name\",\"\"));\r}\r});\r}\r}\r sharedpreferences把数据存在xml文件中 在路径 data\\data\\\u003capplicationId\u003e\\shared_prefs下有一个xml文件 真机要root查看 模拟器直接在终端打开monitor 要查看这个文件可以点击右上角的 pull a file from the device 下载下来 打开之后 File 内部存储 布局和功能几乎与sharedpreferences相同 java文件 package com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rimport java.io.FileInputStream;\rimport java.io.FileOutputStream;\rimport java.io.IOException;\rpublic class fileActivity extends AppCompatActivity {\rprivate Button fibtn1,fibtn2;\rprivate EditText fiet1;\rprivate TextView fitv1;\rprivate final String filename = \"test.txt\";\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_file);\rfibtn1 = findViewById(R.id.fibtn1);\rfibtn2 = findViewById(R.id.fibtn2);\rfiet1 = findViewById(R.id.fiet1);\rfitv1 = findViewById(R.id.fitv1);\rfibtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsave(fiet1.getText().toString());\r}\r});\rfibtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfitv1.setText(read());\r}\r});\r}\rpub","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:0","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["android"],"content":"权限申请 \u003cuses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/\u003e\r\u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/\u003e\r ","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:1","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["nowcoder"],"content":"牛客小白月赛23(部分题解)","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"A 膜法记录 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:0","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 贪心 枚举 集合的整数表示 由于n的数据较小，直接枚举n的所有情况，有2^n种 对于每种情况判断剩下的点列blast能否用完 其实就是贪心思想（把行blast用完，再用列blast） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rchar s[23][100005];\rll t;\rll n,m,a,b;\rll cl[1\u003c\u003c21];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb;\rfor(ll i=0;i\u003c(1\u003c\u003cn);i++) cl[i]=0;\rfor(ll i=1;i\u003c=n;i++) scanf(\"%s\",s[i]+1);\r//memset(cl,0,sizeof(cl));\r for(ll j=1;j\u003c=m;j++) {\rll temp=0;\rfor(ll i=1;i\u003c=n;i++) if(s[i][j]=='*') temp|=(1\u003c\u003ci-1);\rcl[temp]++;\r}\rfor(ll i=1;i\u003c=n;i++)\rfor(ll j=0;j\u003c(1\u003c\u003cn);j++){\rif((j\u0026(1\u003c\u003ci-1))==0) cl[j|1\u003c\u003ci-1]+=cl[j];\r}\rbool ok=false;\rfor(ll i=0;i\u003c(1\u003c\u003cn);i++){\rif(__builtin_popcount(i)\u003c=a and m-cl[i]\u003c=b){\rok=true;break;\r}\r}\rif(ok) puts(\"yes\");\relse puts(\"no\");\r}\rreturn 0;\r}\r 这里用memset会迷之超时，要用for循环 一个神奇的函数 __builtin_popcount(int x) 返回x的二进制1的个数 B 阶乘 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:1","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二分 数论 用二分法获得最小值 检测一个数n的阶乘是否能被p整除 对p进行质因数分解 遍历p的质因数 如果对于所有的质因数 n！被这个质因数整除的个数都不小于p中的个数 那么n！就能被p整除 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll t;\rll p;\rll fac[1000005];\rll num[1000005];\rll tt;\rvoid decompose(ll p){\rtt=0;\rfor(ll i=2;i*i\u003c=p;i++){\rif(p%i==0){\rfac[tt]=i;\rnum[tt]=0;\rwhile(p%i==0) p/=i,num[tt]++;\rtt++;\r}\r}\rif(p\u003e1) {\rfac[tt]=p;num[tt]=1;tt++;\r}\r}\rbool check(ll x){\rfor(ll i=0;i\u003ctt;i++){\rll cnt=0,t=x;\rwhile(t) {\rcnt+=t/fac[i];\rt/=fac[i];\r}\rif(cnt\u003cnum[i]) return false;\r}\rreturn true;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ep;\rdecompose(p);\rll l=1,r=1e10; //开1e6会wa\r while(l\u003cr){\rll mid=l+r\u003e\u003e1;\rif(check(mid)) r=mid;\relse l=mid+1;\r}\rcout\u003c\u003cr\u003c\u003cendl;\r}\rreturn 0;\r}\r C 完全图 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:2","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二分 图论 规律 很容易能找到规律 要分裂出 x 个连通块，就要拆掉 x*n-(x+1)*x/2 条边 然后用二分找到 x 注意 r 的初始值不大于 n 据说解一元二次方程也可以，我随便写了个，失败了 用python可以防溢出，但是我出现了2.9999999！=3的情况 用c++就要用__int128防止爆long long 不过__int128不能用标准输入输出 一种解决方法是自己写输入输出 但是这题只需要在特定的地方转成__int128就行 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing Int = __int128;\rusing ll = long long;\rll t,n,m;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em;\rll l=0,r=n;\rll mid;\rfor(int i=0;i\u003c10000;i++){\rmid=(l+r)/2;\rif(((Int)mid*n-(1+mid)*(Int)mid/2)\u003c=(Int)m)\rl=mid;\relse\rr=mid;\r}\rcout\u003c\u003cr\u003c\u003cendl;\r}\rreturn 0;\r}\r D 病毒传染 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:3","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 不会 E A+B问题 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:4","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 总共能表示的数有2^32个，每一个数都能找到另一个数与之相加等于答案 ac代码 用PHP写的（求比这更短的代码）（再一次证明了PHP是世界上最好的语言） 4294967296\r F 美丽的序列I 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:5","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 不会 G 树上求和 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:6","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 图论 DFS 求出每条边对于所有的简单路径经过了几次 然后按次数从大到小排序，依次赋值1,2,3… 求遍历次数就是求这条边的左右各有几个点，然后相乘 对于每个点再递归求它的子节点 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n;\rvector\u003cll\u003e p[100005];\rll ch[100005];\rbool visit[100005];\rusing pll=pair\u003cll,ll\u003e;\rvector\u003cpll\u003e vt;\rvector\u003cll\u003e w;\rmap\u003cpll,ll\u003e mp;\rbool cmp(ll a,ll b){return a\u003eb;}\rll dfs(ll k){\rvisit[k]=true;\rll ans=1;\rfor(auto it:p[k]){\rif(!visit[it]){\rans+=dfs(it);\r}\r}\rw.push_back(ans*(n-ans));\rreturn ans;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rll t1,t2;\rfor(ll i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\rp[t1].push_back(t2); ch[t1]++;\rp[t2].push_back(t1); ch[t2]++;\r}\rfor(ll i=1;i\u003c=n;i++) ch[i]--;\rdfs(1);\rsort(w.begin(),w.end(),cmp);\rll i=1;\rll ans2=0;\rfor(auto it:w){\rans2+=it*i++;\r//cout\u003c\u003cit\u003c\u003cendl;\r }\rcout\u003c\u003cans2\u003c\u003cendl;\rreturn 0;\r}\r 用另外一种传入父节点的方法就超时，记忆化搜索也超时 这是TLE/RE代码，不知道为什么错了（对80%），等有空或实力更强一点再看 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n;\rvector\u003cll\u003e p[100005];\rll ch[100005];\rusing pll=pair\u003cll,ll\u003e;\rvector\u003cpll\u003e vt;\rvector\u003cll\u003e w;\rmap\u003cpll,ll\u003e mp;\rbool cmp(ll a,ll b){return a\u003eb;}\rll dfs(ll k,ll par){\rif(mp[make_pair(k,par)]!=0) return mp[make_pair(k,par)];\rif(ch[k]==0) {mp[make_pair(k,par)]=0;return 0;} ll ans=0;\rans+=ch[k];\rfor(auto it:p[k]){\rif(it!=par){\rans+=dfs(it,k);\r}\r}\rmp[make_pair(k,par)]=ans;\rreturn ans;\r}\rll cal(ll x,ll y){\rll resx=dfs(x,y);\rll resy=dfs(y,x);\rreturn resx+resy+resx*resy+1;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rll t1,t2;\rfor(int i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\rp[t1].push_back(t2); ch[t1]++;\rp[t2].push_back(t1); ch[t2]++;\rvt.emplace_back(t1,t2);\r}\rfor(int i=1;i\u003c=n;i++) ch[i]--;\rfor(int i=0;i\u003cn-1;i++){\rw.push_back(cal(vt[i].first,vt[i].second));\r}\rsort(w.begin(),w.end(),cmp);\rll i=1;\rll ans2=0;\rfor(auto it:w){\rans2+=it*i++;\r}\rcout\u003c\u003cans2\u003c\u003cendl;\rreturn 0;\r}\r H 奇怪的背包问题增加了 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:7","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二进制 由二进制01串的性质可以发现 如果物品总重量没有2^30就输出impossible 否则从大到小排序，依次增加就可以 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll =long long;\rll t;\rll n;\rll num[100005];\rusing pll=pair\u003cll,ll\u003e;\rint check[100005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rvector\u003cpll\u003e vt; //因为这个wa了好久\r cin\u003e\u003en;\rll ans=0;\rll temp;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003etemp;\rnum[i]=(1\u003c\u003ctemp);\rvt.emplace_back(num[i],i);\rans+=num[i];\r}\rif(ans\u003c(1\u003c\u003c30)) puts(\"impossible\");\relse{\rsort(vt.begin(),vt.end(),greater\u003cpll\u003e());\rll ans=0;\rll i=0;\rll rr=(1\u003c\u003c30);\rfor(ll i=0;i\u003cn;i++) check[i]=0;\rwhile(ans!=rr){\rans+=vt[i].first;\rcheck[vt[i].second]=1;\ri++;\r}\r//for(ll i=0;i\u003cn;i++) cout\u003c\u003cvt[i].first\u003c\u003c\" \";\r for(ll i=0;i\u003cn;i++) cout\u003c\u003ccheck[i];\rcout\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r 有个wa点，就是没有清空容器 T_T I 寻找字串 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:8","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 枚举后缀，比较即可 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cstring\u003e vt;\rstring s;\rbool cmp(string s1,string s2){\rreturn s1\u003es2;\r}\rint main(){\rcin\u003e\u003es;\rint len=s.length();\rfor(int i=0;i\u003clen;i++){\rvt.push_back(s.substr(i,len-i));\r}\rsort(vt.begin(),vt.end(),cmp);\rcout\u003c\u003cvt[0]\u003c\u003cendl;\rreturn 0;\r}\r J 最大的差 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:9","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 最大值减最小值 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n;\rint mi=100005;\rint ma=-1;\rcin\u003e\u003en;\rint t;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003et;\rmi=min(t,mi);\rma=max(t,ma);\r}\rcout\u003c\u003cma-mi\u003c\u003cendl;\rreturn 0;\r}\r 本次比赛官方说难度对标cf div2 a~c，可是根据大家的做题情况除签到题至少应该d吧 不知道为什么有好多题都迷之超时 总体来说，题目还行 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:10","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["android"],"content":"Android 事件处理机制","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"事件处理 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:0:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"基于监听的事件处理机制 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"匿名内部类 mbt1.setOnTouchListener(new View.OnTouchListener() {\r@Override\rpublic boolean onTouch(View v, MotionEvent event) {\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\"listener\",\"touch\");\rbreak;\r}\rreturn false;\r}\r});\r ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:1","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"事件源所在类（activity类） public class eventActivity extends AppCompatActivity implements View.OnClickListener\r ebt1 = findViewById(R.id.ebt1);\rebt1.setOnClickListener(eventActivity.this);\r @Override\rpublic void onClick(View v) {\rswitch (v.getId()){\rcase R.id.ebt1:\rToast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show();\rbreak;\r}\r}\r ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:2","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"在布局文件中设置 \u003cButton\randroid:id=\"@+id/ebt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"click\"\randroid:textSize=\"20sp\"\rapp:layout_constraintTop_toTopOf=\"parent\"\randroid:layout_marginTop=\"50dp\"\randroid:onClick=\"show\"\r/\u003e\r public void show(View view){ //一定是public void\r switch (view.getId()){\rcase R.id.ebt1:\rToast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show();\rbreak;\r}\r}\r ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:3","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"基于回调的事件处理机制 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".eventActivity\"\u003e\r\u003cButton\randroid:id=\"@+id/ebt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"click\"\randroid:textSize=\"20sp\"\rapp:layout_constraintTop_toTopOf=\"parent\"\randroid:layout_marginTop=\"50dp\"\r/\u003e\r\u003ccom.example.test.Mybotton\randroid:id=\"@+id/mbt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"20sp\"\randroid:text=\"Mybotton\"\randroid:textAllCaps=\"false\"\rapp:layout_constraintTop_toBottomOf=\"@+id/ebt1\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r Mybotton类 package com.example.test;\rimport android.content.Context;\rimport android.util.AttributeSet;\rimport android.util.Log;\rimport android.view.MotionEvent;\rimport android.widget.Button;\rimport androidx.appcompat.widget.AppCompatButton;\rpublic class Mybotton extends AppCompatButton {\rpublic Mybotton(Context context) {\rsuper(context);\r}\rpublic Mybotton(Context context, AttributeSet attrs) {\rsuper(context, attrs);\r}\rpublic Mybotton(Context context, AttributeSet attrs, int defStyleAttr) {\rsuper(context, attrs, defStyleAttr);\r}\r@Override\rpublic boolean onTouchEvent(MotionEvent event) {\rsuper.onTouchEvent(event);\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\"Mybotton\",\"touch\");\rbreak;\r}\rreturn false; //return true即onTouchEvent到此终止\r }\r}\r eventactivity.java package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.MotionEvent;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.Toast;\rpublic class eventActivity extends AppCompatActivity {\rprivate Button ebt1;\rprivate Mybotton mbt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_event);\rmbt1 = findViewById(R.id.mbt1);\rmbt1.setOnTouchListener(new View.OnTouchListener() {\r@Override\rpublic boolean onTouch(View v, MotionEvent event) {\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\"listener\",\"touch\");\rbreak;\r}\rreturn false;\r}\r});\r// ebt1 = findViewById(R.id.ebt1);\r// ebt1.setOnClickListener(eventActivity.this);\r\r}\r// @Override\r// public void onClick(View v) {\r// switch (v.getId()){\r// case R.id.ebt1:\r// Toast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show();\r// break;\r// }\r// }\r\r// public void show(View view){ //一定是public void\r// switch (view.getId()){\r// case R.id.ebt1:\r// Toast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show();\r// break;\r// }\r// }\r\r@Override\rpublic boolean onTouchEvent(MotionEvent event) {\rsuper.onTouchEvent(event);\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\"activity\",\"touch\");\rbreak;\r}\rreturn false;\r}\r}\r 触摸Mybotton触发事件 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:2:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"Android 四大组件之Activity","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"Activity ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:0:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity的生命周期 运行以下代码可以看到activity经历的生命周期 package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.util.Log;\rpublic class lifeCircleActivity extends AppCompatActivity {\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_life_circle);\rLog.d(\"lifecircle\",\"-----onCreate----\");\r}\r@Override\rprotected void onStart() {\rsuper.onStart();\rLog.d(\"lifecircle\",\"-----onStart----\");\r}\r@Override\rprotected void onResume() {\rsuper.onResume();\rLog.d(\"lifecircle\",\"-----onResume----\");\r}\r@Override\rprotected void onPause() {\rsuper.onPause();\rLog.d(\"lifecircle\",\"-----onPause----\");\r}\r@Override\rprotected void onStop() {\rsuper.onStop();\rLog.d(\"lifecircle\",\"-----onStop----\");\r}\r@Override\rprotected void onRestart() {\rsuper.onRestart();\rLog.d(\"lifecircle\",\"-----onRestart----\");\r}\r@Override\rprotected void onDestroy() {\rsuper.onDestroy();\rLog.d(\"lifecircle\",\"-----onDestroy----\");\r}\r}\r 启动这个activity之后 按返回键退出activity 再启动activity,并按主页键或者菜单键 在cache中重新进入activity ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:1:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity之间的跳转 方法有很多 以下是设置点击事件来跳转 private Button bt11;\rbt11 = findViewById(R.id.bt11);\rbt11.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(MainActivity.this , broadActivity.class);\rstartActivity(intent);\r}\r});\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:2:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"隐式intent 目标activity在manifest文件中应这样注册 \u003cactivity android:name=\".implicitIntentActivity\"\u003e\r\u003cintent-filter\u003e\r\u003caction android:name=\"com.example.test.124\"/\u003e\r\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\r\u003c/intent-filter\u003e\r\u003c/activity\u003e\r 点击事件的设置 bt14 = findViewById(R.id.bt14);\rbt14.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent();\rintent.setAction(\"com.example.test.124\");\rstartActivity(intent);\r}\r});\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:3:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity之间的数据传输 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:4:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"将activity的数据传输到目标activity 发送数据 @Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump);\rjumpbt1 = findViewById(R.id.jumpbt1);\rjumpbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(jumpActivity.this , jump2Activity.class);\rBundle bundle = new Bundle();\rbundle.putString(\"name\",\"henry\");\rbundle.putInt(\"number\",11);\rintent.putExtras(bundle);\rstartActivity(intent);\r//startActivityForResult(intent,0); //写在点击事件里\r\r}\r});\r}\r 接收数据并呈现 @Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump2);\rjump2tv1 = findViewById(R.id.jump2tv1);\rBundle bundle = new Bundle();\rbundle = getIntent().getExtras();\rString name = bundle.getString(\"name\");\rint number = bundle.getInt(\"number\");\rjump2tv1.setText(name+\",\"+number);}\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:4:1","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"启动一个activity,结束后返回结果 jump界面 jump2界面 点击back返回结果（一个toast） jumpactivity package com.example.test;\rimport androidx.annotation.Nullable;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.Toast;\rpublic class jumpActivity extends AppCompatActivity {\rprivate Button jumpbt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump);\rjumpbt1 = findViewById(R.id.jumpbt1);\rjumpbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(jumpActivity.this , jump2Activity.class);\rBundle bundle = new Bundle();\rbundle.putString(\"name\",\"henry\");\rbundle.putInt(\"number\",11);\rintent.putExtras(bundle);\r//startActivity(intent);\r startActivityForResult(intent,0); //写在点击事件里\r\r}\r});\r}\r@Override\rprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\rsuper.onActivityResult(requestCode, resultCode, data);\rToast.makeText(jumpActivity.this,data.getExtras().getString(\"msg\"),Toast.LENGTH_LONG).show() ;\r}\r}\r jump2activity package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.app.Activity;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rpublic class jump2Activity extends AppCompatActivity {\rprivate TextView jump2tv1;\rprivate Button jump2bt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump2);\rjump2tv1 = findViewById(R.id.jump2tv1);\rBundle bundle = new Bundle();\rbundle = getIntent().getExtras();\rString name = bundle.getString(\"name\");\rint number = bundle.getInt(\"number\");\rjump2tv1.setText(name+\",\"+number);\rjump2bt1 = findViewById(R.id.jump2bt1);\rjump2bt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent();\rBundle bundle1 = new Bundle();\rbundle1.putString(\"msg\",\"i'm back\");\rintent.putExtras(bundle1);\rsetResult(Activity.RESULT_OK,intent);\rfinish();\r}\r});\r}\r}\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:5:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"Android 四大组件之Broadcast Receiver","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"Broadcast Receiver ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:0:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"通过LoaclBroadcastManager发送广播并接收广播 点击broadactivity的click,跳转到broad2activity 点击broad2activity的clickme,发送广播 broadactivity接收广播，将abc改成123 broadactivity broad2activity 点击clickme后返回到broadactivity 代码 broadactivity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".broad.broadActivity\"\u003e\r\u003cButton\randroid:id=\"@+id/bcbt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\rapp:layout_constraintTop_toTopOf=\"parent\"\randroid:layout_marginTop=\"40dp\"\randroid:textSize=\"30sp\"\randroid:text=\"click\"/\u003e\r\u003cTextView\randroid:id=\"@+id/bctv1\"\randroid:layout_width=\"wrap_content\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"abc\"\randroid:textSize=\"60sp\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintTop_toBottomOf=\"@+id/bcbt1\"\rapp:layout_constraintLeft_toLeftOf=\"parent\"\rapp:layout_constraintRight_toRightOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.3\"\r/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r broadactivity_java package com.example.test.broad;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\rimport android.content.BroadcastReceiver;\rimport android.content.Context;\rimport android.content.Intent;\rimport android.content.IntentFilter;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class broadActivity extends AppCompatActivity {\rprivate Button bcbt1;\rprivate TextView bctv1;\rprivate Mybroad mybroad;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_broad);\rbcbt1 = findViewById(R.id.bcbt1);\rbctv1 = findViewById(R.id.bctv1);\rbcbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(broadActivity.this , broad2Activity.class);\rstartActivity(intent);\r}\r});\rmybroad = new Mybroad();\rIntentFilter intentFilter = new IntentFilter();\rintentFilter.addAction(\"sss\");\rLocalBroadcastManager.getInstance(broadActivity.this).registerReceiver(mybroad,intentFilter);\r}\rprivate class Mybroad extends BroadcastReceiver{\r@Override\rpublic void onReceive(Context context, Intent intent) {\r//接收到广播要处理的事\r switch(intent.getAction()){\rcase \"sss\":\rbctv1.setText(\"123\");\rbreak;\r}\r}\r}\r@Override\rprotected void onDestroy() {\rsuper.onDestroy();\rLocalBroadcastManager.getInstance(broadActivity.this).unregisterReceiver(mybroad);\r}\r}\r broad2activity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".broad.broad2Activity\"\u003e\r\u003cButton\randroid:id=\"@+id/bc2bt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\rapp:layout_constraintTop_toTopOf=\"parent\"\randroid:layout_marginTop=\"30dp\"\randroid:textSize=\"30sp\"\randroid:text=\"click me\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r broad2activity_java package com.example.test.broad;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class broad2Activity extends AppCompatActivity {\rprivate Button bc2bt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_broad2);\rbc2bt1 = findViewById(R.id.bc2bt1);\rbc2bt1.setOnC","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:1:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"一些系统操作对应的action ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:2:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"Android 四大组件之Content Provider","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"Content Provider ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:0:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"获取外部应用的信息 以获取通讯录为例 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".contentProviderActivity\"\u003e\r\u003cButton\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/cpbtn1\"\randroid:textSize=\"25sp\"\randroid:text=\"get_contacts\"/\u003e\r\u003cButton\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/cpbtn2\"\randroid:text=\"getdata\"\randroid:textSize=\"25dp\"\rapp:layout_constraintTop_toBottomOf=\"@+id/cpbtn1\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r 点击get_contacts获取联系人信息 手机里存储的联系人信息 在manifest里获取权限 \u003cuses-permission android:name=\"android.permission.READ_CONTACTS\" /\u003e\r 利用content resolver获取 package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ContentResolver;\rimport android.database.Cursor;\rimport android.net.Uri;\rimport android.os.Bundle;\rimport android.provider.ContactsContract;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport java.util.HashSet;\rimport java.util.List;\rpublic class contentProviderActivity extends AppCompatActivity {\rprivate Button cpbtn1,cpbtn2;\r//private List\u003cString\u003e contactlist=null;\r\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_content_provider);\rcpbtn1 = findViewById(R.id.cpbtn1);\rcpbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rContentResolver contentResolver = getContentResolver();\rCursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);\rwhile(cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\rString number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\rLog.d(\"tag\",name+\" \"+number);\r//contactlist.add(name+\" \"+number);\r }\rcursor.close();\r//System.out.println(contactlist.toString());\r }\r});\r// \r}\r}\r 获取到的信息 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:1:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"获取系统权限指令大全 点击此处 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:1:1","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"提供自己的应用信息 在sqlite数据库中创建表 package com.example.test;\rimport android.content.Context;\rimport android.database.sqlite.SQLiteDatabase;\rimport android.database.sqlite.SQLiteOpenHelper;\rimport androidx.annotation.Nullable;\rpublic class Myopenhelper extends SQLiteOpenHelper {\rprivate static final String CREATE_TABLE_PERSON = \"create table person (id integer primary key autoincrement,name text,age integer)\";\rpublic Myopenhelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) {\rsuper(context, name, factory, version);\r}\r@Override\rpublic void onCreate(SQLiteDatabase db) {\rdb.execSQL(CREATE_TABLE_PERSON);\r}\r@Override\rpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\r}\r}\r 插入数据，提供content provider package com.example.test;\rimport android.content.ContentProvider;\rimport android.content.ContentValues;\rimport android.content.UriMatcher;\rimport android.database.Cursor;\rimport android.database.sqlite.SQLiteDatabase;\rimport android.database.sqlite.SQLiteOpenHelper;\rimport android.net.Uri;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rpublic class Myprovider extends ContentProvider {\rprivate static final String PACKAGE_NAME = \"com.example.test\";\rprivate static UriMatcher uriMatcher;\rprivate Myopenhelper myopenhelper;\rprivate SQLiteDatabase sqLiteDatabase;\rstatic {\ruriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\ruriMatcher.addURI(PACKAGE_NAME,\"person\",0);\r}\r@Override\rpublic boolean onCreate() {\rmyopenhelper = new Myopenhelper(getContext(),\"database\",null,1);\rsqLiteDatabase = myopenhelper.getWritableDatabase();\rContentValues contentValues = new ContentValues();\rcontentValues.put(\"name\",\"jingjing\");\rcontentValues.put(\"age\",15);\rsqLiteDatabase.insert(\"person\",null,contentValues);\rcontentValues.put(\"name\",\"kakulukia\");\rcontentValues.put(\"age\",15);\rsqLiteDatabase.insert(\"person\",null,contentValues);\rreturn true;\r}\r@Nullable\r@Override\rpublic Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {\rint code = uriMatcher.match(uri);\rswitch (code){\rcase 0:\rCursor cursor = sqLiteDatabase.query(\"person\",null,null,null,null,null,null);\rreturn cursor;\r}\rreturn null;\r}\r@Nullable\r@Override\rpublic String getType(@NonNull Uri uri) {\rreturn null;\r}\r@Nullable\r@Override\rpublic Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {\rreturn null;\r}\r@Override\rpublic int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {\rreturn 0;\r}\r@Override\rpublic int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {\rreturn 0;\r}\r}\r 在manifest注册 \u003cprovider\randroid:name=\".Myprovider\"\randroid:authorities=\"com.example.test\"\randroid:exported=\"true\" /\u003e\r 到此已经提供了自己的应用信息 现在通过点击“get_data”来查询（利用content resolver） package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ContentResolver;\rimport android.database.Cursor;\rimport android.net.Uri;\rimport android.os.Bundle;\rimport android.provider.ContactsContract;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport java.util.HashSet;\rimport java.util.List;\rpublic class contentProviderActivity extends AppCompatActivity {\rprivate Button cpbtn1,cpbtn2;\r//private List\u003cString\u003e contactlist=null;\r\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_content_provider);\rcpbtn1 = findViewById(R.id.cpbtn1);\rcpbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rContentResolver contentResolver = getContentResolver();\rCursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);\rwhile(cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAM","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:2:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"Android 四大组件之Service","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"Service ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:0:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"Service的生命周期 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:1:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"通过启动Service传递数据 在serviceactivity的输入框中输入数据，启动Myservice并传递数据，打印到日志 serviceactivity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".serviceActivity\"\u003e\r\u003cButton\randroid:id=\"@+id/sbtn1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"startservice\"\randroid:textSize=\"25sp\"/\u003e\r\u003cButton\randroid:id=\"@+id/sbtn2\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25dp\"\randroid:text=\"stopservice\"\rapp:layout_constraintTop_toBottomOf=\"@+id/sbtn1\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003cButton\randroid:id=\"@+id/sbtn3\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25dp\"\randroid:text=\"bindservice\"\rapp:layout_constraintTop_toBottomOf=\"@+id/sbtn2\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003cButton\randroid:id=\"@+id/sbtn4\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25dp\"\randroid:text=\"unbindservice\"\rapp:layout_constraintTop_toBottomOf=\"@+id/sbtn3\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003cEditText\randroid:id=\"@+id/set1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\rapp:layout_constraintTop_toBottomOf=\"@+id/sbtn4\"\randroid:textSize=\"20sp\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003cButton\randroid:id=\"@+id/sbtn5\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25dp\"\randroid:text=\"syncdata\"\rapp:layout_constraintTop_toBottomOf=\"@+id/set1\"\randroid:layout_marginTop=\"30dp\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r serviceactivity.java sbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rintent.putExtra(\"data\",set1.getText().toString());\rstartService(intent);\r}\r});\r Myservice.java private String data=\"cat\";\rprivate boolean running=false;\r @Override\rpublic int onStartCommand(Intent intent, int flags, int startId) {\rdata = intent.getStringExtra(\"data\");\r//Log.d(\"tag\",data);\r return super.onStartCommand(intent, flags, startId);\r}\r @Override\rpublic void onCreate() {\rsuper.onCreate();\r//Log.d(\"tag\",data);\r running=true;\rnew Thread(){\r@Override\rpublic void run() {\rsuper.run();\rwhile (running){\rSystem.out.println(data);\rtry {\rsleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}.start();\r}\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:2:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"通过绑定来同步数据 点击bindservice 输入数据，点击syncdata service.java package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ComponentName;\rimport android.content.Context;\rimport android.content.Intent;\rimport android.content.ServiceConnection;\rimport android.os.Bundle;\rimport android.os.IBinder;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rpublic class serviceActivity extends AppCompatActivity implements ServiceConnection {\rprivate Button sbtn1,sbtn2,sbtn3,sbtn4;\rprivate EditText set1;\rprivate Button sbtn5;\rprivate MyService.mybinder binder;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_service);\rsbtn1 = findViewById(R.id.sbtn1);\rsbtn2 = findViewById(R.id.sbtn2);\rsbtn3 = findViewById(R.id.sbtn3);\rsbtn4 = findViewById(R.id.sbtn4);\rset1 = findViewById(R.id.set1);\rsbtn5 = findViewById(R.id.sbtn5);\rsbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rintent.putExtra(\"data\",set1.getText().toString());\rstartService(intent);\r}\r});\rsbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rstopService(intent);\r}\r});\rsbtn3.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rbindService(intent,serviceActivity.this, Context.BIND_AUTO_CREATE);\r}\r});\rsbtn4.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\r//Intent intent = new Intent(serviceActivity.this,MyService.class);\r unbindService(serviceActivity.this);\r}\r});\rsbtn5.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(binder!=null){\rbinder.setdata(set1.getText().toString());\r//System.out.println(MyService.data);\r }\r}\r});\r}\r@Override\rpublic void onServiceConnected(ComponentName name, IBinder service) {\rLog.d(\"service123\",\"connected123\");\rbinder = (MyService.mybinder) service;\r}\r@Override\rpublic void onServiceDisconnected(ComponentName name) {\r}\r}\r Myservive.java package com.example.test;\rimport android.app.Service;\rimport android.content.Intent;\rimport android.os.Binder;\rimport android.os.IBinder;\rimport android.util.Log;\rpublic class MyService extends Service {\rprivate String data=\"cat\";\rprivate boolean running=false;\rpublic MyService() {\r}\r@Override\rpublic IBinder onBind(Intent intent) {\r// TODO: Return the communication channel to the service.\r //throw new UnsupportedOperationException(\"Not yet implemented\");\r //return new Binder();\r return new mybinder();\r}\rpublic class mybinder extends Binder{ //是binder不是 ibinder\r public void setdata(String data){\rMyService.this.data = data;\r}\r}\r@Override\rpublic int onStartCommand(Intent intent, int flags, int startId) {\r//data = intent.getStringExtra(\"data\");\r\r//Log.d(\"tag\",data);\r return super.onStartCommand(intent, flags, startId);\r}\r@Override\rpublic boolean onUnbind(Intent intent) {\rreturn super.onUnbind(intent);\r}\r@Override\rpublic void onCreate() {\rsuper.onCreate();\r//Log.d(\"tag\",data);\r running=true;\rnew Thread(){\r@Override\rpublic void run() {\rsuper.run();\rwhile (running){\rSystem.out.println(data);\rtry {\rsleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}.start();\r}\r@Override\rpublic void onDestroy() {\rsuper.onDestroy();\rLog.d(\"tag\",\"dog\");\rrunning=false;\r}\r}\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:3:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"在manifest里的注册 \u003cactivity\randroid:name=\".serviceActivity\"\randroid:exported=\"true\" /\u003e\r\u003cservice\randroid:name=\".MyService\"\randroid:enabled=\"true\"\randroid:exported=\"true\" /\u003e\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:4:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["algorithm","hduoj"],"content":"hduoj1711(kmp)","date":"2020-03-17","objectID":"/hduoj1711kmp/","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Number Sequence ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:0","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Problem Description Given two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 \u003c= M \u003c= 10000, 1 \u003c= N \u003c= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:1","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Input The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 \u003c= M \u003c= 10000, 1 \u003c= N \u003c= 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000]. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:2","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Output For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:3","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Sample Input 2 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 1 3 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 2 1 ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:4","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Sample Output 6 -1 ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:5","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Solution 测一下kmp板子 ac代码 #include\u003ciostream\u003e\rusing namespace std;\rint n,m,t;\rint s[1000005];\rint p[10005];\rint nextt[10005];\rvoid get_next(){\rint i=0,j=-1;\rnextt[0]=-1;\rwhile(i\u003cm){\rif(j==-1 || p[i]==p[j]) nextt[++i]=++j;\relse j=nextt[j]; //!!!\r }\r}\rint kmp(){\rint i=0,j=0;\rwhile(1){\rif(s[i]==p[j]) i++,j++;\relse{\rint t=nextt[j];\rif(t==-1) i++,j=0;\relse j=t;\r}\rif(j\u003e=m) return i-m+1; //根据题目要求返回 if(i\u003e=n) return -1;\r}\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(0);cin.tie(0);\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003es[i];\rfor(int i=0;i\u003cm;i++) cin\u003e\u003ep[i];\rget_next();\rcout\u003c\u003ckmp()\u003c\u003cendl;\r}\rreturn 0;\r}\r ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:6","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["codeforces"],"content":"Codeforces Round #628 (Div. 2) A~D","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. EhAb AnD gCd ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:0","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一正整数x，求正整数a,b满足gcd(a,b)+lcm(a,b)=x ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:1","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 数论思维题，a=1，b=x-1满足条件 ac代码 #include\u003ciostream\u003e\rusing namespace std;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--) {\rint k;\rcin\u003e\u003ek;\rcout\u003c\u003c1\u003c\u003c\" \"\u003c\u003ck-1\u003c\u003cendl;\r}\rreturn 0;\r}\r B. CopyCopyCopyCopyCopy ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:2","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数列，将数列无限复制，求最长严格单调子序列的个数 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:3","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 计算数列有多少种数字就行 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll =long long;\rll t;\rll n;\rset\u003cll\u003e st;\rll tmp;\rinline ll read(){\rll x=0;ll f=1;char s=getchar();\rwhile(s\u003c'0' or s\u003e'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u003e='0' and s\u003c='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et;\rwhile(t--){\rst.clear();\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rtmp=read();\rst.insert(tmp);\r} cout\u003c\u003cst.size()\u003c\u003cendl; } return 0;\r}\r C. Ehab and Path-etic MEXs ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:4","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一棵n个节点的树，求边权重的赋值方案（权重为0~n-2互异） 使得max(mex(u,v))最小 其中mex(u,v)为连接顶点u,v的简单路径中“不”包含边权重的最小值 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:5","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 当树为一条链时，随便赋值 否则，树必然有一个顶点的度数为3 所有简单路径中必然经过0和1的边 要让最大值最小，就要让所有简单路径不同时存在0，1，2的边（这样max(mex)=2） 只需要把0，1，2分散在三度顶点的三条边上 其他随便赋值 以第2个样例为例 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rint deg[100005];\rusing pii=pair\u003cint,int\u003e;\rvector\u003cpii\u003e vt;\rbool lis;\r//bool lef;\rint p;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(0);cin.tie(0);\rlis=true;\rcin\u003e\u003en;\rfor(int i=0,t1,t2;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\r//if(t1\u003et2) swap(t1,t2);\r deg[t1]++;\rdeg[t2]++;\rvt.emplace_back(t1,t2);\r}\rfor(int i=1;i\u003c=n;i++) {\rif(deg[i]\u003e2){\rlis=false;\rp=i;\rbreak;\r}\r}\rif(lis){\rfor(int i=0;i\u003cn-1;i++) cout\u003c\u003ci\u003c\u003cendl;\r}\relse{\rint a=0,b=3;\rfor(int i=0;i\u003cn-1;i++){\rif((vt[i].first==p or vt[i].second==p ) and (a\u003c3)){\rcout\u003c\u003ca++\u003c\u003cendl;\r}\relse cout\u003c\u003cb++\u003c\u003cendl;\r} }\rreturn 0;\r}\r D. Ehab the Xorcist ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:6","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 Given 2 integers u and v, find the shortest array such that bitwise-xor of its elements is u, and the sum of its elements is v. ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:7","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 如果是3个数，则这3个数可以是u , (v-u)/2 , (v-u)/2 (利用异或性质) 如果是2个数，p，q 则考虑p+q和p^q的关系 利用以下性质可求得p,q 注意题目说的正整数和样例，进行特判 ac代码 #include\u003cbits/stdc++.h\u003e\rusing ll = long long;\rusing namespace std;\rll u,v;\rint main(){\rcin\u003e\u003eu\u003e\u003ev;\rif((v-u)\u00261 || v-u\u003c0) puts(\"-1\");\relse if(v==0 \u0026\u0026 u==0) puts(\"0\");\relse if(v==u) cout\u003c\u003c1\u003c\u003cendl\u003c\u003cu;\relse{\rll p=(v-u)/2;\rll q=u^p;\rif(p+q==v) cout\u003c\u003c2\u003c\u003cendl\u003c\u003cp\u003c\u003c\" \"\u003c\u003cq\u003c\u003cendl;\relse cout\u003c\u003c3\u003c\u003cendl\u003c\u003cu\u003c\u003c\" \"\u003c\u003cp\u003c\u003c\" \"\u003c\u003cp\u003c\u003cendl;\r} return 0;\r}\r E. Ehab’s REAL Number Theory Problem ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:8","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:9","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 不会 F. Ehab’s Last Theorem ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:10","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:11","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:12","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["note","courses"],"content":"二进制编码","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"二进制转十进制 除2取余 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:0","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"十进制转二进制 乘2次幂 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:1","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"小数进制转换 e.g. 3.59375 整数部分3的二进制位11 小数部分0.59375 0.59375*2=1.1875 ———————— 1 0.1875*2=0.375 —————————0 0.375*2=0.75 ——————————0 0.75*2=1.5 ——————————–1 0.5*2=1 ———————————–1 二进制位0.10011 所以3.59375的二进制表示为11.10011 有些小数不能测出现循环 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:2","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"IEEE754标准的浮点数与十进制数的转换 32位和64位标准 通过全1和全0来划定它的表示范围 E.G. ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:3","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"原码 即正常的二进制码（带符号位） ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:4","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码 正数（包括+0）的补码和原码一样 负数（包括-0）的补码在原码的基础上“按位取反，末尾加1” 补码转原码的一种方法 还可以用逆过程法，即减1取反 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:5","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"反码 正数（包括+0）的补码和原码一样 负数（包括-0）的补码在原码的基础上“按位取反” ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:6","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码的加法运算 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:7","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码的减法运算 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:8","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["codeforces"],"content":"Codeforces Round #627 (Div. 3)","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"A. Yet Another Tetris Problem link B. Yet Another Palindrome Problem link C. Frog Jumps link D. Pair of Topics link E. Sleeping Schedule link ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:0","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题意 假设一天有h个小时，DIO一共要睡n次，每次睡ai个小时（按顺序睡觉），每次刚睡醒，就要继续睡觉，一直睡下去，直至睡眠次数耗光。 给定一个一天中的区间[l,r]，如果有一次睡醒时刻在区间内，则这次睡眠为“好睡眠” 对于每次睡眠时间ai,可以选择睡ai小时或ai-1小时 问一开始就进行睡眠的情况下，“好睡眠”的次数最多有几次 ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:1","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题解 动态规划 dp[i][j] i表示已经进行了i次睡眠 j表示现在在时刻j dp表示最大“好睡眠”次数 初始化 ：dp[i][j]=-inf , dp[0][0]=0 分别讨论下面两种情况 to=(j+a[i])%h to=(j+a[i]-1)%h 状态转移方程 ：dp[i+1][to] = max(dp[i+1][to] , dp[i][j] + flag) flag当to在区间内为1，否则为0 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,h,l,r;\rint dp[2005][2005];\rint data[2005];\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(0);cin.tie(0);\rcin\u003e\u003en\u003e\u003eh\u003e\u003el\u003e\u003er;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003edata[i];\r//preprocess\r memset(dp,0xc0,sizeof(dp)); //0xc0c0c0c0 0x3f3f3f3f\r dp[0][0]=0;\rfor(int i=0;i\u003cn;i++)\rfor(int j=0;j\u003ch;j++) // \u003c即可\r {\rint to=(j+data[i])%h;\rdp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u003c=to and to\u003c=r));\rto =(j+data[i]-1)%h;\rdp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u003c=to and to\u003c=r));\r}\rint ans=-1; for(int i=0;i\u003ch;i++)\rans=max(ans,dp[n][i]);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r 小技巧 inf = 0x3f3f3f3f memset可以用0x3f ninf=0xc0c0c0c0 memset可以用0xc0 F. Maximum White Subtree link ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:2","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题意 给一棵树（比赛当天是植树节！！） 节点有黑的，白的 对于这棵树的某一子图 定义这个子图所有节点的dif=白色节点数-黑色节点数 求每一个节点的最大dif值 ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:3","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题解 深度优先搜索+动态规划 首先考虑以每个节点为父节点的子图的最大dif 然后每个节点的的最大dif=作为父节点的最大dif+作为子节点的最大dif 如何求以每个节点为父节点的子图的最大dif？ 遍历子节点 判断每个子节点以下（作为父节点）是否白色比黑色多，多则累加对应的数值，否则不累加 这样就形成和了dfs 如何求最终的dif？ 作为子节点的部分的dif，可以用该节点的父节点的dif（最终）- 作为父节点的dif 需要判断是否有必要增加“额外部分” 要让该节点的父节点的dif为最终值，需要从根开始，一层层遍历子节点 这样又形成了dfs ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rint dif_orig[200005];\rvector\u003cint\u003e adj[200005];\rint dif_par[200005];\rint ans[200005];\rvoid dfs_par(int u,int par)\r{\rdif_par[u]=dif_orig[u];\rfor(auto v:adj[u])\r{\rif(v!=par)\r{\rdfs_par(v,u);\rdif_par[u]+=max(dif_par[v],0); //如果黑色比白色多，则丢弃 }\r}\r}\rvoid dfs_final(int u,int par,int el)\r{\rans[u]=dif_par[u]+el;\rfor(auto v:adj[u])\r{\rif(v!=par)\r{\rdfs_final(v,u,max(0,ans[u]-max(dif_par[v],0))); //里面的max和上面一样，外面的max判断是否有必要增加其他部分（作为子节点的部分） }\r}\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(0);cin.tie(0);\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003edif_orig[i];\rif(!dif_orig[i]) dif_orig[i]=-1; //如果是黑色，则白色-黑色=-1 }\rfor(int i=1,u,v;i\u003cn;i++)\r{\rcin\u003e\u003eu\u003e\u003ev;\ru--,v--;\radj[u].emplace_back(v);\radj[v].emplace_back(u);\r}\rdfs_par(0,-1);\rdfs_final(0,-1,0);\rfor(int i=0;i\u003cn;i++)\rcout\u003c\u003cans[i]\u003c\u003c\" \";\rreturn 0;\r}\r ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:4","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["anime"],"content":"ef - a tale of melodies","date":"2020-03-09","objectID":"/ef-a-tale-of-melodies/","tags":[],"title":"ef - a tale of melodies","uri":"/ef-a-tale-of-melodies/"},{"categories":["anime"],"content":"《ef - a tale of melodies.》由日本动画公司SHAFT制作电视动画，并于2008年10月6日开始播放，是动画《悠久之翼》系列的第二季。故事内容由原作游戏《ef - the latter tale.》的第四章及终章改篇而成，终章的修改幅度比较大，加入了一些原创的情节。共12话。 剧情 圣诞节，雨宫优子与火村夕两人在教会里重逢。两人怀缅过去，由雨宫优子开始说过去发生过的种种事情。 广野纮是个高中生兼少女漫画家，每一天度过忙碌的生活。在圣诞节的夜晚，遇到追逐小偷的宫村宫子。两人再次在学校见面后，宫村宫子对广野纮开始产生兴趣，而开始纠缠在广野纮身边。 身为青梅竹马的新藤景看到这种场景而感到焦虑。几个月后的夏天。喜欢电影制作的堤京介，在体育馆看到新藤景的射篮的动作时，想要拍摄以她为主的电影。因为失恋与郁闷而退出社团的新藤景，受到热爱电影的堤京介的影响，慢慢走出阴霾。–百度百科 ","date":"2020-03-09","objectID":"/ef-a-tale-of-melodies/:0:0","tags":[],"title":"ef - a tale of melodies","uri":"/ef-a-tale-of-melodies/"},{"categories":["abc"],"content":"abc158","date":"2020-03-08","objectID":"/abc158/","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"A - Station and Bus ","date":"2020-03-08","objectID":"/abc158/:0:0","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:1","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给一长度为3的，只含AB的字符串，问是否存在相邻两个字符不同的情况 ","date":"2020-03-08","objectID":"/abc158/:0:2","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 签到题 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main()\r{\rstring s;\rcin\u003e\u003es;\rif((s[0]=='A' and s[1]=='A' and s[2]=='A') or(s[0]=='B' and s[1]=='B' and s[2]=='B'))\rcout\u003c\u003c\"No\"\u003c\u003cendl;\relse cout\u003c\u003c\"Yes\"\u003c\u003cendl;\rreturn 0;\r}\r B - Count Balls ","date":"2020-03-08","objectID":"/abc158/:0:3","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:4","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 有蓝球和红球若干，将他们排成一排，不断通过以下操作排列，在尾部加a个蓝球，在尾部加b个红球，问前n个球有多少个蓝球 ","date":"2020-03-08","objectID":"/abc158/:0:5","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 签到题 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r ll a,b,n;\rcin\u003e\u003en\u003e\u003ea\u003e\u003eb;\rll m=n/(a+b);\rll ans;\rif(n\u003e0) ans=m*a;\relse ans=0;\rn-=m*(a+b);\rif(n\u003ea) ans+=a;\relse ans+=n;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - Tax Increase ","date":"2020-03-08","objectID":"/abc158/:0:6","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:7","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给俩数a,b，问是否存在整数x使得，floor(x0.08)=a \u0026\u0026 floor(x0.1)=b，若存在，输出满足这种条件的最小数，否则输出-1 ","date":"2020-03-08","objectID":"/abc158/:0:8","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 由于数据不大，遍历x，判断是否满足条件 或者求满足条件的两个区间，判断是否有交集 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r int l1,r1,l2,r2;\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rl1=ceil(a/0.08);\rdouble t;\rt=(a+1)/0.08;\rif(t*0.08==a+1)\rr1=t-1;\relse\rr1=floor((a+1)/0.08);\rl2=ceil(b/0.1);\rt=(b+1)/0.1;\rif(t*0.1==b+1)\rr2=t-1;\relse\rr2=floor((b+1)/0.1);\rbool flag=true;\rint ans;\rif(r1\u003cl2 or r2\u003cl1) flag=false;\relse if(l2\u003e=l1 and r2\u003c=r1) ans=l2;\relse if(l1\u003e=l2 and r1\u003c=r2) ans=l1;\relse ans=max(l1,l2);\rif(flag) cout\u003c\u003cans\u003c\u003cendl;\relse cout\u003c\u003c-1\u003c\u003cendl;\r//cout\u003c\u003cl1\u003c\u003c\" \"\u003c\u003cr1\u003c\u003c\" \"\u003c\u003cl2\u003c\u003c\" \"\u003c\u003cr2;\r return 0;\r}\r D - String Formation ","date":"2020-03-08","objectID":"/abc158/:0:9","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:10","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 对于一个字符串，有三种操作，倒置，在头部添加字符，在尾部添加字符，求最后得到的字符串 ","date":"2020-03-08","objectID":"/abc158/:0:11","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 分别存储前缀和后缀，用一个bool来判断顺序，倒置操作给bool取反。 在头部加，如果是顺序的就加在前缀，其他情况同理。 最后通过bool量来控制输出顺序 （直接模拟也可以） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rstring s;\rint q;\rchar c;\rint f;\rint t;\rstring pre,suf;\rbool order;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r order=true;\rcin\u003e\u003es;\rcin\u003e\u003eq;\rwhile(q--)\r{\rcin\u003e\u003et;\rif(t==1) order^=1; //!!\r else\r{\rcin\u003e\u003ef;\rif(f==1) {\rcin\u003e\u003ec;\rif(order) pre+=c;\relse suf+=c;\r}\relse\r{\rcin\u003e\u003ec;\rif(order) suf+=c;\relse pre+=c;\r}\r}\r}\rif(order)\r{\rreverse(pre.begin(),pre.end());\rcout\u003c\u003cpre\u003c\u003cs\u003c\u003csuf\u003c\u003cendl;\r}\relse\r{\rreverse(suf.begin(),suf.end());\rreverse(s.begin(),s.end());\rcout\u003c\u003csuf\u003c\u003cs\u003c\u003cpre\u003c\u003cendl;\r}\rreturn 0;\r}\r 知识点 1.bool的取反不能flag=-flag，可以用flag^=1 2.string 在的插入函数 e.g. s.insert(s.begin(),c) or s.insert(s.end(),c) 3.string的拼接 s=(string)“aaa\"+\"bbb”; （一定要强制类型转换） s='a'+(string)“kkk”; （string要强制类型转换，char是不能转成string） E - Divisible Substring ","date":"2020-03-08","objectID":"/abc158/:0:12","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:13","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给一个仅由数字组成的字符串和质数p，问有几个子串（连续字符组成的）能够被p整除 ","date":"2020-03-08","objectID":"/abc158/:0:14","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 个人感觉出的特别好的一道题 动态规划+后缀 从最后开始向前遍历每个数 ans+=（以当前数为开头，满足条件的个数） 要求以当前数开头，满足条件的个数，就是个区间问题 这个区间问题可以用后缀来求 当两个后缀模p的余数相等时，这个区间内的数能被p整除（2和5除外） 所以问题转化成求此时的后缀（余数），查询之前和这个余数相等的个数 然后ans+=个数 注意特殊处理一下2和5 以下是对上面结论的证明（实际并不需要严格证明） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rint n,p;\rstring s;\rmap\u003cint,int\u003e mp; //存余数和对应的个数 ll ans=0;\rint main()\r{\rios::sync_with_stdio(false); cin.tie(0);\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003ep\u003e\u003es;\rif(p==2 or p==5)\r{\rint pt=p;\rfor(int i=0;i\u003cn;i++)\rif((s[i]-'0')%pt==0) ans+=i+1;\r}\relse\r{\rmp[0]++;\rint num=0;\rint m=1;\rfor(int i=n-1;~i;i--)\r{\rnum=(num+(s[i]-'0')*m)%p;\rans+=mp[num];\rmp[num]++;\rm=(m*10)%p;\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F - Removing Robots ","date":"2020-03-08","objectID":"/abc158/:0:15","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:16","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 数轴上有n个点，每个点有两个属性（坐标和能够向右移动的距离），随意地激活其中几个点，激活的点必须向右移动该距离，若移动过程中碰到点则那个点被激活，求对于所有的激活情况，最后的结果有多少种 ","date":"2020-03-08","objectID":"/abc158/:0:17","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 动态规划+栈优化 从右往左遍历每个点 给每个点设置一个数值，表示遍历到该点的集合数量（即答案） 判断这个点是否可以覆盖右边的点，可以覆盖，则这个点的数值乘上覆盖点的数值 用栈维护每个遍历的点，如果栈顶没有被覆盖，则栈里面都无需遍历 被覆盖的点就出栈 新的点入栈（因为旧的点被新的点覆盖，集合数已经被新的点记录） 最后遍历一遍栈，累乘数值 ac代码 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll n;\rconst ll mod=998244353;\rvector\u003cpair\u003cint,int\u003e\u003e vt; //存输入 stack\u003cpair\u003cint,int\u003e\u003e stk; //将不覆盖的点入栈 ，用栈优化（对于正在检测的点，如果栈顶不满足，则栈里面的都不满足） //存点的坐标（identifier）和扫描到这个点时，它满足的集合数量 int t1,t2;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(false);cin.tie(0);\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\r{\rcin\u003e\u003et1\u003e\u003et2;\rt2+=t1;\rvt.emplace_back(t1,t2);\r}\rsort(vt.rbegin(),vt.rend()); //这种题目几乎都要sort 此处逆序遍历 for(int i=0;i\u003cn;i++)\r{\rll t=1;\r//cout\u003c\u003cstk.empty()\u003c\u003cendl;\r while(!stk.empty() \u0026\u0026 vt[i].second\u003estk.top().first) //遍历栈 注意开区间 {\rt=(t*stk.top().second)%mod;\rstk.pop();\r}\r//cout\u003c\u003ct\u003c\u003cendl;\r stk.push(make_pair(vt[i].first,t+1)); //!!!!! 一定要加1，因为枚举集合数的时候，对于每个点分两种情况（激活和不激活） } ll ans=1;\rwhile(!stk.empty())\r{\rans=(ans*stk.top().second)%mod;\rstk.pop();\r//cout\u003c\u003cans\u003c\u003cendl;\r }\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r} debug了一小时 发现自己手贱，在声明vector的时候给它分配了空间，然后就出现迷之错误 （我一定是有病才会这么做） 感觉自己的思维和英语都退步了 oh shake it 又没有学习android ","date":"2020-03-08","objectID":"/abc158/:0:18","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["GAME"],"content":"光环1","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"halo1是微软于2001年发行的第一人称射击游戏 halo是一个很注重武器选择的游戏，合适的武器会非常高效 ","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/:0:0","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"剧情 2160-2200：早期冲突 这一时期的人类历史充斥着太阳系中各大政府和派别之间的一系列血腥冲突。具有重大历史意义的冲突包括：木卫战役（Jovian Moons Campaign）、雨林争霸（The Rain Forest Wars）和一系列的火星遭遇战。 随着地球上人口过剩和政局动荡的愈演愈烈，许多新的政治运动兴起了。这一时期最值得注意的政治异端运动是“科思洛维克”（“Koslovics”)和 “福里登”（“Frieden”)运动。“科思洛维克”是指新共产主义者的强权领袖福拉德米亚·科思洛夫(Vladimir Koslov）的拥护者，他们致力于回到共产主义的光荣岁月，要消灭公司和资本家的流毒，特别是要肃清近地轨道和地外殖民地。 “福里登”运动是法西斯主义的复兴，该运动起源于反“科思洛维克”情绪，扎根木星殖民地为据点（很大程度上受到了统一德意志共和国企业的支持，这些企业常常成为科思洛维克“工人起义”的对象）。“福里登”的字面意思是“和平”－－这就是说，他们相信只有消灭了“人类的暴君”（oppressors on Terra Firma），才可能达成和平。 2160 三月－六月：木卫战役开始 木星分裂主义者袭击了位于木卫一爱莪（Io）的联合国殖民地总署（United Nations Colonial Advisors），导致了地球军与木星“福里登”部队之间展开了长达三个月的激战。虽然这并非我们太阳系中的第一起武装冲突，但此役成了最为血腥的战斗之一，也被普遍认为是引发接下来的摩擦和军国主义大潮的导火索。 木卫战役也升级了地球各国政府间的紧张关系－－许多国家在太阳系中都建立了殖民地，开始为各自在地外的利益而开战。殖民地战争的持续，使得地球上的紧张关系一触即发，引发了地球本土的数起武装冲突。 2162：雨林争霸 武装冲突横扫南美大陆，科思洛维克、福里登和联合国军之间因为不同的意识形态而开战。而这又加剧了地外冲突。 2163 十二月：在火星的战斗 地球三股主要派别将雨林争霸中燃起的战火烧到了火星上。一系列在火星Argyre Planitia附近对科思洛维克军的闪电战，是第一次非地军队的部署。战斗取得了决定性胜利。作为结果，后来的军事指导战略，惯用大编制的地面部队突袭配合舰船登陆行动。 2164：星际大战 联合国军开始形成大规模集结的格局，终于迎来了第一次真正的星际大战。继火星的军队部署告捷后，大规模的征兵行动和宣传策略极大地鼓舞了UNSC (United Nations Space Command，联合国太空司令部）军队的士气。联合国军挫败了地球上的科思洛维克和福里登军队，接着开始系统地专注于驱逐其在太阳系内其他行星上建立起来的残存势力。在这些局部战争后，福里登和科思洛维克军队被庞大、统一而强大的联合国军悉数剿灭。 2170：膨胀 2160年代的战乱促使人们建立了统一的地球政府。现在，胜利者必须处理不太引人注目却同样严重的威胁：人口过剩和无仗可打的庞大军队。 战后的岁月里，大量人口急剧膨胀；雨林争霸遗留的资源破坏和饥荒更是雪上加霜，世界经济岌岌可危。 2291：超越光速 一支由研究人员、物理学家和数学家组成的团队正在秘密研发“肖恩·藤川”超光速引擎（Shaw-Fujikawa Translight Engine，SFTE），一种驱动太空船穿越辽远星际的特殊手段。 这种新型引擎允许飞船钻入“跃迁空间”（“the Slipstream\"或\"Slipspace”，又称为“迁跃断层空间”）。“断层”一个变通的物理法则下的空间，允许超光速旅行而避免相对论的副作用。超光速旅行并不是瞬间完成的；“短程”的跳跃一般要花两个月，而“长程”的跳跃则能持续六个月甚至更久。 SFTE能生成一个共振场，当与迁跃空间的物理特性结合时，就能大大缩短跨越星际的时间；然而，科学家们也注意到在迁跃空间内部会有暂时的涌流这一奇怪的“变数”。尽管人类科学家都无法确定为何星际旅行所需的时间不是一个常量，但有理论指出在迁跃空间内部存在“漩涡”或“涌动” －－正是这造成了星际旅行所需的时间会有百分之五到十的出入。这一暂时的不一致性使军事战术家和战略家颇为恼火－－这会妨碍许多协同作战的进行。 2310：初潮 地球政府向公众公布了一系列殖民船中的第一艘－－应征者相当踊跃。地球上的状况因为人口过剩而不断恶化，搭乘飞船去外星殖民自然成了诱人的选择。 每艘殖民船都配备了军队人员和护卫舰，这样有助于更好地利用现有的庞大舰队。在异端武装瓦解后，军队正消耗着庞大的军费和物资。 因为超光速旅行在此阶段还十分新鲜而又昂贵，殖民地居民和军队人员都要通过生理和心理的严格测试。原则上，只有最优秀的公民和士兵才能获准去“邻近”的世界殖民。这就是近地殖民地（Inner Colonies）的诞生。 2362：远征号 远征号（The Odyssey）于2362年1月1日发射。作为浩浩荡荡的殖民舰队的领头舰船，远征号满载着部队和地貌改造装置，殖民的矛头直指新世界。人类超越太阳系的边界向外扩展的初潮由此拉开帷幕。 2390：近地殖民地 到了2390年，近地殖民地的殖民化运动正如火如荼。总计有210个人类占据的世界在进行不同程度的地貌改造，而在人类掌控的太空里，人口负担得到了巨大的缓解。 2490：远地殖民地的诞生 扩张仍在马不停蹄地进行，到2490年已经有800多个人类世界遍布银河系猎户座星臂了（这些世界形形色色，既有高度开化的星际要塞，也有偏僻的小定居点）。随着向外扩张的继续，近地殖民地成了政治和经济重镇，虽然他们极其仰赖远地殖民地提供的原材料。 在这一时期，致远星（planet Reach，围绕波江座第五恒星（Epsilon Eridani）运转，正当地球的咽喉要道）成为了UNSC的主要舰船制造厂和训练营地。致远星是战舰和殖民船的主要制造地，也是训练秘密特工和特种部队的所在地。 2525：星盟战争开始 2525年4月20日，与远地殖民地丰饶星（Harvest）的联络中断了。在试图重新建立联络的努力失败后，殖民军总参谋部 (the Colonial Military Administration，CMA）派遣了一艘侦查舰，金羊毛号（the Argo）前去调查。可是金羊毛号一到达丰饶星系，与飞船的联络也突然中断了。 CMA火速派遣了一支三艘战舰组成的战列舰队前往丰饶星。只有战列舰队领航的旗舰大力神号（the Heracles）返回了致远星，战痕累累，伤亡惨重。战舰的指挥官报告说，出现了一艘配备了强大武器的外星战舰，已经践踏了丰饶星，血洗了殖民地（很可能也已摧毁了金羊毛号）。 战列编队很快遭遇了外星战舰，并被紧密跟踪。在两艘战舰被击毁后，大力神号迅速跳出了星系，但因为受损严重，几周之后大力神号才回到了致远星。 地球军立即提升了警报级别，开始积极准备收复丰饶星的作战计划。当年12月，由普雷斯顿·科尔（Preston Cole）中将率领的地球军舰队浩浩荡荡地出发了，如此快地派出如此庞大的远征军，在人类历史上实数罕见。 2525：丰饶星战役 科尔率领的舰队誓报殖民星沦陷之仇，在与外星战舰的遭遇战中告捷－－尽管胜利的代价是损失了科尔军三分之二的有生力量。扭转战局的，只是科尔在最后几分钟，战术上的灵光乍现罢了。 军队回师地球之后，晋升为上将的科尔才获悉：许多外围殖民地已经沦陷，无人生还。科尔开始排兵布阵，准备对入侵者展开截击。地面战和舰船战相当惨烈，战火绵延到了整个远地殖民地。在一次地面遭遇中，人类部队俘虏了一个外星入侵者。在负伤过重死亡之前，人类得知这些外星人自称为“星盟” (the Covenant）。 远地殖民地大屠杀 在接下来的几年中，科尔部遭到了重创，他个人出色的领导力和战略才华也无济于事。这完全是一场实力悬殊的较量，星盟在舰船战中的胜率甚至接近四比一。 到了2535年11月，事实上所有的远地殖民地都已经惨遭星盟屠戮。“科尔协议”（Cole Protocol）作为军事命令确立了如下原则：所有的地球舰船必须确保星盟军不会发现地球。当地球舰船被迫撤退时，必须远离环地航线，甚至不做计算就进行超时空跳跃也在所不惜。 如果存在被星盟俘虏的危险，连“盲跳”都不可行时，船长必须下令船只自毁。此外，强大的舰船人工智能（AI）核心数据也切不可落入敌军之手。所以，科尔条款的部分内容也指出：在紧急状态下，必须转移或销毁舰船人工智能。 2536-2552：近地殖民地之围 星盟的铁蹄已经踏入近地殖民地。多年来的战事渐成定局：人类只是以极其高昂的代价赢得局部战斗的胜利，尤其是在地面行动中。而在太空对战中，人类的失利猝不及防，殖民地就这样接二连三地沦陷了。 2552：致远星的沦陷 星盟军终于到达了致远星－－这个离地球最近的重大军事要塞覆灭了。秋风之墩号（the Pillar of Autumn）巡洋舰，载着最后一个二期 (SPARTAN）斯巴达战士士官长逃出生天，幸免于难。所谓“斯巴达战士”指的是超级特种兵的一种精英作战单位，装备了令人望而生畏的雷神锤装甲。他们是人造的终极兵种。 现在，仅存一个斯巴达战士能与敌对决了。秋风之墩号的舰长雅各布·凯斯（Jacob Keyes）为了遵守“科尔条款”下令进行目的地未知的长程跳跃，希冀着能让星盟追兵始终远离地球。 引擎熄火后，秋风之墩发现自己落入了一个辽远未知的星系。星系中也有一支星盟舰队，他们附近有一个行星般大小的环状结构－－“光晕”。 2552-2553：地球战役 解决了“光晕”的问题之后，秋风之敦号一小部分幸存者和致远星上的部分幸存者合流，经过一系列艰辛的征战回到了地球。然而，此时星盟舰队也大举入侵。人类不得不为自己最后","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/:0:1","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"刺客信条2","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"ac2由育碧蒙特利尔工作室开发 十年前玩的游戏，环境渲染和剧情真的超棒 背景音乐选的十分用心 后来主角ezio也成为了刺客信条系列的标志 刺客信条系列基本延续着刺客和圣殿骑士（现在的abstergo）的斗争，进入animus为追求祖先记忆，寻找金苹果讯息。。。 续作兄弟会的剧情显得有些乏味，不过以组建兄弟会为主线的游戏安排还是很可以的 线上有更丰富的内容 ","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/:0:0","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"剧情 刺客信条2： Desmond在刺客信条1之后本来是准备要处死的，但是Lucy帮他逃了出来，和另外两个现代刺客会合。为了找到伊甸园圣器的下落，Desmond不得不再次进入刺客兄弟会的机器Animus 2.0，这一次他成为了中世纪佛罗伦萨的贵族Ezio Auditore(艾奇奥)。Ezio的父亲和两个兄弟被陷害以后，他在自己的叔叔Mario Auditore(马里奥)的帮助下脱离险境，并且知道自己的家族是刺客家族。于是他开始自己的复仇之路。在复仇的过程中，Ezio慢慢知道了伊甸园圣器的事，并且自己也在慢慢成长，直到有一次圣殿骑士从外地运回威尼斯一件很重要的物品，被Ezio夺到，原来就是金苹果。 于是Ezio发现一个事实，就是在罗马有一件伊甸园圣器“教皇权杖”，它和“金苹果”结合就能打开一些秘密。于是刺客们就前往罗马，一来为了杀死陷害Ezio一家的罗马教皇Rodrigo Borgia(罗德里格·波奇亚)，二来为了抢夺教皇权杖。谁知Rodrigo早有准备，反刺伤了Ezio，抢了他的金苹果。但是Rodrigo没有刺客的血统，结合了教皇权杖和金苹果，但却无法激活。而后Ezio赶来，两人赤手空拳搏斗，Ezio最终胜利，但心一软没有杀死这位陷害自己一家的幕后主使。Rodrigo逃脱。Ezio身为正统刺客，发现自己的血统使两件伊甸园圣器合体激活，打开了罗马教堂地下的一间密室，而密室中出现的影像却是给后来人，也就是给现代正统刺客Desmond的信息。然而回到现代，正在此时，圣殿骑士出现，Lucy和Desmond不得不展开战斗，Desmond通过Animus的血统效应已经学会了Ezio的一些技能，击退了圣殿骑士以后逃离。 刺客信条兄弟会： Desmond和Lucy一行人一直逃到蒙特奥吉欧尼，也就是中世纪Ezio叔叔Mario的庄园。他们开始继续搜索金苹果的下落。回到Animus中，Ezio打败Rodrigo之后载誉归来，回到Mario的庄园，但不想第二天凌晨，Rodrigo的儿子Cesare Borgia带兵攻打庄园，并最终抢夺了金苹果，还杀死了Mario。Ezio也只能带伤逃离。逃离了以后，他孤身一人来到罗马，再次踏上了复仇之路。在Machiavelli(马基雅维利)、Da Vinci(达芬奇)和罗马当地的佣兵、交际花和盗贼的帮助下，Ezio解放了罗马，拿回了金苹果，并最终杀死了Cesare。夺回金苹果后，Ezio把它埋在了罗马大剧场地下的一间密室里。回到现代，Desmond等人立即赶往罗马大剧场遗址，并进入密室，拿到了金苹果。但Desmond一碰到金苹果之后就被控制，不由自主走向Lucy，刺杀了她，随后陷入了昏迷。 刺客信条启示录： Desmond昏迷之后，其他刺客急忙将他放回了Animus，希望通过Animus能让他苏醒。在Animus中，Desmond的意识和肉体已经分离，他的意识遇见了另一位在Animus中游荡的“16号”意识，来自一位现代已经遇害的刺客。16号告诉他只有在Altair(阿泰尔，刺客信条1主角)、Ezio和Desmond完全同步的时候才能让Desmond找回自我。于是Desmond第三次进入了Ezio的记忆。 Ezio为了寻找古老刺客的知识，来到了Altair所在的马西亚夫城堡，发现一间Altair建造的密室。为了打开密室，Ezio必须找到五把Altair留下的钥匙，而这些钥匙已经被当时马可波罗的父亲带去君士坦丁堡埋藏。到了君士坦丁堡之后Ezio卷入了宫廷斗争，还认识了一位有魅力的女人Sofia(索菲亚)。找到五个钥匙之后，Ezio和Sofia一起回到了马西亚夫城堡，打开了密室，见到了Altair的遗体和Altair留下的另一个力量更强大的金苹果。这时金苹果又被激活，Altair、Ezio和Desmond的意识完全同步，Desmond聆听了人类诞生前的文明留下的信息，需要Desmond拯救世界。在那之后，Ezio扔下了身上的武器，把它们和金苹果放在一起留在了密室，结束了自己的刺客生涯。回到现代，Desmond从Animus中苏醒了过来。 刺客信条-余烬：Ezio老年和Sofia生活在佛罗伦萨郊外的一片农庄里，他们有两个孩子。有一天来了一个中国女刺客，为了刺杀残暴的嘉靖皇帝来向Ezio求教。帮助了女刺客之后，有一天Ezio在和Sofia逛街的时候疾病突发，安详仙去。 当我还年轻时，我身怀自由，但我并未看出它的存在，我有大把的时间，可我不懂得珍惜，我还拥有爱，但是从未真实地感受过它，我花了好几十年才明白这三者的真正意义，但现在，在我生命中的黄昏，这些认知逐渐转变成了幸福。爱，自由，时间,曾经随意丢弃的这些，原来正是驱使我前行的动力，而在这三者中，爱尤其宝贵。以此献给你和我们的孩子，以及我们的兄弟姐妹，还有这个赋予我们生命与好奇的广袤世界。索菲亚，我对你的爱永无止境——无论何时都属于你的——艾吉奥·奥迪托雷 Ezio写给Sofia Sorto的遗书 —来自网络 ","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/:0:1","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"刻痕","date":"2020-03-08","objectID":"/%E5%88%BB%E7%97%95/","tags":[],"title":"刻痕","uri":"/%E5%88%BB%E7%97%95/"},{"categories":["GAME"],"content":"《刻痕》是由蓝天使制作组制作的2D动画游戏，于2008年发行，是一款恐怖推理解谜游戏 《刻痕》是国内原创推理悬疑解谜（猎奇）游戏的始祖，国内第一个以R15作为GALGAME正式标准的游戏，也是国内第一个R15类型的推理悬疑解谜（猎奇）类游戏，刻痕系列首次在国内提出了带有悬疑、血腥、恐怖或者猎奇要素的游戏，要以R15作为分类标准的概念，此分类概念在后来在国内整个GALGAME行业业界被得以广泛认可，并被普遍流传使用。 ","date":"2020-03-08","objectID":"/%E5%88%BB%E7%97%95/:0:0","tags":[],"title":"刻痕","uri":"/%E5%88%BB%E7%97%95/"},{"categories":["GAME"],"content":"波斯王子","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["GAME"],"content":"波斯王子 prince of persia是ubisoft于1989年发行的一款单机游戏 波斯王子有好多部，前3部是一个完整的故事，后面则是一些衍生 这是我2010年玩的游戏，pop1通关了4遍 作为上个世纪的游戏，画质不能与现在的3A大作比 但是，有一说一画质也不差 环境的渲染也特别棒，很符合故事背景，有很多细节 游玩的时候不禁会让人驻足联想 剧情真的很不错，以时间倒流作为主要技能是很大的创新 也增加了游玩的乐趣 值得一提的是，据官方称，这个游戏有六百多种动作 按键的组合确实可以打出很多不同的动作，但前期在战斗的时候基本只需要靠几个动作 pop2应该是最难的一部，小boss血量巨厚 如果我没记错的话，pop3应该是加入了刺杀系统，在当时是一个很大的创新，而且感觉还不错 对于boss来讲，要一遍过还挺难 黑暗王子的20倍攻击力用的太爽了 pop的跑酷系统在当时做的着实优秀 ","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/:0:0","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["GAME"],"content":"游戏剧情 很多人都认为，时间就像一条河流，永远朝着一个方向不断的前进。 印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，并带走了时间女皇的遗物——时之沙漏和时之匕首。 后来，为了将这两件宝物据为己有，以达到长生不老的目的，维瑟尔背叛了穆罕默德。他怂恿波斯国王沙拉曼攻打印度，并承诺作为内应会打开印度的城门。战争结束，沙拉曼得到了时之沙漏，并且俘虏了印度国的公主法拉。而波斯王子由于在战争中的杰出表现，得到了他的第一件战利品——时之匕首。 波斯大军凯旋在阿扎德苏丹皇宫暂时停留时，心怀怨恨的维瑟尔诱惑波斯王子用匕首打开时之沙漏，释放的时之砂瞬间吞噬了整个皇宫，并且将沙拉曼变成了砂之怪物。 王子不得已杀死了自己的父亲，在悲痛欲绝中，逃脱的印度公主法拉告诉王子，只要将时之匕首重新插进时之沙漏，那么时间就会倒退，回到一切的开始。于是王子和法拉开始了他们的冒险。 随着冒险的不断深入，王子和法拉的情感也在发生微妙的变化。最后，法拉悄悄的带着时之匕首离开了王子。王子找到了法拉，但却眼睁睁的看着法拉坠楼身亡。哀伤的王子夺回了匕首并将其插进了沙漏里。 伴随着维瑟尔绝望的呼叫，时间倒退到了波斯军队进攻印度之前。保留着记忆的王子在进攻的前夜悄悄的潜进了公主法拉的卧室，告诉了她一切，包括维瑟尔的背叛。被揭穿的维瑟尔恼羞成怒，想要杀掉法拉嫁祸给王子，但被王子消灭了。后来，王子劝说他的父亲沙拉曼撤走了军队，一切好像都恢复了平静。但是谁也没有料到的是，王子的命运已经被诅咒：任何使用过时之匕首的人，只有死路一条。 “因为王子使用了时之匕首破坏了时间的平衡。而达哈卡就是为了恢复时间的平衡而诞生的，他就像时间一样是不可战胜的。达哈卡会像影子一样追杀着王子，直到王子的生命走到尽头。” 王子是从一位盲眼老人那里得到了自己的命运被诅咒这个消息的。为了改变自己悲惨的命运，王子打算去时之岛，回到过去，回到时间女皇制造时之沙的那一刻，去阻止时之沙的诞生。 历经艰难的王子终于到达了时之岛，并且通过岛上的时间传送点回到了过去。在那里，王子遇到了一位名叫凯琳娜的红衣少女。凯琳娜帮助了王子，她告诉了王子如何去打开时间女皇所在房间的门的机关。 在冒险的过程中，一个神秘的黑衣人不时在王子周围出现，不知是敌是友。更让人感到诡异的是，最后时间的守护者达哈卡突然在王子和黑衣人的面前出现，但是达哈卡却杀掉那个黑衣人，然后没有理会王子就走了！纳闷的王子按照凯琳娜的帮助打开了时间女皇房间的大门，却又愕然发现原来凯琳娜就是时间女皇！怨愤的凯琳娜告诉王子，她之所以帮助王子，就是想让王子在打开大门的过程中被那些机关杀死，或者被时间守护者达哈卡杀死。原来凯琳娜也通过时间线预知到了自己的命运：她将会被波斯王子亲手杀死！同样为了改变自己悲惨的命运，时间女皇和王子展开了一场生死战，最后王子逼不得已只好杀掉了凯琳娜！ 凯琳娜在临死之前告诉王子：没有人能改变自己的命运，你也会像我一样去奋力，但你也会像我一样死去！随后，凯琳娜的尸体迸发出了金色的光芒。 王子通过时间传送点回到了杀死父亲之前。本以为一切都结束的王子突然发现时间的守护者达哈卡仍然在追杀他。这时王子才想起来，凯琳娜死后那些金色的光芒就是时之沙！（王子本以为时之沙是时之女皇凯琳娜制造的，杀死凯琳娜就可以阻止时之沙的诞生，但事实是时之沙的诞生正是因为王子杀死了凯琳娜，时之沙就是凯琳娜死后尸体变成的）绝望的王子被达哈卡困在了一个地下墓穴里。就在万念俱灰之时，墙壁上的文字吸引了王子的注意。 根据文字记载：当年印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，在夺取时之沙漏的过程中，穆罕默德不幸被时之守卫杀死，但幸运的是，一件黑色的面具让他有了第二次机会…… 就像在黑暗中看到了一丝曙光一样，王子暂时摆脱了达哈卡的追杀，去寻找那件黑色面具。终于在时之岛的尽头，王子找到了黑色面具。戴上了面具的王子回到了他刚到时之岛的那一刻，并且变成了一个黑衣人——原来在他冒险的过程中时隐时现的黑衣人其实就是他自己。 又经过一番努力，王子最后阻止了自己被达哈卡杀掉（本来达哈卡杀掉了黑衣人，但王子没有让这件事情发生，达哈卡转而杀掉了原来的王子），王子又变回了原来的样子。由于知道了接下来将要发生的事情，王子决定利用时间传送点把时间女皇凯琳娜带到之前。这样即使凯琳娜死了时之沙也不会威胁到自己。变身回来的王子成功的把凯琳娜带到了之前，但是时间的守护者达哈卡再度现身，只不过这次他的目标换成了凯琳娜。这是理所当然的，凯琳娜本来不属于这个时代，为了维护时间的平衡，达哈卡自然把矛头对准了她。因为不忍心凯琳娜就这样被达哈卡杀死，王子利用从过去带回来的一把水之刃（此刀可以伤害到达哈卡），与达哈卡展开了一场肉搏战。 最后在凯琳娜和王子的配合下，达哈卡居然奇迹般的被消灭了。胜利的王子打算带着凯琳娜一起回到他的故乡——波斯的巴比伦城，想从此过着平静的生活。但此时的巴比伦城正被战火所蹂躏……盲眼老人的声音仍在萦绕在王子心头：你不可能改变自己的命运，没有任何人可以。 几个星期后，王子带着凯琳娜离开了时之岛回到了他故乡巴比伦城，却发现整个巴比伦城陷入一片火海中。震惊和愤怒的王子不敢相信眼前的一切，但随后他的船就被飞来的火球打翻，并且和凯琳娜失散。 昏迷的凯琳娜被侵略军带到了巴比伦皇宫里。王子紧随其后想要去救她。在皇宫中，愤怒的王子不幸被敌人擒住，但他却愕然发现侵略军的首领居然是那个“已经被自己杀死的”邪恶法师维瑟尔！而维瑟尔居然又不认识自己？原来，当王子把时间女皇凯琳娜带到之前的一霎那，历史就已经发生了改变：由于没有时之沙，维瑟尔也就不会去背叛穆罕默德，也就没有了波斯进攻印度的历史，维瑟尔也就不会认识王子，当然也不会被王子杀死了。 历史已经改变，但依然改变不了维瑟尔邪恶的欲望。 多年以前，印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，与原先的历史不同，他们只找到了一把时之匕首，至于传说中的时间女皇和时之沙则没有任何存在过的痕迹。已经对时之沙快要放弃的维瑟尔却突然发现时之匕首在最近几个星期变得活跃了起来，维瑟尔很快明白了究竟发生了什么事情：时间女皇来到了之前！被长生欲望熏昏了头脑的维瑟尔杀死了穆罕默德，囚禁了印度公主法拉，控制了印度的军队来进攻巴比伦城！企图寻找时间女皇！时间女皇凯琳娜终于落在了维瑟尔手中！残忍的维瑟尔用时之匕首杀死了凯琳娜，释放出了时之砂，他又将匕首插进自己的身体里，随后变成了一个金黄色的怪物——维瑟尔终于达到了他长生不老的愿望。整个巴比伦城被时之沙吞没，那些侵略军全部被感染到了时之砂，变成了沙之怪物，就连王子自己的手臂也被时之砂侵入。危急时刻，王子挣脱了束缚，抢走了时之匕首，离开了巴比伦皇宫。时之沙唤起了王子最大的敌人…… 被时之沙感染的王子感觉到体内产生另一个邪恶的人格——黑暗王子。黑暗王子狡猾，残忍，对弱者没有同情心，但在冒险的时候王子却需要变身成黑暗王子来渡过难关。 在这种奇怪的组合下，王子又遇到了自己爱慕的印度公主法拉。法拉被维瑟尔囚禁后也被带到了巴比伦城。后来法拉在时之沙的混乱中逃脱，遇到了游荡在巴比伦城的王子。起初法拉对波斯王子的双重身份深感怀疑，但在随后的冒险中逐渐与王子重新建立了信任和友情（法拉再次遇见王子的时候也和维瑟尔一样不认识他了）。但在冒险的过程中，黑暗王子的感染变得越来越严重，这让王子本身深感不安。不幸的是，冒失的法拉又被维瑟尔抓住，而王子被打入了一个黑暗的深洞里。 最后，在巴比伦城黑暗的地下宫殿里，王子找到了他父亲波斯王沙拉曼的尸体。悲痛的王子拿起父亲的宝剑，抑制住了邪恶的黑暗王子的意识，决心找维瑟尔复仇。 在巴比伦的空中花园，左手持波斯帝王宝剑，右手持时之匕首的王子与维瑟尔展开了一场决战！胜利的王子将时之匕首插进了维瑟尔的心脏，彻底的终结了这个邪恶的灵魂。 已经变成时之沙的凯琳娜再度幻化成人形来跟王子告别：这个世界本不属于我，自有我所归属的世界……王子将时之匕首交给凯琳娜，凯琳娜化做时之砂，向远方飘散而去。 凯琳娜消失之后，黑暗王子从王子的内心世界中分裂出来，企图夺走王子的一切，但王子走出内心的阴霾，最终在虚幻的世界中消灭了黑暗王子。 时之砂消逝，邪恶力量破灭，波斯帝国的子民为王子所拯救，一切都结束了。 在巴比伦的空中花园，王子再次向法拉讲起了那个时间的故事。–百度百科 ","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/:0:1","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["abc"],"content":"abc157","date":"2020-03-02","objectID":"/abc157/","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"A - Duplex Printing 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:0","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 每一页正反两面可以分别写一个数，问有n个不同的数可以写几页 ","date":"2020-03-02","objectID":"/abc157/:0:1","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 简单模拟 ac代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main()\r{\rint a;\rcin\u003e\u003ea;\rif(a\u00261)\rcout\u003c\u003ca/2+1\u003c\u003cendl;\relse\rcout\u003c\u003ca/2;\rreturn 0;\r}\r B - Bingo 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:2","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 有一个3*3的网格填满数字，接下来给出一些数字，如果网格中有，就标记。 问是否存在一行或一列或对角线满足它们都被标记 ","date":"2020-03-02","objectID":"/abc157/:0:3","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 由于数据不是很大，所以暴力模拟 ac代码如下 #include\u003ciostream\u003e\rusing namespace std;\rbool b[3][3];\rint main()\r{\rint d[3][3];\rint n;\rfor(int i=0;i\u003c3;i++)\rfor(int j=0;j\u003c3;j++)\rcin\u003e\u003ed[i][j];\rcin\u003e\u003en;\rint t;\rwhile(n--)\r{\rcin\u003e\u003et;\rfor(int i=0;i\u003c3;i++)\rfor(int j=0;j\u003c3;j++)\r{\rif(d[i][j]==t)\r{\rb[i][j]=true;\rbreak;\r}\r}\r}\rbool flag=false;\rfor(int i=0;i\u003c3;i++)\r{\rif(b[0][i]== true and b[1][i]==true and b[2][i]==true) {\rflag=true;\rbreak;\r}\r}\rfor(int i=0;i\u003c3;i++)\r{\rif(b[i][0]== true and b[i][1]==true and b[i][2]==true) {\rflag=true;\rbreak;\r}\r}\rif(b[0][0]==true and b[1][1]==true and b[2][2]==true) {\rflag=true;\r}\rif(b[0][2]==true and b[1][1]==true and b[2][0]==true)\r{\rflag=true;\r}\rif(flag) cout\u003c\u003c\"Yes\"\u003c\u003cendl;\relse cout\u003c\u003c\"No\"\u003c\u003cendl;\rreturn 0;\r}\r C - Guess The Number 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:4","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 给一个数位n，和若干个条件，条件类型为ai位必须是数字bi，求满足这些条件的最小n 位数，不满足输出-1 ","date":"2020-03-02","objectID":"/abc157/:0:5","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 数据很小，简单模拟，有很多的细节，注意一位数、前导0等特殊情况 由于边打代码边想，所以代码很乱 ac代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rbool use[3];\rint main()\r{\rint d[3];\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rint s,c;\rbool flag=true;\rfor(int i=0;i\u003cm;i++)\r{ cin\u003e\u003es\u003e\u003ec;\rs--;\rif(n!=1 and s==0 and c==0)\r{\rflag=false;\rbreak;\r}\relse if(s\u003en)\r{\rflag=false;\rbreak;\r}\relse if(use[s] and c!=d[s])\r{\rflag=false;\rbreak;\r}\relse\r{\rd[s]=c;\ruse[s]=true;\r}\r}\rif(n!=1 and !use[0]) {\rd[0]=1;\rfor(int i=1;i\u003cn;i++)\r{\rif(!use[i]) d[i]=0;\r}\r}\relse\r{\rfor(int i=0;i\u003cn;i++)\r{\rif(!use[i])\rd[i]=0;\r}\r}\rif(!flag) cout\u003c\u003c-1\u003c\u003cendl;\relse {\rfor(int i=0;i\u003cn;i++)\r{\rcout\u003c\u003cd[i];\r}\rcout\u003c\u003cendl;\r}\r//cout\u003c\u003cuse[2]\u003c\u003cendl;\r return 0;\r}\r D - Friend Suggestions 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:6","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 有n个人和两种关系（双向的）friendship 和 blockship 定义：一个人为另一个人的friend candidate 当且仅当满足他们没有这两种关系且他们之间存在着friendship的传导链 问每个人的friend candidate数量 ","date":"2020-03-02","objectID":"/abc157/:0:7","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 由于需要friendship传导链，又存在friendship的双向关系，所以考虑并查集 再遍历一遍信息，如果是直接的friendship和blockship关系就减掉这个人（数量减1） （需要计算集合元素个数） ac代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,m,k;\r//union find\rint par[100005]; int rankk[100005]; int sizz[100005];\rint ans[100005];\rint a[100005];\rint b[100005];\rint c[100005];\rint d[100005];\rvoid init(int n) {\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} int find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); } void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y,sizz[y]+=sizz[x]; else\r{\rpar[y]=x;\rsizz[x]+=sizz[y];\rif(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\rios::sync_with_stdio(0);cin.tie(0);\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em\u003e\u003ek;\rinit(n);\rfill(sizz,sizz+n,1);\rfor(int i=0;i\u003cm;i++)\r{\rcin\u003e\u003ea[i]\u003e\u003eb[i];\r}\rfor(int i=0;i\u003ck;i++)\r{\rcin\u003e\u003ec[i]\u003e\u003ed[i];\r}\rfor(int i=0;i\u003cm;i++)\r{\runite(a[i],b[i]);\r}\rfor(int i=1;i\u003c=n;i++)\r{\rans[i]=sizz[find(i)];\r}\rfor(int i=0;i\u003cm;i++)\r{\rif(same(a[i],b[i]))\r{\rans[a[i]]--;\rans[b[i]]--;\r}\r}\rfor(int i=0;i\u003ck;i++)\r{\rif(same(c[i],d[i]))\r{\rans[c[i]]--;\rans[d[i]]--;\r}\r}\rcout\u003c\u003cans[1]-1;\rfor(int i=2;i\u003c=n;i++)\r{\rcout\u003c\u003c\" \"\u003c\u003cans[i]-1;\r}\rcout\u003c\u003cendl;\rreturn 0;\r}\r E - Simple String Queries 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:8","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 给一个只有小写字母的字符串s，和两种操作 将ai下标的字符替换成bi 查询l到r区间内有多少个不同的字母，输出结果 ","date":"2020-03-02","objectID":"/abc157/:0:9","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 数据太大，不能简单模拟 用合理的数据结构 用26个集合存储有这个字母对应的下标 对于查询区间，遍历26个集合，查询这个区间是否存在该字母（如果存在 ans++） 只需要对每个集合二分搜索左边界的标号，如果这个标号在右边界内，即存在 ac代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,q;\rstring s;\rset\u003cint\u003e st[27];\rint main()\r{\rios::sync_with_stdio(false);cin.tie(false);\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rcin\u003e\u003es;\rcin\u003e\u003eq;\rfor(int i=0;i\u003c26;i++)\r{\rst[i].insert(n); //防止使用lower_bound时集合为空 }\rfor(int i=0;i\u003cn;i++)\r{\rst[s[i]-'a'].insert(i);\r}\rint t;\rfor(int i=0;i\u003cq;i++)\r{\rcin\u003e\u003et;\rif(t==1)\r{\rint a;char b;\rcin\u003e\u003ea\u003e\u003eb;\rst[s[a-1]-'a'].erase(a-1);\rst[b-'a'].insert(a-1);\rs[a-1]=b;\r}\relse\r{\rint l,r;\rcin\u003e\u003el\u003e\u003er;\rint ans=0;\rfor(int i=0;i\u003c26;i++)\r{\rauto it=st[i].lower_bound(l-1);\rif(*it\u003c=r-1) ans++;\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r F - Yakiniku Optimization Problem 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:10","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 平面上有n个点，每个点有一个属性ci，坐标上至少存在一个点使得这个点到其中k个点 的距离*ci（只对k个点中的一点）的值的最大值最小 输出最小值 ","date":"2020-03-02","objectID":"/abc157/:0:11","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 有趣的计算几何 很难通过找到点来求最小值 很常见的做法是用二分法 区间的值为“最大值“ 每一次检查满足“最大值”的点是否超过k个 超过则将最大值减小 否则将最大值增大（理论上直到满足k个点） 通过精度来停机 怎样检查？ 每个点的属性=当前“最大值” / ci 以点为圆心，每个点的属性为半径，每两个圆可能存在交点 遍历每个点，如果交点在某个点的属性范围内，这个点也满足条件 遍历所有情况，求最多有多少个点满足条件 以此来检查是否超过k 注意点 1.只有一个点的特判 2.要有eps，而且eps不能太大也不能太小 3.为避免重复计算，j从i开始，但不能从i+1开始，因为有可能目标点就在某一点上 从i+1开始会wa掉1个测试点 ac代码如下 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rint n, k;\rdouble x[65], y[65], c[65], r[65];\rdouble eps = 1e-8; //!!!\r\rdouble dist(pair\u003cdouble, double\u003e p, pair\u003cdouble, double\u003e q) {\rdouble xx = (p.first - q.first)*(p.first - q.first);\rdouble yy = (p.second - q.second)*(p.second - q.second);\rreturn sqrt(xx + yy);\r}\rvector\u003cpair\u003cdouble, double\u003e\u003e circle_circle_intersection(double x1, double y1, double r1, double x2, double y2, double r2) {\rvector\u003cpair\u003cdouble, double\u003e \u003e ans;\rdouble d = dist(make_pair(x1, y1), make_pair(x2, y2));\rif (d \u003e r1 + r2) {\rreturn ans;\r}\rif (x1 == x2 \u0026\u0026 y1 == y2) {\rans.push_back(make_pair(x1, y1)); return ans;\r}\rif (d \u003c abs(r1 - r2)) {\rans.push_back(make_pair(x1, y1)); return ans;\r}\rdouble a = (r1*r1 - r2*r2 + d*d)/(2*d);\rdouble h = sqrt(r1*r1 - a*a);\rdouble x3 = (x2 - x1)*(a/d) + x1;\rdouble y3 = (y2 - y1)*(a/d) + y1;\rans.emplace_back(x3 + h*(y2 - y1)/d, y3 - h*(x2 - x1)/d);\rans.emplace_back(x3 - h*(y2 - y1)/d, y3 + h*(x2 - x1)/d);\rreturn ans;\r}\rint check(double t) {\rint ans = 0;\rfor (int i = 0; i \u003c n; i++) {\rr[i] = t/c[i];\r}\rfor (int i = 0; i \u003c n; i++) {\rfor (int j = i; j \u003c n; j++) { //!!!\r vector\u003cpair\u003cdouble, double\u003e \u003e pts = circle_circle_intersection(x[i], y[i], r[i], x[j], y[j], r[j]);\rfor (auto p: pts) {\rint cnt = 0;\rfor (int k = 0; k \u003c n; k++) {\rif (dist(p, make_pair(x[k], y[k])) \u003c= r[k] +eps) cnt++;\r}\rans = max(ans, cnt);\r}\r}\r}\rreturn ans;\r}\rint main() {\rios::sync_with_stdio(0); cin.tie(0);\rcin \u003e\u003e n \u003e\u003e k;\rif (k == 1) {\rcout \u003c\u003c \"0\\n\"; exit(0);\r}\rfor (int i = 0; i \u003c n; i++) {\rcin \u003e\u003e x[i] \u003e\u003e y[i] \u003e\u003e c[i];\r}\rdouble l = 0, r = 100000000;\rwhile(r-l\u003e=1e-8)\r{\rdouble mid = (l + r)/2;\rif (check(mid) \u003e= k) {\rr = mid;\r} else {\rl = mid;\r}\r}\rcout \u003c\u003c fixed \u003c\u003c setprecision(9) \u003c\u003c r \u003c\u003c '\\n'; return 0;\r}\r 个人感觉abc很考验思维和对数据结构的熟练度 ","date":"2020-03-02","objectID":"/abc157/:0:12","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["test"],"content":"test for music and video","date":"2020-03-02","objectID":"/test-for-music-and-video/","tags":["test"],"title":"test for music and video","uri":"/test-for-music-and-video/"},{"categories":["test"],"content":"paste a music below [video(video-HXuIKyFl-1583157343324)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=93185992)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/393b26d243ae8f1c7b3cf4d1ba0bea2fd4015d85.jpg)(title-【暴走大事件】致 杠 精)] [video(video-QTmoAEnp-1585132330863)(type-undefined)(url-undefined)(image-https://img-blog.csdnimg.cn/editor-video.png)(title-undefined)] ","date":"2020-03-02","objectID":"/test-for-music-and-video/:0:0","tags":["test"],"title":"test for music and video","uri":"/test-for-music-and-video/"},{"categories":["test"],"content":"test","date":"2020-02-27","objectID":"/test/","tags":["test"],"title":"test","uri":"/test/"},{"categories":["test"],"content":"\r\r\r\rButton\rTry Element \r\r\r\r\r\rnew Vue({\rel: '#app',\rdata: function() {\rreturn { visible: false }\r}\r})\r\r","date":"2020-02-27","objectID":"/test/:0:0","tags":["test"],"title":"test","uri":"/test/"},{"categories":["note"],"content":"用hugo搭建个人博客网站","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"效果展示 在hugo官网也有说明如何搭建个人网站 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:0","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"注册github账号 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:1","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"创建github仓库 仓库的名字必须是 用户名.github.io 建议全小写 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:2","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"安装git bash（非必须，但建议） 点击此处 选择计算机对应的规格 一步一步安装 在使用前要进行初始化用户名和邮箱 打开终端（以powershell为例） 输入git命令，没有异常就可以 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:3","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"安装hugo 点击此处 选择计算机对应的规格 下载zip压缩包 解压后会得到 hugo.exe（这个是主要的） ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:4","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"创建博客 打开powershell 转到存放hugo.exe的文件夹下（hugo指令只能在这个目录下执行） 如果hugo指令识别不出来，可以配置环境变量 如果还是不行，那就用绝对路径，一直到hugo.exe 要启动hugo.exe就要用 .\\hugo 在存放hugo.exe的文件夹下，执行以下代码 \u003ehugo new site myblog\r myblog是自己起的名字，是一个identifier 之后会生成myblog文件夹 里面已经有一些东西了（大部分都是建立网站必须的） ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:5","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"下载主题 点击此处 选一个主题下载 下载有两种方式 1.点击download，转到作者github，下载zip 把zip转到myblog/theme下，需要改文件夹一些名字 2.在主题下面有git clone(推荐使用这种) 直接在powershell下面输入（一定要 cd 到myblog） 个别主题下载的慢，可以在不同时间不同地点多试试 下载完，myblog/theme 就会多出一个主题对应的文件夹（很重要） 以下是无论哪一种都要进行的操作 根据作者在hugo网页中写的文档进行初始化配置（就是把主题文件夹中的东西搬出来，替换什么的）（很重要，没有这一步，可能本地都打不开，疯狂报错）（但有些主题没有此过程） 尝试在本地打开 输入以下代码(以pure主题为例）(这个主题名字是theme下对应文件夹的名字) myblog\u003ehugo server -t pure\r 会得到一个本地网址 用浏览器打开这个网址 就可以在本地看到自己的网页 局域网内的用户也可以看到你的网页 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:6","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"部署到服务器上（github pages） 建议先在本地查看，确认无误之后再推到服务器 输入以下代码 注意不要写错 myblog\u003ehugo --theme=pure --baseUrl=\"https://你的用户名.github.io\" --buildDrafts\r myblog下会生成public文件夹 输入以下代码 myblog\u003ecd public\rpublic\u003egit init\rpublic\u003egit add .\rpublic\u003egit commit -m \"输入你自己的提交信息\"\rpublic\u003egit remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u003egit push -u origin master\rpublic\u003e\r 此过程中有可能需要输入github的账号和密码 访问 用户名.github.io就可以看到你的网页 会有延迟，需要等一会 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:7","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"配置主题和增加内容 配置因主题而异 通法就是认真仔细地阅读作者的文档 hugo/theme上的或者README.md（可见文档有多重要） 增加的内容一般都放在content文件夹下，当然也可以删掉内容 一般是markdown格式 写markdown可以用markdownpad / visual studio code / csdn自带的等等 但是发现一个问题，不同的编辑器预览的效果不一样 比如markdownpad不能很好的识别latex公式 有可能主题自带的markdown也不能很好的呈现出效果 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:8","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"更新网站内容 ！！！文件名字不能有 # 建议首先在本地预览，确认无误再上传 然后执行以下代码（含本地预览） myblog\u003ehugo server -t pure\rmyblog\u003ehugo --theme=pure --baseUrl=\"https://你的用户名.github.io\" --buildDrafts\rmyblog\u003ecd public\rpublic\u003egit init\rpublic\u003egit add .\rpublic\u003egit commit -m \"输入你自己的提交信息\"\rpublic\u003egit remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u003egit pull origin master\rpublic\u003egit push -u origin master\rpublic\u003e\r 一定要写git pull origin master 有延迟 打开 用户名.github.io 可以看到内容已经更新 之后更新网站内容就一直重复上述操作 =================== 以下是自定义域名（附加内容）===================== 在阿里云上面注册账号 实名制 购买域名 域名实名制 购买SSL证书（有免费的） 确定SSL证书有效 配置DNS服务器 在域名解析中添加记录 记录类型为CNAME 记录值填写 用户名.github.io（或者记录类型为A，记录值填写IP地址） 打开github对应的仓库 在settings中找到custom domain 输入新域名 在github pages下显示绿色的√就可以 访问新域名就可以看到网页了 之后更新的内容，都可以通过访问新域名实现 以上操作都需要时间，需耐心等待 个人博客网站基本搭建完毕 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:9","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"about","date":"2020-02-26","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"this is dyh from hhu major in cs love swimming,coding,poppin it’s the first time to set up a site(fyi:just for fun)(based on hugo and github server) thanks to “dillonzq” offering me theme template i set up this site as a self blog and paste some study experience but maybe i’m not gonna manage it if u wanna leave a message you can reach me by qq “244882973” or number “+86 15850656951” or github account etc hope to receive your advice and talk 2 u ^_^ 2020.02.26 end ","date":"2020-02-26","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"anime","date":"2020-02-26","objectID":"/anime/","tags":null,"title":"Anime","uri":"/anime/"},{"categories":null,"content":"\r\r\r\r\r\r\r\r\r\r\r\r\r\r乒乓                 小林家的龙女仆 第二季        小林家的龙女仆\r\r\r\r\r\r\r\r\r\r\r\r鬼灭之刃               鬼灭之刃 无限列车篇         岸边露伴 一动也不动\r\r\r\r\r\r\r\r\r\r\r\r银魂                 银魂 第二季             银魂 第三季\r\r\r\r\r\r\r\r\r\r\r\rJOJO的奇妙冒险           JOJO的奇妙冒险 星尘远征军      JOJO 星尘远征军 埃及篇\r\r\r\r\r\r\r\r\r\r\r\rJOJO的奇妙冒险 不灭钻石       JOJO的奇妙冒险 黄金之风       JOJO的奇妙冒险 石之海\r\r\r\r\r\r\r\r\r\r\r\r碧蓝之海               舞动青春               白沙的水族馆\r\r\r\r\r\r\r\r\r\r\r\r星合之空               属性咖啡厅           青春猪头少年不会梦到兔女郎学姐\r\r\r\r\r\r\r\r\r\r\r\r总之就是非常可爱           玲音                 SSSS.电光机王\r\r\r\r\r\r\r\r\r\r\r\rSSSS.GRIDMAN           言叶之庭               蜂蜜与四叶草\r\r\r\r\r\r\r\r\r\r\r\r冰菓                 平家物语               名侦探柯南\r\r\r\r\r\r\r\r\r\r\r\r工作细胞                工作细胞 第二季          工作细胞BLACK\r\r\r\r\r\r\r\r\r\r\r\r知晓天空之蓝的人啊          流汗吧！健身少女           攻壳机动队\r\r\r\r\r\r\r\r\r\r\r\r我的青春恋爱物语果然有问题。     我们的存在              人形电脑天使心\r\r\r\r\r\r\r\r\r\r\r\r悠久之翼               悠久之翼2              很帅很可爱宣言\r\r\r\r\r\r\r\r\r\r\r\r悠久之翼               悠久之翼2              很帅很可爱宣言\r\r\r\r\r\r\r\r\r\r\r\r希德尼娅的骑士 第一季         轻音少女 第一季           星际牛仔 SP\r\r\r\r\r\r\r\r\r\r\r\r进击的巨人第一季           搞笑漫画日和             \r未闻花名\r\r\r\r\r\r\r\r\r\r\r\r关于前辈很烦人的事          辉夜大小姐想让我告白...        刀剑神域\r\r\r\r\r\r\r\r\r\r\r\r在下坂本，有何贵干？         天使降临到我身边           赛马娘 第二季\r\r\r\r\r\r\r\r\r\r\r\r游戏王GX              干物妹！小埋             重启咲良田\r\r\r\r\r\r\r\r\r\r\r\r甘城光辉游乐园            可塑性记忆              声之形\r\r\r\r\r\r\r\r\r\r\r\r你的名字。              天气之子               起风了\r\r\r\r","date":"2020-02-26","objectID":"/anime/:0:0","tags":null,"title":"Anime","uri":"/anime/"},{"categories":null,"content":"cloud","date":"2020-02-26","objectID":"/cloud/","tags":null,"title":"Cloud","uri":"/cloud/"},{"categories":null,"content":"\r\r.el-tabs--border-card {background : #fff0}\r.el-tabs--border-card.el-tabs__content{height:500px}\rel-container{\rwidth:50px;\rheight:100px\r}\r\r\r\rfail to load fail to load fail to load fail to load fail to load fail to load \r\r\r\r\rvar Main = {\rdata() {\rreturn {\r}\r}\r}\rvar Ctor = Vue.extend(Main)\rnew Ctor().$mount('#app')\r\r","date":"2020-02-26","objectID":"/cloud/:0:0","tags":null,"title":"Cloud","uri":"/cloud/"},{"categories":null,"content":"game","date":"2020-02-26","objectID":"/game/","tags":null,"title":"Game","uri":"/game/"},{"categories":null,"content":"\r\r\r\r\r\r\r\r\r\r\r\r\r\rWatch_Dogs2           Watch Dogs: Legion       Forza Horizon 4\r\r\r\r\r\r\r\r\r\r\r\r\rForza Horizon 5          Dishonored           Dishonored 2\r\r\r\r\r\r\r\r\r\r\r\r\rAssassin's Creed 2         Assassin's Creed Brotherhood  Assassin's Creed Unity\r\r\r\r\r\r\r\r\r\r\r\r\rAssassin's Creed Origins      Assassin's Creed Odyssey      Assassin's Creed Valhalla\r\r\r\r\r\r\r\r\r\r\r\r\rMetro Exodus           PUBG              Dota 2\r\r\r\r\r\r\r\r\r\r\r\r\rCS:GO                Grand Theft Auto V         Riders Republic\r\r\r\r\r\r\r\r\r\r\r\r\rPoP: The Sands of Time      PoP: Warrior Within        PoP: The Two Thrones\r\r\r\r\r\r\r\r\r\r\r\r\rHITMAN 2            Human: Fall Flat          SCP: Secret Laboratory\r\r\r\r\r\r\r\r\r\r\r\r\rCyberpunk 2077          Sekiro: Shadows Die Twice    Battlefield 1\r\r\r\r\r\r\r\r\r\r\r\r\rSteep               Notch              Halo: Combat Evolved\r\r\r\r\r\r\r\r\r\r\r\r\rDARK SOULS III          Apex Legends          Overwatch\r\r\r\r\r\r\r\r\r\r\r\r\r\rIt Takes Two            NieR:Automata         Tomb Raider\r\r\r\r\r\r\r\r\r\r\r\r\r\rLife is Strange - Episode 1     Yakuza 0             The Witcher 3: Wild Hunt\r\r\r\r\r\r\r\r\r\r\r\r\r\rLeft 4 Dead            Subnautica            Devil May Cry 5\r\r\r\r\r\r\r\r\r\r\r\r\r\rFINAL FANTASY XV        ICEY               God of War\r\r\r\r\r\r","date":"2020-02-26","objectID":"/game/:0:0","tags":null,"title":"Game","uri":"/game/"},{"categories":null,"content":"life","date":"2020-02-26","objectID":"/life/","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"\r\r\r\r\r\r\r要毕业🌶️\r\r新版的vue和目前的elementui不匹配，替换了新的vue的cdn（vue2），重新渲染出时间线\r\r考研加油！！\r\r更新了较多内容，暂且称它为V2.2\r增加了雪花效果\r找了好久的live2d模型，单击换装，双击换人\r修改了音乐分区，增加了番剧分区和游戏分区，并且合并，搞了特定的背景图\r删除之前的“语言选择”\r更改了导航栏选项的tooltip\r利用接口修改css和js，更高效地部署网站，感谢github上的老哥完美解决我的问题\r\r更新了网址，旧网址的重定向以后再搞\r\r“城镇手指”玩得是越来越烂了\r\r新出游戏：极限国度、地平线5。拿到奖学金就买，拿不到就算了\r\r接下来我该做什么\r\r行，我顺利回校了\r\r后天能顺利回校吗😟\r\r更新了tf-idf，属于是不知道要更新什么\r\r暂时不知道要更新什么，就每天做一道题吧\r\r更新了网站重启的公告\r\r更新了linux相关\r\r更新了一些好玩的游戏\r\r更新了相机模型和非线性优化\r\r更新了两个题\r\r更新了一个可以用状态压缩dp或dfs暴搜的题目，更新了hhucpc的部分代码，明天开始玩cyberpunk2077 复习编译原理\r\r更新了cf 688 div2 a~d\r\r好久没打牌了，不得不感叹六武众没连得起来还是别打了，剑斗兽也太离谱了，高攻防又能连锁，不能再玩了，要写汇编了\r\r记录一下网站的bug 1.footer不能正常显示。 2.顶部导航栏的走马灯会吞并右边的字。 3.代码块有一些合法的括号序列无法正常显示。 4.latex的转义字符通常不能很好地识别（写了个转换程序，目前没问题）。 5.移动端不能很好地适配。 6.云盘还没开发。 7.简体中文那边懒得写副本。 8.live2d模型没有渲染成功。 其实还有很多的bug，由于技术太弱以及没时间，这些bug和想法不知道要鸽到什么时候\r\r更新了abc184，很久才补完题，真的没时间，明天要考微机实验，害怕\r\r想整活又没技术，满脑子想法\r\r目前由于使用框架，夜间模式不会同步，以后再解决这个bug吧\r\r今天晚上又浪费了一晚上的时间，只做了微机实验报告，明明还有那么多事情要做啊，我学不完了\r\r蓝色图标是随便写写的，绿色图标是网站更新的内容\r\r这是一个随想分区，很早就想整活，但是没时间整，晚上因为不想学习，所以随意整了个界面，和自己真正想要做的还差很多，这个是在md中直接用elementui，等到有时间在认真搞吧（什么时候能有时间，elementui还是用的cdn\r\r这是一个随想分区，很早就想整活，但是没时间整，晚上因为不想学习，所以随意整了个界面，和自己真正想要做的还差很多，这个是在md中直接用elementui，等到有时间在认真搞吧（什么时候能有时间，elementui还是用的cdn\r\r\r\r\r\r\rnew Vue({\rel: '#app',\rdata: function() {\rreturn {\r};\r}\r})\r\r","date":"2020-02-26","objectID":"/life/:0:0","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"music","date":"2020-02-26","objectID":"/music/","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"Funky =================================================================== =================================================================== ","date":"2020-02-26","objectID":"/music/:1:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"Anime =================================================================== ","date":"2020-02-26","objectID":"/music/:2:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"轻音乐 =================================================================== ","date":"2020-02-26","objectID":"/music/:3:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"热歌榜 =================================================================== ","date":"2020-02-26","objectID":"/music/:4:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"Billboard榜 ","date":"2020-02-26","objectID":"/music/:5:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"poppin","date":"2020-02-26","objectID":"/poppin/","tags":null,"title":"Poppin","uri":"/poppin/"},{"categories":null,"content":"\r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r","date":"2020-02-26","objectID":"/poppin/:0:0","tags":null,"title":"Poppin","uri":"/poppin/"},{"categories":null,"content":"keshe","date":"2020-02-26","objectID":"/keshe/","tags":null,"title":"课设测试（临时）","uri":"/keshe/"},{"categories":null,"content":"\r\rel-button {circle:true}\r\r\r\r 实验一\r\r实验二\r\r实验三\r\r实验四\r\r实验五\r\r清空\r\r例子\r\r\r \r\r\r\r\rvar Main = {\rdata() {\rreturn {\rtextarea1: '',\rtextarea2: ''\r}\r}\r}\rvar Ctor = Vue.extend(Main)\rnew Ctor().$mount('#app')\rfunction func(){\rvar tmp = document.getElementById('qwe');\rvar str = tmp.value;\rvar fstr = '';\r// tmp = document.getElementById('zxc');\r// tmp.value = str;\rfunction do_word(s) {\rfstr += '(';\rfstr += dict[s];\rfstr += ', ';\rfstr += s;\rfstr += ') ';\r}\rfunction do_id(s) {\rfstr += '(';\rfstr += 10;\rfstr += ', ';\rfstr += s;\rfstr += ') ';\r}\rfunction do_num(s) {\rfstr += '(';\rfstr += 11;\rfstr += ', ';\rfstr += s;\rfstr += ') ';\r}\rfunction do_symbol(s) {\rfstr += '(';\rfstr += dict[s];\rfstr += ', ';\rfstr += s;\rfstr += ') ';\r}\rfunction contains(arr, obj) {\rvar i = arr.length;\rwhile (i--) {\rif (arr[i] === obj) {\rreturn true;\r}\r}\rreturn false;\r}\rvar dict = {'begin' : 1, 'if' : 2, 'then' : 3, 'while' : 4, 'do' : 5, 'end' : 6,\r'+' : 13, '-' : 14, '*' : 15, '/' : 16, ':' : 17, ':=' : 18,\r'' : 21, '' : 23, '=' : 24, '=' : 25, ';' : 26,\r'(' : 27, ')' : 28, '#' : 0};\rvar word = new Array('begin', 'if', 'then', 'while', 'do', 'end');\rvar i = 0;\rwhile(str[i] != '#'){\rvar ch = str[i];\rif(ch == ' '){\ri++;\rcontinue;\r}\rif((ch = 'a' \u0026\u0026 ch = 'A' \u0026\u0026 ch = 'a' \u0026\u0026 ch = 'A' \u0026\u0026 ch = '0' \u0026\u0026 ch = '0' \u0026\u0026 ch = '0' \u0026\u0026 ch '){\rtmp_str = '';\ri++;\r}else if(str[i] == '' \u0026\u0026 str[i + 1] == '='){\rtmp_str= '=';\ri++;\r}else tmp_str = ch;\rdo_symbol(tmp_str);\ri++;\r}\r}\rfstr += '(0, #)';\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\r}\r//----------------------------------------------------------------------------------------\rfunction func2() {\rvar tmp = document.getElementById('qwe');\rvar str = tmp.value;\rvar fstr = '';\rvar st_lex = [];\rvar st_tok = [];\rconst NUM = 256, DIV = 257, MOD = 258, ID = 259, DONE = 260, NONE = -1, EOSTR = '\\0';\rconst BUF_SIZE = 100, SYM_SIZE = 200;\rvar lookahead, lineno = 1, tokenval = NONE;\rvar lexbuf = '';\rvar I = 0;\rvar eflag = false;\rvar estr = '';\rfunction emit(type, tval) {\rswitch (type) {\rcase '+':\rcase '-':\rcase '*':\rcase '/':\rfstr += type;\rbreak;\rcase DIV:\rfstr += 'div';\rbreak;\rcase MOD:\rfstr += 'mod';\rbreak;\rcase NUM:\rfstr += tval;\rbreak;\rcase ID:\rfstr += st_lex[tval];\rbreak;\rdefault:\rreturn;\r}\r}\rfunction error(s) {\rfstr += 'line ' + lineno + ': ' + s + '\\n';\reflag = true;\restr = fstr;\r//add a teiminate statement\rtmp = document.getElementById('zxc');\rtmp.value = fstr;\r//alert('qqq');\rthrow new Error ('error');\r}\rfunction insert(s, num) {\rif(st_lex.length = SYM_SIZE){\rerror('symbol table full');\r}\rst_lex.push(s);\rst_tok.push(num);\r}\rfunction init() {\rinsert('', 0);\rinsert('div', DIV);\rinsert('mod', MOD);\r}\rfunction lookup(s) {\rfor(var i = 1; i = '0' \u0026\u0026 tmp = '0' \u0026\u0026 tmp = 'a' \u0026\u0026 tmp = 'A' \u0026\u0026 tmp = 'a' \u0026\u0026 tmp = 'A' \u0026\u0026 tmp = '0' \u0026\u0026 tmp = BUF_SIZE){\rerror('the length of identifier is too long');\r}\r}\rif(tmp != '#'){\rI--;\r}\rpos = lookup(lexbuf);\rif(pos == 0){\rinsert(lexbuf, ID);\rtokenval = st_lex.length - 1;\rreturn ID;\r}else if(st_lex[pos] == 'div' || st_lex[pos] == 'mod'){\rif(st_lex[pos] == 'div'){\rtokenval = DIV;\rreturn DIV;\r}else {\rtokenval = MOD;\rreturn MOD;\r}\r}else {\rtokenval = pos;\rreturn ID;\r}\r}else if(tmp == '#'){\rreturn DONE;\r}else{\rtokenval = NONE;\rreturn tmp;\r}\r}\r}\rfunction match(x) {\rif(lookahead == x){\rlookahead = lex();\r}else error('syntax error');\r}\rfunction factor() {\rswitch (lookahead) {\rcase '(':\rmatch('(');\rexpress();\rmatch(')');\rbreak;\rcase NUM:\remit(NUM, tokenval);\rmatch(NUM);\rbreak;\rcase ID:\remit(ID, tokenval);\rmatch(ID);\rbreak;\rdefault:\rerror('syntax error');\r}\r}\rfunction term() {\rvar tmp;\rfactor();\rwhile(true){\rswitch (lookahead) {\rcase '*':\rcase '/':\rcase DIV:\rcase MOD:\rtmp = lookahead;\rmatch(lookahead);\rfactor();\remit(tmp, NONE);\rcontinue;\rdefault:\rreturn ;\r}\r}\r}\rfunction express() {\rvar tmp;\rterm();\rwhile (true){\rswitch (lookahead) {\rcase '+':\rcase '-':\rtmp = lookahead;\rmatch(lookahead);\rterm();\remit(tmp, NONE);\rcontinue;\rdefault:\rreturn ;\r}\r}\r}\rfunction parse() {\rlookahead = lex();\rwhile (lookahead != DONE){\rexpress();\rmatch(';');\rf","date":"2020-02-26","objectID":"/keshe/:0:0","tags":null,"title":"课设测试（临时）","uri":"/keshe/"},{"categories":["note"],"content":"二进制表示集合","date":"2020-02-24","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/","tags":["cpp","binary"],"title":"二进制表示集合","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/"},{"categories":["note"],"content":"以二进制的原理表示集合，以整数呈现 1表示在集合内，0表示不在集合内 一位运算优先于按位逻辑运算 空集 0 只含有第i个元素的集合{i} 1«i 含有全部n个元素的集合 {0,1,2,…n-1} (1«n) - 1 判断第i个元素是否属于集合S if ( s»i \u0026 1 ) 原来的集合变了 向集合中加入第i个元素 S∪{i} S|1«i 从集合中去除第i个元素 S{i} S\u0026~(1«i) 集合S和T的并集 S|T 集合S和T的交集 S\u0026T 按顺序枚举集合的子集 for(int S=0;S\u003c1\u003c\u003cn;S++)\r 枚举某个集合sup的子集 int sub=sup;\rdo\r{\rsub=(sub-1)\u0026sup;\r}while(sub!=sup); //处理完0之后，会有-1\u0026sup=sup 枚举{0,1,2,…n-1}所包含的大小为k的子集 int comb=(1\u003c\u003ck)-1;\rwhile(comb\u003c1\u003c\u003cn)\r{\rint x=comb \u0026 -comb , y=comb+x;\rcomb=((comb \u0026 ~y) / x\u003e\u003e1) | y;\r}\r ","date":"2020-02-24","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/:0:0","tags":["cpp","binary"],"title":"二进制表示集合","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/"},{"categories":["algorithm"],"content":"Number Theory","date":"2020-02-22","objectID":"/number-theory/","tags":["cpp","number_theory"],"title":"Number Theory","uri":"/number-theory/"},{"categories":["algorithm"],"content":"求最大公约数和最小公倍数 辗转相除法 时间复杂度O(log(max(a,b))) int gcd(int a,int b)\r{\rif(b==0) return a;\relse return gcd(b,a%b);\r}\rint lcm(int a,int b)\r{\rreturn a*b/gcd(a,b);\r}\r 或直接调用algorithm库中的__gcd(int a,int b) 扩展欧几里得算法 求满足 ax+by=gcd(a,b) 的整数解 x ，y 时间复杂度O(log(max(a,b))) int ex_gcd(int a,int b,int\u0026 x,int\u0026 y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\r  埃氏筛质数 时间复杂度O(nloglogn) int prime[maxn]; //ith prime number\rbool isprime[maxn+1] //is i a prime number\rint e_sieve(int n)\r{\rint p=0; //position\r for(int i=0;i\u003c=n;i++) isprime[i]=true; //initialize\r isprime[0]=isprime[1]=false;\rfor(int i=2;i\u003c=n;i++)\r{\rif(isprime[i])\r{\rprime[p++]=i;\rfor(int j=2*i;j\u003c=n;j+=i) isprime[j]=true;\r}\r}\rreturn p;\r}\r 欧拉筛质数 时间复杂度O(n) int prime[maxn];\rbool isprime[maxm];\rvoid get_prime(int n){\rmemset(isprime, 1, sizeof(isprime));\risprime[0] = false;\risprime[1] = false;\rint cnt = 0;\rfor(int i = 2; i \u003c n; ++i){\rif(isprime[i]){\rprime[++cnt] = i;\r}\rfor(int j = 1; j \u003c= cnt and i * prime[j] \u003c n; ++j){\risprime[i * prime[j]] = false;\rif(i % prime[j] == 0) break; //最关键的一句\r }\r}\r}\r  数论的一些性质 Premise: a≡c (mod m) and b≡d (mod m) Conclusion: a±b≡c±d (mod m) a*b≡c*d (mod m) d|a \u0026\u0026 d|b ⇒ d|gcd(a,b) gcd(an,bn) = n*gcd(a,b) 任意正整数n，n|ab \u0026\u0026 a,n互质 ⇒ n|b a,p 互质 ， b,p互质 ⇒ ab,p互质 任意一个合数都可以分解成唯一的质数幂积的形式，即 $$ a=\\prod\\limits_{i=1} ^ {n} {pi ^ ei} $$ 因子个数为 $$ \\sum\\limits_{i=1} ^ {n} {(1+e_i)} $$ 积性函数 f(ab) = f(a)f(b) 欧拉函数 莫比乌斯函数 gcd 狄利克雷函数  快速幂 时间复杂度O(logn) typedef long long ll;\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\r  逆元 $$ 逆元\\quad y=a^{-1}\\quad满足\\quad ay≡1(mod\\ m) ~\\ y为a在模m下的逆元 $$ $$ 对于\\quad ax≡b(mod\\ m) ~\\ x=a^{-1}*b $$ 求逆元 $$ ax≡1(mod\\ m) ~\\ ax-mk=1 ~\\ ax+my=1 ~\\ ax+my=gcd(a,m) ~\\当a,m不互质的时候，逆元不存在 $$ int mod_inverse(int a,int m)\r{\rint x,y;\rex_gcd(a,m,x,y);\rreturn (m+x%m)%m;\r}  线性时间内预处理逆元 inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\r 欧拉函数 设 $$ \\quad n =\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} ~\\ $$ 则欧拉函数 $$ \\quad φ(n)=n*\\prod\\limits_{i=1} ^ {n} {\\frac{p_i-1}{p_i}} $$ 欧拉函数的数值等于不超过n且与n互质的数的个数 欧拉函数的数值等于不超过n且与n互质的数的个数 当n时质数时，φ(n)=n-1 如果n=p^k , φ(n)=p^k - p^(k-1) = (p-1)p^(k-1) 如果m,n互质，则φ(mn)=φ(m)φ(n) φ(n)的值都为偶数，φ(2)除外 质因子之和 (φ(n)*n)/2 欧拉定理 $$ 当a,m互质时 ~\\ a^{φ(m)}≡1(mod \\ m) $$ 费马小定理 $$ 当p是质数时， 对任意整数x 都有 ~\\ x^p≡x(mod \\ p) ~\\~\\ 当x,p互质时 ~\\ x^{p-1}≡1(mod \\ p) ~\\ 这就是欧拉定理的特殊形式 $$ 求欧拉函数 时间复杂度O(√(n)) 求欧拉函数值的表，类似于埃氏筛，时间复杂度O(n) int phi(int n)\r{\rint res=n;\rfor(int i=2;i*i\u003c=n;i++)\r{\rif(n%i==0)\r{\rres=res/i*(i-1);\rwhile(n%i==0) n/=i;\r}\r}\rif(n!=1) res=res/n*(n-1);\rreturn res;\r}\rint euler_phi[maxn];\rvoid phi_arr()\r{\rfor(int i=0;i\u003cmaxn;i++) euler_phi[i]=i;\rfor(int i=2;i\u003cmaxn;i++)\r{\rif(euler_phi[i]==i)\r{\rfor(int j=i;j\u003cmaxn;j+=i) euler_phi[j]=euler_phi[j]/i*(i-1);\r}\r}\r}\r  线性同余方程组 $$ a_ix≡b_i(mod \\ m_i) $$ 如果方程组有解，一定有无穷多解 解的全集可以写成 x≡b(mod m) 所以将问题转化为求b,m 可以对如下方程组依次求解 $$ x≡b_1(mod \\ m_1) ~\\ ax≡b_2(mod\\ m_2) $$ $$ x≡b_1(mod \\ m_1) ~\\ x=b_1+m_1t ~\\a(b_1+m_1t)≡b_2(mod\\ m_2) ~\\am_1t≡b_2-ab_1(mod \\ m_2) ~\\a’t≡b’(mod \\ m_2) $$ 当gcd(m₂,am₁)与b₂-ab₁互质时，方程组无解 时间复杂度O(n) pair\u003cint,int\u003e linear_congruence(const vector\u003cint\u003e\u0026 A,const vector\u003cint\u003e\u0026 B,const vector\u003cint\u003e\u0026 M)\r{\r//最开始没有限制，把解设为所有整数 x ≡0(mod 1)\r int x=0,m=1;\rfor(int i=0;i\u003cA.size();i++)\r{\rint a=A[i]*m , b=B[i]-A[i]*x , d=gcd(M[i],a); //d!!!\r if(b%d!=0) return make_pair(0,-1); //无解\r int t=b / d * mod_inverse(a/d,M[i]/d) % (M[i]/d) ;\rx=x+m*t;\rm*=M[i]/d; //*= !!!\r }\rreturn make_pair(x%m,m);\r}\r  中国剩余定理(CRT) crt是线性同余方程组ai=0，mi互质的特殊形式 这时，x≡b(mod Πmi) crt的思想是余数的加性和模数的乘性，当模数为合数时，可以拆成质因数的积 crt定理如下 $$ 对于x≡b_i(mod \\ m_i) \\ \\ \\ \\ \\ \\ m_i互质 ~\\ ~\\令M=\\prod{m_i} ~\\M_i=\\frac{M}{m_i} ~\\M_i ^ {-1} 为M_i模m_i的逆元 ~\\ 则 \\ x≡(\\sum\\limits_{i=1} ^ {n} {b_iM_iM_i ^{-1}}) \\ (mod \\ M) $$ // x=x+(Πmi)*t\r//return minimum int crt(const vector\u003cint\u003e\u0026 b,const vector\u003cint\u003e \u0026m)\r{\rint M=1,x=0;\rfor(int i=0;i\u003cm.size();i++) M*=m[i];\rfor(int i=0;i\u003cm.size();i++){\rint Mprime=M/m[i];\rint M_p_i=mod_inverse(Mprime,m[i]);\rx=(x + b[i] * Mprime * M_p_i)%M;\r}\rretu","date":"2020-02-22","objectID":"/number-theory/:0:0","tags":["cpp","number_theory"],"title":"Number Theory","uri":"/number-theory/"},{"categories":["algorithm","hduoj"],"content":"hduoj2089(数位dp + 记忆化搜索)","date":"2020-02-20","objectID":"/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"categories":["algorithm","hduoj"],"content":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input 输入的都是整数对n、m（0\u003cn≤m\u003c1000000），如果遇到都是0的整数对，则输入结束。 Output 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input 1 100 0 0 Sample Output 80 Solution 与数位的组成有关，可以用数位dp。 利用前缀即 solve(m)-solve(n-1) dp[i][j] 表示 符合条件的个数[当前操作的数位(倒序排)][当前操作的数位的前一个数] $$ dp[pos][pre] = \\sum\\limits_{i=0} ^ {maxd} dp[pos-1][i] $$ maxd可以由一个boolean变量limit控制，是否是9还是dig[pos] 为了不重复计算（重复计算也可以），可以用记忆化搜索，也就是可以利用计算好的dp。为了使dp普适，dp必须是稳定，经全搜索得到的（即maxd=9）。所以通过limit控制dp的存储和dp的读取 通过dp递推式，可以用dfs实现（理论上来说可以不用dfs，但不能记忆化且dp可能要增加维度，且要特殊初始化。没有实践过，有时间可以去试试） int dfs(int pos,int pre,bool limit) 通过limit和返回值来使dp结果普适 AC代码如下 #include\u003ciostream\u003e\r#include\u003ccstring\u003e\rusing namespace std;\rint n,m;\rint dp[10][10]; //dp[i][j] i:总共有i位 , j:前导数字为j , dp:满足条件（不含4和62）的个数 int dig[10];\rint dfs(int pos,int pre,bool limit) //pos 当前位置 ， pre 当前位置的前一个数字 {\rif(pos==-1) return 1; //只有0（1个数字）满足\r if(dp[pos][pre]!=-1 \u0026\u0026 !limit) return dp[pos][pre]; //已经搜索过则直接返回 //!!!!\r int ans=0;\rint maxd;\rif(limit) maxd=dig[pos];\relse maxd=9;\rfor(int i=0;i\u003c=maxd;i++)\r{\rif(i==4 || (pre==6 \u0026\u0026 i==2)) ;\relse ans+=dfs(pos-1,i,limit \u0026\u0026 i==dig[pos]); //这里需要传limit !!!!!!!!!! }\rif(!limit) //只有在全搜索的时候才能给dp赋值，这样可以保证dp适用于所有情况，从而实现记忆化搜素 dp[pos][pre]=ans;\rreturn ans;\r}\rint solve(int x)\r{\rint len=0;\rwhile(x)\r{\rdig[len++]=x%10;\rx/=10;\r}\rreturn dfs(len-1,0,1);\r} int main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r memset(dp,-1,sizeof(dp)); //不需要每次都初始化，因为要记忆化搜索 //不需要对dp特殊初始化，因为dfs中有return 1 while(scanf(\"%d%d\",\u0026n,\u0026m)==2 \u0026\u0026 (n || m))\r{\rcout\u003c\u003csolve(m)-solve(n-1)\u003c\u003cendl;\r}\rreturn 0;\r} 第一次写数位dp，参考了别人的代码，也调试了很久，思考了很多，才弄懂其中的细节 ","date":"2020-02-20","objectID":"/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/:0:0","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"categories":["algorithm","nowcoder"],"content":"Segment Tree","date":"2020-02-20","objectID":"/segment-tree/","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"/segment-tree/"},{"categories":["algorithm","nowcoder"],"content":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树 用一个例子来介绍线段树 RMQ（range minimum query） 实现功能 对于一个数列 1.给定s,t求[s,t)区间的最小值（最大值） 2.给定i和x,把ai改成x const int maxn = 1\u003c\u003c17;\rint n,dat[2*maxn+1];\rvoid init(int n_)\r{\r//为了计算方便,把元素个数扩大到2的幂次方的个数\r n=1;\rwhile(n\u003cn_) n*=2;\rfill(dat,dat+2*n-1,inf);\r}\r//将从0开始的第k个值，改成a void update(int k,int a)\r{\rk+=n-1;\rdat[k]=a;\r//向上更新\r while(k\u003e0)\r{\rk=(k-1)/2;\rdat[k]=min(dat[2*k+1],dat[2*k+2]);\r} }\r//求[a,b)区间的最小值(从0开始数)\r//后面的参数是为了计算方便传入的\r//k是节点编号，l，r是k节点对应的区间\r//在外部调用是用query(a,b,0,0,n)\rint query(int a,int b,int k,int l,int r)\r{\rif(r\u003c=a || b\u003c=l) return inf;\rif(a\u003c=l \u0026\u0026 r\u003c=b) return dat[k];\relse\r{\rint vl=query(a,b,2*k+1,l,(l+r)/2);\rint lr=query(a,b,2*k+2,(l+r)/2,r);\rreturn min(vl,vr);\r}\r} 初始化的时间复杂度O(n) 更新和查询的时间复杂度O(logn) 如果dat以1开头，则可以利用这些性质 \u003e\u003e1 : /2取整 «1 : 乘2 «1|1 : (*2+1) 以这题为例 给出一个长度为 n 的数列，a1,a2,…,an,求其长度为 k 的连续子段的乘积对 998244353 取模余数的最大值。 solution:这道题可以用尺取法、线段树、逆元 线段树的做法不需要update函数，最底层存每个数，父节点存子节点的乘积，最后query每一段区间 AC代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rconst ll mod = 998244353;\rll n_,k;\rll n;\rll dat[4*200005+2];\r//[a,b)\rll query(ll a ,ll b,ll k,ll l,ll r)\r{\rif(r\u003c=a || b\u003c=l) return 1;\rif(a\u003c=l \u0026\u0026 r\u003c=b) return dat[k];\rreturn (query(a,b,k*2+1,l,(l+r)/2) * query(a,b,k*2+2,(l+r)/2,r))%mod;\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r scanf(\"%lld%lld\",\u0026n_,\u0026k);\rn=1;\rwhile(n\u003cn_) n*=2;\rfor(ll i=n-1;i\u003cn_-1+n;i++)\r{\rscanf(\"%lld\",\u0026dat[i]);\r}\rfor(ll i=n-2;i\u003e=0;i--)\r{\rdat[i]=(dat[i*2+1]*dat[i*2+2]) % mod;\r}\rll ans=-1;\rfor(ll i=0;i+k\u003c=n_;i++)\r{\rans=max(ans,query(i,i+k,0,0,n));\r}\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r}\r 有几个点导致WA 1.要用long long 不能用int 2.dat的的大小要用4乘，否则会断错误，因为在query时，最底层的也有可能访问子节点 边界条件是线段树容易出错的地方，以上代码的区间是左闭右开，在判断条件里面用等号注意n_和n的使用 线段树的lazy思想 参考这里 =========================================================================================================== 在这里补一个线段树板子 支持区间加、区间乘、区间求和、区间求平方和 如果求最值可以用上面那个模板 这个模板还没有融合进去 其实线段树的基本操作就是区间查询和区间更新，其他的操作都可以通过两个基本的区间加（区间求最值）、区间求和操作转化 平方和就是通过等式转化、类似地还可以求立方和、不过四次方应该会很麻烦 测板子题 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst int maxn = 10005;\rstruct tnode{ ll w,l,r,siz,alazy;\rll sq,mlazy=1;\r}tn[maxn\u003c\u003c2]; ll n,m;\rconst ll mod = 0x3f3f3f3f3f3f3f3f;\rll wt[maxn];\rvoid pushup(ll u){ tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod;\rtn[u].sq = (tn[u\u003c\u003c1].sq + tn[u\u003c\u003c1|1].sq) % mod;\r}\rvoid build(ll u,ll l,ll r){ tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[l]; tn[u].sq = wt[l] * wt[l];\rreturn ;\r}\rll mid = (l+r) \u003e\u003e 1;\rbuild(u\u003c\u003c1 , l , mid); build(u\u003c\u003c1|1 , mid+1 , r);\rpushup(u); }\rvoid pushdown(ll u){ if(tn[u].alazy != 0 or tn[u].mlazy != 1){\rtn[u\u003c\u003c1].sq = ((tn[u\u003c\u003c1].sq + 2LL * tn[u\u003c\u003c1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1].siz % mod) % mod; tn[u\u003c\u003c1|1].sq = ((tn[u\u003c\u003c1|1].sq + 2LL * tn[u\u003c\u003c1|1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1|1].siz % mod) % mod;\rtn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1].siz * tn[u].alazy % mod) % mod;\rtn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1|1].siz * tn[u].alazy % mod) % mod;\rtn[u\u003c\u003c1].alazy = (tn[u\u003c\u003c1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u003c\u003c1|1].alazy = (tn[u\u003c\u003c1|1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod;\rtn[u\u003c\u003c1].mlazy = (tn[u\u003c\u003c1].mlazy * tn[u].mlazy) % mod;\rtn[u\u003c\u003c1|1].mlazy = (tn[u\u003c\u003c1|1].mlazy * tn[u].mlazy) % mod;\rtn[u].alazy = 0; tn[u].mlazy = 1;\r}\r}\rll query(ll u,ll l,ll r,ll t){ if(l\u003c=tn[u].l and r\u003e=tn[u].r) {\rif(t == 1) return tn[u].w;\rif(t == 2) return tn[u].sq;\r} ll ans = 0;\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1;\rif(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r , t)) % mod;\rif(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r , t)) % mod;\rreturn ans;\r}\rvoid update(ll u,ll l,ll r,ll wa,ll wm){ if(l\u003c=tn[u].l and r\u003e=tn[u].r){ tn[u].sq = ((tn[u].sq + 2LL * tn[u].w * wa % mod) % mod + wa * wa % mod * tn[u].siz % mod) % mod;\rtn[u].w = (tn[u].w * wm % mod + tn[u].siz * wa % mod) % mod;\rtn[u].alazy = (tn[u].alazy * wm % mod + wa) % mod;\rtn[u].mlazy = (tn[u].mlazy * wm) % mod;\rreturn ;\r}\rpushdown(u);","date":"2020-02-20","objectID":"/segment-tree/:0:0","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"/segment-tree/"},{"categories":["nowcoder"],"content":"牛客基础训练营5B","date":"2020-02-14","objectID":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/"},{"categories":["nowcoder"],"content":"题目在这 这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快 三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2 求mid midmid与n个点的距离，然后依据较小值缩减区间 代码如下 //三分法 最快的应该是0.618法\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rstruct point {\rdouble x,y;\r}p[100005];\rdouble eps = 5e-5;\rdouble check(double x)\r{\rdouble dist = -1;\rfor(int i=0;i\u003cn;i++)\r{\rdist = max(dist,(x-p[i].x)*(x-p[i].x) + p[i].y*p[i].y); }\rreturn sqrt(dist);\r}\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\rscanf(\"%lf %lf\",\u0026p[i].x,\u0026p[i].y);\rdouble l = -10000.0;\rdouble r = 10000.0;\rwhile(r-l\u003eeps)\r{\rdouble mid = l + (r -l)/2; //这里的三分\r double midmid = mid+(r-mid)/2;\rif(check(mid)\u003echeck(midmid)) l=mid;\relse r=midmid;\r}\rprintf(\"%.5lf\\n\",check(l));\rreturn 0;\r}\r ","date":"2020-02-14","objectID":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/:0:0","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/"},{"categories":["algorithm"],"content":"Graph Theory","date":"2020-02-05","objectID":"/graph-theory/","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等 ","date":"2020-02-05","objectID":"/graph-theory/:0:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"链式前向星存图 struct edge{\rint to , w , next;\r}e[maxn];\rint tot,head[maxn];\rvoid add_edge(int u,int v,int w){\re[tot].to = v;\re[tot].w = w;\re[tot].next = head[u];\rhead[u] = tot++;\r}\rfor(int i=head[u];~i;i=e[i].next){\rint v = e[i].to;\rint w = e[i].w;\r}\r//init\rmemset(head , -1 , sizeof(head));\r ","date":"2020-02-05","objectID":"/graph-theory/:1:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"二分图判定 通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图 用dfs判断每个点是否可染色，如果每个点都是可染色的，就是二分图 //input\rvector\u003cint\u003e G[max_v];\rint V;\rint color[max_v] //顶点i的颜色 1或-1\r\rbool dfs(int v,int c)\r{\rcolor[v]=c; //染色\r for(int i=0;i\u003cG[v].size();i++)\r{\rif(color[v][i]==c) return false; //相邻顶点同色\r if(color[G[v][i]]==0 \u0026\u0026 !dfs(G[v][i],-c)) return false; //对于还没染色的点，如果不能染色则返回false } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=0;i\u003cV;i++)\r{\rif(color[i]==0) //还未着色//如果是连通图，遍历一次就够\r if(!dfs(i,1)) return false; }\rreturn true;\r} 把顶点和边都算的话，时间复杂度是O(|V|+|E|) ","date":"2020-02-05","objectID":"/graph-theory/:2:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"求DAG的拓扑序 求拓扑序可以dfs，删边法（通过栈或队列） 求每个点的入度，将入度为0的点入栈，遍历栈里的点，将于这些点相邻的点的入度减1，如果有点入度为0，则入栈。依靠这个顺序，得到的就是拓扑序。如果点访问两次，则有圈。可以通过这个方法判断有向图是否有圈 //input\rvector\u003cint\u003e G[max_v]\rint V;\rint indgree[max_v] //每个顶点的入度\rvector\u003cint\u003e res; //拓扑排序的结果\r\rbool topological_sort() //判断是否能拓扑排序 ，若果有圈就不能 {\rstack\u003cint\u003e s;\r//int counter=0; //遍历的点的个数 for(int i=0;i\u003cV;i++) if(indegree[i]==0) s.push(i); //入度为0 的顶点入栈\r while(!s.empty())\r{\rint v=s.top(); s.pop();\rres.push_back(v);\r//counter++;\r for(int i=0;i\u003cG[v].size();i++)\r{\rint k=G[v][i];\rif(--indegree[k] == 0) s.push(k); //遍历到的点入度间1，入度为0则入栈 }\r} if(res.size()==n) return true;\relse return false;\r}\r 时间复杂度是O(|V|+|E|) ","date":"2020-02-05","objectID":"/graph-theory/:3:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Bellman-Ford算法 求单源最短路 d[i]=min{d[j]+e(j,i)} 只要图中不存在负圈，这样的更新操作是有限的（由于最短路不会经过一个顶点两次，所以这种操作只会重复|v|-1次） 时间复杂度O(|V|*|E|) struct edge\r{\rint from,to,cost;\r}es[max_e];\rint d[max_v];\rint V,E;\rvoid bellman_ford(int s)\r{\rfor(int i=0;i\u003cV;i++) d[i]=inf; //把最短距离初始化成无限\r d[s]=0; while(true)\r{\rbool update=false; //判断while是否进行了更新操作，没有更新操作则退出循环 for(int i=0;i\u003cE;i++) //根据公式，遍历边\r {\redge e=es[i];\rif(d[e.from]!=inf \u0026\u0026 d[e.to]\u003ed[e.from]+e.cost)\r{\rd[e.to]=d[e.from]+e.cost;\rupdate=true;\r}\r}\rif(!update) break;\r}\r}\r 如果更新操作（while循环）进行了超过|V|-1次，则存在负圈 所以判断负圈的一个方法可以是 把所有d[i]都变成0，如果有负圈，则一定执行超过|V|-1次 bool find_negative_loop()\r{\rmemset(d,0,sizeof(d));\rfor(int i=0;i\u003cV;i++)\r{\rfor(int j=0;j\u003cE;j++)\r{\redge e=es[j];\rif(d[e.to]\u003ed[e.from]+e.cost)\r{\rd[e.to]\u003ed[e.from]+e.cost;\rif(i==V-1) return true; //这条语句不能放在if外，如果放在if外需要加update }\r}\r}\rreturn false; }\r ","date":"2020-02-05","objectID":"/graph-theory/:4:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Dijkstra算法 求单源最短路，适用于没有负边的情况 将已求出最短路的点，放入一个集合中 ，每次从集合外找到一个和集合距离最近的点，加入集合 int cost[max_v][max_v]; //权值，不存在时为inf\rint d[max_v];\rbool used[max_v];\rint V;\rvoid dijkstra(int s)\r{\rfill(d,d+v,inf);\rfill(used,used+v,false);\rd[s]=0;\rwhile(true)\r{\rint v=-1;\r//从尚未使用过的点中选一个距离最小的点\r for(int u=0;u\u003cV;u++)\r{\rif(!used[u] \u0026\u0026 (v==-1 || d[u]\u003cd[v])) v=u;\r} if(v==-1) break;\rused[v]=true;\rfor(int u=0;u\u003cV;u++)\rd[u]=min(d[u],d[v]+cost[v][u]); }\r} 时间复杂度O(V^2) 优化 如果将点放入优先队列中，这要查找和更新就会节省很多时间，时间复杂度O(ElgV) struct edge\r{\rint to,cost;\r}\rtypedef pair\u003cint,int\u003e pii; //first 是距离 ，second是点编号\rint V;\rvector\u003cedge\u003e G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; //使小的在上面\r fill(d,d+V,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(int i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} } ","date":"2020-02-05","objectID":"/graph-theory/:5:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Floyd-Warshall算法 求任意两点最短路，暴力枚举思想 d[i][j]=min(d[i][j],d[i][k]+d[k][j]) 遍历所有的k 时间复杂度O(V^3) int d[max_v][max_v]; //存储权值，边不存在时为inf，d[i][i]=0 int V;\rvoid floyd_warshall()\r{\rfor(k=0;k\u003cV;k++)\rfor(int i=0;i\u003cV;i++)\rfor(int j=0;j\u003cV;j++)\rd[i][j]=min(d[i][j],d[i][k]+d[k][j]);\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:6:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"路径还原 通过找满足d[j]=d[k]+cost[k][j]的顶点k，来寻找前趋节点，不断寻找前趋节点来还原路径，时间复杂度O(E) 还可以用prev[j]在算法内直接记录前趋节点，最后遍历数组即可，时间复杂度O(V) //算法内记录前趋节点 (优化的dijkstra算法)\rint prev[max_v] //前趋节点\rstruct edge\r{\rint to,cost;\r}\rtypedef pair\u003cint,int\u003e pii; //first 是距离 ，second是点编号\rint V;\rvector\u003cedge\u003e G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; //使小的在上面\r fill(d,d+V,inf);\rfill(prev,prev+V,-1); //!!!! d[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(int i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rprev[e.to]=v; //!!!!\r q.push(pii(d[e.to],e.to));\r}\r}\r} }\rvector\u003cint\u003e get_path(int t)\r{\rvector\u003cint\u003e path;\rfor(;t!=-1;t=prev[t]) path.push_back(t);\rreverse(path.begin(),path.end());\rreturn path;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:7:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Prim算法 求最小生成树 prim算法和dijkstra算法很像，也是把已确定的点放入一个集合中，贪心地选取集合和未确定的点相连的最小权边，并加入到集合中，得到一棵生成树，可以证明是MST(minimum spanning tree) //也可以堆优化 int cost[max_v][max_v] //权值\rint mincost[max_v]; //从集合出发到其他点的最小权值,!!!这个权值是 集合 和 点 之间的 bool used[max_v]; //是否在集合中\rint V;\rint prim() //返回MST的权值\r{\rfill(mincost,mincost+V,inf); //初始化 fill(used,used+V,false);\rmincost[0]=0; //从0开始 int res=0;\rwhile(true)\r{\rint v=-1;\rfor(int u=0;u\u003cV;u++)\r{\rif(!used[u] \u0026\u0026 (v==-1 || mincost[u]\u003cmincost[v])) v=u;\r}\rif(v==-1) break;\rused[v]=true;\rres+=mincost[v];\rfor(int u=0;u\u003cV;u++)\r{\rmincost[u]=min(mincost[u],cost[v][u]); //每次往集合中加入一个点，所有点的mincost都有可能改变 }\r}\rreturn res; } 时间复杂度与dijkstra算法一样 ","date":"2020-02-05","objectID":"/graph-theory/:8:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Kruskal算法 求MST 将边的权值按大小排序，如果不产生圈和重边，就依次把边加入到生成树中 要判断是否产生圈和重边，只需要判断加入这条边前，这条边的两个端点是否已在同一个连通分量里，这样就可以用并查集 Kruskal在边的排序上最费时，算法复杂度O(ElgV) Kruskal适用于sparse graph Prim适用于dense graph 在实际应用中，Kruskal更普遍 struct edge\r{\rint u,v,cost;\r}es[max_e];\rint V,E;\rint par[max_v]; //union find需要 int rankk[max_v]; //key word \"rank\"\rbool cmp(const edge\u0026 e1,const edge\u0026 e2)\r{\rreturn e1.cost\u003ce2.cost;\r}\rvoid init_union_find(int x)\r{\rfor(int i=0;i\u003cx;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x)\rreturn x;\relse\rreturn par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return;\rif(rankk[x]\u003crankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint kruskal()\r{\rsort(es,es+E,cmp);\rinit_union_find(V);\rint res=0;\rfor(int i=0;i\u003cE;i++)\r{\redge e=es[i];\rif(!same(e.u,e.v))\r{\runite(e.u,e.v);\rres+=e.cost;\r}\r}\rreturn res;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:9:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Kosaraju算法 强连通分量(strongly connected component)分解高效的算法有kosaraju算法， tarjan算法，gabow算法 kosaraju算法通过随便选一点dfs，给点标号 把边的方向反过来，再一次dfs 由于在强连通分量中的点，其可达性不受边反向的影响 所以最后需独立进行k次搜索 即分裂出k个强连通分量 时间复杂度 O(V+E) //kosaraju int V; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv];\rvector\u003cint\u003e vs; //后序遍历顺序的顶点列表（标号） bool used[maxv]; //是否访问 int cmp[maxv]; //所属强连通分量的拓扑序（序号） \rvoid add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u003cG[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u003crG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u003cV;i++) if(!used[i]) dfs(i);\rmemset(uesd,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:10:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Tarjan算法 （scc部分） 求scc的tarjan算法是给一个点赋上两个属性 dfn low分别表示dfs的访问时间和该点可追踪到的最小访问时间 dfs过程中先访问自己，再访问邻接点，最后对自己进行操作 在访问自己时，将两个属性初始化为当前时间，并且进栈 接下来访问未被访问过的邻接点，并且更新low属性 如果已被访问过且在栈里也更新low属性 最后对自己的操作就是判断dfn 和 low是否相等 相等说明它是连通块的头，已经无法再更新了 这时候不断出栈直到自己也出栈 总的操作就是遍历每个点，没访问就dfs tarjan算法和kosaraju算法有点类似，都是利用了反向边的性质，本质上是强连通分量中反向边的可达性，依此对每个点都最小化点的属性，而属性选择dfs序较高效 tarjan算法要dfs一次，邻接表的时间复杂度是 O(V+E) 求连通块的出度和入度就是判断原本连接的两个点是否在同一个强连通分量中 int V;\rvector\u003cint\u003e G[maxv];\rint dfn[maxv],low[maxv],cmp[maxv];\rbool in_stack[maxv];\rstack\u003cint\u003e s;\rint tim;\rint num=0; //最后的num是连通块数量 int in[maxv];\rint out[maxv];\rvoid tarjan_dfs(int x){\rdfn[x] = low[x] = ++tim;\rs.push(x);\rin_stack[x] = true;\rfor(int i=0;i\u003cG[x].size();i++){\rint to = G[x][i];\rif(dfn[to] == 0){\rtarjan_dfs(to);\rlow[x] = min(low[x] , low[to]);\r}\relse if(in_stack[to]){\rlow[x] = min(low[x] , low[to]);\r}\r}\rint tmp;\rif(dfn[x] == low[x]){\rdo{\rtmp = s.top();\rcmp[tmp] = num;\rs.pop();\rin_stack[tmp] = false;\r}while(tmp != x);\rnum++;\r}\r}\rvoid tarjan_scc(){\rfor(int i=0;i\u003cV;i++){\rif(!dfn[i]){\rtarjan_dfs(i);\r}\r}\r}\rvoid in_out_d(){\rfor(int i=0;i\u003cV;i++){\rfor(int j=0;j\u003cG[i].size();j++){\rint to = G[i][j];\rif(cmp[i] != cmp[to]){\rin[cmp[to]]++;\rout[cmp[i]]++;\r}\r}\r}\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:11:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Tarjan算法 （割点、桥部分） 利用dfn和low判定割点和桥，注意更新 int V;\rvector\u003cint\u003e G[maxv];\rint dfn[maxv],low[maxv],cmp[maxv];\rbool in_stack[maxv];\rstack\u003cint\u003e s;\rint tim;\rint num=0; //最后的num是连通块数量 set\u003cint\u003e cut;\rint Rchild;\rint cnt_root;\rset\u003cpair\u003cint,int\u003e\u003e bridge; void tarjan_dfs(int x,int p){\rdfn[x] = low[x] = ++tim; s.push(x);\rin_stack[x] = true;\rfor(int i=0;i\u003cG[x].size();i++){\rint to = G[x][i];\rif(to != p){\rif(dfn[to] == 0){\rif(x == cnt_root) Rchild++;\rtarjan_dfs(to , x);\rlow[x] = min(low[x] , low[to]);\rif(x != cnt_root and low[to] \u003e= dfn[x]) cut.insert(x); //不是根，求割点 if(low[to] \u003e dfn[x]) bridge.insert({min(x,to),max(x,to)}); //求桥 }\relse if(in_stack[to]){\rlow[x] = min(low[x] , dfn[to]); //注意这里是dfn，而不是求scc的low }\r}\r}\rint tmp;\rif(dfn[x] == low[x]){\rdo{\rtmp = s.top();\rcmp[tmp] = num;\rs.pop();\rin_stack[tmp] = false;\r}while(tmp != x);\rnum++;\r}\r}\rvoid tarjan_scc(){\rfor(int i=0;i\u003cV;i++){\rif(!dfn[i]){\rcnt_root = i;\rRchild = 0;\rtarjan_dfs(i,-1);\rif(Rchild \u003e 1) cut.insert(cnt_root); //是根，求割点 }\r}\r}\r 割点的模板测试 这个题的数据好像有森林 桥的模板测试 ","date":"2020-02-05","objectID":"/graph-theory/:12:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"LCA 大致的做法就是直接法，直接向上追溯 对于多次查询通过跳级预处理，利用二分的思想 单次查询，O(n) vector\u003cint\u003e G[maxv];\rint root;\rint parent[maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[v] = p;\rdepth[v] = d;\rfor(int i=0;i\u003cG[v].size();i++){\rif(G[v][i] != p) dfs(G[v][i] , v , d+1);\r}\r}\rvoid init(){\rdfs(root , -1 , 0);\r}\rint lca(int u,int v){\rwhile(depth[u] \u003e depth[v]) u = parent[u];\rwhile(depth[v] \u003e depth[v]) v = parent[v];\rwhile(u != v){\ru = parent[u];\rv = parent[v];\r}\rreturn u;\r}\r 多次查询 O(nlogn) vector\u003cint\u003e G[maxv];\rint root;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i=0;i\u003cG[v].size();i++){\rif(G[v][i]!=p) dfs(G[v][i],v,d+1);\r}\r}\rvoid init(int V){\rdfs(root,-1,0);\rfor(int k=0;k+1\u003cmax_logv;k++){\rfor(int v=0;v\u003cV;v++){\rif(parent[k][v]\u003c0) parent[k+1][v]=-1;\relse parent[k+1][v]=parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u]\u003edepth[v]) swap(u,v);\rfor(int k=0;k\u003cmax_logv;k++){\rif((depth[v]-depth[u])\u003e\u003ek\u00261) v=parent[k][v];\r}\rif(u==v) return u;\rfor(int k=max_logv-1;k\u003e=0;k--){\rif(parent[k][u]!=parent[k][v]){\ru=parent[k][u];\rv=parent[k][v];\r}\r}\rreturn parent[0][u];\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:13:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"dfs序 (与线段树和树状数组结合) vector\u003cint\u003e G[maxv]; //图的领接表 int od[maxv]; //dfs序 int L[maxv]; //子树区间左边界 int R[maxv]; //子树区间有边界 int cnt = 1; //当前是第几个节点（dfs序） void dfs(int x,int p){\rod[x] = cnt++;\rL[x] = cnt - 1;\rfor(int i:G[x]){\rif(i!=p){\rdfs(i,x);\r}\r}\rR[x] = cnt - 1;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:14:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"树链剖分 树链剖分利用重孩子的定义和dfs序将树上路径权值和子树整体权值的修改和查询压缩成连续的区间的查询，对于区间的修改和查询可以利用线段树 以这道题为例 （无注释代码点击此处） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst int maxn = 1e5+10;\rstruct edge{ //链式前向星存图 int to,nxt;\r}e[maxn\u003c\u003c1]; //用双向边代替无向边 \rstruct tnode{ //线段树的节点 节点权值，覆盖的左区间，覆盖的右区间，覆盖的范围，lazy标签 int w,l,r,siz,lazy;\r}tn[maxn\u003c\u003c2]; // 大小要*4 \r//wch：重孩子 sz：子树大小 head：链式前向星的head //wt：原来树上节点的权值 dep：深度 dfn：dfs序 //par：父节点 top：树上节点所属链的链首 rdfn：dfs序的反映射 \rint wch[maxn],sz[maxn],head[maxn],wt[maxn],dep[maxn],dfn[maxn],par[maxn],top[maxn],rdfn[maxn];\rint n,m,r,mod; int cnt_e; //链式前向星的计数器 int cnt_d; //dfs序的计数器 \rvoid add_edge(int u,int v){ //链式前向星的建图函数 e[++cnt_e].to = v; e[cnt_e].nxt = head[u]; //头插法 head[u] = cnt_e;\r}\rvoid dfs1(int u,int p){ //获得子树大小 ，深度，父节点，重孩子 sz[u] = 1;\rfor(int i = head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p){\rdep[t] = dep[u] + 1;\rpar[t] = u;\rdfs1(t,u);\rsz[u] += sz[t];\rif(sz[t] \u003e sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid dfs2(int u,int p,int tp){ //剖分重链和轻链 top[u] = tp;\rdfn[u] = ++cnt_d; //dfs序 rdfn[cnt_d] = u; //反dfs序 if(wch[u]){ //先操作重孩子，目的是让重链节点的dfs序连续，便于在线段树上的区间操作 dfs2(wch[u],u,tp);\r}\rfor(int i=head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p and t != wch[u]){\rdfs2(t,u,t); //操作轻孩子 }\r}\r}\rvoid pushup(int u){ //通过两个孩子，更新自己的权值 由于题目要求，所以是求和形式 tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod;\r}\rvoid build(int u,int l,int r){ //建立线段树 tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[rdfn[l]]; //此时获得线段树节点的权值 return ;\r}\rint mid = (l+r) \u003e\u003e 1;\rbuild(u\u003c\u003c1 , l , mid); //递归建树 build(u\u003c\u003c1|1 , mid+1 , r);\rpushup(u); //每建一层就通过两个孩子更新自己 }\rvoid pushdown(int u){ //通过迟滞，下放lazy，在需要的时候更新，这样会减少操作量 if(tn[u].lazy){\rtn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1].siz * tn[u].lazy) % mod; //通过迟滞来更新子节点的权值 tn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w + tn[u\u003c\u003c1|1].siz * tn[u].lazy) % mod;\rtn[u\u003c\u003c1].lazy = (tn[u\u003c\u003c1].lazy + tn[u].lazy) % mod; //下放迟滞 tn[u\u003c\u003c1|1].lazy = (tn[u\u003c\u003c1|1].lazy + tn[u].lazy) % mod;\rtn[u].lazy = 0; //该节点迟滞的作用结束，清空 }\r}\rvoid update(int u,int l,int r,int w){ //更新区间 if(l\u003c=tn[u].l and r\u003e=tn[u].r){ // 当目标区间包含了节点区间时，无法往下操作，更新节点的权值和迟滞 tn[u].w += tn[u].siz * w;\rtn[u].lazy += w;\rreturn ;\r}\rpushdown(u); // 下放迟滞准备对子节点的更新操作 int mid = (tn[u].l + tn[u].r) \u003e\u003e 1; //这里是节点区间的一半 if(l\u003c=mid) update(u\u003c\u003c1, l , r , w);\rif(r\u003emid) update(u\u003c\u003c1|1, l , r , w);\rpushup(u); //子树更新完毕,通过子节点更新自己 }\rvoid add_path(int u,int v,int w){ //对路径的更新操作 while(top[u]!=top[v]){ //如果不属于一条重链 if(dep[top[u]] \u003c dep[top[v]]) swap(u,v); //现在它们属于两条链，始终对链头深度大的进行操作 update(1,dfn[top[u]],dfn[u],w); //更新这条链 u = par[top[u]]; //这条链更新完毕，跳到链头的父节点，这样最终它们会相遇，处在同一条链上 }\rif(dep[u] \u003e dep[v]) swap(u,v); //让深度低的节点在左，才可以区间操作 update(1,dfn[u],dfn[v],w); //根据dfs序 }\rint query(int u,int l,int r){ //区间查询 if(l\u003c=tn[u].l and r\u003e=tn[u].r) return tn[u].w; //已经缩到最小区间，直接返回值 int ans = 0;\rpushdown(u); //下放迟滞，以备后续操作 int mid = (tn[u].l + tn[u].r) \u003e\u003e 1;\rif(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r)) % mod;\rif(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r)) % mod;\rreturn ans;\r}\rint query_path(int u,int v){ //路径上的查询 int ans = 0;\rwhile(top[u] != top[v]){ //与路径上的更新相同 if(dep[top[u]] \u003c dep[top[v]]) swap(u,v);\rans = (ans + query(1, dfn[top[u]] , dfn[u])) % mod;\ru = par[top[u]];\r}\rif(dep[u] \u003e dep[v]) swap(u,v);\rans = (ans + query(1,dfn[u],dfn[v])) % mod;\rreturn ans;\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em\u003e\u003er\u003e\u003emod;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ewt[i];\r}\rfor(int i=0;i\u003cn-1;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\radd_edge(x,y);\radd_edge(y,x);\r}\rdfs1(r,0); //初始化 dfs2(r,0,r);\rbuild(1,1,n);\rfor(int i=0;i\u003cm;i++){\rint tp;\rcin\u003e\u003etp;\rswitch(tp){\rcase 1:{\rint x,y,z;\rcin\u003e\u003ex\u003e\u003ey\u003e\u003ez;\radd_path(x,y,z%mod);\rbreak;\r}\rcase 2:{\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\rcout\u003c\u003cquery_path(x,y)\u003c\u003cendl;\rbreak;\r}\rcase 3:{\rint x,z;\rcin\u003e\u003ex\u003e\u003ez;\rupdate(1,dfn[x],dfn[x]+sz[x]-1,z%mod);\rbreak;\r}\rcase 4:{\rint x;\rcin\u003e\u003ex;\rcout\u003c\u003cquery(1,dfn[x],dfn[x]+sz[x]-1)\u003c\u003cendl;\rbreak;\r}\r}\r}\rreturn 0;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:15:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"树上启发式合并 dsu on tree 并查集的按秩合并是启发式，即小的往大的合并，减少查询难度 树上启发式合并通过树链剖分中重孩子的定义，在对子树查询时，先处理所有轻孩子，然后撤销（消除轻孩子对父节点的影响），再处理重孩子，不撤销，最后再处理一遍轻孩子，把对父节点的贡献和重孩子合并 撤销的目的在于对节点信息查询时会开辟一个数组，对于不同子节点，这个数组要再开辟一次，这样会MLE 以这道题为例 （无注释代码点击此处） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst int maxn = 1e5 + 10;\rstruct edge{\rint to,nxt;\r}e[maxn\u003c\u003c1];\rint sz[maxn],par[maxn],c[maxn],head[maxn],wch[maxn],ans[maxn],num[maxn]; //这些变量见树链剖分部分 int n,m;\rint sum; //子树颜色数 int cnt; //计数器 \rvoid add_edge(int u,int v){\re[++cnt].to = v;\re[cnt].nxt = head[u];\rhead[u] = cnt;\r}\rvoid dfs(int u,int p){\rsz[u] = 1;\rfor(int i = head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p){\rdfs(t,u);\rsz[u] += sz[t];\rif(sz[t] \u003e sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid cal(int u,int p,int wch,int val){\rif(!num[c[u]]) sum++; //如果之前数量为0，说明是新颜色 num[c[u]] += val;\rfor(int i=head[u]; i ; i=e[i].nxt){ int t = e[i].to;\rif(t != p and t != wch){ //跳过重孩子 cal(t,u,wch,val); }\r}\r}\rvoid dsu(int u,int p,int kp){ //kp表示是否撤销 for(int i=head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p and t != wch[u]){\rdsu(t,u,0); //先处理轻孩子，需要撤销 }\r}\rif(wch[u]) dsu(wch[u] , u , 1); //处理重孩子，需要保留 cal(u,p,wch[u],1); //计算轻孩子 ans[u] = sum;\rif(!kp){ cal(u,p,0,-1); //撤销操作 sum = 0;\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u003e\u003en;\rfor(int i=0;i\u003cn-1;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\radd_edge(x,y);\radd_edge(y,x);\r}\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ec[i];\r}\rdfs(1,0); //初始化 dsu(1,0,1);\rcin\u003e\u003em;\rwhile(m--){\rint foo;\rcin\u003e\u003efoo;\rcout\u003c\u003cans[foo]\u003c\u003cendl;\r}\rreturn 0;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:16:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Dinic算法 用来解决最大流问题 有两类算法 增广路算法（dinic ek isap ff） 预流推进算法 （hlpp） dinic算法是经典算法，hlpp可能更快一点 dinic算法的本质还是贪心+暴力 通过不断地对残余网络(residual networks)求增广路(augmenting paths)，对每一条增广路求流量，然后把流量加起来就是最大流 有一个问题：在对增广路下放流量时，可能错过最优解 解决的方法是，对每条边加一条反向边，流量在原来的边减多少，就在反向边加多少，这样可以通过流入反向边来达到撤销的操作 dinic的操作过程分两步 bfs建立分层图，通过最短路的原则分层，每次在最短路的前提下找增广路，这是贪心的思想，这样会使找增广路高效且达到可行解 dfs找增广路，不断对边进行流量增减操作，暴力枚举思想 不断迭代每次产生的残余网络 三种优化（主要是后两者）参考文章 当前弧优化 ： 增广路搜索中不再考虑之前搜索过的边 多路增广优化： 对于某一条边减去的流量，因增广路覆盖的次数会进行多次操作，现在只需要一次操作就行（操作总的流量），从一次bfs，多次dfs到多次bfs，一次dfs 炸点优化 ： 当某一条增广路中流量为0时，这个点在当前dfs搜索增广路中将不可达，所以直接炸点 时间复杂度 O(n*n*m) 实际合理运用优化之后，很难达到这样的时间复杂度，dinic算法还是很高效的，甚至可以跑十万个点 根据最大流最小割定理(maximum flow minimum cut theorem) 最大流就是有源汇最小割 对于无源汇最小割和全局最小割可以用Stoer Wagner算法 对于有源汇无源汇上下界最大流，参考此处 对于时间要求苛刻的最大流可以用HLPP算法 对于费用流，可以用spfa 对于最大流的各种变体，参考其他资料 测模板题 无注释代码 //有时需改成long long \r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rconst int maxn = 205;\rconst int maxm = 5005;\rint n,m,s,t;\rconst int inf = 0x3f3f3f3f; struct edge{\rint to , w , nex;\r}e[maxm\u003c\u003c1]; //maxm int tot=2,head[maxn]; // tot = 2 !!\r\rint dep[maxn],cur[maxn]; //dep : dfs得到的最短距离 cur : 当前弧优化需要拷贝的数组 \rvoid add_edge(int u,int v,int w){\re[tot].to = v;\re[tot].w = w;\re[tot].nex = head[u];\rhead[u] = tot++;\r}\rbool bfs(){\rmemset(dep , 0 , sizeof(dep)); //memset(dep , 0 , (tot+2)\u003c\u003c2); queue\u003cint\u003e q;\rq.push(s);\rdep[s] = 1; int u , v;\rwhile(q.size()){\ru = q.front();\rq.pop();\rfor(int i = head[u] ; i ; i = e[i].nex){\rv = e[i].to;\rif(dep[v] or e[i].w \u003c= 0) continue; //v 已达到不能作为dfs的增广路 ， 断流的点不能作为dfs的增广路 dep[v] = dep[u] + 1;\rq.push(v);\r}\r} for(int i=0;i\u003c=n;i++) cur[i] = head[i]; //拷贝作为当前弧优化 return dep[t]; //是否到达汇点 }\rint dfs(int u , int flow){\rif(u == t) return flow;\rint nowflow = 0; //当前流量 for(int\u0026 i = cur[u] , v ; i ; i = e[i].nex){ //当前弧优化 v = e[i].to;\rif(dep[v] != dep[u] + 1 or e[i].w \u003c= 0) continue; //不满足深度递增或断流就不能作为增广路 if(int delta = dfs(v , min(flow - nowflow , e[i].w))){ e[i].w -= delta;\re[i^1].w += delta;\rnowflow += delta; //多路增广优化，for循环一直进行，nowflow一直增加 if(nowflow == flow) break; //已达到最大流量 }\r}\rif(!nowflow) dep[u] = -2; //炸点优化 return nowflow;\r}\rll dinic(){\rll ans = 0 ;\rwhile(bfs()){ //对残余网络不断分层，以备之后dfs求增广路，当汇点不可达时，残余网络将永远不可达 ans += dfs(s , inf);\r}\rreturn ans;\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u003e\u003en\u003e\u003em\u003e\u003es\u003e\u003et;\rfor(int i=0;i\u003cm;i++){\rint x,y,z;\rcin\u003e\u003ex\u003e\u003ey\u003e\u003ez;\radd_edge(x,y,z);\radd_edge(y,x,0);\r}\rll ans = dinic();\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:17:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["poj"],"content":"poj","date":"2020-01-27","objectID":"/poj/","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"线段相交 1127 ","date":"2020-01-27","objectID":"/poj/:1:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 判断两条线段是否相交，对于N条线段，间接相交也算相交。对于每次询问，判 断给定的两条线段是否相交 ","date":"2020-01-27","objectID":"/poj/:1:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 这个题目分成两部分，一部分是基础的判断两条线段是否相交，用一个bool数组来存储信息。另一部分是判断间接相交，可以用floyd-warshall（比较巧妙）或者并查集.第一部分就是套模板。 点可以用结构体存储（推荐），线段也可以用结构体存储或pair 判断两条线段相交有多重模板，比如判是否平行、重合、求两条直线交点，判断交点是否在线段上，还有ccw（counter clock wise）函数，可参考discuss 比较常见的是快速排斥和跨立检验 以线段为对角线，作平行于x轴、y轴的射线，使之形成矩形，若两个矩形没有相交，则线段不相交（可以排除大部分） 不满足快速排斥进入跨立检验,判断两个点是否在线段的两侧（即跨立），判断方法是外积的符号是否相反，等于0说明在线上 如果两两互相跨立，则线段相交 #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint n;\rbool con[15][15];\rint p,q;\rstruct point\r{\rdouble x,y;\r//point(double a,double b) : x(a),y(b) {} //!!!!!会发生编译错误 };\rpair\u003cpoint,point\u003e seg[15];\rdouble dir(point a,point b,point c) //用外积 {\rreturn (c.x-a.x)*(c.y-b.y) - (c.y-a.y)*(c.x-b.x); }\rbool judge(pair\u003cpoint,point\u003e p1,pair\u003cpoint,point\u003e p2)\r{\rpoint a,b,c,d;\ra=p1.first; b=p1.second;\rc=p2.first;\rd=p2.second;\r//快速排斥\r if(min(a.x,b.x)\u003emax(c.x,d.x) or min(c.x,d.x)\u003emax(a.x,b.x) or\rmin(a.y,b.y)\u003emax(c.y,d.y) or min(c.y,d.y)\u003emax(a.y,b.y))\rreturn false;\r//跨立检验 (int 可改成double)\r else\r{\rint d1,d2,d3,d4;\rd1=dir(a,b,c);\rd2=dir(a,b,d);\rd3=dir(c,d,a);\rd4=dir(c,d,b);\rreturn d1*d2\u003c=0 and d3*d4\u003c=0; //!!!\r }\r}\rint main()\r{\rwhile(scanf(\"%d\",\u0026n)==1 and n!=0)\r{\rfor(int i=1;i\u003c=n;i++) con[i][i]=true;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%lf%lf%lf%lf\",\u0026seg[i].first.x,\u0026seg[i].first.y,\u0026seg[i].second.x,\u0026seg[i].second.y);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=1;j\u003ci;j++)\r{\rif(judge(seg[i],seg[j])) con[i][j]=con[j][i]=true;\relse con[i][j]=con[j][i]=false;\r}\rfor(int k=1;k\u003c=n;k++) //Floyd-Warshall算法或并查集都可以 for(int i=1;i\u003c=n;i++)\rfor(int j=1;j\u003c=n;j++)\rcon[i][j] |= con[i][k] and con[k][j];\rwhile(scanf(\"%d%d\",\u0026p,\u0026q)==2 and p!=0)\rputs(con[p][q] ? \"CONNECTED\" : \"NOT CONNECTED\");\r}\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:1:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"艰难的debug 计算几何有些很麻烦，代码太相似，debug比较难，有时还要考虑精度问题（即误差eps） debug一个上午 写完代码CE，seg[i].first.x错误，把stl_pair.h中的代码小改一下可以通过，但放到oj上肯定不行，怕污染代码还是不这样做。最后发现把构造函数去掉可以通过 自测，最后一个样例没过，发现是边界情况，把跨立检验最后一步的等号加上 自测，中间有一个样例没过，作图，把样例分离出来，过了。说明可能不是judge函数的问题。 单测样例，没过，说明错误不是受别组影响 编译器debug，把函数内的局部变量，变成全局变量，add watch 发现d1 d2 d3 d4都等于0，a.x a.y b.x b.y ….有问题 继续add watch 发现seg[1].first的内容就有问题，是double边界数，然后发现最终问题 %d 赋值给了double型变量 ","date":"2020-01-27","objectID":"/poj/:1:3","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 提高debug能力，少犯白痴错误。 写代码要有清晰性和完整性，这样鲁棒性更强。 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:1:4","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"并查集 1182 ","date":"2020-01-27","objectID":"/poj/:2:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 并查集 看到信息的内容，有并查集的影子 依次遍历信息，对于每一条信息，因为没有说种类，所以设置三个种类，把每一种情况都加上去，比如：x和y属于同一类，则合并x和y属于A类，B类，C类 判断是否是错误信息，只要判断是否与前面信息矛盾即可 并查集的时间复杂度O(α(n)) α(n)是阿克曼函数的反函数，比O(lgn)还快 代码如下（并查集的模板 + 并查集的应用） #include\u003ciostream\u003e\rusing namespace std;\rint T[100005],X[100005],Y[100005];\rint n,k;\r//union find\rint par[150005]; //父亲 int rankk[150005]; //树的高度,!!!元素是根 （优化用）//reference to \"rank\" is ambiguous\r//初始化，要用并查集前要初始化\rvoid init(int n) {\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} //查询树的根\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); //return find(par[x]);也可以 。par[x]=find(par[x]) 是路径压缩优化 } //合并x,y //优化高度（如果rankk不同，那么从rankk小的向大的连边 void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; //判断是否已在同一个集合内\r if(rankk[x]\u003crankk[y]) par[x]=y; //!!!利用它们的 根 进行合并 else\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++; //这时候rankk还是原来的高度 } } //判断是否在同一个集合内\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=0;i\u003ck;i++)\rscanf(\"%d%d%d\",\u0026T[i],\u0026X[i],\u0026Y[i]);\rinit(n*3);\rint ans=0;\rfor(int i=0;i\u003ck;i++)\r{\rint t=T[i],x=X[i]-1,y=Y[i]-1;\r//错误的编号\r if(x\u003c0 || x\u003e=n || y\u003c0 || y\u003e=n)\r{\rans++;\rcontinue;\r} else if(t==1) //第一种类型\r {\rif(same(x,y+n) || same(x,y+2*n)) ans++; //判断是否矛盾 //!!!只需要判断x在A类就行，因为每次unite都\r //涵盖所有情况，它们是平行影响的，判断一个就相当于判断所有 else\r{\runite(x,y);\runite(x+n,y+n);\runite(x+n+n,y+n+n);\r}\r} else if(t==2)\r{\rif(same(x,y) || same(x,y+2*n)) ans++;\relse\r{\runite(x,y+n);\runite(x+n,y+2*n);\runite(x+2*n,y);\r}\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:2:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"完全背包问题 1384 ","date":"2020-01-27","objectID":"/poj/:3:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 题意：完全背包问题求最小价值 时间复杂度O(nm) 二维数组如下，MLE #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint dp[505][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\rcin\u003e\u003et;\rwhile(t--)\r{\rcin\u003e\u003ee\u003e\u003ef;\rm=f-e;\rcin\u003e\u003en;\r//init\r fill(dp[0],dp[0]+n*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026v[i],\u0026w[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=0;j\u003c=m;j++)\rif(j\u003cw[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=min(dp[i-1][j],dp[i][j-w[i]]+v[i]);\rif(dp[n][m]!=inf)\rprintf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[n][m]);\relse\rprintf(\"This is impossible.\\n\");\r}\rreturn 0;\r}\r 改一维数组，AC #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint dp[10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\rcin\u003e\u003et;\rwhile(t--)\r{\rcin\u003e\u003ee\u003e\u003ef;\rm=f-e;\rcin\u003e\u003en;\r//init\r fill(dp,dp+m+1,inf); //!!!!!\r dp[0]=0;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026v[i],\u0026w[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=w[i];j\u003c=m;j++)\rdp[j]=min(dp[j],dp[j-w[i]]+v[i]);\rif(dp[m]!=inf)\rprintf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[m]);\relse\rprintf(\"This is impossible.\\n\");\r}\rreturn 0;\r}\r 这个地方要注意 fill 到 dp+m+1 滚动数组好啊 AC代码 #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint dp[2][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--)\r{\rcin\u003e\u003ee\u003e\u003ef;\rm=f-e;\rcin\u003e\u003en;\r//init\r fill(dp[0],dp[0]+2*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026v[i],\u0026w[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=0;j\u003c=m;j++)\rif(j\u003cw[i])\rdp[i\u00261][j]=dp[(i-1)\u00261][j];\relse\rdp[i\u00261][j]=min(dp[(i-1)\u00261][j],dp[i\u00261][j-w[i]]+v[i]);\rif(dp[n\u00261][m]!=inf)\rprintf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[n\u00261][m]);\relse\rprintf(\"This is impossible.\\n\");\r}\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:3:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 这种类型的dp有两个重点，初始化边界条件，找递推式 求最小，一般初始化为inf，dp[0][0]=0; 求最大，一般初始化为0 必要时可用滚动数组 完全背包递推式的证明（这里证明求最大值的情况） dp[i][j]=max{dp[i-1][j-k*w[i]]+k*v[i] | k\u003e=0} =max(dp[i-1][j] , max{dp[i-1][j-k*w[i]]+k*v[i] | k\u003e=1} =max(dp[i-1][j] , max{dp[i-1][(j-w[i])-k*w[i]]+k*v[i] | k\u003e=0}+v[i]) =max(dp[i-1][j] , dp[i][j-w[i]]+v[i]) 这种分离思想很常见 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:3:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"线性dp LCS 1458 ","date":"2020-01-27","objectID":"/poj/:4:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 水一题线性dp裸题–LCS(longest common subsequence) 因为没加string头文件CE了3次（被error误导了） ac代码 #include\u003ciostream\u003e\r#include\u003ccstring\u003e\r#include\u003cstring\u003e\rusing namespace std;\rstring s1,s2;\rint dp[1000][1000]; //dp[i][j] 表示s1到i，s2到j的lcs长度\rint len1,len2; int lcs(string s1,string s2)\r{\rlen1=s1.length();\rlen2=s2.length();\rmemset(dp,0,sizeof(dp));\rfor(int i=0;i\u003clen1;i++)\rfor(int j=0;j\u003clen2;j++)\rif(s1[i]==s2[j])\rdp[i+1][j+1]=dp[i][j]+1;\relse\rdp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);\rreturn dp[len1][len2];\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r while(cin\u003e\u003es1\u003e\u003es2)\rcout\u003c\u003clcs(s1,s2)\u003c\u003cendl; return 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:4:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"凸包 2187 ","date":"2020-01-27","objectID":"/poj/:5:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 平面上有n个不重合的点，求两个点的最远距离 ","date":"2020-01-27","objectID":"/poj/:5:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 由于点的个数为50000，所以暴力超时 构造凸包，遍历凸包上的点即可 坐标范围在n内的凸多边形（顶点在格点上）的顶点个数最多为O（√n）（尝试不严谨的画图证明，和公差为1的等差数列求和有关，所以是平方关系） 所以构造凸包后，暴力遍历的时间复杂度为O（n） 构造凸包可以用模板 此处介绍的是时间复杂度O(nlgn）的graham扫描法 外积是很常用的工具，此处利用外积的坐标公式的符号判断凹凸性 可以对点先排序，然后按逆时针方向依次遍历点，先构造凸包的下侧，到达最右端时，构造凸包的上侧 代码如下 #include\u003ciostream\u003e\r#include\u003cvector\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rdouble s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u003cb.x;\rreturn a.y\u003cb.y;\r}\rdouble out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u003cpoint\u003e convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\r int k=0; // 凸包点的index vector\u003cpoint\u003e qs(n*2); //构造凸包\r //逆时针构造凸包\r //构造凸包的下侧\r for(int i=0;i\u003cn;i++)\r{\rwhile(k\u003e1 \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\r for(int i=n-2,t=k;i\u003e=0;i--)\r{\rwhile(k\u003et \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--; //这里有个k\u003et 和 k\u003e1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\r{\rpoint p;\rscanf(\"%lf%lf\",\u0026p.x,\u0026p.y);\rps[i]=p;\r}\rvector\u003cpoint\u003e qs=convex_hull(ps,n);\rdouble res=0;\rfor(int i=0;i\u003cqs.size();i++)\rfor(int j=0;j\u003ci;j++)\rres=max(res,s_dist(qs[i],qs[j]));\rcout\u003c\u003c(int)res\u003c\u003cendl; //!!!不加int 或不用printf(\"%.0lf\\n\",res); 就会WA return 0;\r}\r 还有一种时间复杂度更低的方法 convex hull + rotating calipers 这是一种常见、经典的方法 对踵点：如果凸包上过两个点画两条平行线，使凸包所有的点都夹在这两条线之间，这两个点就叫对踵点，称为一对对踵点对 对于一个凸包，最远距离一定是对踵点对 所以先找一对对踵点对，根据判断凹凸性，确定哪个点向后面的点移动（如图）（图懒得画），宏观来看就是对踵点对的连线旋转了180° 这样就总时间复杂度就是O（√n） 代码如下 #include\u003ciostream\u003e\r#include\u003cvector\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rinline double s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u003cb.x;\rreturn a.y\u003cb.y;\r}\rinline double out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u003cpoint\u003e convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\r int k=0; // 凸包点的index vector\u003cpoint\u003e qs(n*2); //构造凸包\r //逆时针构造凸包\r //构造凸包的下侧\r for(int i=0;i\u003cn;i++)\r{\rwhile(k\u003e1 \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\r for(int i=n-2,t=k;i\u003e=0;i--)\r{\rwhile(k\u003et \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--; //这里有个k\u003et 和 k\u003e1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\r{\rpoint p;\rscanf(\"%lf%lf\",\u0026p.x,\u0026p.y);\rps[i]=p;\r}\rvector\u003cpoint\u003e qs=convex_hull(ps,n);\rdouble res=0; int m=qs.size();\rif(m==2) //特殊处理凸包退化情况\r {\rcout\u003c\u003c(int)s_dist(qs[0],qs[1])\u003c\u003cendl; return 0; } int i=0,j=0; //表示左右俩对踵点\r //求x轴方向上的对踵点对\r for(int k=0;k\u003cm;k++)\rif(cmp(qs[j],qs[k])) j=k;\r//rotating calipers\r int si=i,sj=j;\rwhile(!(i==sj \u0026\u0026 j==si)) //旋转180°，注意判断条件 {\r//cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cj\u003c\u003cendl;\r res=max(res,s_dist(qs[i],qs[j])); //这条语句放在while循环体的前端，可以把x轴方向上的对踵点对都比较\r //通过外积判断凹凸性，判断是i移到i+1，还是j移到j+1\r if(out_product(qs[(i+1)%m].x-qs[i].x , qs[(i+1)%m].y-qs[i].y , qs[(j+1)%m].x-qs[j].x , qs[(j+1)%m].y-qs[j].y)\u003c0) //\u003c0 或\u003c=0都可以\r i=(i+1)%m; //把m错写成n,tle好久 else\rj=(j+1)%m; //!!!要%m 这样转一圈才能回到起点，退出循环 } //之前添加的debug条件忘记屏蔽，WA了特久 cout\u003c\u003c(int)res\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:5:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"bfs dfs 2386 ","date":"2020-01-27","objectID":"/poj/:6:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 bfs dfs都行 基础dfs 时间复杂度 O(mn) //dfs\r#include\u003ciostream\u003e\rusing namespace std;\rchar field[105][105];\rint n,m;\rvoid dfs(int x,int y)\r{\rfield[x][y]='.';\rfor(int dx=-1;dx\u003c=1;dx++)\rfor(int dy=-1;dy\u003c=1;dy++)\r{\rint nx=x+dx,ny=y+dy;\rif(0\u003c=nx \u0026\u0026 nx\u003cn \u0026\u0026 0\u003c=ny \u0026\u0026 ny\u003cm \u0026\u0026 field[nx][ny]=='W')\rdfs(nx,ny);\r}\rreturn ;\r}\rint main()\r{\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++)\rfor(int j=0;j\u003cm;j++)\r{\rcin\u003e\u003efield[i][j];\r}\rint res=0;\rfor(int i=0;i\u003cn;i++)\rfor(int j=0;j\u003cm;j++)\r{\rif(field[i][j]=='W') {\rdfs(i,j);\rres++;\r}\r}\rcout\u003c\u003cres\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:6:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 经典dfs就是递归思想 如果图外面是可达且连通的，就在图外面加一圈 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:6:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"状态压缩dp 2686 ","date":"2020-01-27","objectID":"/poj/:7:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 TSP问题 不能在多项式时间内求解 暴力求解是阶乘数量级的 在数据不是很大的时候可以用状态压缩dp 对于这道题时间复杂度O((2^n)*m*m*n) 基础状态压缩dp 以3.667为例 道路图为 dp[S][x] S表示剩余车票集合 x表示从a出发到达x（单源最短路） dp表示最小花费 这样就变成DAG求最短路问题，不需要使用dijkstra算法，用dp就可以 dp的初始条件是 dp=inf , dp[U][a]=0 dp的状态转移方程 dp[S/{i}][u] = min{dp[S][v]+d[v][u]/t[i] (i∈S)} 将集合用整数的二进制表示 根据状态转移方程，可以用记忆化搜索+递归 这个问题可以用循环嵌套求解 约束条件很重要 这道题的约束条件是“车票” 如果题目要求每个点只能走一遍的话 那么又有一个约束条件是“点”（即判断这个点是否走过） 循环嵌套的写法就是按照套路 遍历所有子集，嵌套遍历每种子集的操作情况 遍历集合的所有情况（逆序） 嵌套遍历每个点 再嵌套遍历每个点 依题意再嵌套遍历剩下的所有车票（顺序可与上一步调换） 最后遍历所有的dp[S’][b] S'⊆U，获得最小值 ac代码 #include\u003ciostream\u003e\r#include\u003ccstring\u003e\r#define maxn 8\r#define maxm 30\r#define inf 0x3f3f3f3f\rusing namespace std;\rint n,m,p,a,b;\rint t[maxn];\rint d[maxm][maxm];\rdouble dp[1\u003c\u003cmaxn][maxm]; //dp[剩下的车票集合][目标城市]=从a到达目标城市的最短时间 int main()\r{\rwhile(scanf(\"%d%d%d%d%d\",\u0026n,\u0026m,\u0026p,\u0026a,\u0026b)==5 and !(n==0 and m==0 and p==0 and a==0 and b==0))\r{\rfor(int i=0;i\u003cn;i++) scanf(\"%d\",\u0026t[i]);\rmemset(d,-1,sizeof(d));\rint temp1,temp2,temp3;\rfor(int i=0;i\u003cp;i++)\r{\rscanf(\"%d%d%d\",\u0026temp1,\u0026temp2,\u0026temp3);\rd[temp1-1][temp2-1]=temp3;\rd[temp2-1][temp1-1]=temp3;\r}\rfor(int i=0;i\u003c1\u003c\u003cn;i++) fill(dp[i],dp[i]+m,inf); //注意这里要用循环初始化二维数组 //inf是因为要用到min dp[(1\u003c\u003cn)-1][a-1]=0;\rdouble res=inf; //inf是因为要用到min for(int s=(1\u003c\u003cn)-1;s\u003e=0;s--)\r{\rres=min(res,dp[s][b-1]);\rfor(int v=0;v\u003cm;v++)\r{\rfor(int u=0;u\u003cm;u++)\r{\rif(d[v][u]\u003e=0)\r{\rfor(int i=0;i\u003cn;i++)\r{\rif(s\u003e\u003ei\u00261)\r{\rdp[s\u0026~(1\u003c\u003ci)][u]=min(dp[s\u0026~(1\u003c\u003ci)][u],dp[s][v]+(double)d[u][v]/t[i]);\r}\r}\r}\r}\r}\r}\rif(res==inf) printf(\"Impossible\\n\");\relse printf(\"%.3lf\\n\",res); //discuss里面说poj用lf会wa,用f就ac ，但我试了lf也可以ac\r }\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:7:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"强连通分量 2816 ","date":"2020-01-27","objectID":"/poj/:8:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 如果一头牛被其他所有牛认为是红牛，那么和它在同一个强连通分量的所有牛都 是红牛，所以scc分解，拓扑序最后一个强连通分量是红牛群，最后检查这个连通 块中的一头红牛是否对所有牛可达 #include\u003ciostream\u003e\r#include\u003cvector\u003e\r#include\u003ccstring\u003e\rusing namespace std;\rint V,m;\rint t1,t2; #define maxv 10005 vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv];\rvector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; void add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u003cG[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u003crG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u003cV;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u003e\u003eV\u003e\u003em;\rwhile(m--){\rcin\u003e\u003et1\u003e\u003et2;\radd_edge(t1-1,t2-1);\r}\rint k=kosaraju_scc();\rint u=0,num=0; //备选个数 u取得正序最后一个 for(int i=0;i\u003cV;i++){\rif(cmp[i]==k-1){\ru=i;\rnum++;\r}\r}\rmemset(used,0,sizeof(used));\rrdfs(u,0); //反向判断是否都可达\r for(int i=0;i\u003cV;i++){\rif(!used[i]){\rnum=0;\rbreak;\r}\r} cout\u003c\u003cnum\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:8:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"扫描线 2932 ","date":"2020-01-27","objectID":"/poj/:9:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 坐标上有n个不相交的圆，求最外层圆的index ","date":"2020-01-27","objectID":"/poj/:9:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 由于数据规模，暴力超时 sweeping line 一般有两种，平移扫描，环形扫描 对于这一题，从左到右平移扫描 用一个容器维护每个圆的左右两个端点，代表扫描到圆和扫描出圆 对于扫描到的圆，判断它是否在别的圆内 只需要判断上下最近的两个圆（可画图证明，不严谨） 用一个容器维护还没扫描出的最外圆，可以排序，再查找。总时间复杂度O(nlgn) 可以选用set 当扫描到右时，把圆从set中去除，意味着扫描过了 #include\u003ciostream\u003e\r#include\u003cset\u003e\r#include\u003cvector\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rdouble x[40005],y[40005],r[40005];\rint n;\rtypedef pair\u003cdouble ,int\u003e pdi;\rbool inside(int i,int j)\r{\rdouble dx=x[i]-x[j],dy=y[i]-y[j];\rreturn dx*dx+dy*dy\u003c=r[j]*r[j];\r}\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\rscanf(\"%lf%lf%lf\",\u0026r[i],\u0026x[i],\u0026y[i]);\rvector\u003cpdi\u003e vt; //存左右两边界 for(int i=0;i\u003cn;i++)\r{\rvt.push_back(make_pair(x[i]-r[i],i));\rvt.push_back(make_pair(x[i]+r[i],i+n));\r}\rsort(vt.begin(),vt.end());\r//扫描\r set\u003cpdi\u003e outers; //set为了排序 vector\u003cint\u003e res; //存放结果 for(int i=0;i\u003cvt.size();i++)\r{\rint id=vt[i].second%n;\rif(vt[i].second\u003cn) //扫描到左 {\rset\u003cpdi\u003e::iterator it=outers.lower_bound(make_pair(y[id],id));\rif(it!=outers.end() \u0026\u0026 inside(id,it-\u003esecond)) continue; //上面最近的圆 if(it!=outers.begin() \u0026\u0026 inside(id,(--it)-\u003esecond)) continue; //下面最近的圆 res.push_back(id);\routers.insert(make_pair(y[id],id));\r}\relse //扫描到右 outers.erase(make_pair(y[id],id));\r} sort(res.begin(),res.end());\rcout\u003c\u003cres.size()\u003c\u003cendl;\rfor(int i=0;i\u003cres.size();i++)\rprintf(\"%d%c\",res[i]+1,i+1==res.size()? '\\n' : ' ');\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:9:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"贪心 3069 ","date":"2020-01-27","objectID":"/poj/:10:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 一条路上有n个路灯，每个路灯都能照亮左右的一段距离，问最少需要多少路灯才能使街道都亮着 ","date":"2020-01-27","objectID":"/poj/:10:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 greedy 从最左开始向右延伸r，在r的范围内将最右的路灯点亮，此时这盏路灯将照亮左边和右边，从暗处的最左路灯开始，已知重复下去。 时间复杂度 O(n) !!!!需要将路灯位置排序 #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint r,n;\rint x[1006];\rint main()\r{\rwhile(scanf(\"%d%d\",\u0026r,\u0026n)==2 \u0026\u0026 r!=-1)\r{\rfor(int i=0;i\u003cn;i++)\rscanf(\"%d\",\u0026x[i]);\rsort(x,x+n); // ！！！记得排序\r int j=0,ans=0;\rwhile(j\u003cn)\r{\rint s=x[j++];\rwhile(j\u003cn \u0026\u0026 x[j]\u003c=s+r) j++;\rint p=x[j-1];\rwhile(j\u003cn \u0026\u0026 p+r\u003e=x[j]) j++;\rans++;\r} printf(\"%d\\n\",ans);\r}\rreturn 0;\r} =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:10:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"贪心 3617 ","date":"2020-01-27","objectID":"/poj/:11:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 给一个字符串s和空字符串p，每次进行以下操作之一 删除s的头部字符，加入到p的尾部 删除s的尾部字符，加入到p的尾部 最后s为空，p的字典序最小 ","date":"2020-01-27","objectID":"/poj/:11:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 greedy 时间复杂度最坏 O($n^2$) #include\u003ciostream\u003e\rusing namespace std;\rint n;\rchar s[2005];\rint c=0;\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\r{\rcin\u003e\u003es[i];\r}\rint a=0,b=n-1;\rbool left=false;\rwhile(a\u003c=b)\r{\rfor(int i=0;a+i\u003c=b;i++)\r{\rif(s[a+i]\u003cs[b-i])\r{\rleft=true;\rbreak;\r}\relse if(s[a+i]\u003es[b-i])\r{\rleft=false;\rbreak;\r}\r}\rif(left) putchar(s[a++]);\relse putchar(s[b--]);\rc++;\rif(c%80==0) putchar('\\n');\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:11:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"01背包问题 3624 ","date":"2020-01-27","objectID":"/poj/:12:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 基础01背包问题 如果用二维数组写的话就会MLE 猜测测试数据可能不会满，就随着数据动态申请内存，想侥幸过（可以用new/delete 或 malloc/free）结果还是MLE 这是MLE代码 #include\u003ciostream\u003e\rusing namespace std;\r//int dp[3410][12885];\rint n,m;\r//int w[3410];\r//int v[3410];\rint main()\r{\rcin\u003e\u003en\u003e\u003em;\rint **dp,*w,*v;\rdp=new int*[n+3];\rfor(int i=0;i\u003cn+3;i++)\rdp[i]=new int[m+3];\rw=new int[n+3];\rv=new int[n+3];\rfor(int i=1;i\u003c=n;i++)\r{\rscanf(\"%d%d\",\u0026w[i],\u0026v[i]);\r}\r//initialized\r for(int i=0;i\u003c=n;i++)\rdp[i][0]=0;\rfor(int i=0;i\u003c=m;i++)\rdp[0][i]=0;\rfor(int i=1;i\u003c=n;i++)\rfor(int j=0;j\u003c=m;j++)\rif(j\u003cw[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);\rcout\u003c\u003cdp[n][m];\rdelete dp,w,v;\rreturn 0;\r}\r 在discuss找了一圈也没有二维数组过的 优化成一维数组（节省内存，容易出bug） AC代码 #include\u003ciostream\u003e\rusing namespace std;\rint n,m;\rint dp[12885];\rint w[3410];\rint v[3410];\rint main()\r{\rcin\u003e\u003en\u003e\u003em;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026w[i],\u0026v[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=m;j\u003e=w[i];j--)\rdp[j]=max(dp[j],dp[j-w[i]]+v[i]);\rcout\u003c\u003cdp[m];\rreturn 0;\r}\r 这个内层循环是递减的，如果是递增则解决完全背包问题 由于01背包问题的dp[i]只依赖于dp[i-1]，内层循环递减时，dp[j]依赖的dp[j]为i-1的dp[j] 由于原来在二维数组中就是递增的，是同一个i，所以内层循环递增时，dp[j]依赖的dp[j]为i的dp[j]，符合完全背包问题 由于有两种状态（i和i-1），所以可利用奇偶性滚动数组实现 AC代码 #include\u003ciostream\u003e\rusing namespace std;\rint n,m;\rint dp[2][12885];\rint w[3410];\rint v[3410];\rint main()\r{\rcin\u003e\u003en\u003e\u003em;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026w[i],\u0026v[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=0;j\u003c=m;j++)\rif(j\u003cw[i])\rdp[i\u00261][j]=dp[(i-1)\u00261][j];\relse\rdp[i\u00261][j]=max(dp[(i-1)\u00261][j],dp[(i-1)\u00261][j-w[i]]+v[i]);\rcout\u003c\u003cdp[n\u00261][m];\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:12:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"2-SAT 3683 ","date":"2020-01-27","objectID":"/poj/:13:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 xi表示某一婚礼 xi为真表示在开始举行 xi为假表示在结束举行 对于两个婚礼 如果同在开始时间举行会产生冲突 则 ¬xi ∨ ¬xj 为真 遍历所有的关系对，检查是否产生冲突 如果产生冲突则有一个析取式成立 遍历完之后得到一个合取范式 这样就把问题转换成2-SAT 根据蕴含等值式 a ∨ b ⇒ (a ∨ b) ∧ (b ∨ a) ⇒ (¬a → b) ∧ (¬b → a) 对于每一个蕴含式都可以构造一条有向边 最后scc分解 判断合取范式是否是可满足式，只需要检查¬xi 和 xi 是否在同一个强连通分量中 最后对于所在强连通分量的拓扑序，依次给出真值 ac代码 #include\u003ciostream\u003e\r#include\u003cvector\u003e\r#include\u003ccstring\u003e\rusing namespace std;\rint n;\rint V; const int maxv=2005; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv];\rvector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; int s[1005],t[1005],d[1005];\rvoid add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u003cG[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u003crG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u003cV;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u003e\u003en;\rint t1,t2,t3,t4,t5;\rfor(int i=0;i\u003cn;i++){\rscanf(\"%d:%d%d:%d%d\",\u0026t1,\u0026t2,\u0026t3,\u0026t4,\u0026t5);\rs[i]=t1*60+t2;\rt[i]=t3*60+t4;\rd[i]=t5;\r}\rV=n*2;\rfor(int i=0;i\u003cn;i++)for(int j=i+1;j\u003cn;j++){\rif( min( s[i]+d[i] , s[j]+d[j] ) \u003e max(s[i] , s[j])){\radd_edge(i,n+j);\radd_edge(j,n+i);\r}\rif(min(s[i]+d[i] , t[j]) \u003e max(s[i] , t[j]-d[j])){\radd_edge(i,j);\radd_edge(n+j,i+n);\r}\rif(min(t[i] , s[j]+d[j]) \u003e max(s[j] , t[i]-d[i])){\radd_edge(i+n,j+n);\radd_edge(j,i);\r}\rif(min(t[i] , t[j]) \u003e max(t[i]-d[i] , t[j]-d[j])){\radd_edge(n+i,j);\radd_edge(n+j,i);\r}\r}\rkosaraju_scc();\rfor(int i=0;i\u003cn;i++){\rif(cmp[i]==cmp[i+n]){\rcout\u003c\u003c\"NO\\n\";\rreturn 0;\r}\r}\rcout\u003c\u003c\"YES\\n\";\rfor(int i=0;i\u003cn;i++){\rif(cmp[i]\u003ecmp[i+n]){\rprintf(\"%02d:%02d %02d:%02d\\n\",s[i]/60,s[i]%60,(s[i]+d[i])/60,(s[i]+d[i])%60);\r}\relse{\rprintf(\"%02d:%02d %02d:%02d\\n\",(t[i]-d[i])/60,(t[i]-d[i])%60,t[i]/60,t[i]%60);\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:13:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"bfs dfs 3984 ","date":"2020-01-27","objectID":"/poj/:14:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 dfs/bfs都行 基础bfs （这个测试点只有一个，就是样例） 时间复杂度O(mn) #include\u003ciostream\u003e\r#include\u003cmap\u003e\r#include\u003cvector\u003e\r#include\u003cqueue\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint n,m;\rint maze[7][7];\rint d[7][7];\rconst int inf=0x3f3f3f3f;\rtypedef pair\u003cint,int\u003e pii; //表示坐标 int sx,sy,gx,gy; //起点终点 int dx[]={0,0,1,-1};\rint dy[]={1,-1,0,0};\rmap\u003cpii,pii \u003e mp; //记录前驱节点,目的是记录路径 （如果记录路径就可以不用求最短距离） vector\u003cpii \u003e vt; //记录路径 void bfs()\r{\rqueue\u003cpii\u003e q;\rfill(d[0],d[0]+7*7,inf);\rq.push(pii(sx,sy));\rd[sx][sy]=0;\rwhile(q.size())\r{\rpii p=q.front();\rq.pop();\rif(p.first==gx and p.second==gy) break; //很重要的终止判断条件\r for(int i=0;i\u003c4;i++)\r{\rint nx=p.first+dx[i],ny=p.second+dy[i];\rif(nx\u003e=0 and ny\u003e=0 and nx\u003cn and ny\u003cm and maze[nx][ny]==0 and d[nx][ny]==inf) //inf的判断很重要\r {\rq.push(pii(nx,ny));\rd[nx][ny]=d[p.first][p.second]+1;\rmp[pii(nx,ny)]=pii(p.first,p.second);\r} } }\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r n=5;\rm=5;\rfor(int i=0;i\u003cn;i++)\rfor(int j=0;j\u003cm;j++)\rcin\u003e\u003emaze[i][j];\rsx=0,sy=0,gx=4,gy=4;\rbfs();\r//cout\u003c\u003cd[gx][gy]\u003c\u003cendl;\r pii p;\rp=pii(gx,gy);\rwhile(p!=pii(sx,sy))\r{\rvt.push_back(p);\rp=mp[p];\r}\rreverse(vt.begin(),vt.end());\rprintf(\"(%d, %d)\\n\",sx,sy);\rfor(vector\u003cpii\u003e::iterator it=vt.begin();it!=vt.end();it++)\r{\rprintf(\"(%d, %d)\\n\",it-\u003efirst,it-\u003esecond);\r}\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:14:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 一个经典的bfs模板就是用队列来控制广度优先 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:14:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"强连通分量 1236 ","date":"2020-01-27","objectID":"/poj/:15:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 第一问就是求scc的数量，第二问就是求对每个scc出度为0的数量和入度为0的数量 #include\u003ciostream\u003e\r#include\u003ccstring\u003e\r#include\u003cvector\u003e\rusing namespace std;\rconst int maxv = 105;\rint V; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv];\rvector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; int in[maxv],out[maxv];\rvoid add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u003cG[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u003crG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u003cV;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u003e\u003eV; for(int i=0;i\u003cV;i++){\rwhile(1){\rint tmp;\rcin\u003e\u003etmp;\rif(tmp==0) break;\rtmp--;\radd_edge(i,tmp); }\r}\rint k = kosaraju_scc();\rfor(int i=0;i\u003cV;i++){\rfor(int j=0;j\u003cG[i].size();j++){\rint to = G[i][j];\rif(cmp[i] != cmp[to]){\rin[cmp[to]]++;\rout[cmp[i]]++;\r}\r}\r}\rint ind =0;\rint outd = 0;\rfor(int i=0;i\u003ck;i++){\rif(in[i]==0) ind++;\rif(out[i]==0) outd++;\r}\rint ans;\rif(k==1) ans = 0;else ans = max(ind,outd);\rcout\u003c\u003cind\u003c\u003cendl;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:15:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"平面点分治 3714 ","date":"2020-01-27","objectID":"/poj/:16:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 懒得写 #include \u003ciostream\u003e\r#include \u003ciomanip\u003e\r#include \u003calgorithm\u003e\r#include \u003ccmath\u003e\rusing namespace std;\rtypedef double db ;\rstruct node{\rdb x, y;\rint flag;\r}vt[200005], tmp[200005];\rbool compy(node n1, node n2){\rreturn n1.y \u003c n2.y;\r}\rbool compx(node n1, node n2){\rreturn n1.x \u003c n2.x;\r}\rdb dist(node n1, node n2){\rdb dx = fabs(n1.x - n2.x);\rdb dy = fabs(n1.y - n2.y);\rreturn sqrt(dx * dx + dy * dy);\r}\rdb solve(int l, int r){\rif(l == r) return 1e50;\rint m = (l + r) / 2;\rdb d = min(solve(l, m), solve(m + 1, r));\rint cnt = 0;\rfor(int i = l; i \u003c= r; ++i){\rif(abs(vt[i].x - vt[m].x) \u003c d){\rtmp[++cnt] = vt[i];\r}\r}\rsort(tmp + 1, tmp + cnt + 1, compy);\rfor(int i = 1; i \u003c= cnt; ++i){\rfor(int j = i + 1; j \u003c= cnt; ++j){\rif(tmp[j].y - tmp[i].y \u003e= d) break;\rif(tmp[j].flag == tmp[i].flag) continue;\rd = min(d, dist(tmp[i], tmp[j]));\r}\r}\rreturn d;\r}\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n;\rcin \u003e\u003e n;\rfor(int i = 1; i \u003c= n; ++i){\rcin \u003e\u003e vt[i].x \u003e\u003e vt[i].y;\rvt[i].flag = 0;\r}\rfor(int i = n + 1; i \u003c= 2 * n; ++i){\rcin \u003e\u003e vt[i].x \u003e\u003e vt[i].y;\rvt[i].flag = 1;\r}\rsort(vt + 1, vt + 2 * n + 1, compx);\rcout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c solve(1, 2 * n) \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:16:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["note"],"content":"简易对拍","date":"2020-01-27","objectID":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/","tags":["cpp"],"title":"简易对拍","uri":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/"},{"categories":["note"],"content":"以这道题为例 准备一个对拍的文件夹，里面装这些东西 duipai_random_input_src.cpp是产生随机测试数据的代码 #include\u003ccstdlib\u003e\r#include\u003ciostream\u003e\r#include\u003cctime\u003e\rusing namespace std;\rint t=100; //数据组数\rint main()\r{\rsrand(time(0));\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"w\",stdout);\rint a,b;\rwhile(t--)\r{\ra=rand();\rb=rand();\rif(a\u003eb) swap(a,b);\rcout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003cendl;\r}\rreturn 0;\r} 将产生的随机测试数据写入duipai_random_input.txt中 ac代码或暴力搜索正确的代码 //ac\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u003c=50) return x;\rif(x\u003e50 and x\u003c=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u003e0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"r\",stdin);\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_ac_output.txt\",\"w\",stdout);\rwhile(~scanf(\"%lld%lld\",\u0026t1,\u0026t2)) {\rprintf(\"input data are %lld %lld --- \",t1,t2);\rprintf(\"%lld\\n\",fun(t2)-fun(t1-1));\r}\r//cout\u003c\u003cfun(180);\r return 0;\r}\r 从duipai_random_input.txt读入，写到duipai_ac_output.txt中 wa代码 //wa\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u003c=50) return x;\rif(x\u003e50 and x\u003c=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u003e0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"r\",stdin);\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_wa_output.txt\",\"w\",stdout);\rwhile(~scanf(\"%lld%lld\",\u0026t1,\u0026t2)) {\rprintf(\"input data are %lld %lld --- \",t1,t2);\rprintf(\"%lld\\n\",fun(t2)-fun(t1)+1);\r}\r//cout\u003c\u003cfun(180);\r return 0;\r}\r 从duipai_random_input.txt读入，写到duipai_wa_output.txt中 比较duipai_ac_output.txt 和 duipai_wa_output.txt 在duipai文件夹下运行批处理命令（duipai.bat） @echo off\rfc duipai_ac_output.txt duipai_wa_outout.txt\rpause\r echo off是不回显，fc是文件比较 运行cpp和bat程序 得到结果 过于复杂的输入数据和输出数据，简易对拍不好实现 要产生大随机数，可以用 long long r=123456789;\rcout\u003c\u003c(long long)((double)(rand()*r)/RAND_MAX);\r 这题也可对拍 ","date":"2020-01-27","objectID":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/:0:0","tags":["cpp"],"title":"简易对拍","uri":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/"},{"categories":["abc"],"content":"abc152-D","date":"2020-01-26","objectID":"/abc152-d/","tags":["cpp"],"title":"abc152-D","uri":"/abc152-d/"},{"categories":["abc"],"content":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数 字，B的第一个数字是A的最后一个数字，个位数也算，输出满足条件的正整数对的个数 这种题感觉abc一贯的风格 当时第一感觉是纯模拟肯定巨麻烦，就想着有没有规律，发现没有规律 又想着按数位分类。 按数位分类就要考虑对子里面的数位 花了一些时间把它整理成元素都是9^n的矩阵（一个对称矩阵） 然而并没有什么用，还是得求N-10^k这个剩余部分 问题又回到起点 试图从9^n求和中找规律，无果 试图简化模拟或换个角度模拟，无果 看了别人的解答，大同小异 遍历一遍N，二维数组存N中第一个数字为 i ，最后一个数字为 j 的个数 最后遍历ans+=c[i][j]*c[j][i] #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rlong long ans;\rlong long c[10][10];\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++)\r{\rstring s=to_string(i);\rc[s[0]-'0'][s[s.length()-1]-'0']++;\r}\rfor(int i=0;i\u003c10;i++)\rfor(int j=0;j\u003c10;j++)\rans+=c[i][j]*c[j][i];\rcout\u003c\u003cans;\rreturn 0; }\r 总结：我好弱啊 ","date":"2020-01-26","objectID":"/abc152-d/:0:0","tags":["cpp"],"title":"abc152-D","uri":"/abc152-d/"},{"categories":["note"],"content":"排序算法的时间复杂度","date":"2020-01-23","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","tags":["cpp","sort"],"title":"排序算法的时间复杂度","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["note"],"content":"时间复杂度与计算时间的关系","date":"2020-01-23","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","tags":["cpp"],"title":"时间复杂度与计算时间的关系","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["note"],"content":"CP笔记","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"记录的东西十分零散，适用于速查，不适合系统学习 由于记录的时候所掌握的知识很浅，所以可能存在错误 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:0:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"快速排序 #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\rvoid quicksort(int s[], int l, int r) {\rif (l \u003c r) {\rint i = l, j = r, x = s[l];\rwhile (i \u003c j) {\rwhile (i \u003c j \u0026\u0026 s[j] \u003e= x)\rj--;\rif (i \u003c j)\rs[i++] = s[j];\rwhile (i \u003c j \u0026\u0026 s[i] \u003c x)\ri++;\rif (i \u003c j)\rs[j--] = s[i];\r}\rs[i] = x;\rquicksort(s, l, i - 1);\rquicksort(s, i + 1, r);\r}\r}\rint main() {\rint a[10] = {3, 5, 1, 8, 9, 4, 2, 6, 0, 1};\rint i;\rquicksort(a, 1, 9);\rfor (i = 0; i \u003c 10; i++)\rcout \u003c\u003c a[i] \u003c\u003c ' ';\rreturn 0;\r}\r//3 0 1 1 2 4 5 6 8 9\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:1:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"产生随机数 #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\r//#include \u003crandom\u003e\r//#include \u003cchrono\u003e\r int main() {\rmt19937 rd(chrono::steady_clock::now().time_since_epoch().count());\rcout \u003c\u003c rd() % 101 + 1;\rreturn 0;\r}\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:2:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"STL ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"set #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\rint main() {\rset\u003cint\u003e st;\rint a[] = {1, 2, 3};\rst.insert(a, a + 3);\rst.erase(2);\rfor (int i : st) {\rcout \u003c\u003c i \u003c\u003c ' ';\r}\rst.erase(st.begin(), st.end());\rreturn 0;\r}\r//1 3\r\r 集合运算 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:1","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"map 和set差不多 map按key倒序排 map\u003cint, int, greater\u003cint\u003e\u003e mp;\r map想按value排，就要提取出来变成vector\u003cpair\u003cint, int» ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:2","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"其他 multiset允许值重复 multimap允许key重复 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:3","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"约瑟夫环 总共有people个人，喊到num的倍数退出，求最后一个人 int Josephus(int people, int num) {\rint i, r = 0;\rfor (i = 2; i \u003c= people; i++)\rr = (r + num) % i;\rreturn r + 1;\r}\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:4:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"流操作符boolalpha #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\rint main() {\rbool a = true;\rcout \u003c\u003c boolalpha \u003c\u003c a;\rreturn 0;\r}\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:5:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"自定义排序 #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\rstruct cmp {\rbool operator()(const int \u0026l, const int \u0026r) const {\rreturn l \u003e r;\r}\r};\rint main() {\rset\u003cint, cmp\u003e s;\rreturn 0;\r}\r #include \u003cbits/stdc++.h\u003e\r\rusing namespace std;\rusing ll = long long;\rstruct Student {\rint a;\rbool operator\u003c(const Student \u0026s) const {\rreturn this-\u003ea \u003e s.a;\r}\r};\rint main() {\rset\u003cStudent\u003e s;\rreturn 0;\r}\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:6:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"字符串和字符 c语言有关函数 #include \u003cbits/stdc++.h\u003e\r#include \u003ccctype\u003e\r\rusing namespace std;\rusing ll = long long;\r#define log(x) cout \u003c\u003c x \u003c\u003c '\\n'\r\rint main() {\rchar x ;\risalpha(x);\risdigit(x);\risupper(x);\rislower(x);\risalnum(x);\risblank(x); // space \\t\r isspace(x); // space \\t \\r \\n\r\rchar a[20] = \"hello\";\rchar b[20] = \" world\";\rchar c[20];\rstrcpy(c, a);\rlog(c); // hello\r memset(c, 0, sizeof(c));\rstrncpy(c, a, 3);\rlog(c); // hel\r strcat(a, b); // a = a + b\r log(a); // hello world\r log(strlen(a)); // 11\r bool yes = strcmp(a, b);\rchar* chptr = strchr(a, 'l');\rlog(chptr); // llo world\r char* chptr2 = strstr(a, \"rl\");\rlog(chptr2); // rld\r\rreturn 0;\r}\r string有时要用c_str() ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:7:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"背包问题 01背包2维 int n; // 物品个数\r int W; // 背包容量\r int dp[n + 5][W + 5];\rint w[n + 5]; // 每个物品的体积\r int v[n + 5]; // 每个物品的价值\r for (int i = 1; i \u003c= n; ++i) {\rfor (int j = 0; j \u003c= W; ++j) {\rif(j \u003c w[i]) {\rdp[i][j] = dp[i - 1][j];\r} else {\rdp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);\r}\r}\r}\rcout \u003c\u003c dp[n][W];\r 完全背包 2维 int n; // 物品个数\r int W; // 背包容量\r int dp[n + 5][W + 5];\rint w[n + 5]; // 每个物品的体积\r int v[n + 5]; // 每个物品的价值\r for (int i = 1; i \u003c= n; ++i) {\rfor (int j = 0; j \u003c= W; ++j) {\rif(j \u003c w[i]) {\rdp[i][j] = dp[i - 1][j];\r} else {\rdp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]); // 注意是dp[i]不是dp[i-1]\r }\r}\r}\rcout \u003c\u003c dp[n][W];\r 完全背包2维公式推导 01背包1维 for (int i = 1; i \u003c= n; ++i) for (int j = W; j \u003e= w[i]; j--) dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\rreturn dp[W];\r 完全背包1维 for (int i = 1; i \u003c= n; ++i) for (int j = w[i]; j \u003c= W; j++) dp[j] = max(dp[j], dp[j - w[i]] + v[i]);\rreturn dp[W];\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:8:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"memset memset只能初始化0, 1, 0x3f, 0xc0这种的，不能写2,3这种的 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:9:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"binary_search binary_search 用在有序数组里 #include \u003calgorithm\u003e\r\rvector\u003cint\u003e v = {1, 2, 3};\rbool condition = binary_search(v.begin(), v.begin() + 2, 1);\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:10:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"next_permutation next_permutation #include \u003calgorithm\u003e\rint a[3] = {1, 2, 3};\rdo {\rcout \u003c\u003c a[0] \u003c\u003c ' ' \u003c\u003c a[1] \u003c\u003c ' ' \u003c\u003c a[2] \u003c\u003c '\\n';\r}while (next_permutation(a, a + 3));\r//1 2 3\r//1 3 2\r//2 1 3\r//2 3 1\r//3 1 2\r//3 2 1\r next_permutation只能用在数字和字符中 prev_premutation类似 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:11:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"unique unique作用域有序数组 vector\u003cint\u003e a = {3, 3, 2, 2, 1, 1};\rsort(a.begin(), a.end());\ra.erase(unique(a.begin(), a.end(), [\u0026](int i, int j){return (i + 1) == j;}), a.end());\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:12:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"加速读写 ios::sync_with_stdio(false);\rcin.tie(nullptr);\rcout.tie(nullptr);\r 这样最好只用cin cout，不要用scanf和printf和gets()和puts() scanf和printf比这种加速读写快 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:13:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"While 读取 int a;\rwhile (~scanf(\"%d\", \u0026a)) {\r}\rwhile (scanf(\"%d\", \u0026a) != EOF) {\r}\r ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:14:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"sizeof退化 #include \u003cbits/stdc++.h\u003e\r#include \u003calgorithm\u003e\r\rusing namespace std;\rusing ll = long long;\r#define log(x) cout \u003c\u003c x \u003c\u003c '\\n'\r\rvoid fun(int a[]) {\rcout \u003c\u003c sizeof(a) \u003c\u003c '\\n';\r}\rint main() {\rint a[] = {1, 2, 3, 4, 5, 6, 7};\rfun(a); // output 8\r\rreturn 0;\r}\r 此处int[]变为指针，sizeof算的是地址长度，不是数组长度 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:15:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"find string的find没找到返回string::npos，stl返回end()，找到则返回下标的迭代器或偏移地址 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:16:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"c++交集、并集、差、对称差函数","date":"2020-01-17","objectID":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/"},{"categories":["note"],"content":" #include\u003ciostream\u003e\r#include\u003cset\u003e\r//#include\u003cmap\u003e\r//#include\u003cstring\u003e\r#include\u003calgorithm\u003e\r#include\u003citerator\u003e\rusing namespace std;\rint main()\r{\rint a[]={3,2,1};\rint b[]={3,4,5,6};\rset\u003cint\u003e s1(a,a+3);\rset\u003cint\u003e s2(b,b+4);\rset\u003cint\u003e s3;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin()));\rfor(set\u003cint\u003e::iterator it=s3.begin();it!=s3.end();it++)\rcout\u003c\u003c*it\u003c\u003c\" \";\rcout\u003c\u003cendl;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\"*\"));\rcout\u003c\u003cendl;\rset_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \"));\rcout\u003c\u003cendl;\rset_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \"));\rcout\u003c\u003cendl;\rset_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \"));\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/:0:0","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/"},{"categories":["note"],"content":"c++每种类型的值域","date":"2020-01-17","objectID":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/","tags":["cpp"],"title":"c++每种类型的值域","uri":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/"},{"categories":["note"],"content":" #include\u003ciostream\u003e\r#include\u003cstring\u003e\r#include \u003climits\u003e\rusing namespace std;\rint main()\r{\rcout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl;\rcout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl;\r// \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl;\r cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/:0:0","tags":["cpp"],"title":"c++每种类型的值域","uri":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/"},{"categories":["algorithm","note"],"content":"extended euclidean algorithm","date":"2020-01-17","objectID":"/extended-euclidean-algorithm/","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"/extended-euclidean-algorithm/"},{"categories":["algorithm","note"],"content":" #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint ex_gcd(int a,int b,int\u0026 x,int\u0026 y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main()\r{\rint a,b,x,y;\ra=60;\rb=22;\rcout\u003c\u003cex_gcd(a,b,x,y)\u003c\u003cendl;\rcout\u003c\u003cx\u003c\u003c\" \"\u003c\u003cy\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/extended-euclidean-algorithm/:0:0","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"/extended-euclidean-algorithm/"},{"categories":["algorithm","note"],"content":"ford fulkerson algorithm","date":"2020-01-17","objectID":"/ford-fulkerson-algorithm/","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"/ford-fulkerson-algorithm/"},{"categories":["algorithm","note"],"content":" //O(FE) /* input 5 7\r1 3 6\r3 5 8\r2 5 5\r3 2 3\r1 2 6\r4 1 10\r4 2 2\r4 5\routput\r11\r*/\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\r#define maxv 100\r#define inf 0x3f3f3f3f\rint v,e;\rint s,t;\rstruct edge{int to,cap,rev;\r};\rvector\u003cedge\u003e G[maxv];\rbool used[maxv];\rvoid add_edge(int from ,int to,int cap)\r{\rG[from].push_back((edge){to,cap,G[to].size()});\rG[to].push_back((edge){from,0,G[from].size()-1});\r}\rint dfs(int s,int t,int f)\r{\rif(s==t) return f;\rused[s]=true;\rfor(int i=0;i\u003cG[s].size();i++)\r{\redge \u0026e =G[s][i];\rif(!used[e.to] \u0026\u0026 e.cap\u003e0)\r{\rint d=dfs(e.to,t,min(f,e.cap));\rif(d\u003e0)\r{\re.cap-=d;\rG[e.to][e.rev].cap+=d;\rreturn d;\r}\r}\r}\rreturn 0;\r}\rint max_flow(int s,int t)\r{\rint flow=0;\rfor(;;)\r{\rmemset(used,0,sizeof(used));\rint f=dfs(s,t,inf);\rif(f==0) return flow;\rflow+=f;\r}\r}\rint main()\r{\rfreopen(\"input.txt\",\"r\",stdin);\rcin\u003e\u003ev\u003e\u003ee;\rfor(int i=0;i\u003ce;i++)\r{\rint from,to,cap;\rscanf(\"%d%d%d\",\u0026from,\u0026to,\u0026cap);\radd_edge(from,to,cap);\r}\rcin\u003e\u003es\u003e\u003et;\rcout\u003c\u003cmax_flow(s,t);\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/ford-fulkerson-algorithm/:0:0","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"/ford-fulkerson-algorithm/"},{"categories":["algorithm","note"],"content":"字符串匹配算法(未完成)","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"从学习方法和代码实现debug花了挺长时间。。。 这个算法是从字符串s中找子串p出现的第一个位置 以下是两个常见的字符串匹配算法（还有其他更高效的比如Turbo-bm算法，sunday算法） kmp算法和bm算法 时间复杂度是O(s+p) bm算法总体比kmp算法要快3倍 当然也可以直接用函数，比如 s.find( p ); //懒得写更多，懒得修饰代码 plus:字符串的读入常常会出现读空格、读回车等奇妙现象 ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:0","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"kmp算法 //kmp without optimization\r//strncpy() memmove()\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint kmp(char s[],char p[])\r{\r//preprocess\r int sl=strlen(s);\rint pl=strlen(p);\rchar subp[pl+1][pl+1];\rint next[pl+1];\rfor(int k=0;k\u003cpl;k++)\r{\rstrncpy(subp[k],p,k+1);\r}\r//can optimized\r for(int k=0;k\u003cpl;k++)\r{\rstring tl;\rstring tr;\rint len_sub=k+1;\rint len=0;\rfor(int m=len_sub-1;m\u003e0;m--)\r{\rtl=string(subp[k],subp[k]+m);\rtr=string(subp[k]+len_sub-m,subp[k]+len_sub);\rif(tl==tr)\r{\rlen=m;\rbreak;\r}\r}\rnext[k]=len;\r}\rfor(int k=pl-1;k\u003e0;k--)\r{\rnext[k]=next[k-1];\r}\rnext[0]=-1;\r//match\r int i=0;int j=0;\rwhile(1)\r{\rif(s[i]==p[j])\r{\ri++;\rj++;\r}\relse\r{\rint t=next[j];\rif(t==-1)\r{\ri++;\rj=0;\r}\relse\r{\rj=t;\r}\r}\rif(j\u003e=pl)\r{\rreturn i-pl;\r}\rif(i\u003e=sl)\r{\rreturn -1;\r}\r}\r}\rint main()\r{\rfreopen(\"input.txt\",\"r\",stdin);\rchar a[100];\rchar b[100];\rcin\u003e\u003ea\u003e\u003eb;\rcout\u003c\u003ckmp(a,b);\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:1","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"bm算法 //bm algorithm three to five times faster than kmp in genneral\r#include\u003ciostream\u003e\r#include\u003calgorithm\u003e\r#include\u003ccstring\u003e\r#include\u003cstring\u003e\r#include\u003cvector\u003e\rusing namespace std;\rint get_badc(char t,char a[])\r{\rint k=strlen(a)-1;\rwhile(1)\r{\rif(k\u003e=0) //assert\r {\rif(a[k--]==t)\r{\rreturn k+1;\r}\r}\relse return -1;\r}\r}\rint get_goods(vector\u003cchar\u003e t,char a[]) //most difficult\r{\rint k=strlen(a)-1;\rvector\u003cchar\u003e temp;\rint max_len=0;\rint m=0;\rint loc=-1;\rwhile(1)\r{ if(k\u003e=0) //assert\r {\rif(t[m]==a[k])\r{\rtemp.push_back(a[k]);\rm++;\rk--;\r}\relse\r{\rm=0;\rk--;\rif(temp.size()\u003emax_len)\r{\rmax_len=temp.size();\rloc=k+1;\rtemp.clear();\r}\r}\r}\relse return loc;\r}\r}\rint bm(char s[],char p[])\r{\rint sl=strlen(s);\rint pl=strlen(p);\rint i=pl-1;\rint j=pl-1;\rwhile(1)\r{\rif(i\u003csl and j\u003e=0) //asseert // i\u003csl !!!!!!!!!! not i\u003e0\r {\rif(s[i]==p[j])\r{\rvector\u003cchar\u003e goods;\rgoods.push_back(s[i]);\rwhile(1)\r{\ri--;\rj--;\rif(i\u003e=0 and j\u003e=0) //assert\r {\rif(s[i]!=p[j])\r{\rchar badc1=s[i];\rstring str(p,p+pl-goods.size());\rint loc1=get_badc(badc1,\u0026str[0]);\rint loc2=get_goods(goods,\u0026str[0]);\rif(loc1==-1 and loc2!=-1)\r{\ri+=pl-1-loc2;\rj=pl-1;\r}\relse if(loc2==-1 and loc1!=-1)\r{\ri+=pl-1-loc1;\rj=pl-1;\r}\relse\r{\ri+=pl-1-min(loc1,loc2);\rj=pl-1;\r}\r}\relse\r{\rgoods.push_back(s[i]); //still add in good-suffix\r }\r}\relse break;\r}\r}\relse //only have bad-character\r {\rchar badc2=s[i];\rint loc=get_badc(badc2,p);\ri+=pl-1-loc;\rj=pl-1;\r}\r}\relse if(i\u003e=sl) return -1; //!!!!!!!!!!!!!\r else return i+1; //!!!!!!!!!!!!\r }\r}\rint main()\r{\rfreopen(\"input.txt\",\"r\",stdin);\rchar a[100];\rchar b[100];\rcin\u003e\u003ea\u003e\u003eb;\rcout\u003c\u003cb\u003c\u003cendl\u003c\u003ca;\rcout\u003c\u003cbm(b,a)\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:2","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"筛法求区间内质数个数？","date":"2020-01-17","objectID":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/"},{"categories":["algorithm","note"],"content":"很早以前写的懒得去审查。。。 不知道对不对。。。 Eprime #include\u003cbits/stdc++.h\u003e\rusing namespace std;\r#define MAX 10000\rlong long prime1[MAX],num1;\rlong long prime2[MAX],num2;\rbool isprime1[MAX],isprime2[MAX];\rint qprime1(int n)\r{\rnum1=0;\rmemset(isprime1,1,sizeof(isprime1));\risprime1[0]=isprime1[1]=0;\rfor(int i=2;i\u003c=n;i++)\r{\rif(isprime1[i])\r{\rprime1[num1++]=i;\rfor(int j=2;j*i\u003c=n;j++)\risprime1[j*i]=0;\r}\r}\rreturn num1;\r}\rint qprime2(int m,int n)\r{\rnum2=0;\rqprime1((int)sqrt(n));\rmemset(isprime2,1,sizeof(isprime2));\rfor(int i=0;i\u003cnum1;i++)\r{\rfor(int j=m/prime1[i];j*prime1[i]\u003c=n;j++)\r{\risprime2[j*prime1[i]]=0;\r}\r}\rfor(int i=m;i\u003c=n;i++)\rif(isprime2[i]) num2++;\rreturn num2;\r} int main()\r{\rcout\u003c\u003cqprime2(10,100);\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/:0:0","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/"},{"categories":["note"],"content":"输入输出优化(提高读入输出速度)","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291 ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:0:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"1.用scanf,printf代替cin,cout ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:1:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"2.取消同步和绑定 ios::sync_with_stdio(false);\rcin.tie(0);\r//cout.tie(0);\r 此时只能用cin,cout ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:2:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"3.对整型输入输出，将每个数字变成字符 inline int read()\r{\rint x=0;int f=1;char s=getchar();\rwhile(s\u003c'0' or s\u003e'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u003e='0' and s\u003c='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rvoid write(int x)\r{\rif(x/10\u003e0) write(x/10);\rputchar(char(x%10+'0'));\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r int n=read();\rcout\u003c\u003cn\u003c\u003cendl;\rwrite(200);\rreturn 0;\r} ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:3:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"}]
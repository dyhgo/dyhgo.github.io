[{"categories":["note","cv"],"content":"三维空间的刚体运动","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"内积与外积 内积 外积 定义 ^ 符号 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:1:0","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"欧氏变换 euclidean transform ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:0","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"单次欧氏变换 同一个向量在两个坐标系中的表示，坐标系的变换包括一次旋转和一次平移 旋转 R为旋转矩阵（rotation matrix），它是一个行列式为1的正交矩阵（又叫特殊正交矩阵）（正交矩阵即逆为自身转置的矩阵）。反之，行列式为1的正交矩阵也是一个旋转矩阵，所以可以将n维旋转矩阵的集合定义为 SO(n) 是特殊正交群 （special orthogonal group） $$ a{}‘=R^{-1}a=R^Ta $$ R的逆矩阵或转置矩阵刻画了相反的旋转 平移 $$ a{}‘=Ra+t $$ $$ a_1=R_{12}a_2+t_{12} $$ t12表示2到1的变换 注意 t12 != -t21 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:1","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"多次欧氏变换 由于这种形式在多次变换之后会显得很冗长，所以采取以下措施 其中T是变换矩阵（transform matrix），a转变成齐次坐标 这样多次转换就变成 （约定之后的Ta，a就是齐次坐标化的，而Ra，a就是原来的） 对于变换矩阵T，满足该形式的矩阵可以构成特殊欧氏群（special euclidean group） T的逆表示相反的变换 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:2","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"旋转向量 由于旋转矩阵用16个量来表达6个自由度的变换显得很多余，为了减少变量，引入旋转向量 实际上，任意的旋转都可以有旋转轴和旋转角度来刻画 假设旋转轴为一个单位长度的向量n，旋转角度为θ 根据罗德里格斯公式（rodrigues’s formula） 对等式两边求迹（trace）得到角度的表示 由于旋转轴上的向量在旋转后不发生变化，所以 n是R在特征值为1时的特征向量 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:3:0","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"欧拉角 由于旋转向量和旋转矩阵不够直观，所以引入欧拉角 欧拉角把旋转分解成绕三个轴各自的旋转，由于分解方式很多，这里介绍最著名的rpy角 yaw-pitch-roll 绕物体的z轴旋转，得到yaw 绕旋转之后的y轴旋转，得到pitch 绕旋转之后的x轴旋转，得到roll 欧拉角的重大缺点就是万向锁问题（gimbal lock），当某个轴旋转90度时，第一次旋转和第三次旋转将使用同一个轴，这样就散失了一个自由度（这被称为奇异性问题），理论上可以证明，只要想用3个实数来表达三维旋转，都会出现奇异性问题，所以很少在slam中使用欧拉角，只用来验证自己的算法 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:4:0","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"四元数 四元数可视化的网站 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:0","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"复数 欧拉公式 把复平面的向量旋转x度，相当于乘上e^(ix) ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:1","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"四元数的定义 它有1个实部，3个虚部，虚部分别对应空间坐标系的三个坐标轴 自己和自己的运算像复数，自己和别人的运算像叉乘 乘以i相当于绕轴旋转180度，i^2=-1意味着绕i轴旋转360度后得到一个相反的东西（这是个定义） 补充 ijk = -1 四元数也可以这样表示 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:2","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"四元数的运算 加减法 乘法 向量形式 模长 共轭 四元数共轭与其本身相乘会得到一个实四元数，其实部为模长的平方 $$ q^*q=qq*=[s_a ^ 2 + v^Tv, 0]^T $$ 逆 如果q为单位四元数，其逆和共轭就是同一个量 $$ qq^{-1}=q^{-1}q=1 $$ 乘法的逆类似于矩阵 $$ (q_aq_b)^{-1} = q_b^{-1}q_a^{-1} $$ 数乘 点乘 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:3","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"四元数表示旋转 假设点p = [x, y, z] 是最初的点，旋转后变成 p’ 先将p变成虚四元数 $$ p = [0, x, y, z]^T = [0, v]^T $$ p'可以这样求得 $$ p{}‘=qpq^{-1} $$ 这里的乘法均为四元数乘法，结果也是四元数。最后把p'的虚部取出，就是旋转后的坐标。可以验证，计算后的实部为0 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:4","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"四元数到其他旋转表示的变换 假设 $$ q=[s,v]^T $$ $$ q=[q_0, q_1,q_2, q_3]^T $$ 从四元数得到旋转矩阵 $$ R=vv^T + s^2I+2sv^{\\wedge}+(v^{\\wedge})^2 $$ 从四元数得到旋转向量 从旋转向量到四元数 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:5","tags":["cv"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","cv"],"content":"今天你也要来点cmake吗","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/","tags":["cpp","cv"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","cv"],"content":"前言 很早就想写cmake，但是一直懒得写 今天也随便写点cmake 官方对cmake的解释 CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK. 按我的理解，cmake就是工程构建工具（多用于c++） ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:1:0","tags":["cpp","cv"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","cv"],"content":"实践 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:0","tags":["cpp","cv"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","cv"],"content":"预备 以一道题目来介绍cmake最基本的用法，这个例子不会用到任何ide，实际上用ide应该更好 实验环境 ubuntu 16.04 LTS cmake的安装见此处 题目如下，由于题意不清，仅供参考，实际的构建和题目有点差别 这个实验分成两部分，编写共享库并安装，使用库和头文件 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:1","tags":["cpp","cv"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","cv"],"content":"编写共享库并安装 编写静态库的操作和它差不多 首先建立tt文件夹，作为工程的总文件夹 在tt文件夹下建立build文件夹作为存放外部编译的中间文件，lib文件夹存放生成的库，CMakeLists.txt（按我的理解，这个文件就像cpu里的控制器，MakeFile文件夹之于CMakeLists.txt就像低级语言之于高级语言），src 文件夹放置该工程的源代码 文章最后有文件结构，看得更直观 tt/CMakeLists.txt tt文件夹下的CMakeLists.txt cmake_minimum_required(VERSION 3.5)\rproject(sayHello)\radd_subdirectory(lib)\radd_subdirectory(src)\r 解释一下，cmake_minimum_required 声明版本，不加构建的时候会报不是很严重的错 project 声明该工程的名字 add_subdirectory 关联子目录 如果是add_subdirectory(aaa bbb) 就是当外部编译时本该在build/aaa下生成的目标二进制文件，现在生成到了build/bbb下 tt/lib lib文件夹放三个文件，与库有关 hello.c #include \"hello.h\"\r#include \u003cstdio.h\u003e\rvoid sayHello(){printf(\"hello slam\\n\");}\r hello.h #pragma once\rvoid sayHello();\r CMakeLists.txt （为了追踪，这几乎每个文件夹都有） add_library(hello SHARED hello.c)\rset(CMAKE_INSTALL_PREFIX /usr/local)\rinstall(TARGETS hello LIBRARY DESTINATION lib)\rinstall(FILES hello.h DESTINATION include)\r 解释一下 add_library(hello SHARED hello.c) 第一个参数指库的名字，如果是hello，库的名字会自动变成libhello 第二个参数指代库的类型（共享库（动态库），静态库） ，分别对应 SHARED STATIC ，如果是动态库则生成 libhello.so 如果是静态库，则生成 libhello.a ，第三个参数是库的源代码 set(CMAKE_INSTALL_PREFIX /usr/local) CMAKE_INSTALL_PREFIX这是一个cmake变量，安装时路径是\u003cprefix\u003e/\u003ccustom\u003e install(TARGETS hello LIBRARY DESTINATION lib) 安装路径，第一个参数是静态库、动态库、目标二进制专用，hello指代库的名称（add_library时已指定），最后一个参数就是自定义相对路径，所以它会被装在/usr/local/lib 下 install(FILES hello.h DESTINATION include) 第一个参数表明待安装的是文件，它将被装在 /usr/local/include 下 构建 在build文件夹下 sudo cmake ..\rsudo make\rsudo make install\r 解释一下，这是cmake的最常用、最基本的命令， ..表示用上一级的CMakeLists.txt install是安装命令，构建之后，会在build文件夹下生成与tt文件夹下类似的文件（注意这句话） (忽略tt前面的前缀） 可以看到库和头文件已经按照题目要求成功安装（安装的目的在于可以使用） ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:2","tags":["cpp","cv"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","cv"],"content":"使用库 tt/src 在src文件夹编写要使用库的源代码 useHello.c （注意hello.h要用双引号，不能用尖括号） #include \"hello.h\"\rint main(int argc, char** argv){sayHello();}\r CMakeLists.txt add_executable(sayHello useHello.c)\rinclude_directories(/usr/local/include)\rlink_directories(/usr/local/lib)\rtarget_link_libraries(sayHello hello)\r 解释一下，add_executable(sayHello useHello.c) 第一个参数是程序名（自定义），第二个参数是程序源文件，这条指令的作用就是它的名字所描述的 include_directories(/usr/local/include) 注意，这条语句并不是包含了哪些目录的库（这么理解似乎也没什么问题），而是在包含库之后，它应该在哪个路径下搜索，由于hello.h是相对路径，如果装在/usr/include就没事了，因为它是默认的搜索路径，但是现在装在了 /usr/local/include 所以就要增加搜索路径（导向作用） link_directories(/usr/local/lib) 这条语句和上一条是相似的，我一直觉得它写成 library_directories 应该更好理解（其实没有这条指令，又想到include是动词，link也是动词就没事了），所以这条命令就是增加库的搜索路径（是的，不仅要搜索头文件，还要搜索库，因为头文件里什么也没有，只有一堆函数的空壳，实际的内容在源文件里(hello.c)，它和头文件一起生成了 libhello.so)，这也就是为什么有下一条指令的原因 target_link_libraries(sayHello hello) 用来连接目标二进制和库，至于为什么是 sayHello ，第一条指令已经给出 在build文件夹下构建，看到build文件夹下也有个 src文件夹，正如之前 build文件夹下有了lib一样 运行tt/build/src/sayHello 可以看到终端输出 hello world ，表明使用库成功 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:3","tags":["cpp","cv"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","cv"],"content":"文件结构 tt ---------------------------\r|\r| build -------------------\r| 。。。\r| 。。。\rlib ----------------------\r| hello.c\r| hello.h\r| CMakeLists.txt\rsrc -----------------------\r| useHello.c\r| CMakeLists.txt\rCMakeLists.txt ------------\r cmake好难，还有很多想写。。。下次一定 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:3:0","tags":["cpp","cv"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["codeforces"],"content":"Codeforces Round #672 (Div. 2) A~D","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"A. Cubes Sorting ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:1:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题意 对于一个数列，每次操作交换相邻的两个数，问是否需要达到n(n-1)/2次操作才可以让数列递增 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:1:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题解 判断数列是否严格单调递减 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rvector\u003cint\u003e vt;\rint n;\rcin \u003e\u003e n;\rfor(int i = 0; i \u003c n; ++i){\rint u;\rcin \u003e\u003e u;\rvt.push_back(u);\r}\rbool ok = false;\rfor(int i = 0; i \u003c n - 1; i ++){\rif(vt[i] \u003e vt[i + 1]) continue;\relse {\rok = true;\rbreak;\r}\r}\rif(ok) puts(\"YES\"); else puts(\"NO\");\r}\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:1:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"B. Rock and Lever ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:2:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题意 给一数列，判断有多少对数满足 x \u0026 y \u003e= x ^ y ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:2:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题解 根据位运算的定义，两个数的最高位（1）互相对齐就行，即二进制位数相等 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint main() {\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\rll n;\rcin \u003e\u003e n;\rmap\u003cll, ll\u003e mp;\rfor(ll i = 0; i \u003c n; ++i){\rll u;\rcin \u003e\u003e u;\rll v = u;\rll tmp = 0;\rwhile(v != 0){\rv \u003e\u003e= 1;\rtmp++;\r}\rmp[tmp]++;\r}\rll ans = 0;\rfor(auto i : mp){\rans += i.second * (i.second - 1) / 2;\r}\rcout \u003c\u003c ans \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:2:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"C1. Pokémon Army (easy version) ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:3:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题意 对于一个数列，选择一些数，按顺序执行加减交替操作，求可得到的最大值（第一个是加） ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:3:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题解 dp #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll dp[300005][2];\rll a[300005];\rint main() {\rll _;\rcin \u003e\u003e _;\rwhile (_--) {\rmemset(dp, 0, sizeof(dp));\rll n, q;\rcin \u003e\u003e n \u003e\u003e q;\rfor(ll i = 1; i \u003c= n; ++i){\rcin \u003e\u003e a[i];\r}\rdp[1][0] = a[1];\rdp[1][1] = 0;\rfor(ll i = 2; i \u003c= n; ++i){\rdp[i][0] = max(dp[i-1][0], dp[i-1][1] + a[i]);\rdp[i][1] = max(dp[i-1][1], dp[i-1][0] - a[i]);\r}\rcout \u003c\u003c max(dp[n][0], dp[n][1]) \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:3:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"C2. Pokémon Army (hard version) ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:4:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题意 在C1的基础上，增加q次操作，每次操作交换两个位置的数值，每次操作询问可得到的最大值 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:4:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题解 对于数列中的数值大小，波峰一定是加操作，波谷一定是减操作，对于每次的交换操作， 先消去这两个数（和它左右两个数）的影响，因为左右两个数决定了它是波峰还是波谷还是其他，交换后的数可能会影响原来左右的两个数 再加上交换数值后的影响（即该点和左右是否是波峰、波谷） #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxn = 300005;\rll a[maxn];\rint pos[maxn];\rint n, q;\rll ans;\rvoid init(){\ra[0] = a[n + 1] = 0;\rpos[0] = pos[n + 1] = -1;\rfor(int i = 1; i \u003c= n; ++i){\rif(a[i] \u003e a[i - 1] and a[i] \u003e a[i + 1]) {\rpos[i] = 1;\rans += a[i];\r}else if(a[i] \u003c a[i - 1] and a[i] \u003c a[i + 1]){\rpos[i] = -1;\rans -= a[i];\r}else{\rpos[i] = 0;\r}\r}\r}\rvoid did(int x){\rif(x \u003c= 0 or x \u003e n) return;\rif(pos[x] == 1){\rpos[x] = 0;\rans -= a[x];\r}else if(pos[x] == -1){\rpos[x] = 0;\rans += a[x];\r}\r}\rvoid update(int x){\rif(x \u003c= 0 or x \u003e n) return ;\rif(pos[x] == 0 and a[x] \u003e a[x + 1] and a[x] \u003e a[x - 1]) {\rpos[x] = 1;\rans += a[x];\r}else if(pos[x] == 0 and a[x] \u003c a[x + 1] and a[x] \u003c a[x - 1]){\rpos[x] = -1;\rans -= a[x];\r}\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rans = 0;\rcin \u003e\u003e n \u003e\u003e q;\rfor(int i = 1; i \u003c= n; ++i) cin \u003e\u003e a[i];\rinit();\rcout \u003c\u003c ans \u003c\u003c endl;\rwhile(q--){\rint l, r;\rcin \u003e\u003e l \u003e\u003e r;\rdid(l); did(l - 1); did(l + 1); did(r); did(r - 1); did(r + 1);\rswap(a[l], a[r]);\rupdate(l); update(l - 1); update(l + 1); update(r); update(r - 1); update(r + 1);\rcout \u003c\u003c ans \u003c\u003c endl;\r}\r}\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:4:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"D. Rescue Nibel! ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:5:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题意 有n盏灯，每盏灯有打开的时间和关闭的时间l，r，选择其中k盏，满足存在某一时刻这k盏灯同时亮，求选择方案数 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:5:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["codeforces"],"content":"题解 离散化，枚举每个时间点，查看有多少盏灯之前就亮着，多少盏灯加入到亮的行列，排列组合 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll n, k;\rll ans;\rset\u003cll\u003e L;\runordered_map\u003cll, vector\u003cll\u003e \u003e R;\rpriority_queue\u003cll, vector\u003cll\u003e, greater\u003c\u003e \u003e pq;\rconst ll maxn = 300005;\rll inv[maxn];\rll fac[maxn];\rll cnt;\rll tmp;\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinline ll A(ll m,ll n){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rfor(ll i=0;i\u003cmaxn;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u003cmaxn;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!!\r for(ll i=2;i\u003cmaxn;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003cmaxn;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rcin \u003e\u003e n \u003e\u003e k;\rfor(int i = 0; i \u003c n; ++i){\rll l, r;\rcin \u003e\u003e l \u003e\u003e r;\rR[l].push_back(r);\rL.insert(l);\r}\rfor(auto i : L){\rtmp = 0;\rcnt = pq.size();\rwhile(!pq.empty()){\rif(pq.top() \u003c i){\rpq.pop();\rcnt--;\r}else break;\r}\rfor(auto j : R[i]){\rpq.push(j);\rtmp++;\r}\rif(tmp + cnt \u003c k) continue;\rfor(ll e = 1; e \u003c= min(k, tmp); ++e){\rif(tmp \u003e= e and cnt \u003e= k - e) ans += C(e, tmp) * C(k - e, cnt) % mod;\r}\r}\rcout \u003c\u003c ans % mod \u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a-~-d/:5:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a-~-d/"},{"categories":["algorithm"],"content":"FFT \u0026 NTT","date":"2020-09-24","objectID":"/fft-ntt/","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"前言 一篇没什么用的文章，记录一下FFT和NTT的板子 fft和ntt的原理参考FFT \u0026 NTT ","date":"2020-09-24","objectID":"/fft-ntt/:1:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"概述 fft和ntt差不多，基础用法就是加速多项式乘法，把多项式从系数表示转成点值表示来方便计算，而要转成点值表示，不能选择任意点。有些点的若干次方是1（实际上可以是-1,+i,-i等等），这样不需要做所有的次方运算，而这些点在复平面单位圆上。在ntt中是拿原根替换fft的单位根。 它们的时间复杂度都是O(nlgn) ","date":"2020-09-24","objectID":"/fft-ntt/:2:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"优缺点 ntt能取模，没有浮点精度误差，但是系数必须是整数，模数通常是998244353，原根是3 fft和ntt还有很多扩充的技巧和应用 以多项式乘法为例 ","date":"2020-09-24","objectID":"/fft-ntt/:3:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"模板 ","date":"2020-09-24","objectID":"/fft-ntt/:4:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"fft typedef complex\u003cdouble\u003e cp ;\rconst double pi = acos(-1);\rint m, n;\rconst int maxn = 4 * 1e6 + 2; //记得开大点 因为2的幂次，最好乘4\rcp a[maxn], b[maxn]; // a表示第一个多项式的系数（按幂次递增）\rint rev[maxn];\rint bt; // 扩展成2的次幂后的二进制位数\rint mn; //相乘后的最高次幂即mn = m + n，m和n分别是最高次幂\rint fmn; //扩展成2的次幂的最高次幂\rvoid fft(cp* x, int len, int sign){ //sign表示共轭复数的符号\r for(int i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(int i = 1; i \u003c len; i \u003c\u003c= 1){\rcp tmp(cos(pi / i), sign * sin(pi / i));\rfor(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){\rcp omega(1, 0);\rfor(int l = 0; l \u003c i; l++, omega *= tmp){\rcp p = x[j + l], q = omega * x[j + l + i];\rx[j + l] = p + q, x[j + l + i] = p - q;\r}\r}\r}\r}\r ","date":"2020-09-24","objectID":"/fft-ntt/:4:1","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"ntt const ll mod = 998244353; //一般意义下的模数\rconst ll g = 3; //998244353对应的原根\rll m, n;\rconst ll maxn = 4 * 1e6 + 2; //记得开大点\rll a[maxn], b[maxn];\rll rev[maxn];\rll bt;\rll mn;\rll fmn;\rll qpow(ll x, ll nn){\rll res = 1;\rwhile(nn \u003e 0){\rif(nn \u0026 1) res = res * x % mod;\rx = x * x % mod;\rnn \u003e\u003e= 1;\r}\rreturn res;\r}\rvoid ntt(ll x[], ll len, int type){\rfor(ll i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(ll i = 1; i \u003c len; i *= 2){\rll tmp = qpow(g, (mod - 1) / (i * 2) );\rif(type == -1) tmp = qpow(tmp, mod - 2);\rfor(ll j = 0; j \u003c len; j += i * 2){\rll omega = 1;\rfor(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){\rll p = x[j + k], q = omega * x[j + k + i] % mod;\rx[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod;\r}\r}\r}\r}\r ","date":"2020-09-24","objectID":"/fft-ntt/:4:2","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"模板题 ","date":"2020-09-24","objectID":"/fft-ntt/:5:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"多项式乘法 题目 fft实现 #include \"bits/stdc++.h\"\rusing namespace std;\rtypedef long long ll ;\rtypedef complex\u003cdouble\u003e cp ;\rconst double pi = acos(-1);\rint m, n;\rconst int maxn = 4 * 1e6 + 2; //记得开大点\rcp a[maxn], b[maxn];\rint rev[maxn], ans[maxn];\rint bt;\rint mn;\rint fmn;\rvoid fft(cp* x, int len, int sign){\rfor(int i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(int i = 1; i \u003c len; i \u003c\u003c= 1){\rcp tmp(cos(pi / i), sign * sin(pi / i));\rfor(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){\rcp omega(1, 0);\rfor(int l = 0; l \u003c i; l++, omega *= tmp){\rcp p = x[j + l], q = omega * x[j + l + i];\rx[j + l] = p + q, x[j + l + i] = p - q;\r}\r}\r}\r}\rint main() {\rscanf(\"%d%d\", \u0026m, \u0026n);\rfor(int i = 0; i \u003c= m; ++i){\rscanf(\"%lf\", \u0026a[i]);\r}\rfor(int i = 0; i \u003c= n; ++i){\rscanf(\"%lf\", \u0026b[i]);\r}\rmn = m + n;\rfor(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++;\rfor(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1));\rfft(a, fmn, 1);\rfft(b, fmn, 1);\rfor(int i = 0; i \u003c= fmn; ++i) a[i] = a[i] * b[i];\rfft(a, fmn, -1);\rfor(int i = 0; i \u003c= mn; ++i) printf(\"%d \", (int)(a[i].real()/fmn + 0.5));\rreturn 0;\r}\r ntt实现 #include \"bits/stdc++.h\"\rusing namespace std;\rtypedef long long ll ;\rconst ll mod = 998244353;\rconst ll g = 3;\rll m, n;\rconst ll maxn = 4 * 1e6 + 2; //记得开大点\rll a[maxn], b[maxn];\rll rev[maxn], ans[maxn];\rll bt;\rll mn;\rll fmn;\rll qpow(ll x, ll nn){\rll res = 1;\rwhile(nn \u003e 0){\rif(nn \u0026 1) res = res * x % mod;\rx = x * x % mod;\rnn \u003e\u003e= 1;\r}\rreturn res;\r}\rvoid ntt(ll x[], ll len, int type){\rfor(ll i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(ll i = 1; i \u003c len; i *= 2){\rll tmp = qpow(g, (mod - 1) / (i * 2) );\rif(type == -1) tmp = qpow(tmp, mod - 2);\rfor(ll j = 0; j \u003c len; j += i * 2){\rll omega = 1;\rfor(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){\rll p = x[j + k], q = omega * x[j + k + i] % mod;\rx[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod;\r}\r}\r}\r}\rint main() {\rscanf(\"%d%d\", \u0026m, \u0026n);\rfor(int i = 0; i \u003c= m; ++i){\rscanf(\"%lld\", \u0026a[i]);\ra[i] += mod;\ra[i] %= mod;\r}\rfor(int i = 0; i \u003c= n; ++i){\rscanf(\"%lld\", \u0026b[i]);\rb[i] += mod;\rb[i] %= mod;\r}\rmn = m + n;\rfor(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++;\rfor(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1));\rntt(a, fmn, 1);\rntt(b, fmn, 1);\rfor(ll i = 0; i \u003c= fmn; ++i) a[i] = (a[i] * b[i]) % mod;\rntt(a, fmn, -1);\rll inv_fmn = qpow(fmn, mod - 2);\rfor(ll i = 0; i \u003c= mn; ++i){\rprintf(\"%lld \", a[i] * inv_fmn % mod);\r}\rreturn 0;\r}\r ","date":"2020-09-24","objectID":"/fft-ntt/:5:1","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"高精度乘法 fft实现 #include \"bits/stdc++.h\"\rusing namespace std;\rtypedef complex\u003cdouble\u003e cp ;\rconst double pi = acos(-1);\rint m, n;\rconst int maxn = 4 * 1e6 + 2; //记得开大点\rcp a[maxn], b[maxn];\rint rev[maxn];\rint ans[maxn];\rint bt;\rint mn;\rint fmn;\rvoid fft(cp* x, int len, int sign){\rfor(int i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(int i = 1; i \u003c len; i \u003c\u003c= 1){\rcp tmp(cos(pi / i), sign * sin(pi / i));\rfor(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){\rcp omega(1, 0);\rfor(int l = 0; l \u003c i; l++, omega *= tmp){\rcp p = x[j + l], q = omega * x[j + l + i];\rx[j + l] = p + q, x[j + l + i] = p - q;\r}\r}\r}\r}\rint main() {\rstring s1, s2;\rcin \u003e\u003e s1 \u003e\u003e s2;\rm = s1.size() - 1;\rn = s2.size() - 1;\rfor(int i = 0; i \u003c= m; ++i){\ra[i] = (double) (s1[m - i] - '0');\r}\rfor(int i = 0; i \u003c= n; ++i){\rb[i] = (double) (s2[n - i] - '0');\r}\rmn = m + n;\rfor(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++;\rfor(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1));\rfft(a, fmn, 1);\rfft(b, fmn, 1);\rfor(int i = 0; i \u003c= fmn; ++i) a[i] = a[i] * b[i];\rfft(a, fmn, -1);\rfor(int i = 0; i \u003c= mn; ++i){\rans[i] += (int) (a[i].real() / fmn + 0.5); // 注意+= 不是 =\r ans[i + 1] += ans[i] / 10 ;\rans[i] %= 10;\r}\rif((mn == 0 and ans[0] == 0) or (mn \u003e 0 and ans[1] == 0)) {\rputs(\"0\");\rexit(0);\r}\rfor(int i = mn + 1; i \u003e= 0; --i){ //进位\r if(ans[i] == 0 and i == mn + 1)\rcontinue;\rcout \u003c\u003c ans[i];\r}\rreturn 0;\r}\r ntt实现 #include \"bits/stdc++.h\"\rusing namespace std;\rtypedef long long ll ;\rconst ll mod = 998244353;\rconst ll g = 3;\rll m, n;\rconst ll maxn = 4 * 1e6 + 2; //记得开大点\rll a[maxn], b[maxn];\rll rev[maxn];\rll ans[maxn];\rll bt;\rll mn;\rll fmn;\rll qpow(ll x,ll nn){\rll res = 1;\rwhile(nn \u003e 0){\rif(nn \u0026 1) res = res * x % mod;\rx = x * x % mod;\rnn \u003e\u003e= 1;\r}\rreturn res;\r}\rvoid ntt(ll x[], ll len, int type){\rfor(ll i = 0; i \u003c len; ++i){\rif(i \u003c rev[i]) swap(x[i], x[rev[i]]);\r}\rfor(ll i = 1; i \u003c len; i *= 2){\rll tmp = qpow(g, (mod - 1) / (i * 2));\rif(type == -1) tmp = qpow(tmp, mod - 2);\rfor(ll j = 0; j \u003c len; j += i * 2){\rll omega = 1;\rfor(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){\rll p = x[j + k], q = omega * x[j + k + i] % mod;\rx[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod;\r}\r}\r}\r}\rint main() {\rstring s1, s2;\rcin \u003e\u003e s1 \u003e\u003e s2;\rm = s1.size() - 1;\rn = s2.size() - 1;\rfor(int i = 0; i \u003c= m; ++i){\ra[i] = s1[m - i] - '0';\r}\rfor(int i = 0; i \u003c= n; ++i){\rb[i] = s2[n - i] - '0';\r}\rmn = m + n;\rfor(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++;\rfor(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1));\rntt(a, fmn, 1);\rntt(b, fmn, 1);\rfor(ll i = 0; i \u003c= fmn; ++i) {\ra[i] = a[i] * b[i] % mod;\r}\rntt(a, fmn, -1);\rll inv_fmn = qpow(fmn, mod - 2);\rfor(ll i = 0; i \u003c= fmn; ++i){\rans[i] += a[i] * inv_fmn % mod;\rans[i + 1] = ans[i] / 10;\rans[i] %= 10;\r}\rif((mn == 0 and ans[0] == 0) or (mn \u003e 0 and ans[1] == 0)) {\rputs(\"0\");\rexit(0);\r}\rfor(int i = mn + 1; i \u003e= 0; --i){ //进位\r if(ans[i] == 0 and i == mn + 1)\rcontinue;\rcout \u003c\u003c ans[i];\r}\rreturn 0;\r}\r 接下来了解下trie树，国庆做点dp题 ","date":"2020-09-24","objectID":"/fft-ntt/:5:2","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["problemlist"],"content":"无聊的做题记录","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数学公式 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 错排公式 Dn = floor(n!/e + 0.5) = (n - 1) * (Dn-1 + Dn-2) D1 = 0 , D2 = 1 //457ms/1000ms 488k/32768k\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint main() {\rll n;\rcin \u003e\u003e n;\rll one = 0, to = 1;\rll ans = 0;\rfor(int i = 2; i \u003c n; ++i){\rans = i * (one + to);\rans %= mod;\rone = to;\rto = ans;\r}\rcout \u003c\u003c ans ;\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"贪心 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 最优策略一定是捕鱼和炖鱼并行，但是捕鱼的过程不能中断，所以就有时间浪费，分两种，1.在炖鱼结束前停止捕鱼，2.炖鱼结束前，捕一条鱼，炖鱼结束，捕鱼还没结束 对每一次炖鱼选择哪一种？2优于1在于同样是浪费时间，2可以多收获一条生鱼 所以每次都选择2策略，捕鱼顺序会影响时间，为了让浪费时间尽可能少，应该求出每一次炖鱼的“浪费时间”，然后从小到大排序，选择前“浪费时间的次数”个 //436ms/1000ms 4024kb/65536kb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll a[100005];\rvector\u003cll\u003e b;\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rb.clear();\rint n, k;\rcin \u003e\u003e n \u003e\u003e k;\rll ans = 0;\rll sum = 0;\rfor(int i = 0; i \u003c n; ++i) {\rcin \u003e\u003e a[i];\rans += a[i];\rsum += a[i] / k;\rb.push_back(k - a[i] % k);\r}\rsort(b.begin(), b.end());\rfor(int i = 0; i \u003c n - sum - 1; ++i){\rans += b[i];\r}\rans += k;\rcout \u003c\u003c ans \u003c\u003c endl;\r}\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"树形dp dfs 数论 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 dp[i][j] 表示以 i 为根的树，i节点为j时的方案数 dp[i][j] = 每个子节点满足条件的方案数相乘（满足的条件是gcd(i,j) != w） 子节点又要求子节点所以形成dfs 由于求j满足gcd(i,j) = w比较好求（枚举w的倍数），所以满足条件的方案数是所有方案数减不满足条件方案数 所有方案数即dp[i][1] + dp[i][2] + … + dp[i][m] 这可以每次求完所有的dp[i][x] 之后求和，用sum[i]维护 整体过程就是先dfs子节点，处理完毕后遍历m，然后遍历每个子节点，算出该子节点对dp[i][j]的贡献（满足的方案数），最后求积，赋值给dp[i][j]，然后再遍历一遍m在线预处理sum[i] 时间复杂度 O(m^2logm) 如果m是1e5，可能需要莫比乌斯反演 注意这不是一棵树，是无向图 //537ms/1000ms 8192kb/262144kb\r #include \"bits/stdc++.h\"\r using namespace std;\rusing ll = long long;\rconst int maxn = 1005;\rll sum[maxn];\rconst ll mod = 1e9 + 7;\rll n, m;\rll dp[maxn][maxn];\rstruct edge{\rint to , next;\rll w;\r}e[2*maxn];\rint tot,head[maxn];\rll gcd(ll a, ll b){\rreturn b ? gcd(b, a%b) : a;\r}\rvoid add_edge(int u, int v, ll w){\re[tot].to = v;\re[tot].w = w;\re[tot].next = head[u];\rhead[u] = tot++;\r}\rvoid dfs(int x, int p){\rfor(int i = head[x]; ~i; i = e[i].next){\rint v = e[i].to;\rif(v != p) dfs(v, x);\r}\rfor(ll i = 1; i \u003c= m; ++i){\rll cnt = 1;\rfor(int j = head[x]; ~j; j = e[j].next){\rint v = e[j].to;\rll w = e[j].w;\rif(v == p) continue;\rll rem = sum[v];\rfor(ll k = w; k \u003c= m; k += w){\rif(gcd(i, k) == w){\rrem -= dp[v][k];\rrem += mod;\rrem %= mod;\r}\r}\rcnt *= rem;\rcnt %= mod;\r}\rdp[x][i] = cnt;\rdp[x][i] %= mod;\r}\rfor(ll i = 1; i \u003c= m; ++i){\rsum[x] += dp[x][i];\rsum[x] %= mod;\r}\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(nullptr);\rcout.tie(nullptr);\rmemset(head , -1 , sizeof(head));\rcin \u003e\u003e n \u003e\u003e m;\rfor(int i = 0; i \u003c n - 1; ++i){\rint u, v, w;\rcin \u003e\u003e u \u003e\u003e v \u003e\u003e w;\radd_edge(u, v, w);\radd_edge(v, u, w);\r}\rdfs(1, 0);\rcout \u003c\u003c sum[1] \u003c\u003c endl;\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp 乘法原理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 用dp处理排列组合问题，对于子序列的数量，考虑对前缀的依赖 dp[3] 表示扫描到当前abc的数量，dp[2]表示扫描到当前ab的数量，dp[1]表示扫描到当前a的数量，dp[0]表示扫描到当前单纯排列组合的数量 转移方程 dp[3] = dp[3] + dp[2] [ch[i] == 'c'] dp[2] = dp[2] + dp[1] [ch[i] == 'b'] dp[1] = dp[1] + dp[0] [ch[i] == 'a'] 当前字符是？时，它有三种情况a, b, c所以对于dp[0], dp[1], dp[2], dp[3]都乘以3 然后再分a, b, c三种情况 对于c，dp[3] += dp[2] （这是未扫描到当前的dp[2]）其他同理 初始化 dp[0] = 1 //61ms/1000ms 208kb/256mb\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9 + 7;\rchar a[200005];\rll dp[4];\rint main(){\rint n;\rcin \u003e\u003e n;\rcin \u003e\u003e a;\rdp[0] = 1;\rfor(int i = 0; i \u003c n; ++i){\rif(a[i] == 'a'){\rdp[1] = (dp[1] + dp[0]) % mod;\r}else if(a[i] == 'b'){\rdp[2] = (dp[2] + dp[1]) % mod;\r}else if(a[i] == 'c'){\rdp[3] = (dp[3] + dp[2]) % mod;\r}else{\rdp[3] = (3ll * dp[3] + dp[2]) % mod;\rdp[2] = (3ll * dp[2] + dp[1]) % mod;\rdp[1] = (3ll * dp[1] + dp[0]) % mod;\rdp[0] = (3ll * dp[0]) % mod;\r}\r}\rcout \u003c\u003c dp[3] \u003c\u003c endl;\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp bf 预处理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给定一个大写的字符串，每个大写的字母都代表三个字母的组合（qwe），每次释放一个qwe中的技能就会获得这个字母，至多只能获得三个，如果在已有三个字母的情况下获得释放技能，第一个字母将会被挤掉（类似于队列）当集齐该大写字母的三个字母组合时，释放r技能就能成功点亮这个大写字母，这时候字母队列中不会有任何变化，问最少需要释放几个技能把所有的大写字母按顺序点亮 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 按顺序暴力，由于大写字母对应的是技能的组合，总共有6种，所以求出前6种组合对后6种组合的影响，然后对每个都取最小值，这样就形成dp dp[i][j] 表示扫描完第 i 个大写字母时，对应的第 j 种组合（至多6种）的答案 初始化 dp[0][i] = 3 [0 \u003c= i \u003c 6] 状态转移方程 dp[i][j] = min(dp[i][j], dp[i - 1][k] + cot(string s[i - 1][k], string s[i][j]) 最后的答案就是 min(dp[s.len - 1][i]) [0 \u003c= i \u003c 6] 如果不做优化会超时，优化的方法就是两处预处理（在代码中标注） //358ms/1000ms 2772kb/1024mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxn = 100005;\r//string s;\rchar s[maxn];\runordered_map\u003cchar, int\u003e mp;\r//括号不匹配\rchar ch[11][7][4] =\r{{\"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\"}},\r{\"QQW\", \"QWQ\", \"QQW\", \"QWQ\", \"WQQ\", \"WQQ\"},\r{\"QQE\", \"QEQ\", \"QQE\", \"QEQ\", \"EQQ\", \"EQQ\"},\r{\"WWW\", \"WWW\", \"WWW\", \"WWW\", \"WWW\", \"WWW\"},\r{\"QWW\", \"QWW\", \"WQW\", \"WWQ\", \"WQW\", \"WWQ\"},\r{\"WWE\", \"WEW\", \"WWE\", \"WEW\", \"EWW\", \"EWW\"},\r{\"EEE\", \"EEE\", \"EEE\", \"EEE\", \"EEE\", \"EEE\"},\r{\"QEE\", \"QEE\", \"EQE\", \"EEQ\", \"EQE\", \"EEQ\"},\r{\"WEE\", \"WEE\", \"EWE\", \"EEW\", \"EWE\", \"EEW\"},\r{{\"QWE\", \"QEW\", \"WQE\", \"WEQ\", \"EQW\", \"EWQ\"}};\rint dp[maxn][6];\rint did(string s1, string s2){\rif(s1 == s2) return 0;\rif(s1[1] == s2[0] and s1[2] == s2[1]) return 1;\rif(s1[2] == s2[0]) return 2;\rreturn 3;\r}\rconst int inf = 0x3f3f3f3f;\r//int get_id(char x){\r// if(x == 'Y') return 0;\r// if(x == 'V') return 1;\r// if(x == 'G') return 2;\r// if(x == 'C') return 3;\r// if(x == 'X') return 4;\r// if(x == 'Z') return 5;\r// if(x == 'T') return 6;\r// if(x == 'F') return 7;\r// if(x == 'D') return 8;\r// return 9;\r//}\rint cot[11][7][11][7];\rint main() {\rmp['Y'] = 0;\rmp['V'] = 1;\rmp['G'] = 2;\rmp['C'] = 3;\rmp['X'] = 4;\rmp['Z'] = 5;\rmp['T'] = 6;\rmp['F'] = 7;\rmp['D'] = 8;\rmp['B'] = 9;\rfor(int i = 0; i \u003c 10; ++i){\rfor(int j = 0; j \u003c 6; ++j){\rfor(int k = 0; k \u003c 10; ++k){\rfor(int m = 0; m \u003c 6; ++m){\rstring s1 = ch[i][j];\rstring s2 = ch[k][m];\rcot[i][j][k][m] = did(s1, s2);\r}\r}\r}\r}\r//cin \u003e\u003e s;\r scanf(\"%s\", s);\rint len = strlen(s);\rfor(int i = 0; i \u003c= len; ++i)\rfor(int j = 0; j \u003c 6; ++j)\rdp[i][j] = inf;\r//cout \u003c\u003c len \u003c\u003c endl;\r for(int i = 0; i \u003c 6; ++i){\rdp[0][i] = 3;\r}\rfor(int i = 1; i \u003c len; ++i){\rint id1 = mp[s[i - 1]]; //在外层循环得到\r int id2 = mp[s[i]];\rfor(int j = 0; j \u003c 6; ++j){\rfor(int k = 0; k \u003c 6; ++k){\rdp[i][j] = min(dp[i][j], dp[i - 1][k] + cot[id1][k][id2][j]); //!!!此处预处理\r //dp[i][j] = min(dp[i][j], dp[i - 1][k] + did(ch[id1][k], ch[id2][j]));\r }\r}\r}\rint ans = 0x3f3f3f3f;\rfor(int i = 0; i \u003c 6; ++i){\rans = min(ans, dp[len - 1][i]);\r}\rcout \u003c\u003c ans + len \u003c\u003c endl;\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dfs 图论 乘法原理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给一个森林，每个连通块都是仙人掌图，每次删除一些边，使得它变成一个森林且每个连通块都是一棵树，问有多少种删边方法 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 根据仙人掌图的定义，对于每个环，至少删除一条边就能满足条件，所以计算每个环的边数 对于不在环上的边，可以任意删除或保留，假设每个环的边数为ci，不在环上的边数是r $$ ans = 2^r*\\prod (2^{c_i} - 1) $$ 对于找环的边数，可以用tarjan算法的思想，用dfs序来判断是否遍历过这个点，如果遍历过就说明形成环，dfs序相减就是环的长度 //358ms/1000ms 138640kb/1048576kb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxv = 300005;\rconst ll mod = 998244353;\rconst int maxn = 2000005;\rstruct edge{\rint to, nxt;\r}e[maxn];\rint tot,head[maxn];\rvoid add_edge(int u,int v){\re[tot].to = v;\re[tot].nxt = head[u];\rhead[u] = tot++;\r}\rvector\u003cll\u003e res;\rint dfn[maxv],low[maxv];\rbool in_stack[maxv];\rstack\u003cint\u003e s;\rint tim;\rll qpow(ll x,ll n){\rll res =1;\rwhile(n\u003e0){\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rvoid tarjan_dfs(int x, int p){\rfor(int i = head[x]; ~i; i = e[i].nxt){\rint v = e[i].to;\rif(v == p) continue;\rif(dfn[v] != 0){\rres.push_back(dfn[x] + 1 - dfn[v]);\r}else{\rdfn[v] = dfn[x] + 1;\rtarjan_dfs(v, x);\r}\r}\r}\rint main() {\rint n, m;\rwhile(scanf(\"%d%d\", \u0026n, \u0026m) != EOF){\r//reset\r res.clear();\rtim = 0;\rmemset(dfn, 0, sizeof(dfn));\rmemset(low, 0, sizeof(low));\rmemset(in_stack, 0, sizeof(in_stack));\rwhile(!s.empty()) s.pop();\rtot = 0;\rmemset(head , -1 , sizeof(head));\rfor(int i = 0; i \u003c m; ++i){\rint u, v;\rscanf(\"%d%d\", \u0026u, \u0026v);\radd_edge(u, v);\radd_edge(v, u);\r}\rfor(int i = 1; i \u003c= n; ++i){\rif(!dfn[i]){\rdfn[i] = 1;\rtarjan_dfs(i, 0);\r}\r}\rll rem = 0;\rfor(ll i : res) {\rif(i \u003e 0) rem += i;\r}\rrem = m - rem;\rll ans = 1;\rfor(ll i : res){\rif(i \u003c= 0) continue;\rans *= qpow(2, i) - 1;\rans += mod;\rans %= mod;\r}\rans *= qpow(2, rem);\rans += mod;\rans %= mod;\rprintf(\"%lld\\n\", ans);\r//for(ll i : res) cout \u003c\u003c i \u003c\u003c \" \";\r //for(int i = 1; i \u003c 6; ++i) cout \u003c\u003c dfn[i] \u003c\u003c \" \";\r }\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp lis 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 在一个网格上有n个明星，他们出现的时间是0~ti，从(1,1)出发，每走一格消耗一个时间单位，问最多能碰见几个明星 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 注意一个重要条件：时间是按严格升序排的，r\u003c=500 类似于lis的dp，dp[i]表示最后碰见第i个人时的答案 ans = max(ans, dp[i]) [1 \u003c= i \u003c= n] dp[i] = max(dp[i], dp[j] + 1) 在lis中更新的条件是后面的数比前面的大，在这里条件是曼哈顿距离不大于时间差（已排好序） 这样时间复杂度就是O(n^2) 对于当前明星，它存活到ti，由于网格大小的限制，所以ti - 2r之前消失的明星一定可达，而(ti-2r, ti)这段时间的明星就需要一个一个判断 接下来有一个很巧妙的将时间复杂度降到O(nr)的优化 由于[0, ti-4r]已经用来更新过（更新到ti-2r）所以这段区间将不再使用（因为它的影响已经叠加在了[ti-4r,ti-2r]这段区间上了），所以只需要看[ti-4r,ti-2r]这段区间，加上需要一个一个判断的[ti-2r,ti)这段区间。最后只需要遍历[ti-4r,ti) 时间之所以能转化成明星的个数，就是因为时间是严格有序的 //702ms/2000ms 1572kb/256mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint r, n;\rconst int maxn = 100005;\rint dp[maxn];\rtuple\u003cint, int, int\u003e cel[maxn];\rint dist(int i, int j){\rreturn abs(get\u003c1\u003e(cel[i]) - get\u003c1\u003e(cel[j])) + abs(get\u003c2\u003e(cel[i]) - get\u003c2\u003e(cel[j]));\r}\rint main() {\rmemset(dp, -1, sizeof(dp));\rscanf(\"%d%d\", \u0026r, \u0026n);\rget\u003c0\u003e(cel[0]) = 0;\rget\u003c1\u003e(cel[0]) = 1;\rget\u003c2\u003e(cel[0]) = 1;\rfor(int i = 1; i \u003c= n; ++i){\rint t, x, y;\rscanf(\"%d%d%d\", \u0026t, \u0026x, \u0026y);\rget\u003c0\u003e(cel[i]) = t;\rget\u003c1\u003e(cel[i]) = x;\rget\u003c2\u003e(cel[i]) = y;\r}\rdp[0] = 0;\rfor(int i = 1; i \u003c= n; ++i){\rfor(int j = max(0, i - 4 * r); j \u003c i; ++j){\rif(dp[j] == -1) continue;\rif(dist(i, j) \u003c= get\u003c0\u003e(cel[i]) - get\u003c0\u003e(cel[j])) dp[i] = max(dp[i], dp[j] + 1);\r}\r}\rint ans = 0;\rfor(int i = 1; i \u003c= n; ++i){\rans = max(ans, dp[i]);\r}\rprintf(\"%d\\n\", ans);\rreturn 0;\r}\r =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给俩数p,q，求最大的x满足p%x=0，x%q!=0 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 如果p%q!=0，x=p 否则对于pq相同的因子m，假设q中有n个m，那么就让p中m的个数减到n-1，得到一个tmp，这样就能保证p%tmp=0,tmp%q!=0，对于所有的因子产生的tmp取最大值 //46ms/1000ms 12kb/512mb\r#include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rvector\u003cpair\u003cll, ll\u003e\u003e vt;\rll p, q;\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rll ans = -1;\rcin \u003e\u003e p \u003e\u003e q;\rif(p % q != 0) ans = p;\relse{\rvt.clear();\rfor(ll i = 2; i * i \u003c= q; ++i){\rif(q % i == 0){\rll cot = 0;\rwhile(q % i == 0) {\rq /= i;\rcot++;\r}\rvt.emplace_back(i, cot);\r}\r}\rif(q \u003e 1) vt.emplace_back(q, 1);\rfor(auto i : vt){\rll x = i.first;\rll y = i.second;\rll tmp = p;\rwhile(tmp % x == 0){\rtmp /= x;\r}\rfor(ll j = 0; j \u003c y - 1; ++j) tmp *= x;\rans = max(ans, tmp);\r}\r}\rcout \u003c\u003c ans \u003c\u003c endl;\r}\r//for(auto i : vt){\r// cout \u003c\u003c i.first \u003c\u003c \" \" \u003c\u003c i.second \u003c\u003c endl;\r//}\r return 0;\r}\r ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["abc"],"content":"abc173","date":"2020-07-06","objectID":"/abc173/","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"A - Payment ","date":"2020-07-06","objectID":"/abc173/:0:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std;\rint main(){\rint n;\rcin\u003e\u003en;\rint i=1000;\rwhile(i\u003cn){\ri+=1000;\r}\rcout\u003c\u003ci-n;\rreturn 0;\r}\r B - Judge Status Summary ","date":"2020-07-06","objectID":"/abc173/:1:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std;\rconst int maxn = 1e5+2;\rint wa,tle,ac,re;\rint main(){\rint n;\rcin\u003e\u003en;\rwhile(n--){\rstring s;\rcin\u003e\u003es;\rswitch(s[0]){\rcase 'A':{\rac++;\rbreak;\r}\rcase 'W':{\rwa++;\rbreak;\r}\rcase 'T':{\rtle++;\rbreak;\r}\rdefault:{\rre++;\rbreak;\r}\r}\r}\rcout\u003c\u003c\"AC x \"\u003c\u003cac\u003c\u003cendl\u003c\u003c\"WA x \"\u003c\u003cwa\u003c\u003cendl\u003c\u003c\"TLE x \"\u003c\u003ctle\u003c\u003cendl\u003c\u003c\"RE x \"\u003c\u003cre\u003c\u003cendl;\rreturn 0;\r}\r C - H and V ","date":"2020-07-06","objectID":"/abc173/:2:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std;\rchar a[7][7];\rchar b[7][7];\rint n,m;int k;\rvoid row(int x){\rfor(int i=0;i\u003cm;i++){\rb[x][i] = '.';\r}\r}\rvoid col(int x){\rfor(int i=0;i\u003cn;i++){\rb[i][x] = '.';\r}\r}\rvoid sol(int x,int y){\rfor(int i=0;i\u003cn;i++){\rif(x\u003e\u003ei\u00261){\rrow(i);\r}\r}\rfor(int j=0;j\u003cm;j++){\rif(y\u003e\u003ej\u00261){\rcol(j);\r}\r}\r}\rint cal(){\rint ans =0;\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003cm;j++){\rif(b[i][j] == '#') ans++;\r}\r}\rreturn ans;\r}\rint main(){\rcin\u003e\u003en\u003e\u003em;cin\u003e\u003ek;\rchar c;\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003cm;j++){\rcin\u003e\u003ea[i][j];\r}\r}\rint ans = 0;\rfor(int i=0;i\u003c(1\u003c\u003cn);i++){\rfor(int j=0;j\u003c(1\u003c\u003cm);j++){\rmemcpy(b,a,sizeof(a));\rsol(i,j);\rif (cal() == k) ans++;\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - Chat in a Circle ","date":"2020-07-06","objectID":"/abc173/:3:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std;\rusing ll = long long;\rll a[200005];\rll n;\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\rsort(a,a+n,[](int a,int b){return a\u003eb;});\rif(n==2) {\rcout\u003c\u003ca[0]\u003c\u003cendl;\rexit(0);\r}\rn--;\rll t;\rll q = n;\rif(n\u00261){\rt = (n-1)/2;\rt++;\r}\relse{\rn++;\rt = (n-1)/2;\rt++; }\rll ans = a[0];\rfor(ll i=1;i\u003ct;i++){\rans += 2LL * a[i];\r}\rif(q%2 == 0){\rans -= a[t-1];\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - Multiplication 4 ","date":"2020-07-06","objectID":"/abc173/:4:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll a[200005];\rll n,k;\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\rsort(a,a+n);\rint L = 0,R = n-1;\rif(k\u00261){\rif(a[n-1] \u003c 0){\rll ans = 1;\rfor(int i=n-1;i\u003e=n-k;i--){\rans *= a[i];\rans %= mod;\r}\rif(ans \u003c 0) cout\u003c\u003cans+mod\u003c\u003cendl;else cout\u003c\u003cans\u003c\u003cendl;\rexit(0);\r}\rR--,k--;\r}\rwhile(k){\rll lv = a[L] * a[L+1];\rll rv = a[R] * a[R-1];\rif(lv \u003c rv){\rR -= 2;\r} else L += 2;\rk -= 2;\r}\rll ans = 1;\rfor(int i=0;i\u003cL;i++){\rans *= a[i];\rans %= mod;\r}\rfor(int i=R+1;i\u003cn;i++){\rans *= a[i];\rans %= mod;\r}\rif(ans \u003c 0) cout\u003c\u003cans+mod\u003c\u003cendl;\relse cout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F - Intervals on Tree ","date":"2020-07-06","objectID":"/abc173/:5:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 对于一个森林，点和边对连通图个数的贡献是每个点+1，每条边-1 所以计算点被遍历几次，边被遍历几次 这与区间的左右数字个数有关 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint n;\rint main(){\rll ans = 0;\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++){\rans += (ll)i * (n-i+1);\r}\rint _ = n;\r_--;\rwhile(_--){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rif(a \u003e b) swap(a,b);\rans -= (ll)a * (n-b+1);\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-07-06","objectID":"/abc173/:6:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["problemlist"],"content":"某不科学的暑假做题记录","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"简单思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 直接法，注意数组大小爆long long #include\u003cbits/stdc++.h\u003e\rusing ll = long long;\rconst ll mod = 1e6+3;\rll fac[mod+2];\rint main(){\rfac[0] = 1LL;\rfac[1] = 1LL;\rfor(ll i=2;i\u003cmod+2;i++){\rfac[i] = i*fac[i-1];\rfac[i] %= mod;\r}\rll n;\rwhile(std::cin\u003e\u003en){\rif(n\u003e=mod) puts(\"0\");else\rstd::cout\u003c\u003cfac[n]\u003c\u003cstd::endl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 排列组合 容斥原理 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 并查集模拟操作 每次的答案依赖于上一次的答案 对于当前给出的两个数 如果在一个集合内，则 ans = ans 如果不在一个集合内，假设一个在A集合，一个在B集合 num(S) 表示满足条件S的方案数 四元组为 Q 并查集的集合为 U 设合并A、B后的集合为C ans -= num(∃q ∈ Q , (q∈A) ∧ (Q\\q ∈ U\\(A , B) ) ) ans -= num(∃q ∈ Q , (q∈B) ∧ (Q\\q ∈ U\\(A , B) ) ) ans -= num(∃q1,q2 ∈ Q , (q1 ∈ A) ∧ (q2 ∈ B) ∧ (Q\\(q1 , q2) ∈ U\\(A , B) ) ans += num(∃q ∈ Q , (q ∈ C) ∧ (Q\\q ∈ U\\C) ) 由于12式和4式相抵消，所以实际只要操作3式 由于3式需要在并查集中选两个的方案数，所以维护两个变量 ans two (在并查集中选两个元素的方案数，选的元素可重复) 利用容斥原理和排列组合 num(∃q1,q2 ∈ Q , (q1 ∈ A) ∧ (q2 ∈ B) ∧ (Q\\(q1 , q2) ∈ U\\(A , B) ) = size(A) * size(B) * (two - (size(A) * (n - size(A)) - (size(B) * (n - size(B)) + size(A) * size(B) ) 更新完ans后更新two 初始化 ans = C(n,4) two = C(n,2) 数据规模大，用unsigned long long 注意这样初始化 ll ans = n*(n-1)/4*(n-2)/3*(n-3)/2; 而不是 ll ans = n*(n-1)*(n-2)*(n-3)/24; #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = unsigned long long;\r//using ld = long double;\rconst int maxn = 1e5+3;\rll n,m;\rll par[maxn]; ll rankk[maxn]; ll sizz[maxn];\rvoid init(ll n) {\rfor(ll i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\rfill(sizz,sizz+n,1);\r} ll find(ll x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); } void unite(ll x,ll y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y,sizz[y]+=sizz[x]; else\r{\rpar[y]=x;\rsizz[x]+=sizz[y];\rif(rankk[x]==rankk[y]) rankk[x]++; } } bool same(ll x,ll y)\r{\rreturn find(x)==find(y);\r}\rint main(){\rcin\u003e\u003en\u003e\u003em;\rll two = n*(n-1)/2;\rll ans = n*(n-1)/4*(n-2)/3*(n-3)/2; cout\u003c\u003cans\u003c\u003cendl;\rinit(n);\rfor(ll i=0;i\u003cm;i++){\rll x,y;\rcin\u003e\u003ex\u003e\u003ey;\rx--,y--;\rif(!same(x,y)){\rll szx = sizz[find(x)];\rll szy = sizz[find(y)];\rans -= (szx * szy * (two - szx * (n - szx) - szy * (n - szy) + szx * szy));\rtwo -= szx * szy;\runite(x,y);\rcout\u003c\u003cans\u003c\u003cendl;\r}else cout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"kmp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 先找既是前缀又是后缀的最长子串 这可以利用kmp的next数组 然后去掉原串的头尾作为匹配串，由next数组得到的作为模式串 再进行kmp匹配，如果匹配不成功，则在模式串中取前next[len]的长度 不断重复，直到与匹配串匹配 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rchar s[100005],p[100005],pp[100005],ppp[100005];\rint n,m;\rint nextt[100005];\rvoid get_next(){\rint i=0,j=-1;\rnextt[0]=-1;\rwhile(i\u003cm){\rif(j==-1 || p[i]==p[j]) nextt[++i]=++j;\relse j=nextt[j]; //!!!\r }\r}\rint kmp(){\rint i=0,j=0;\rwhile(1){\rif(s[i]==p[j]) i++,j++;\relse{\rint t=nextt[j];\rif(t==-1) i++,j=0;\relse j=t;\r}\rif(j\u003e=m) return i-m; if(i\u003e=n) return -1;\r}\r}\rint main(){\rcin\u003e\u003ep;\rm = strlen(p);\rget_next();\rint len = nextt[m];\rstrncpy(pp,p,len);\rlen = strlen(p) - 2;\rstrncpy(s,p+1,len);\rstrcpy(p,pp);\rm = strlen(p);\rn = strlen(s);\rwhile(1){\rif(kmp()!=-1){\rcout\u003c\u003cp\u003c\u003cendl;\rbreak; }//else if(nextt[strlen(p)] == -1) break;\r else{\rstrncpy(ppp,p,nextt[strlen(p)]); //不能拷贝给自身\r strcpy(p,ppp);\rm = strlen(p);\r//cerr\u003c\u003cp\u003c\u003cendl;\r }\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"换根dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 dpd[u] 表示以u为根的子树的连通块数 dpu[u] 表示u之上的连通块数 ans[u] 表示包含u的连通块数 假设 v 是 u 的子节点，p 是 u 的父节点 ，s 是 u 的兄弟节点 dpd[u] = (dpd[v1] + 1) * (dpd[v2] + 1) * (dpd[v3] + 1) * ... ans[u] = dpd[u] * (dpu[u] + 1) dpu[u] = ans[p] / (dpd[u] + 1) 当 (dpd[u] + 1) % mod = 0 时，模数无效，所以这种情况要特殊处理 dpu[u] = (dpu[p] + 1) * (dpd[s1] + 1) * (dpd[s2] + 1) * ... 两次dfs，一次求dpd，一次求dpu并更新ans #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9 + 7;\rconst int maxn = 1e6 + 5;\rstruct edge{\rint to , next;\r}e[maxn\u003c\u003c1];\rll tot,head[maxn\u003c\u003c1];\rvoid add_edge(int u,int v){\re[tot].to = v;\re[tot].next = head[u];\rhead[u] = tot++;\r}\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll dpu[maxn],par[maxn],dpd[maxn],ans[maxn];\rll V;\rvoid dfs1(int u,int p){\rdpd[u] = 1;\rpar[u] = p;\rfor(int i=head[u]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == p) continue;\rdfs1(v,u);\rdpd[u] *= (dpd[v] + 1);\rdpd[u] %= mod;\r}\r}\rvoid dfs2(int u,int p){\rif(u != 1){\rif((dpd[u] + 1) % mod){\rdpu[u] = ans[p] * qpow(dpd[u] + 1 , mod - 2);\rdpu[u] %= mod;\rans[u] = dpd[u] * (dpu[u] + 1);\rans[u] %= mod;\r}\relse{\rll tmp = dpu[p] + 1;\rfor(int i=head[p]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == par[p] or v == u) continue;\rtmp *= dpd[v] + 1;\rtmp %= mod;\r}\rdpu[u] = tmp;\rans[u] = dpd[u] * (dpu[u] + 1);\rans[u] %= mod;\r}\r}\rfor(int i=head[u]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == p) continue;\rdfs2(v,u);\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rmemset(head,-1,sizeof(head));\rcin\u003e\u003eV;\rfor(int i=0;i\u003cV-1;i++){\rll x,y;\rcin\u003e\u003ex\u003e\u003ey;\radd_edge(x,y);\radd_edge(y,x);\r} dfs1(1,0);\rans[1] = dpd[1];\rdfs2(1,0);\rfor(int i=1;i\u003c=V;i++){\rcout\u003c\u003cans[i]\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"贪心 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把L大的放左边，把R大的放右边 假设L大的有a个，R大的有b个 可以把他们分开放置 先处理前a个位置（这些都放置L大的数） 再处理后b个位置（这些都放置R大的数） 对于前a个位置 遍历L大的集合（L大的排前面） 对于当前数，贪心地把它放在不超过k的最右边 如果不满足条件，就放在区间的最右边（此时放哪里，贡献都一样，为了给别的数腾出位置，贪心地放在最右边） 对于后b个位置 遍历R大的集合（R大的排前面） 对于当前数，贪心地把它放在超过k的最左边 如果不满足条件，就放在区间的最左边（此时放哪里，贡献都一样，为了给别的数腾出位置，贪心地放在最左边） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rvector\u003cpair\u003cint,int\u003e\u003e vL;\rvector\u003cpair\u003cint,int\u003e\u003e vR;\rint t;\rint n;\rset\u003cint\u003e sL;\rset\u003cint\u003e sR;\r#define fi first\r#define se second\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rll ans = 0;\rcin\u003e\u003en;\rvL.clear();\rvR.clear();\rfor(int i=0;i\u003cn;i++){\rint k,l,r;\rcin\u003e\u003ek\u003e\u003el\u003e\u003er;\rif(l\u003cr) vR.push_back({l-r,k});\relse vL.push_back({l-r,k});\rans += r;\r}\rfor(int i=1;i\u003c=vL.size();i++) sL.insert(i);\rfor(int i=vL.size()+1;i\u003c=n;i++) sR.insert(i);\rsort(vL.begin(),vL.end(),greater\u003cpair\u003cint,int\u003e\u003e());\rsort(vR.begin(),vR.end());\rfor(auto i:vL){\rauto tmp = sL.upper_bound(i.se);\rif(tmp == sL.begin()){\rsL.erase(--sL.end());\r}else{\rans += i.fi;\rsL.erase(--tmp);\r}\r}\rfor(auto i:vR){\rauto tmp = sR.upper_bound(i.se);\rif(tmp == sR.end()) {\rsR.erase(sR.begin());\rans += i.fi;\r}\relse{\rsR.erase(tmp);\r} }\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"栈 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 栈的经典应用 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a[10005];\rstack\u003cint\u003e sk;\rint ans[10005];\rint main(){\rll n;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003ea[i];\r}\rint i = 0;\rwhile(i \u003c n){\rif(sk.empty() or a[i] \u003c= a[sk.top()]){\rsk.push(i);\ri++;\r}\relse{\rans[sk.top()] = i;\rsk.pop();\r}\r}\rwhile(!sk.empty()){\rans[sk.top()] = -1;\rsk.pop();\r}\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cans[i]+1\u003c\u003c\" \"; cout\u003c\u003c\"\\n\";\rreturn 0;\r}\r ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"树链剖分 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 树链剖分裸题 线段树需支持区间平方和操作 这道题用int不能过 注意细节 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 1e5+10;\rstruct edge{ ll to,nxt;\r}e[maxn\u003c\u003c1]; struct tnode{ ll w,l,r,siz,alazy;\rll sq,mlazy=1LL;\r}tn[maxn\u003c\u003c2]; ll wch[maxn],sz[maxn],head[maxn],wt[maxn],dep[maxn],dfn[maxn],par[maxn],top[maxn],rdfn[maxn];\rll n,q;\rconst ll mod = 23333;\rll cnt_e; ll cnt_d; void add_edge(ll u,ll v){ e[++cnt_e].to = v; e[cnt_e].nxt = head[u]; head[u] = cnt_e;\r}\rvoid dfs1(ll u,ll p){ sz[u] = 1;\rfor(ll i = head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p){\rdep[t] = dep[u] + 1;\rpar[t] = u;\rdfs1(t,u);\rsz[u] += sz[t];\rif(sz[t] \u003e sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid dfs2(ll u,ll p,ll tp){ top[u] = tp;\rdfn[u] = ++cnt_d; rdfn[cnt_d] = u; if(wch[u]){ dfs2(wch[u],u,tp);\r}\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch[u]){\rdfs2(t,u,t); }\r}\r}\rvoid pushup(ll u){ tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod;\rtn[u].sq = (tn[u\u003c\u003c1].sq + tn[u\u003c\u003c1|1].sq) % mod;\r}\rvoid build(ll u,ll l,ll r){ tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[rdfn[l]]; tn[u].sq = wt[rdfn[l]] * wt[rdfn[l]];\rreturn ;\r}\rll mid = (l+r) \u003e\u003e 1;\rbuild(u\u003c\u003c1 , l , mid); build(u\u003c\u003c1|1 , mid+1 , r);\rpushup(u); }\rvoid pushdown(ll u){ if(tn[u].alazy != 0 or tn[u].mlazy != 1){\rtn[u\u003c\u003c1].sq = ((tn[u\u003c\u003c1].sq + 2LL * tn[u\u003c\u003c1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1].siz % mod) % mod; tn[u\u003c\u003c1|1].sq = ((tn[u\u003c\u003c1|1].sq + 2LL * tn[u\u003c\u003c1|1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1|1].siz % mod) % mod;\rtn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1].siz * tn[u].alazy % mod) % mod;\rtn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1|1].siz * tn[u].alazy % mod) % mod;\rtn[u\u003c\u003c1].alazy = (tn[u\u003c\u003c1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u003c\u003c1|1].alazy = (tn[u\u003c\u003c1|1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod;\rtn[u\u003c\u003c1].mlazy = (tn[u\u003c\u003c1].mlazy * tn[u].mlazy) % mod;\rtn[u\u003c\u003c1|1].mlazy = (tn[u\u003c\u003c1|1].mlazy * tn[u].mlazy) % mod;\rtn[u].alazy = 0; tn[u].mlazy = 1;\r}\r}\rll query(ll u,ll l,ll r,ll t){ if(l\u003c=tn[u].l and r\u003e=tn[u].r) {\rif(t == 1) return tn[u].w;\rif(t == 2) return tn[u].sq;\r} ll ans = 0;\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1;\rif(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r , t)) % mod;\rif(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r , t)) % mod;\rreturn ans;\r}\rvoid update(ll u,ll l,ll r,ll wa,ll wm){ if(l\u003c=tn[u].l and r\u003e=tn[u].r){ tn[u].sq = ((tn[u].sq + 2LL * tn[u].w * wa % mod) % mod + wa * wa % mod * tn[u].siz % mod) % mod;\rtn[u].w = (tn[u].w * wm % mod + tn[u].siz * wa % mod) % mod;\rtn[u].alazy = (tn[u].alazy * wm % mod + wa) % mod;\rtn[u].mlazy = (tn[u].mlazy * wm) % mod;\rreturn ;\r}\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1; if(l\u003c=mid) update(u\u003c\u003c1, l , r , wa , wm);\rif(r\u003emid) update(u\u003c\u003c1|1, l , r , wa , wm);\rpushup(u); }\rint main(){\rcin\u003e\u003en\u003e\u003eq;\rfor(ll i=1;i\u003c=n;i++){\rscanf(\"%lld\",\u0026wt[i]);\r}\rfor(ll i=0;i\u003cn-1;i++){\rll x,y;\rscanf(\"%lld %lld\",\u0026x,\u0026y);\radd_edge(x,y);\radd_edge(y,x);\r}\rdfs1(1,0);\rdfs2(1,0,1);\rbuild(1,1,n);\rfor(ll i=0;i\u003cq;i++){\rll t;\rscanf(\"%lld\",\u0026t);\rif(t==1){\rll x,y;\rscanf(\"%lld %lld\",\u0026x,\u0026y);\rupdate(1,dfn[x],dfn[x]+sz[x]-1,y%mod,1LL);\r}\relse{\rll x;\rscanf(\"%lld\",\u0026x);\rprintf(\"%lld\\n\", query(1,dfn[x],dfn[x]+sz[x]-1,2));\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"计算几何 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 两两求圆心，圆心相同表示能在同一个圆上 求最多的圆心数量 需要固定一个点，每次换点时求一次max，如果在遍历完所有点对求max，就变成排列组合 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing db = double;\rstruct point{\rdb x,y;\r}ps[2005];\rmap\u003cpair\u003cdb,db\u003e,int\u003e mp;\rdb X,Y;\rinline db out(point a,point b,point c) {\rreturn (c.x - a.x) * (c.y - b.y) - (c.y - a.y) * (c.x - b.x); }\rbool circle_center(point a,point b,point c){\rif(out(a,b,c) == 0 ) return false;\rdb a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;\rdb a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;\rdb d = a1 * b2 - a2 * b1;\rX = a.x + (c1 * b2 - c2 * b1) / d , Y = a.y + (a1 * c2 - a2 * c1) / d;\rreturn true;\r}\rint main(){\rint n;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003eps[i].x;\rcin\u003e\u003eps[i].y;\r}\rint ans = 0;\rfor(int i=0;i\u003cn;i++){\rmp.clear();\rfor(int j=i+1;j\u003cn;j++){\rif(circle_center((point){0,0} , ps[i] , ps[j]))\rmp[{X,Y}]++;\r}\rint tmp = 0;\rfor(auto i:mp) tmp = max(tmp , i.second);\rans = max(ans , tmp);\r}\rcout\u003c\u003cans+1\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 并查集模改 细节参考官方题解 并查集模拟操作，链表维护相同颜色的节点 注意要记录初始的状态（debug好久） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst int maxn = 8e5 + 10;\rvector\u003cint\u003e G[maxn];\rlist\u003cint\u003e ls[maxn];\rint par[maxn]; void init(int n) {\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rls[i].push_back(i);\r}\r} int find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); }\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\r//reset\r for(int i = 0;i\u003c=n;i++) {\rG[i].clear(); ls[i].clear();\r}\rfor(int i = 0;i\u003cm;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\rG[x].push_back(y);\rG[y].push_back(x);\r}\rinit(n);\rint q;\rcin\u003e\u003eq;\rwhile(q--){\rint x;\rcin\u003e\u003ex;\rif(x != par[x]) continue;\rint sz = ls[x].size(); //记录初始的链表大小\r int px = find(x); //记录初始的根节点\r while(sz--){\rint cnt = ls[x].front();\rls[x].pop_front();\rfor(int i:G[cnt]){\rint pi = find(i); //记录初始的根节点\r if(px == pi) continue;\rpar[pi] = px; //这样合并\r ls[x].splice(ls[x].end() , ls[pi]); }\r}\r}\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cfind(i)\u003c\u003c\" \";\rputs(\"\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 1和大于n/2的质数都不能匹配 先处理质因子稀有的数，就是从大到小遍历质数 然后把含有这个质因子的数两两匹配 如果含有这个质因子的数的个数是奇数个 就不匹配 2*p 这个数，留给下一个质因子，因为2是最多的质因子 #include \"bits/stdc++.h\"\rusing namespace std;\rconst int maxnn = 2e5+10;\rbool isprime[maxnn];\rvoid e_sieve(int n = maxnn){\rfor(int i = 1;i\u003cn;i++){\risprime[i] = true;\r}\risprime[0] = isprime[1] = false;\rfor(int i = 2;i \u003c n;i++){\rif(isprime[i]){\rfor(int j = 2 * i ; j \u003c n ; j += i){\risprime[j] = false;\r}\r}\r}\r}\rint use[maxnn] ;\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\re_sieve();\rint t;\rcin\u003e\u003et;\rwhile (t--){\rint n;\rcin\u003e\u003en;\rfor(int i = 1; i \u003c= n ; i++) use[i] = 0;\rvector\u003cpair\u003cint,int\u003e\u003e ans;\rfor(int i = n/2 ; i \u003e= 2 ; --i){\rif(isprime[i]){\rvector\u003cint\u003e tmp;\rfor(int j = i; j \u003c= n ; j += i){\rif(use[j] == 0){\rtmp.push_back(j);\r}\r}\rif(tmp.size() \u0026 1){\rfor(int x = 0 ; x \u003c tmp.size() ; ++x){\rif(tmp[x] == i * 2) tmp.erase(tmp.begin() + x);\r}\r}\rfor(int i = 0 ; i \u003c tmp.size() - 1 ; i += 2){\rans.push_back({tmp[i] , tmp[i+1]});\ruse[tmp[i]] = 1;\ruse[tmp[i+1]] = 1;\r}\r}\r}\r//for(int i = 2; i \u003c 20 ; i++) cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cisprime[i]\u003c\u003c\"\\n\";\r cout\u003c\u003cans.size()\u003c\u003cendl;\rfor(auto i : ans){\rcout\u003c\u003ci.first\u003c\u003c\" \"\u003c\u003ci.second\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 如果没有 d\u003cb f\u003cb 的条件直接让 d = f = b 如果 a/b 能约分成 a’ / b’ 则 d = f = b’ e = 1 , c = a‘+1（随便赋值） 如果 a/b不能约分 就把b分解质因数（预处理每个数最小的质因子） 设b分解成 p1 p2 如果p1 p2 有1 无解 否则根据通分公式 d = p1 , f = p2 cf - de = a 因为d f是b的因子 ，b 和 a 互质 ，所以gcd(f/a , d/a) = 1 -(d/a)e + c(f/a) = 1 用扩展欧几里得公式求出 c e e = -e 如果 e c有负数 ，正数化 然后 e c 都乘上 a #include \"bits/stdc++.h\"\r\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 2e6+10;\rll gcd(ll a , ll b){\rreturn b == 0 ? a : gcd(b , a % b);\r}\rbool isprime[maxn+1]; //is i a prime number\rll minp[maxn+1];\rvoid e_sieve(int n = maxn)\r{\rfor(int i=0;i\u003c=n;i++) isprime[i]=true; //initialize\r isprime[0]=isprime[1]=false;\rfor(int i=2;i\u003c=n;i++)\r{\rif(isprime[i])\r{\rfor(int j=2*i;j\u003c=n;j+=i) isprime[j]=false;\r}\r}\rfor(ll i = 2 ; i \u003c= n; i++){\rif(isprime[i]){\rfor(ll j = i; j \u003c= n; j += i){\rif(minp[j] == 0) minp[j] = i;\r}\r}\r}\r}\rll ex_gcd(ll a,ll b,ll\u0026 x,ll\u0026 y)\r{\rll t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"r\", stdin);\rfreopen(\"out1.txt\", \"w\", stdout);\r#endif\r\re_sieve();\r//for(int i = 2; i\u003c 100;i++) cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cminp[i]\u003c\u003cendl;\r int _;\rcin \u003e\u003e _;\rwhile (_--) {\rll a, b;\rcin \u003e\u003e a \u003e\u003e b;\rll c , d , e , f;\rll t = gcd(a , b);\rif(t != 1){\ra /= t;\rb /= t;\rd = f = b;\re = 1;\rc = a + 1;\rcout\u003c\u003cc\u003c\u003c\" \"\u003c\u003cd\u003c\u003c\" \"\u003c\u003ce\u003c\u003c\" \"\u003c\u003cf\u003c\u003cendl;\rcontinue;\r}\rll p1 = 1,p2 = b,p = minp[b];\rif(p == 0) {\rcout\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003cendl;\rcontinue;\r}\rwhile(p2 % p == 0){\rp2 /= p;\rp1 *= p;\r}\rif(p2 == 1){\rcout\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003cendl;\rcontinue;\r}\rd = p1;\rf = p2;\rex_gcd(d, f, e, c);\re = -e;\rif(e \u003c= 0 or c \u003c= 0){\rll et = (e % f + f) % f;\rll ct = (c % d + d) % d;\rll mm = max(0ll , max((et - e) / f , (ct - c) / d));\re += f * mm;\rc += d * mm;\r}\re *= a;\rc *= a;\rcout\u003c\u003cc\u003c\u003c\" \"\u003c\u003cd\u003c\u003c\" \"\u003c\u003ce\u003c\u003c\" \"\u003c\u003cf\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"计算几何 区间dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 很难的一道题 由于切割的方案数太多，所以考虑dp dp[i][j] 表示点 i 到点 j 的答案 转移方程 dp[i][j] = min(dp[i][j] , max( max (dp[i][k] , dp[k][j]) , area(ps[i] , ps[j] , ps[k]) ) ) 计算面积直接用外积 1/2 * (A-\u003eB) X (A-\u003eC) 由于题目存在凹多边形的情况 所以当有点在三角形 i j k中，这个区间不可分割（根据面积判断，这个技巧可以用于求一个点是否在凸多边形内） dp的初始化 dp[i][i+2] = area(ps[i] , ps[i+1] , ps[i+2]) dp[i][i] = dp[i][i+1] = 0 dp[i][i+m] = inf [m\u003e2] 几个注意点 用eps ， 初始化只有一类为inf ， 用外积求面积要加绝对值 ， dp的遍历先遍历区间长度（因为从小的先更新，大的区间依赖于小的，这也是很多区间dp要求的） #include \"bits/stdc++.h\"\r\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int maxn = 105;\rdouble eps = 1e-10;\rstruct point{\rdouble x,y;\r}ps[maxn];\rdouble dp[maxn][maxn];\rint n;\r//a-\u003ec X b-\u003ec\rdouble area(point a,point b,point c) {\rreturn fabs((c.x - a.x) * (c.y - b.y) - (c.y - a.y) * (c.x - b.x)) / 2;\r}\rbool judge(int a,int b,int c){\rdouble s = area(ps[a], ps[b], ps[c]);\rfor(int i =1;i\u003c=n;i++){\rif(i == a or i == b or i == c) continue;\rdouble t = area(ps[i],ps[a],ps[b]) + area(ps[i],ps[a],ps[c]) + area(ps[i],ps[b],ps[c]);\rif(fabs(t - s) \u003c eps) return false;\r}\rreturn true;\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"r\", stdin);\rfreopen(\"out1.txt\", \"w\", stdout);\r#endif\r ios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rwhile(cin\u003e\u003en){\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003eps[i].x\u003e\u003eps[i].y;\rif(i\u003e=3){\rdp[i-2][i] = area(ps[i] , ps[i-1] , ps[i-2]);\r}\r}\rfor(int len = 3 ; len \u003c= n ; len++){\rfor(int i = 1,j = i+len;j\u003c=n;i++,j++){\rdp[i][j] = inf;\rfor(int k = i + 1 ; k \u003c j ; k++){\rif(judge(i,j,k)){\rdp[i][j] = min(dp[i][j] , max(max(dp[i][k] , dp[k][j]) , area(ps[i] , ps[j] , ps[k])));\r}\r}\r}\r}\rprintf(\"%.1lf\\n\", dp[1][n]);\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 选择权值不为0的极大连通块，全部-1，不断重复，并记录操作次数 由于点变成0后要从连通块中分裂出来很麻烦，所以考虑倒着来，即单个点合并成连通块 权值从大到小处理，对于u先假设它是单点，ans+=该点的权值，标记为访问 对于它相邻的点v，如果访问过（表示v比u权值大）但不在一个集合内，则合并，然后减去u的权值 因为u和v在一个集合内，v和u共享了u的权值次操作 注意用scanf //#include \"bits/stdc++.h\"\r#include \"iostream\"\r#include \"algorithm\"\r#include \"vector\"\r\rusing namespace std;\rusing ll = long long;\rconst int maxn = 100005;\rpair\u003cint,int\u003e b[maxn];\rvector\u003cint\u003e G[maxn];\r//union find\rint par[maxn];\rint rankk[maxn];\rint sz[maxn];\rint used[maxn];\rvoid init(int n)\r{\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ;\rif(rankk[x]\u003crankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"r\", stdin);\rfreopen(\"out1.txt\", \"w\", stdout);\r#endif\r\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n,m;\rscanf(\"%d%d\",\u0026n,\u0026m);\rfor(int i=0;i\u003c=n;i++) G[i].clear();\rfor(int i=1;i\u003c=n;i++) {\rscanf(\"%d\",\u0026b[i].first);\rb[i].second = i;\r}\rfor(int i=0;i\u003cm;i++){\rint u,v;\rscanf(\"%d%d\",\u0026u,\u0026v);\rG[u].push_back(v);\rG[v].push_back(u);\r}\rsort(b+1,b+n+1,[](pair\u003cint,int\u003e a,pair\u003cint,int\u003e b){return a.first\u003eb.first;});\rinit(n+1);\rfor(int i=0;i\u003c=n;i++) used[i] = 0;\rll ans = 0;\rfor(int i=1;i\u003c=n;i++){\rans += b[i].first;\rused[b[i].second] = 1;\rfor(int j:G[b[i].second]){\rif(used[j]){\rif(!same(b[i].second,j)){\runite(b[i].second,j);\rans -= b[i].first;\r}\r}\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"哈希 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把问题转化成求 A * B = C + Fk 由于k很大，所以这些数会溢出，用除余法哈希，除数选择不超过ull的数，然后遍历k找到满足C + Fk等于 A * B的k 实际上不哈希也可以，所以数都自然溢出（可以看做是特殊的哈希），也可以找到答案 #include \"bits/stdc++.h\"\r\rusing namespace std;\rusing ull = unsigned long long;\rull fib[2000005];\rull a,b,c;\rint n;\rvoid init(){\rfib[1] = 1;\rfib[2] = 2;\rfor(int i=3;i\u003c2000005;i++){\rfib[i] = fib[i-1] + fib[i-2];\r}\r}\rvoid cal(ull \u0026x,int n){\rx = 0;\rfor(int i=1;i\u003c=n;i++){\rint t;\rscanf(\"%d\",\u0026t);\rif(t){\rx += fib[i];\r}\r}\r}\rint main() {\r#ifdef LOCAL\r freopen(\"in1.txt\", \"r\", stdin);\rfreopen(\"out1.txt\", \"w\", stdout);\r#endif\r init();\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\ra = b = c = 0;\rscanf(\"%d\",\u0026n);\rcal(a,n);\rscanf(\"%d\",\u0026n);\rcal(b,n);\rscanf(\"%d\",\u0026n);\rcal(c,n);\ra *= b;\rfor(int i=1;i\u003c=n;i++){\rif(fib[i] + c == a){\rprintf(\"%d\\n\",i);\rcontinue; //应该是break 但这样也不会超时\r }\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"置换群 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:15:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 求排列中每个循环的长度，对它们求lcm 注意大数（可不必取模） 贴一份队友的代码 def gcd(a, b):\rreturn a if b == 0 else gcd(b, a % b)\rdef dfs(i):\rglobal vis\ru = i\rans = 1\rwhile p[i] != u:\rans += 1\rvis[i] = 1\ri = p[i]\rreturn ans\rn = int(input())\rMOD = pow(10, n)\rvis = [0] * 100007\rp = [0] * 100007\rpp = list(map(int, input().split()))\rfor i in range(1, n + 1):\rp[i] = pp[i-1]\rans = 1\rfor i in range(1, n + 1):\rif vis[i] == 1:\rcontinue\rk = dfs(i)\rans = ((ans * k) // gcd(ans, k)) % MOD\rprint(ans)\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:15:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 LIS 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:16:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 invert操作不会改变数的相对位置，drop2操作会改变数的相对位置 drop2操作是把最后一个数之前的数往数列头部移动 由于这两种操作的性质，把数列看成一个环 那么invert操作就是旋转环，drop2操作就是把最后一个数（在环里就是任意一个数）插到任意位置上 所以问题转化成对于一个数列（排列），最少有多少次“将任意数插入到任意位置上”的操作，使得数列递增 操作数 = n - len(LIS) , 对于环的不同起始位置求LIS，取最大值 时间复杂度 O(n*n*logn) #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint dp[505];\rconst int inf = 0x3f3f3f3f;\rint a[1010];\rint main() {\rint n;\rint ma = -1 ;\rscanf(\"%d\",\u0026n);\rfor(int i=0;i\u003cn;++i){\rcin\u003e\u003ea[i];\r}\rint i,j;\rfor(i=0;i\u003cn;i++){\rfill(dp,dp+n,inf);\rfor(j=i;j\u003ci+n;j++){\r*lower_bound(dp,dp+n,a[j]) = a[j];\r}\rma = max(ma , (int)(lower_bound(dp,dp+n,inf) - dp));\ra[j] = a[i];\r}\rcout\u003c\u003cn-ma\u003c\u003c\"\\n\";\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:16:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数据结构 实现 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:17:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于每个数，判断能否把前min(i,k)个数作为一个排列，即在它的后面放置切割 判断是否是排列，即判断这些数中每个数是否只出现一次，出现次数可以用unordered_map记录(map超时) 想了一个非常复杂的方法，不知道怎么实现，以下是参考了别人的代码，实现效率非常高 #include \"iostream\"\r#include \"unordered_map\"\r#include \"cstring\"\r#pragma GCC optimize(2)\rusing namespace std;\rtypedef long long ll;\rint a[500005],cut[500005];\runordered_map\u003cint,int\u003e mp;\rinline int read()\r{\rint x=0;int f=1;char s=getchar();\rwhile(s\u003c'0' or s\u003e'9')\r{\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u003e='0' and s\u003c='9')\r{\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rint main() {\rint _;\r_ = read();\rwhile (_--) {\rmp.clear();\rint flag = 0;\rint n,k;\rn = read() , k = read();\rfor (register int i = 1; i \u003c= n; ++i) {\ra[i] = read();\rif(a[i] \u003e k) {\rflag = 1;\rbreak;\r}\r}\rif(flag) {\rputs(\"NO\");\rcontinue;\r}\rint dif_num = 0; memset(cut , 0 , sizeof(cut));\rcut[0] = 1;\rfor(register int i=1;i\u003c=n;++i){\rif(i \u003e k) {\rif (mp[a[i - k]] == 1) dif_num-- ; mp[a[i - k]]--;\r}\rif(mp[a[i]] == 0) dif_num++; mp[a[i]]++;\rif(dif_num == k or dif_num == i){\rcut[i] = (i\u003e=k ? cut[i-k] : 1);\r}\r}\rdif_num = 0 ; mp.clear();\rflag = 0;\rfor(register int i=n;i\u003e=max(n-k,0);--i){\rif(dif_num == n-i and cut[i] == 1){\rflag = 1;\rbreak;\r}\rif(mp[a[i]] == 0) dif_num++;\rmp[a[i]]++;\r}\rflag ? puts(\"YES\") : puts(\"NO\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:17:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"状态压缩dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:18:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于铁路线，肯定是过某个点最划算，而且是过不同的点，即一个点一条线穿过 所以枚举即将被穿线的点集，每个点有被特定的一条线穿过，穿过的方式有横线、竖线（对于特定的点集，枚举横线竖线的所有情况） 对于每种情况，更新答案 （两条铁路重合的情况不会影响答案，因为这始终不是最优解） 玄学时间复杂度 O(sum(2^i * C(n,i) * n * n) 应该有千亿计算量 一直以为会超时，想把n*n优化成O(1) 无果，看了别人的做法，居然不会超时？？？ 最后跑了2700+ms ，时限是3000ms 注意long long的强制类型转化 实际上还有更快的暴力方法和dfs，但我不会 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint n,x[16],y[16],d[16],D[16],p[16];\rll ans[16];\rint main() {\rmemset(ans , 0x3f , sizeof(ans));\rcin \u003e\u003e n;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ex[i]\u003e\u003ey[i]\u003e\u003ep[i];\r}\rfor(int i=0;i\u003cn;i++){\rD[i] = min(abs(x[i]) , abs(y[i]));\r}\rans[0] = 0;\rfor(int i=0;i\u003cn;i++){\rans[0] += (ll)D[i]*p[i];\r}\rfor(int i=1;i\u003c(1\u003c\u003cn);i++){\rint j = i;\rdo{\rmemcpy(d,D,sizeof(D));\rfor(int k=0;k\u003cn;k++){\rif(i\u003e\u003ek\u00261){\rif(j\u003e\u003ek\u00261){\rfor(int q=0;q\u003cn;q++){\rd[q] = min(d[q] , abs(x[q] - x[k]));\r}\r}\relse{\rfor(int q=0;q\u003cn;q++){\rd[q] = min(d[q] , abs(y[q] - y[k]));\r}\r}\r}\r}\rll tmp = 0;\rfor(int i=0;i\u003cn;i++) tmp += (ll)d[i] * p[i];\rans[__builtin_popcount(i)] = min(ans[__builtin_popcount(i)] , tmp);\rj = (j-1) \u0026 i;\r}while(j != i);\r}\rfor(int i=0;i\u003c=n;i++) cout\u003c\u003cans[i]\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:18:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"01背包问题 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:19:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 01背包问题模改 dp[i][j][k] 表示前i个从者，前j个装备，容量为k的最大价值 由于从者和装备是平级的，所以分别对它们用01背包问题 但是有约束条件，装备数量不多于从者，从者最多选5个 所以应该这样dp ， dp[a][i][b][j][k] 表示从前i个选a个，从前j个选b个，容量为k的最大价值，其中a，b只需遍历到5 但这样内存超限，由于01背包问题可以从2维降到1维（重复利用，滚动原理），所以这个dp也可以将2维 dp[i][j][k] 表示选i个从者，j个装备，容量为k的最大价值 由于装备数量不多于从者，所以先枚举从者（即j=0），然后枚举不大于从者的装备 最后3重循环求最大值 #include \"bits/stdc++.h\"\r#include \"algorithm\"\rusing namespace std;\rusing ll = long long;\rint dp[6][6][140];\rint a1[305],c1[305],a2[305],c2[305];\rint main() {\rint n,m,c;\rcin\u003e\u003en\u003e\u003em\u003e\u003ec;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003ea1[i]\u003e\u003ec1[i];\rfor(int i=1;i\u003c=m;i++) cin\u003e\u003ea2[i]\u003e\u003ec2[i];\rmemset(dp,0xc0,sizeof(dp));\rdp[0][0][0] = 0;\rfor(int i=1;i\u003c=n;i++){\rfor(int j=c;j\u003e=c1[i];j--){\rfor(int k=1;k\u003c=5;k++){\rdp[k][0][j] = max(dp[k][0][j] , dp[k-1][0][j-c1[i]] + a1[i]);\r}\r}\r}\rfor(int i=1;i\u003c=m;i++){\rfor(int j=c;j\u003e=c2[i];j--){\rfor(int k=1;k\u003c=5;k++){\rfor(int x=1;x\u003c=k;x++){\rdp[k][x][j] = max(dp[k][x][j] , dp[k][x-1][j-c2[i]] + a2[i]);\r}\r}\r}\r}\rint ans = -1;\rfor(int i=1;i\u003c=5;i++){\rfor(int j=0;j\u003c=i;j++){\rfor(int k=0;k\u003c=c;k++){\rans = max(ans , dp[i][j][k]);\r}\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:19:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"容斥原理 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:20:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 考虑特定的k种颜色的染色方案，那么答案就乘上 C(m,k) 如果是选k种颜色涂色，方案数就是 k(k-1)^(n-1) 但这是不多于k种颜色的方案，对于“恰好”的方案，可以考虑用容斥原理 设不多于k种颜色的方案为f(k) exactly(k) = f(k) - ( f(k-1) - ( f(k-2) - ( f(k-3) - ( f(k-4) -… f(1) )))) f(k) - part 锁定了第k个元素必须使用，f(k-1) - part锁定了k-1个元素必须使用，以此类推 把括号打开，就是容斥原理的结构 exactly(k) = f(k) - f(k-1) + f(k-2) - f(k-3) + f(k-4) … f(1) 由于在加减的过程中不断锁定第i个元素，但没有指定在哪个位置锁定这个元素，所以f要乘上所有的方案数 即F(i) = C(k,i)f(i) 所以答案为 $$ C_{m}^{k}\\sum\\limits_{i=0} ^ {k-1} {(-1)^iC_{k}^{k-i}(k-i)(k-i-1)^{n-1}} $$ #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll ans,n,m,k;\rconst int maxn = 1e6+10;\rconst ll mod = 1e9+7;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll inv[maxn];\rll fac[maxn];\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rint main() {\rfor(ll i=0;i\u003cmaxn;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u003cmaxn;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!!\r for(ll i=2;i\u003cmaxn;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003cmaxn;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rll ckm = 1;\rans = 0;\rcin \u003e\u003e n \u003e\u003e m \u003e\u003e k;\rfor(ll i=0;i\u003ck;i++){\rckm *= (m-i);\rckm %= mod;\r}\rckm *= inv[k];\rckm %= mod;\rint sign = 1;\rfor(int i = k; i \u003e0 ; --i){\rll tmp = 1;\rtmp *= C(i,k);\rtmp %= mod;\rtmp *= i;\rtmp %= mod;\rtmp *= qpow(i-1 , n-1);\rtmp %= mod;\rif(sign == 1) ans += tmp ; else ans -= tmp;\rans += mod;\rans %= mod;\rsign = -sign;\r}\rans *= ckm;\rans %= mod;\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:20:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"bfs 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:21:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 问题转化成创建一条路径连通三个国家，使路径长度最短 那么路径一定汇集于一个点 这就是bfs问题，枚举每个点，求它们到每个国家的最小值，然后和的最小值就是答案，但这样会超时 以每个国家为起点，bfs到每个点，这样每个点会得到三个信息（分别到三个国家的最短距离），和的最小值就是答案，不会超时 当这个点是平地时，距离和-2，因为它被创造了三条公路 我的bug：用fill初始化产生错误，用memset初始化正常，bfs时当点是国家时，距离不需要+1 ， 在求距离和时，要将一个数强制类型转化成long long，它才会升级 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rint n,m;\rchar maze[1005][1005];\rint dist[1003][1003][4];\rusing pii = pair\u003cint,int\u003e;\rint dir[4][2] = { {0,1} , {1,0} , {-1,0} , {0,-1} };\rconst ll inf = 0x3f3f3f3f;\rvoid bfs(int x){\rqueue\u003cpii\u003e q;\rchar ch = '0' + x;\rfor(int i=0;i\u003cn;i++)for(int j=0;j\u003cm;j++){\rif(maze[i][j] == ch) {\rdist[i][j][x] = 0;\rq.push({i,j});\r}\r}\rwhile(q.size()){\rpii tmp = q.front();\rq.pop();\rfor(int i=0;i\u003c4;i++){\rint xt = tmp.first + dir[i][0];\rint yt = tmp.second + dir[i][1];\rif(maze[xt][yt] == '#') continue;\rif(xt \u003c0 or yt\u003c0 or xt\u003e=n or yt\u003e=m) continue;\rint cost = (maze[xt][yt] == '.');\rif(dist[tmp.first][tmp.second][x] + cost \u003c dist[xt][yt][x]){\rdist[xt][yt][x] = dist[tmp.first][tmp.second][x] + cost;\rq.push({xt,yt});\r}\r}\r}\r}\rint main() {\rcin\u003e\u003en\u003e\u003em;\rmemset(dist , inf , sizeof(dist));\rfor(int i=0;i\u003cn;i++){\rscanf(\"%s\",\u0026maze[i]);\r} bfs(1);bfs(2);bfs(3);\rll ans = inf;\rfor(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++){\rif(maze[i][j] == '#') continue;\rll sum = (ll)dist[i][j][1] + dist[i][j][2] + dist[i][j][3];\rif(maze[i][j] == '.') sum -= 2;\rans = min(ans , sum);\r}\rcout\u003c\u003c(ans == inf ? -1 : ans)\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:21:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dfs 图论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:22:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把问题转化成求在所有简单路径中，每个点被遍历了几次，如果是偶数次，异或和为0，奇数次异或和为本身 这样就是图论中求所有简单路径XX被遍历几次的经典模型，基础的有边和点 如果是边 $$ f(edge) = size[x] * ( n - size[x]) $$ 如果是点，考虑三种情况，以这个点为端点，有n-1条，这个点的子树连到子树外面有 (size[x] - 1) * ( n - size[x]) ， 这个点的子节点的子树连到另外一个子节点的子树有 (sum(size[ch] * (size[x] - 1 - size[ch]))) / 2 除以2因为每个点都作为起点和终点一次，但这样只有一条 $$ f(node) = n-1 + (size[x] - 1) * (n-size[x]) + \\frac{\\sum\\limits_{} ^ {} {size[ch] * (size[x] - 1 - size[ch])} }{2} $$ 还有另一种算法 $$ f(node) = \\frac{\\sum{f(edge) [connected \\ to \\ node]+ n-1} }{2} $$ #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rvector\u003cll\u003e G[500005];\rll sz[500005];\rll a[500005];\rll ans ;\rll n;\rll dfs(ll u,ll p){\rsz[u] = 1;\rfor(ll i:G[u]){\rif(i == p) continue;\rsz[u] += dfs(i,u);\r}\rll sum = 0;\rfor(ll i:G[u]){\rif(i == p) continue;\rsum += sz[i] * (sz[u] - 1 - sz[i]) ;\r}\rsum /= 2;\rsum += (sz[u] - 1) * (n - sz[u]);\rsum += n - 1;\rif(sum\u00261) ans ^= a[u];\rreturn sz[u];\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn-1;i++){\rll x,y; cin\u003e\u003ex\u003e\u003ey;\rG[x].push_back(y); G[y].push_back(x);\r}\rfor(ll i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\rdfs(1,0);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:22:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 高精度 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:23:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 这道题主要是发现高精度，理论上ans会达到 1e9*1e5*1e5 以下是__int128的输入输出模板（支持负数） #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rtypedef __int128 INT ;\rconst INT N=1e5+5;\rINT a[N],b[N],s[N],m[N];\rinline INT read(){\rINT x=0,f=1;\rchar ch=getchar();\rwhile(ch\u003c'0'||ch\u003e'9'){\rif(ch=='-')\rf=-1;\rch=getchar();\r}\rwhile(ch\u003e='0'\u0026\u0026ch\u003c='9'){\rx=x*10+ch-'0';\rch=getchar();\r}\rreturn x*f;\r}\rinline void write(INT x){\rif(x\u003c0){\rputchar('-');\rx=-x;\r}\rif(x\u003e9)\rwrite(x/10);\rputchar(x%10+'0');\r}\rint main(){\rINT t,n;\rt = read();\rfor(int u=1;u\u003c=t;u++){\rn = read();\rfor(int i=1;i\u003c=n;i++) a[i] = read();\rfor(int i=1;i\u003c=n;i++) b[i] = read();\rs[1] = a[1];\rfor(int i=2;i\u003c=n;i++){\rs[i] = s[i-1] + a[i];\r}\rm[1] = b[1];\rfor(int i=2;i\u003c=n;i++){\rm[i] = min(b[i],m[i-1]);\r}\rINT ans = 0;\rINT cnt = a[1];\rfor(int i=2;i\u003c=n;i++){\rif(b[i-1]\u003eb[i]){\rans += cnt * (m[i-1] - m[i]);\r}\rcnt = max(cnt,s[i]);\r}\rans += cnt * m[n];\rcout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": \";\rwrite(b[1]);\rcout\u003c\u003c\" \";\rwrite(ans);\rputs(\"\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:23:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 并查集 离散化 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:24:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于当前的一对数，给它们连一条边，对所有的对数都进行这样的操作，最后会形成很多连通块，如果连通块有环，则这些数都能被选择，否则其中有一个数不能被选择，因为数据大小，用unordered_map离散化 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\runordered_map\u003cint,int\u003e used;\rset\u003cint\u003e rt;\runordered_map\u003cint,int\u003e rel;\runordered_map\u003cint,int\u003e num;\runordered_map\u003cint,int\u003e id;\rconst int maxn = 2e5+10;\rint a[maxn],b[maxn];\r//union find\rint par[maxn];\rint rankk[maxn];\rint sz[maxn];\rvoid init(int n){\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x){\rif(par[x]==x) return x;\relse return par[x]=find(par[x]);\r} void unite(int x,int y){\rx=find(x);\ry=find(y);\rif(x==y) return ;\rif(rankk[x]\u003crankk[y]) par[x]=y;\relse{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r} bool same(int x,int y){\rreturn find(x)==find(y);\r}\rint getid(int u){\rreturn id[u];\r}\rint main() {\rint _;\rcin \u003e\u003e _;\rfor(int q=1;q\u003c=_;q++) {\rused.clear();\rrt.clear();\rrel.clear();\rnum.clear();\rid.clear();\rint n;\rscanf(\"%d\",\u0026n);\rfor(int i=0;i\u003cn;i++){\rscanf(\"%d%d\",\u0026a[i],\u0026b[i]);\r}\rinit(2*n+2);\rint cnt = 0;\rfor(int i=0;i\u003cn;i++){\rif(id[a[i]] == 0) id[a[i]] = ++cnt;\rif(id[b[i]] == 0) id[b[i]] = ++cnt;\r}\rfor(int i=1;i\u003c=cnt;i++){\rrt.insert(i);\r}\rfor(int i=1;i\u003c=cnt;i++){\rnum[i] = 1;\r}\r// for(int i=1;i\u003c=cnt;i++){\r// cout\u003c\u003cid[i]\u003c\u003c\" \";\r// }puts(\"\");\r for(int i=0;i\u003cn;i++){\rint u = a[i],v = b[i];\r//if(used[u] == 1 and used[v] == 1) continue;\r //used[u] = used[v] = 1;\r if(!same(getid(u) , getid(v))){\rint urt = find(getid(u));\rint vrt = find(getid(v));\rint t1 = rel[urt],t2 = rel[vrt];\rint t3 = num[urt],t4 = num[vrt];\rrt.erase(urt);\rrt.erase(vrt);\rint t5 = t1 + t2 + 1;\rint t6 = t3 + t4;\runite(getid(u),getid(v));\rint uvrt = find(getid(u));\rrel[uvrt] = t5;\rnum[uvrt] = t6;\rrt.insert(uvrt);\r}else{\rrel[find(getid(u))]++;\r}\r}\rll ans = 0;\rfor(int i:rt){\rans += (rel[i] \u003e= num[i] ? num[i] : num[i] - 1);\r//cout\u003c\u003crel[i]\u003c\u003c\" \"\u003c\u003cnum[i]\u003c\u003c\" \"\u003c\u003ci;\r //cout\u003c\u003cfind(getid(44));\r }\rcout\u003c\u003c\"Case #\"\u003c\u003cq\u003c\u003c\": \"\u003c\u003cans\u003c\u003cendl；\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:24:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"模拟 枚举 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:25:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 三重循环枚举 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxn = 260;\rstring cards[maxn][4];\rbool check(int i,int j,int k){\rbool flags[4] = {false};\rfor(int q=0;q\u003c4;q++){\rstring s1 = cards[i][q];\rstring s2 = cards[j][q];\rstring s3 = cards[k][q];\rif((s1==\"[*]\" or s2==\"[*]\" or s3==\"[*]\") or (s1 == s2 and s2 == s3) or (s1 != s2 and s2 != s3 and s1 != s3)) flags[q] = true;\r}\rif(flags[0] and flags[1] and flags[2] and flags[3]) return true;\rreturn false;\r}\rint main() {\rint _;\rcin \u003e\u003e _;\rfor(int u=1;u\u003c=_;u++) {\rint n;\rcin\u003e\u003en;\r//reset\r for(int i=0;i\u003c=n;i++){\rfor(int j=0;j\u003c4;j++){\rcards[i][j].clear();\r}\r}\rstring s;\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003es;\rfor(int j=0,k=0;j\u003cs.length();j++){\rcards[i][k].push_back(s[j]);\rif(s[j]==']') k++;\r}\r}\r// for(int i=0;i\u003c4;i++){\r// cout\u003c\u003ccards[0][i]\u003c\u003c\" \";\r// }\r bool ok = false;\rfor(int i=0;i\u003cn;i++){\rif(ok) break;\rfor(int j=i+1;j\u003cn;j++){\rif(ok) break;\rfor(int k=j+1;k\u003cn;k++){\rif(ok) break;\rif(check(i,j,k)){\rcout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": \"\u003c\u003ci+1\u003c\u003c\" \"\u003c\u003cj+1\u003c\u003c\" \"\u003c\u003ck+1\u003c\u003cendl;\rok = true;\r}\r}\r}\r}\rif(!ok) cout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": -1\\n\";\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:25:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:26:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 #include \"bits/stdc++.h\"\rusing namespace std;\rconst int maxn = 1e5 + 5;\rint a[maxn];\rint dp[maxn][2];\rint main() {\rint n;\rcin \u003e\u003e n;\rfor(int i = 0; i \u003c n; i++){\rcin \u003e\u003e a[i];\r}\rif(a[0] == 0) dp[0][0] = 0, dp[0][1] = 1;\rif(a[0] == 1) dp[0][0] = 1, dp[0][1] = 0;\rfor(int i = 1; i \u003c n; i++){\rif(a[i] == 0){\rdp[i][0] = min(dp[i-1][0] , dp[i-1][1] + 1);\rdp[i][1] = min(dp[i-1][0] + 2 , dp[i-1][1] + 1);\r}\rif(a[i] == 1){\rdp[i][0] = min(dp[i-1][0] + 1 , dp[i-1][1] + 2);\rdp[i][1] = min(dp[i-1][0] + 1 , dp[i-1][1]);\r}\r}\rcout \u003c\u003c min(dp[n-1][0] , dp[n-1][1] + 1)\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:26:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"图论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:27:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 暴力O(n^2) ，所以考虑将问题本质化（结论化） 把问题转化成求一个点，使得它到集合中的点的最大距离最小，求值 这样这个点从直观上看应该处在这些点的中间，并且是集合中两个最远的点的中点 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rconst int maxv = 3e5 + 5;\rconst int max_logv = 20;\rvector\u003cint\u003e G[maxv];\rint root;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v, int p, int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i = 0; i \u003c G[v].size(); i++){\rif(G[v][i] != p) dfs(G[v][i], v, d+1);\r}\r}\rvoid init(int V){\rdfs(root, -1, 0);\rfor(int k = 0; k+1 \u003c max_logv; k++){\rfor(int v = 0; v \u003c V; v++){\rif(parent[k][v] \u003c 0) parent[k+1][v] = -1;\relse parent[k+1][v] = parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u] \u003e depth[v]) swap(u, v);\rfor(int k =0; k \u003c max_logv; k++){\rif((depth[v] - depth[u]) \u003e\u003e k \u0026 1) v = parent[k][v];\r}\rif(u == v) return u;\rfor(int k = max_logv-1; k \u003e= 0; k--){\rif(parent[k][u] != parent[k][v]){\ru = parent[k][u];\rv = parent[k][v];\r}\r}\rreturn parent[0][u];\r}\rint a[1000005];\rint main() {\rint n;\rcin \u003e\u003e n;\rfor(int i = 0; i \u003c n-1; i++){\rint u, v;\rcin \u003e\u003e u \u003e\u003e v;\rG[u].push_back(v);\rG[v].push_back(u);\r}\rroot = 1;\rinit(n+1);\rint num ;\rcin \u003e\u003e num;\rfor(int i = 0; i \u003c num; i++){\rint m;\rcin \u003e\u003e m;\rint est = root;\rfor(int j = 0; j \u003c m; j++){\rcin \u003e\u003e a[j];\rif(depth[a[j]] \u003e depth[est]) est = a[j];\r}\rint ans = -1;\rfor(int j = 0; j \u003c m; j++){\rans = max(ans, depth[est] + depth[a[j]] - 2 * depth[lca(est, a[j])]);\r}\rcout \u003c\u003c ((ans + 1) \u003e\u003e 1) \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:27:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["abc"],"content":"abc172","date":"2020-06-28","objectID":"/abc172/","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"A - Calc ","date":"2020-06-28","objectID":"/abc172/:0:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:1:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rint a;\rcin\u003e\u003ea;\rcout\u003c\u003ca+a*a+a*a*a\u003c\u003cendl;\rreturn 0;\r}\r B - Minor Change ","date":"2020-06-28","objectID":"/abc172/:2:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:3:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rstring s,t;\rcin\u003e\u003es\u003e\u003et;\rint ans = 0;\rfor(int i=0;i\u003cs.length();i++){\rif(s[i]!=t[i])ans++;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - Tsundoku ","date":"2020-06-28","objectID":"/abc172/:4:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:5:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 前缀和+双指针 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a[200005];\rll b[200005];\rint main(){\rll n,m,k;\rcin\u003e\u003en\u003e\u003em\u003e\u003ek;\ra[0] = 0;\rb[0] = 0;\rfor(ll i=1;i\u003c=n;i++){\rll tmp;\rcin\u003e\u003etmp;\ra[i] = a[i-1] + tmp;\r}\rfor(ll j=1;j\u003c=m;j++){\rll tmp;\rcin\u003e\u003etmp;\rb[j] = b[j-1] + tmp;\r}\rll ans = 0;\rll j = m;\rll i;\rfor(i=0;i\u003c=n;i++){\rwhile(a[i] + b[j] \u003e k and j\u003e=0){\rj--;\r}\rif(a[i] + b[j] \u003c= k) {\rans = max(ans , i+j);\r//cerr\u003c\u003cj\u003c\u003cendl;\r }\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - Sum of Divisors ","date":"2020-06-28","objectID":"/abc172/:6:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:7:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 筛法预处理因子个数，O(1)查询 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rll num[10000005];\rvoid init(){\rfor(ll i=1;i\u003c=10000005;i++){\rfor(ll x=i;x\u003c10000005;x+=i){\rnum[x]++;\r}\r}\r}\rint main(){\rinit();\rcin\u003e\u003en;\rll ans = 0;\rfor(ll i=1;i\u003c=n;i++){\rans += i*num[i];\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - NEQ ","date":"2020-06-28","objectID":"/abc172/:8:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:9:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 对于从M个选N个全排列的每一种方案都有对应的若干个情况，它们都是等价的 比如M=4 N=3 ，对于全排列的一种方案 123 与之对应的有第一个数字不能为1、第二个数字不能为2，第三个数字不能为3 第一个数字和第二个数字不能同时为12，第二个和第三个数字不能同时为23，第一个和第三个数字不能同时为13 第一个第二个第三个数字不能同时为123 这样就是基于容斥原理的排列组合 总的方案数是 $$ A_{M}^{N}*\\sum\\limits_{i=0} ^ {n} {C_{N}^{i}A_{M-i}^{N-i}(-1)^n} $$ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rll m;\rconst ll mod = 1e9+7;\rconst ll maxn = 500005;\rll inv[maxn+3];\rll fac[maxn+3];\rinline ll A(ll n,ll m){\rreturn fac[n]*inv[n-m]%mod;\r}\rinline ll C(ll n,ll m){\rreturn A(n,m)*inv[m]%mod;\r}\rint main(){\rcin\u003e\u003en\u003e\u003em;\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u003cmaxn;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=maxn;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=maxn;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rll ans =0;\rfor(ll i=0;i\u003c=n;i++){\rll tmp = C(n,i) * A(m-i,n-i);\rtmp %= mod;\rif(i%2==0){\rans += tmp;\r}else ans -= tmp;\rans += mod;\rans %= mod;\r}\rans *= A(m,n);\rans += mod;\rans %= mod;\rcout\u003c\u003cans\u003c\u003cendl;\r//cout\u003c\u003ctmp\u003c\u003cendl;\r return 0;\r}\r F - Unfair Nim ","date":"2020-06-28","objectID":"/abc172/:10:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:11:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 题解url #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rll n;\rcin\u003e\u003en;\rll q,w;\rcin\u003e\u003eq\u003e\u003ew;\rll x = 0;\rfor(ll i=2;i\u003cn;i++){\rll tmp;\rcin\u003e\u003etmp;\rx ^= tmp;\r}\rll d = (q+w-x) / 2;\rif(d\u003c0 or d\u003eq or (d\u0026x) or (q+w-x)%2==1){\rcout\u003c\u003c-1\u003c\u003cendl;\rexit(0);\r}\rfor(ll i=45;i\u003e=0;i--){\rif(x\u003e\u003ei\u00261LL){\rif(d+(1LL\u003c\u003ci) \u003c= q){\rd += (1LL\u003c\u003ci);\r}\r}\r}\rif(d==0) cout\u003c\u003c-1\u003c\u003cendl;\relse cout\u003c\u003cq-d\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-06-28","objectID":"/abc172/:12:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["nowcoder"],"content":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"挺好的比赛 A-找规律 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:0:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 玄学题，打表找规律或者猜测规则是每次洗牌是将一个位置移动到另一个固定位置 13次洗牌之后所有的位置都占过一遍，所以13次是循环 要求洗牌5次的结果就是求9次两次洗牌的结果 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rstring s[30];\rstring t[30];\rint a[30];\rvoid init_a(){\rfor(int i=0;i\u003c13;i++){\rfor(int j=0;j\u003c13;j++){\rif(s[i] == t[j]){\ra[i] = j;\rbreak;\r}\r}\r}\r}\rvoid sol(){\rfor(int i=0;i\u003c13;i++){\rt[a[i]] = s[i];\r}\rfor(int i=0;i\u003c13;i++){\rs[i] = t[i];\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rwhile(cin\u003e\u003es[0]){\rfor(int i=1;i\u003c13;i++) cin\u003e\u003es[i]; for(int i=0;i\u003c13;i++) cin\u003e\u003et[i]; init_a();\rfor(int i=0;i\u003c9;i++) sol();\rfor(int i=0;i\u003c13;i++) cout\u003c\u003cs[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\r//cout\u003c\u003c\"end\"\u003c\u003cendl;\r }\rreturn 0;\r}\r B-签到题 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:1:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 排列组合 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+9;\rll fac[100005];\rll inv[100005];\rll C(ll n,ll m){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rll A(ll n,ll m){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main(){\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u003c100005;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rinv[0] = 1;\rinv[1] = 1; //inv[0]=1 !!! for(ll i=2;i\u003c=100005;i++){\rinv[i] = (mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=100005;i++){\rinv[i] = (inv[i]*inv[i-1])%mod;\r}\rll n;\rwhile(cin\u003e\u003en){\rcout\u003c\u003cn*C(n,2)%mod*A(n-1,n-2)%mod\u003c\u003cendl;\r}\rreturn 0;\r}\r C-救救AR ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:2:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题意 找规律 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n;\rcin\u003e\u003en;\rif(n==1 or n==2 or n==3){\rcout\u003c\u003c-1\u003c\u003cendl;\r}\relse{\rif(n\u00261){\rcout\u003c\u003c\"ARA\";\rfor(int i=0;i\u003cn/2;i++){\rcout\u003c\u003c\"R\";\r}\rcout\u003c\u003cendl;\r}\relse{\rcout\u003c\u003c\"AA\";\rfor(int i=0;i\u003cn/2;i++) cout\u003c\u003c\"R\";\rcout\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r D-ar采蘑菇 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:3:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 状态压缩dp #include\u003ciostream\u003e\r#include\u003ccstring\u003e\rusing namespace std;\rusing ll = long long;\rint r[7],u[7];\rint dp[105][105][35];\rint main(){\rint t;\rcin\u003e\u003et;\rint n,m,k;\rwhile(t--){\rmemset(r,0,sizeof(r));\rmemset(u,0,sizeof(u));\rmemset(dp,0,sizeof(dp));\rcin\u003e\u003en\u003e\u003em\u003e\u003ek;\rfor(int i=0;i\u003ck;i++){\rstring s;\rcin\u003e\u003es;\rfor(int j=0;j\u003cs.length();j++){\rif(s[j] == 'R') r[i]++; else u[i]++;\r}\r}\rdp[0][0][0] = 1;\rfor(int i=0;i\u003c=n;i++){\rfor(int j=0;j\u003c=m;j++){\rfor(int st=0;st\u003c(1\u003c\u003ck);st++){\rfor(int q=0;q\u003ck;q++){\rint nn = i - r[q];\rint mm = j - u[q];\rif(nn\u003c0 or nn\u003en or mm\u003c0 or mm\u003em) continue;\rif(st\u003e\u003eq\u00261){\rdp[i][j][st] |= dp[nn][mm][st];\rdp[i][j][st] |= dp[nn][mm][st^(1\u003c\u003cq)];\r}\r}\r}\r}\r}\rint ans = 0; //等于0就ac,-1wa\r for(int i=0;i\u003c(1\u003c\u003ck);i++){\rif(dp[n][m][i]){\rans = max(ans , __builtin_popcount(i));\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r E-呼兰河传 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:4:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 最大的lcm为全选取 经典的大数求lcm 暴力超时，且除以gcd无法取模 由于题目的数据规模可以去重 对于每一个因数，求这些数对于它幂次方贡献的最大值 最后遍历所有因数，对于最大贡献求积 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+9;\rll pn[100005];\rset\u003cll\u003e st;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rvoid did(ll x){\rfor(ll i=2;i*i\u003c=x;i++){\rif(x%i==0){\rll num = 0;\rwhile(x%i==0){\rx /= i;\rnum++;\r}\rpn[i] = max(pn[i] , num);\r}\r}\rif(x != 1){\rpn[x] = max(pn[x] , 1LL);\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rll n;\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rll x;\rcin\u003e\u003ex;\rst.insert(x);\r}\rfor(ll i:st){\rdid(i);\r}\rll ans = 1;\rfor(ll i=2;i\u003c=1e5+2;i++){\rans *= qpow(i,pn[i]);\rans %= mod;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F-月出皎兮，佼人僚兮。 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:5:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 对于某一节点u，设子树颜色数最大是 p，颜色总数是sum，如果p*2 \u003e sum 最大匹配数是sum - p，否则都能匹配 sum/2 所以只要求子树颜色最多的数量 暴力dfs超时，所以用树上启发式合并 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 2e5+3;\rstruct edge{\rint to,nxt;\r}e[maxn\u003c\u003c1];\rll sz[maxn],par[maxn],c[maxn],num[maxn],head[maxn],wch[maxn],tot[maxn],ans[maxn];\rll n;\rll cnt;\rll tmax;\rll sum;\rvoid add_edge(ll u,ll v){\re[++cnt].to = v;\re[cnt].nxt = head[u];\rhead[u] = cnt;\r}\rvoid dfs(ll u,ll p){\rsz[u] = 1;\rfor(ll i=head[u]; i ;i=e[i].nxt){\rll t = e[i].to;\rif(t != p){\rdfs(t,u);\rsz[u] += sz[t];\rif(sz[t] \u003e sz[wch[u]]) wch[u] = t;\r}\r}\r}\rvoid cal(ll u,ll p,ll wch,ll val){\rtot[c[u]] += val * num[u];\rsum += val * num[u];\rtmax = max(tmax , tot[c[u]]);\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch){\rcal(t,u,wch,val);\r}\r}\r}\rvoid dsu(ll u,ll p,ll kp){\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch[u]){\rdsu(t,u,0);\r}\r}\rif(wch[u]) dsu(wch[u],u,1);\rcal(u,p,wch[u],1);\rif(2*tmax \u003e sum) ans[u] = sum - tmax;\relse ans[u] = sum / 2; if(!kp) {\rcal(u,p,0,-1);\rtmax = 0;\rsum = 0;\r}\r}\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn-1;i++){\rll x,y;\rcin\u003e\u003ex\u003e\u003ey;\radd_edge(x,y); add_edge(y,x);\r}\rfor(ll i=1;i\u003c=n;i++){\rll x,y;\rcin\u003e\u003ex\u003e\u003ey;\rc[i] = x;\rnum[i] = y;\r}\rdfs(1,0);\rdsu(1,0,1);\rfor(int i=1;i\u003c=n;i++){\rcout\u003c\u003cans[i]\u003c\u003cendl;\r} return 0;\r}\r G-寻找未曾见过的你 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:6:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 不会 H-AR的背包 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:7:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 不会 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:8:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["abc"],"content":"abc171","date":"2020-06-22","objectID":"/abc171/","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"A - αlphabet ","date":"2020-06-22","objectID":"/abc171/:0:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:1:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rchar a;\rcin\u003e\u003ea;\rif(isupper(a)) cout\u003c\u003c'A';else cout\u003c\u003c'a';\rreturn 0;\r}\r B - Mix Juice ","date":"2020-06-22","objectID":"/abc171/:2:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:3:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n,k;\rcin\u003e\u003en\u003e\u003ek;\rint a[n];\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rsort(a,a+n);\rint ans = 0;\rfor(int i=0;i\u003ck;i++) ans+=a[i];\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - One Quadrillion and One Dalmatians ","date":"2020-06-22","objectID":"/abc171/:4:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 类似于十进制转26进制 不同的是27是 aa ","date":"2020-06-22","objectID":"/abc171/:5:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 这个题目没有像正常的转化那样进位 所以对每一位求值前先减1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rll a;\rcin\u003e\u003ea;\rstring s = \"\";\r//a--;\r while(a!=0){\ra--;\rs += (a%26) + 'a';\ra /= 26;\r}\rreverse(s.begin(),s.end());\rcout\u003c\u003cs\u003c\u003cendl;\rreturn 0;\r}\r D - Replacing ","date":"2020-06-22","objectID":"/abc171/:6:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:7:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 模拟 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rlong long a[100005];\rint main(){\rlong long n;\rcin\u003e\u003en;\rlong long sum = 0;\rfor(long long i=0;i\u003cn;i++) {\rlong long x;\rcin\u003e\u003ex;\ra[x]++;\rsum+=x;\r}\rlong long q;\rcin\u003e\u003eq;\rfor(long long i=0;i\u003cq;i++){\rlong long t,y;\rcin\u003e\u003et\u003e\u003ey;\rsum+=((y-t)*a[t]);\rcout\u003c\u003csum\u003c\u003cendl;\ra[y]+=a[t];\ra[t] = 0;\r}\rreturn 0;\r}\r E - Red Scarf ","date":"2020-06-22","objectID":"/abc171/:8:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 对于一个数列，第一个位置的值是原数列其他位置的异或，依此类推 还原数列 ","date":"2020-06-22","objectID":"/abc171/:9:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 利用异或性质 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint a[200005];\rint main()\r{\rint n;\rcin\u003e\u003en;\rint ans = 0;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\rans ^= a[i];\r}\rfor(int i=0;i\u003cn;i++){\rcout\u003c\u003c(ans^a[i])\u003c\u003c\" \";\r}cout\u003c\u003cendl;\rreturn 0;\r}\r F - Strivore ","date":"2020-06-22","objectID":"/abc171/:10:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:11:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 把问题转化成满足长度为n的，包含子序列s的字符串有几个 然后就变成排列组合题 考虑所有情况减去不包含子序列s的字符串 不含子序列s的字符串可以这样构造 目标串T可以包含子序列中的1个，2个，3个。。。s.length() - 1个 这样取子序列只能是前几个，因为取s的中间部分就一定不满足条件 对于其中一种情况，举个例子 s = \" acf” 总长度为8 假设从s中选两个，那这两个就一定是 a c 假设它们被安排在这样的位置 12a45c78 那么1号和2号一定不能选到a，4号和5号一定不能选到c，7号和8号一定不能选到f 这样T就一定没有子序列s 对于除ac外的位置都有25种选择 所以这种情况（选两个）就有 $$ C_{8}^{2} * 25^6 $$ 种方案 所以对于所有情况(n是T的长度，s是子序列的长度)，方案数 $$ 26^{n} - \\sum\\limits_{i=0} ^ {s-1} {C_n^i*25^{n-i}} $$ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll fac[2000005];\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll C(ll n,ll m){\rreturn fac[n]*qpow(fac[m] , mod-2)%mod*qpow(fac[n-m] , mod-2)%mod;\r}\rint main(){\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u003c2000002;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rll k;\rcin\u003e\u003ek;\rstring ss;\rcin\u003e\u003ess;\rll s = ss.size();\rll ans = 0;\rfor(ll i=0;i\u003cs;i++){\rans += C(k+s , i) * qpow(25 , k+s-i);\rans %= mod;\r}\rcout\u003c\u003c(qpow(26 , k+s) - ans + mod) % mod\u003c\u003cendl;\rreturn 0;\r}\r 如果用逆元 inline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=n;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\r ","date":"2020-06-22","objectID":"/abc171/:12:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["linux"],"content":"install ubuntu in vmware","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装vmware 点击这里 需要注册账号 vmware的安装基本选择默认选项，一直next ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:1:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"准备一个ubuntu镜像文件 点击这里 选择对应版本的ubuntu文件 文件类似于 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:2:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装ubuntu 打开vmware 点击“创建新的虚拟机” 点击“自定义” 点击“下一步” 硬件兼容性选低一点能兼容的比较多 点击“下一步” 选择“稍后安装操作系统” 点击“下一步” 选择linux 选择 ubuntu64位 点击“下一步” 选择”虚拟机名称“和安装的路径 点击“下一步” 根据自身计算机性能来分配处理器数量 点击“下一步” 选择虚拟机内存，一般2G就行 点击“下一步” 选择“桥接网络” 点击“下一步” 选择推荐的那个 点击“下一步” 选择推荐的那个 点击“下一步” 选择“创建新的虚拟磁盘” 点击“下一步” 根据需求选择磁盘空间大小（一般20G以上） 点击“立即分配磁盘空间” 选择“将虚拟磁盘拆分成多个文件” 点击“下一步” 点击“下一步” 点击“完成”，开始创建（需要花很长的时间） 完成之后 先不要开启虚拟机 点击“编辑虚拟机设置” 点击”cd/dvd“ 选择“使用iso影像文件” 点击“浏览” 找到最开始装的iso文件 点击“确定 点击“开启虚拟机” 选择”中文“，点击“安装ubuntu” 点击“继续” 点击“继续” 点击“现在安装” 完成后 点击“继续” 点击“继续” 输入信息 点击“继续”，开始安装 完成后 点击“现在重启” 点击“小圆”，选择”ubuntu2d“ 输入密码，登录 完成 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:3:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"附加 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"鼠标滚轮无法使用的问题 应该只有罗技鼠标会出现这种情况吧 参考此处 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:1","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"chromium无法打开的问题 升级版本，据说chrome不支持ubuntu12及以下 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:2","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"中文输入法无法显示候选词框的问题 莫名其妙可以，如果fcitx不行，尝试安装搜狗输入法，要重启才能启用搜狗，但一般搜狗输入法也无法显示，可能与kde桌面有关，真正的原理未知 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:3","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"创建快捷方式（在启动器中） 在dash中输入，找到后直接拖到启动器中，可调整顺序 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:4","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装flatabulous主题 参考此处 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:5","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装clion 官网下载 tar.gz压缩包 然后 tar -zxvf XXX.tar.gz 解压缩 然后在bin目录下./clion.sh 安装gcc sudo apt-get update sudo apt-get install build-essential gcc --version 如果没有 sudo apt-get install gcc-对应的版本号 安装cmake 参考此处 初步使用ubuntu的感想 虽然ubuntu有图形界面，但它不像windows那样丰富，大多数的操作都可以通过点击可视化界面完成 ubuntu类似于万物皆文件，以抽象的形式存在，所以很多操作只能由命令行完成 ubuntu的很多操作都比windows直接，且安全性也比windows高，管理c++工程，比如安装库都要比windows方便，我觉得很大的原因在于windows要服务于大众，而linux更像自娱自乐的工具 使用linux只是使用它的特性，整体上windows还是大大优于linux ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:6","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["abc"],"content":"abc170","date":"2020-06-15","objectID":"/abc170/","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"A - Five Variables ","date":"2020-06-15","objectID":"/abc170/:0:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 找5个数中值为0的下标 ","date":"2020-06-15","objectID":"/abc170/:1:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 a = list(map(int , input().split()))\rprint(a.index(0) + 1)\r B - Crane and Turtle ","date":"2020-06-15","objectID":"/abc170/:2:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 鸡兔同笼问题 ","date":"2020-06-15","objectID":"/abc170/:3:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 n , m = map(int , input().split())\rprint('Yes') if (m - 2 * n) % 2 == 0 and (m - 2 * n) \u003e= 0 and 4 * n - m \u003e= 0 and (4 * n - m) % 2 == 0 else print('No')\r C - Forbidden List ","date":"2020-06-15","objectID":"/abc170/:4:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一数x 和一数列，找不在数列中离x最近的数 ","date":"2020-06-15","objectID":"/abc170/:5:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 x , n = map(int , input().split())\rb = []\rif n!=0:\rb = list(map(int,input().split()))\rt = 0\rans = 0\rwhile 1:\rif x-t not in b:\rans = x - t\rbreak\rif x+t not in b:\rans = x + t\rbreak\rt += 1\rprint(ans)\r D - Not Divisible ","date":"2020-06-15","objectID":"/abc170/:6:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一数列，对于数列中的每个数，如果都不能被其他数整除，计数器 + 1 求计数器的值 ","date":"2020-06-15","objectID":"/abc170/:7:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 暴力时间复杂度 O(n*√(V)) 好像会超时 可以排序，从小到大遍历，对于当前数，考虑 2*x 3*x 4*x 的值是否在数列里，如果在数列里（只会比当前数大）则移除 这样总共要算 (1/2 + 1/3 + 1/4 + 1/5 + 1/6 + … + 1/n) * V = (ln(n) + 0.578) * V 次 时间复杂度为 O(n*ln(n)) 注意当数列中有重复数，则都不能算 注意特判1个数 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\r//int a[200005];\rset\u003cint\u003e st;\rset\u003cint\u003e stt;\rmultiset\u003cint\u003e ms;\rvoid did(int x){\rfor(int i=2;i*x\u003c=1000005;i++){\rint tmp = i*x;\rif(st.find(tmp)!=st.end()){\rst.erase(tmp);\r}\r}\r}\rint main(){\rcin\u003e\u003en;\r//for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\r for(int i=0;i\u003cn;i++){\rint x;\rcin\u003e\u003ex;\rst.insert(x);\rstt.insert(x);\rms.insert(x);\r}\r//for(int i:st) cout\u003c\u003ci\u003c\u003cendl;\r if(st.size()==1 and n\u003e1) {\rcout\u003c\u003c0\u003c\u003cendl;\rreturn 0;\r}\rif(n==1) { // WA!!!\r cout\u003c\u003c1\u003c\u003cendl;\rreturn 0;\r}\rfor(int i:st){\rdid(i);\r}\r//for(int i:st) cout\u003c\u003ci\u003c\u003cendl;\r int ans = st.size(); // WA !!!!\r for(int i:st){\rif(ms.count(i)\u003e1) ans--;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - Smart Infants ","date":"2020-06-15","objectID":"/abc170/:8:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 每个小朋友都有一个分数和初始的幼儿园 每次转学的操作是 将第 i 个小朋友转到第 j 个幼儿园 对于q次转学 每次输出每个幼儿园中分数最高的最小值 ","date":"2020-06-15","objectID":"/abc170/:9:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 一开始的思路是最小值的更新肯定在有变动的幼儿园和当前最小值之间选择 但这是错的，因为当前最小值被覆盖之后，更新后的最小值可能是之前的次小值（而次小值没有记录） 所以：用集合模拟幼儿园（目的在于log时间内排序） 对于每次操作都用集合模拟，用多重集维护所有的最大值 通过查看幼儿园最大值是否被更换来决定是否对多重集进行增删 一百万个数据错了3个，原因竟然是： 多重集的erase操作是全删而不是删一个 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,q;\rset\u003cpair\u003cint,int\u003e, greater\u003cpair\u003cint,int\u003e \u003e \u003e st[200005];\rmultiset\u003cint\u003e ms;\rint rat[200005];\rint wh[200005];\r//multiset\u003cint , greater\u003cint\u003e\u003e ts[200005];\rint main(){\rcin\u003e\u003en\u003e\u003eq;\rfor(int i=0;i\u003cn;i++){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rb--;\rrat[i] = a;\rwh[i] = b;\rst[b].insert({a,i});\r//ts[b].insert(a);\r }\rfor(int i=0;i\u003c200005;i++){\rif(st[i].empty()) continue;\r//int num = ts[i].count(*ts[i].begin());\r //for(int j=0;j\u003cnum;j++){\r ms.insert(st[i].begin()-\u003efirst);\r//}\r }\rwhile(q--){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\ra--,b--;\rbool ismax = false;\rif(st[wh[a]].begin()-\u003esecond == a) ismax = true;\rif(ismax){\rms.erase(ms.find(rat[a]));\rst[wh[a]].erase({rat[a] , a});\rif(st[wh[a]].empty()) ;\relse ms.insert(st[wh[a]].begin()-\u003efirst);\rwh[a] = b;\rif(st[b].empty()) ;\relse ms.erase(ms.find(st[b].begin()-\u003efirst));\rst[b].insert({rat[a] , a});\rms.insert(st[b].begin()-\u003efirst);\r}\relse{\rst[wh[a]].erase({rat[a] , a});\rwh[a] = b;\rif(st[b].empty()) ;\relse ms.erase(ms.find(st[b].begin()-\u003efirst));\rst[b].insert({rat[a] , a});\rms.insert(st[b].begin()-\u003efirst);\r}\rcout\u003c\u003c*ms.begin()\u003c\u003cendl;\r}\rreturn 0;\r}\r F - Pond Skater ","date":"2020-06-15","objectID":"/abc170/:10:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一个迷宫、起点、终点 对于走的方向，只能是上下左右 对于每一步，最多只能走k格且不能转弯 求是否能到达终点，如果能，最少走几步 ","date":"2020-06-15","objectID":"/abc170/:11:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 bfs 每次沿一个方向，尽可能地走k步 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint h ,w ,k;\rint xs,ys,xt,yt;\rconst int inf = 1e9;\rint dirx[] = {0,-1,1,0};\rint diry[] = {1,0,0,-1};\rint main(){\rcin \u003e\u003e h \u003e\u003e w \u003e\u003e k;\rcin\u003e\u003exs\u003e\u003eys\u003e\u003ext\u003e\u003eyt;\rxs--,ys--,xt--,yt--;\rvector\u003cstring\u003e vt(h);\rfor(int i=0;i\u003ch;i++) cin\u003e\u003evt[i];\rvector\u003cvector\u003cint\u003e\u003e d(h , vector\u003cint\u003e(w,inf));\rqueue\u003cpair\u003cint,int\u003e\u003e q;\rq.push({xs,ys});\rd[xs][ys] = 0;\rwhile(q.size()){\rauto tmp = q.front();\rq.pop();\rint tmpx = tmp.first;\rint tmpy = tmp.second;\rfor(int i=0;i\u003c4;i++){\r// int tox = tmpx + dirx[i];\r// int toy = tmpy + diry[i];\r int ttmpx = tmpx;\rint ttmpy = tmpy;\rint j;\rfor(j=0;j\u003ck;j++){\rttmpx += dirx[i];\rttmpy += diry[i];\rif(ttmpx\u003e=0 and ttmpy\u003e=0 and ttmpx\u003ch and ttmpy\u003cw and vt[ttmpx][ttmpy]!='@' and d[ttmpx][ttmpy] \u003e d[tmpx][tmpy]){\rif(d[ttmpx][ttmpy] \u003e d[tmpx][tmpy] + 1){\rd[ttmpx][ttmpy] = d[tmpx][tmpy] + 1;\rq.push({ttmpx , ttmpy});\r}\r}else break;\r}\r}\r}\rcout\u003c\u003c(d[xt][yt]==1e9 ? -1 : d[xt][yt])\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-06-15","objectID":"/abc170/:12:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["codeforces"],"content":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"A. Shovels and Swords ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:0:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 两个钻石和一个棍子可以造出A，两个棍子和一个钻石可以造出B 每个A或B都可以卖出一块钱，求 x个棍子和y个钻石最多可以卖多少钱 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:1:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 钻石和棍子是等价的，他们一共用了三个，只要贪心地将总数/3即可 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint t;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rcout\u003c\u003cmin({a,b,(a+b)/3})\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Shuffle ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:2:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 初始有n个数，第i个为1，其他为0，给若干个区间，对每个区间，可以选择区间内的数（两个或自身）交换数值 问有多少个数字能在合理选择后达到1 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:3:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 首先前面的区间是否覆盖1，没覆盖全部抛弃，否则从那个区间开始做以下事 判断接下来的区间和这个区间有没有交集，有则用并集刷新当前区间，否则抛弃 最后求集合包含了几个数 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n,x,m;\rint t;\rint l,r;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ex\u003e\u003em;\rint L=-1,R=-1;\rbool ok = false;\rwhile(m--){\rcin\u003e\u003el\u003e\u003er;\rif(ok){\rif(l\u003c=R and L\u003c=r){\rL = min(L,l);\rR = max(R,r);\r}\r}\relse\r{\rif(x\u003cl or x\u003er ) continue;\rL = l,R = r;\rok = true;\r}\r}\rif(L==-1 and R==-1) cout\u003c\u003c1\u003c\u003cendl;\relse cout\u003c\u003cR-L+1\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Palindromic Paths ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:4:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一充满01的矩阵，从左上角走到右下角，只能向右走和向下走 改变矩阵中的若干元素，使得所有路径按序组成的字符串都是回文串 求最小改动数 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:5:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 由于题限，到每个点都走固定的步数，每个步数值与对称的步数值相同（同为0或1） bfs求每格步数，然后对于每一组求0多还是1多，以此决定全是0还是全是1 [WARNING] 以下代码，逻辑低效(懒得改) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n,m;\rint t;\rint a[32][32];\rint d[32][32];\rvector\u003cint\u003e stp[62];\rint used[32][32];\rpriority_queue\u003cpair\u003cint,int\u003e\u003e pq;\rvoid bfs(){\rpq.push({0,0});\rd[0][0] = 0;\rused[0][0] = 1;\rwhile(pq.size()){\rpair\u003cint,int\u003e pii = pq.top();\rpq.pop();\rif(pii.first+1 \u003c n and used[pii.first+1][pii.second]==0) {\rpq.push(make_pair(pii.first+1,pii.second));\rd[pii.first+1][pii.second] = d[pii.first][pii.second] + 1;\rused[pii.first+1][pii.second] = 1;\r}\rif(pii.second+1 \u003c m and used[pii.first][pii.second+1]==0){\rpq.push(make_pair(pii.first,pii.second+1));\rd[pii.first][pii.second+1] = d[pii.first][pii.second] + 1;\rused[pii.first][pii.second+1] = 1;\r}\r}\rfor(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) stp[d[i][j]].push_back(a[i][j]);\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rint ans = 0;\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003c62;i++) stp[i].clear();\rmemset(used,0,sizeof(used));\rfor(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) cin\u003e\u003ea[i][j];\rbfs();\rfor(int i=0,j=n+m-2;i\u003cj;i++,j--){\rif((n+m-2)%2==0 and i==j) continue;\rint zero = count(stp[i].begin(),stp[i].end(),0) + count(stp[j].begin(),stp[j].end(),0);\rint one = count(stp[i].begin(),stp[i].end(),1) + count(stp[j].begin(),stp[j].end(),1);\rans += 2*stp[i].size() - max(zero,one);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r D. Two Divisors ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:6:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一数n，判断n的所有因子中（1除外）是否存在 d1 d2使得 d1+d2与n互质 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:7:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 如果存在，则这组数可以是 d1*d2 = n d1 与d2一定互质 让n一直除以最小因子，除到最后不为1，则剩下的数与之前的除数互质，满足条件 最小因子可以筛法预处理 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n;\rint d1[500005];\rint d2[500005];\rint a[500005];\rint f[10000005];\rvoid preprocess(){\rfor(int i=2;i\u003c10000005;i++)\rif(f[i] == 0)\r{\rf[i] = i;\rfor(int j=i+i;j\u003c10000005;j+=i) f[j] = i;\r}\r}\rvoid did(int x,int ind){\rint foo = f[x];\rint bar = x;\rwhile(x%foo==0) x /= foo;\rif(x==1) d1[ind]=-1,d2[ind]=-1;\relse d1[ind]=x,d2[ind]=bar/x;\r}\rint main(){\rpreprocess();\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rfor(int i=0;i\u003cn;i++) did(a[i] , i);\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cd1[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cd2[i]\u003c\u003c\" \"; cout\u003c\u003cendl; return 0;\r}\r E. Two Arrays ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:8:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给两个数组A B（B为递增），B的大小为m，将A分成m个区间，使得每个区间的最小值与B的每个数相同（按顺序对应），求方案数 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:9:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 隔板法，双指针锁定每个数之间隔板可以移动的范围，最后乘法原理 对于可移动范围，因为B是递增的，从右往左遍历 就是A B数组元素比大小，然后右边的指针贪心地选择可满足数中最右边的数，左指针贪心地选择可满足数中最左边的数 （即右指针左移过程中，碰到可满足数就停下来，左指针要一直移动直到不满足，这样得到最大的区间） 注意特判！！ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll ans = 1;\rint a[200005];\rint b[200005];\rint n,m;\rint l[200005];\rint r[200005];\rint main(){\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rfor(int i=0;i\u003cm;i++) cin\u003e\u003eb[i];\rfor(int i=0;i\u003cm;i++) l[i] = r[i] = -1;\rint ind = m-1;\rfor(int i=n-1;i\u003e=0;i--){\rwhile(ind\u003e=0 and b[ind] \u003e a[i]) ind--;\rif(ind\u003c0) {\rcout\u003c\u003c0\u003c\u003cendl;\rexit(0);\r}\rl[ind] = i;\rif(a[i] == b[ind] and r[ind]==-1){ //greedy\r r[ind] = i;\r}\r}\rif(l[0]==-1 or r[0]==-1) {\rcout\u003c\u003c0\u003c\u003cendl;\rexit(0);\r}\rfor(int i=1;i\u003cm;i++){\rif(l[i]==-1 or r[i]==-1) {\rcout\u003c\u003c0\u003c\u003cendl;\rexit(0); }\rans *= (ll) (r[i] - l[i] + 1);\rans %= mod;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F. Jog Around The Graph ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:10:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:11:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 不会 G. Construct the String ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:12:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:13:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:14:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["Python web"],"content":"Flask-RESTful简单实例","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"Python web的框架有Django Flask Tornado Flask 是一个使用 Python 编写的轻量级 Web 应用程序框架，由werkzeug服务器和jinja2模板引擎组成 RESTful是一个与资源（resource）有关的架构理念 REST全称Representational State Transfer，详细信息参考下面的资料 ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:0","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"功能说明 接下来用Flask-RESTful扩展实现一个非常简单的实例，没有用到数据库，没有用到前端页面（模板），没有表单验证，没有复杂的业务逻辑 只用字典存储数据，实现crud（后期将增加数据库） ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:1","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"实现原理 安装 pip install flask-restful Flask-RESTful最基本的套路 实例化app api 实例化解析器，将待验证的参数加进解析器中 根据路由编写对应的类，在类下面编写需要的函数 将类和对应的路由集成到api中 代码如下 from flask import Flask\rfrom flask_restful import reqparse , abort , Api , Resource\r#实例化\r app = Flask(__name__)\rapi = Api(app)\r#创造初始数据\r PERSONS = {\r'p1' : {'name' : 'qaz' , 'num' : '15'} ,\r'p2' : {'name' : 'wsx' , 'num' : '16'} ,\r'p3' : {'name' : 'edc' , 'num' : '17'} ,\r}\rdef not_exist(ps_id):\rif ps_id not in PERSONS:\rabort(404 , message = 'person {} not exist'.format(ps_id))\r#实例化解析器\r #增加验证参数\r parser = reqparse.RequestParser()\rparser.add_argument('name' , type=str , required=True , help='it is a string') #把它设为必填项\r parser.add_argument('num' , type=int , required=True , help='it is a number') #把它设为必填项\r #对单个人的操作\r class Person(Resource):\rdef get(self , ps_id):\rnot_exist(ps_id)\rreturn PERSONS[ps_id]\rdef delete(self , ps_id):\rnot_exist(ps_id)\rdel PERSONS[ps_id]\rreturn '' , 204\rdef put(self , ps_id):\rnot_exist(ps_id)\rargs = parser.parse_args() #开始数据验证\r info = {'name' : args['name'] , 'num' : args['num']}\rPERSONS[ps_id] = info #更新\r return info , 201\r#对所有人的操作\r class PersonList(Resource):\rdef get(self):\rreturn PERSONS\rdef post(self):\rglobal ps_id\rargs = parser.parse_args()\r#暴力求缺失id\r lis = []\r#求每个键，然后过滤出数字，加进列表中，遍历获得空位置\r for i in PERSONS.keys():\rtmp_filter = filter(str.isdigit , i)\rtmp_list = list(tmp_filter)\rtmp_str = ''.join(tmp_list)\rtmp_int = int(tmp_str)\rlis.append(tmp_int)\rlis.sort()\rflag = False\rfor i,j in range(len(lis)),lis:\rif i+1 != j:\rps_id = i+1\rflag = True\rbreak\rif(not flag): ps_id = len(lis) + 1\rps_id = 'p%d' % (ps_id)\rPERSONS[ps_id] = {'name':args['name'] , 'num':args['num']}\rreturn PERSONS[ps_id] , 201\r#增加对应的路由\r api.add_resource(Person , '/persons/\u003cstring:ps_id\u003e')\rapi.add_resource(PersonList , '/persons')\rif __name__ == '__main__':\rapp.run()\r ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:2","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"测试 查询所有信息 根据ps_id查询单个人的信息 根据ps_id删除某个人的信息 再查看所有人的信息 增加某个人的信息 查看所有人的信息 由于之前删除了2号，所以它占据了2号的位置 改变某个人的信息 现在p3 的name是edc num是17 改成name是uuu，num是27 查看所有人的信息以验证 ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:3","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"参考资料（部分） ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:4","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["abc"],"content":"abc169","date":"2020-06-08","objectID":"/abc169/","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"由于事情太多，拖了这么久 A - Multiplication 1 ","date":"2020-06-08","objectID":"/abc169/:0:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入两个数，求积 ","date":"2020-06-08","objectID":"/abc169/:1:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 n,m = map(int,input().split())\rprint(n*m)\r B - Multiplication 2 ","date":"2020-06-08","objectID":"/abc169/:2:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入很多大数，求积是否超过1e18 ","date":"2020-06-08","objectID":"/abc169/:3:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 用 __int128 ， 样例有个情况是前面超过1e18但后面有0 所以遍历一遍数组判断是否有0 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing INT = __int128;\rll a[100005];\rint main(){\rll n;\rcin\u003e\u003en;\rINT ans = 1;\rbool flag = true;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\rif(!a[i]) flag = false;\r}\rif(!flag) {\rcout\u003c\u003c0\u003c\u003cendl;\rexit(0);\r}\rfor(ll i=0;i\u003cn;i++){\rll x = a[i];\rans *= (INT) x;\rif(ans \u003e (INT) 1e18) {\rcout\u003c\u003c-1\u003c\u003cendl;\rexit(0);\r}\r}\rcout\u003c\u003c(ll)ans\u003c\u003cendl;\rreturn 0;\r}\r C - Multiplication 3 ","date":"2020-06-08","objectID":"/abc169/:4:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入两个数，求积 。一个数上限 1e15 ，一个数为小于10的正两位小数 ","date":"2020-06-08","objectID":"/abc169/:5:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 因为精度问题，先 *100 再 /100 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rll a,b,c;\rscanf(\"%lld %lld.%lld\",\u0026a,\u0026b,\u0026c);\rll ans = a*(b*100+c) ;\rans /= 100LL;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - Div Game ","date":"2020-06-08","objectID":"/abc169/:6:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-08","objectID":"/abc169/:7:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 根据唯一分解定理分解，得到质因子和每种质因子的个数 要求次数最多，对于每种质因子，取1次方，2次方，3次方。。。 有个WA点，当无法整除时，ans+1（本身的质数） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rmap\u003cll,ll\u003e mp;\rbool isprime(ll n){\rif(n==1) return false;\rfor(ll i=2;i*i\u003c=n;i++){\rif(n%i==0){\rreturn false;\r}\r}\rreturn true;\r}\rint main(){\rll n;\rcin\u003e\u003en;\rll nn = n;\rfor(ll i=2;i*i\u003c=nn;i++){\rwhile(n%i==0){\rn/=i;\rmp[i]++;\r}\r}\r//cout\u003c\u003cmp[2]\u003c\u003cmp[5];\r ll ans = 0;\rfor(auto i:mp){\r//cout\u003c\u003ci.first\u003c\u003c\" \"\u003c\u003ci.second\u003c\u003cendl;\r ll tmp = i.second;\rll cnt = 0;\rll ct = 1;\rwhile(cnt\u003c=tmp){\rcnt += ct++; }\rct -= 2;\rans += ct;\r}\rif(isprime(n)) ans++; //wa点 做不下去时要判断是不是质数 如果是质数那么z可以等于这个数 即答案+1 cout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - Count Median ","date":"2020-06-08","objectID":"/abc169/:8:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 给 n 个区间，可以在每个区间中选一个数，这样就有 n 个数，对这n个数求中位数，问所有方案中，中位数有几种 ","date":"2020-06-08","objectID":"/abc169/:9:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 数学题 求最小的可能中位数和最大的可能中位数，在此之间的所有数都能取到 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a[200005],b[200005];\rint main(){\rll n;\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rscanf(\"%lld%lld\",\u0026a[i],\u0026b[i]);\r}\rsort(a,a+n);\rsort(b,b+n);\rll low ,hi;\rif(n\u00261){\rlow = a[(n-1)/2];\rhi = b[(n-1)/2];\r}else{\rlow = a[(n-2)/2] + a[(n-2)/2+1] ;\rhi = b[(n-2)/2] + b[(n-2)/2+1];\r}\rcout\u003c\u003chi-low+1\u003c\u003cendl;\rreturn 0;\r}\r F - Knapsack for All Subsets ","date":"2020-06-08","objectID":"/abc169/:10:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 给一堆数，和一个数s 对于这堆数形成的集合，对于它的每个子集 如果该子集中有一个子集的数和为s，计数器加1 求计数器的值 ","date":"2020-06-08","objectID":"/abc169/:11:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 计数dp题 可以考虑其中一种方案是 i 个数加起来等于 s 那么容纳它的所有集合都满足条件 所以计数器加 i*2^(n-i) 要求一堆数中，哪些数加起来能等于s就类似于背包问题 所以考虑dp dp[i][j] 表示前 i 个数和为 j 的答案 对于当前数，可以选择，也可以不选 转移方程 dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]] 根据上面的结论加上dp表示的是答案，所以每多选一个数，就会在前一个的基础上 /2 所以真正的转移方程为 dp[i][j] = dp[i-1][j] + ( dp[i-1][j-a[i]] ) / 2 这样初始条件就是 dp[0][0] = 2^n #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll dp[3005][3005];\rll n,s;\rll a[3005];\rconst ll mod = 998244353;\rll qpow(ll a, ll b, ll m){\rif(b == 0)\rreturn 1;\relse if(b % 2 == 1)\rreturn a * qpow(a, b - 1, m) % m;\relse{\rll num = qpow(a, b/2, m) % m; return num * num % m;\r}\r}\rconst ll inv2 = (mod+1) / 2;\rint main(){\rcin\u003e\u003en;\rcin\u003e\u003es;\rfor(ll i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\rdp[0][0] = qpow(2,n,mod);\rfor(int i=1;i\u003c=n;i++){\rfor(int j=0;j\u003c=s;j++){\r(dp[i][j] += dp[i-1][j]) %= mod;\rif(j\u003e=a[i]) {\r(dp[i][j] += dp[i-1][j-a[i]] * inv2) %= mod;\r}\r}\r}\rcout\u003c\u003cdp[n][s]%mod\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-06-08","objectID":"/abc169/:12:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["problemlist"],"content":"每日一题 (X)","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"堆 贪心 题目 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rstruct p{\rll v,s;\r}ps[100005];\rbool cmp(p a,p b){return a.s\u003eb.s;}\rpriority_queue\u003cll , vector\u003cll\u003e , greater\u003cll\u003e \u003e pq;\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++) cin\u003e\u003eps[i].v\u003e\u003eps[i].s;\rsort(ps,ps+n,cmp);\rll temp=0,ans=0;\rfor(ll i=0;i\u003cn;i++){\rtemp+=ps[i].v;\rpq.push(ps[i].v);\rwhile(pq.size()\u003eps[i].s){\rtemp-=pq.top();\rpq.pop();\r}\rans=max(ans,temp);\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:1:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"区间dp 题目 不会做，看了别人的题解写的 考虑到数据大小 区间dp dp[i][j][k][l] 表示在s1中取i到j区间，在s2中取k到l区间是否能组成回文串 这样它有四种状态转移（分别考虑边界） 对于每一种状态，只要有一种满足就行，用或运算实现 注意一些边界条件，长度从0开始、特判 先枚举长度，对于每一种长度，枚举区间 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rchar s1[52];\rchar s2[52];\rint dp[52][52][52][52];\rint ans=0;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rans=0;\rmemset(dp,0,sizeof(dp)); //没有重置又WA了 scanf(\"%s\",s1+1);\rscanf(\"%s\",s2+1);\rint len1=strlen(s1+1);\rint len2=strlen(s2+1);\rfor(int i=0;i\u003c=len1;i++)\rfor(int j=0;j\u003c=len2;j++)\rfor(int l1=1,r1=i+l1-1;r1\u003c=len1 ;l1++,r1++)\rfor(int l2=1,r2=j+l2-1;r2\u003c=len2 ;l2++,r2++){\rif(i+j\u003c=1) dp[l1][r1][l2][r2]=1;\relse{\rif(s1[l1]==s1[r1] and r1\u003e0) dp[l1][r1][l2][r2] |= dp[l1+1][r1-1][l2][r2]; if(s1[l1]==s2[r2] and r2\u003e0) dp[l1][r1][l2][r2] |= dp[l1+1][r1][l2][r2-1];\rif(s2[l2]==s1[r1] and r1\u003e0) dp[l1][r1][l2][r2] |= dp[l1][r1-1][l2+1][r2];\rif(s2[l2]==s2[r2] and r2\u003e0) dp[l1][r1][l2][r2] |= dp[l1][r1][l2+1][r2-1];\r} if(dp[l1][r1][l2][r2]) ans=max(ans,r2-l2+r1-l1+2);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:2:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"前缀和 区间dp 题目 暴力时间复杂度 O(n^2) dp[i] 表示右区间的右边界为i时的最大值 maxv[i] 表示前 i+1个数区间长度为k的最大值（单区间） 那么 dp[i]=右区间的值+maxv[i] 求 maxv[i] 直接用前缀和预处理，时间复杂度 O(n) 依次遍历数组求答案 据说用st表也可以做，但我不会 思考问题的变形 一：不限制长度——在一个数列里找两个不相交区间使得他们权值和最大 二：区间数目变多——找 m个长度为 k 的不相交区间使得他们的权值和最大 (1≤n≤5000) 三：区间数目变多且不限制长度——找 m 个不相交长度不限的区间使得他们权值和最大(1≤n≤5000) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll t;\rll a[200005];\rll n,k;\rll maxv[200005];\rll sum[200005];\rll ans=0;\rll asn1=0;\rll ans2=0;\rll dp[200005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\r//reset TODO ans=-1e15; //开1e9WA了一发 无语\r cin\u003e\u003en\u003e\u003ek;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\rif(i\u003e0) sum[i]=sum[i-1]+a[i]; else sum[i]=a[i];\r}\r//preprocess\r maxv[k-1]=sum[k-1];\rfor(ll i=k;i\u003cn-k;i++){\rmaxv[i]=max(maxv[i-1],sum[i]-sum[i-k]);\r}\rll temp=0;\rfor(ll i=k;i\u003c2*k;i++) temp+=a[i];\rfor(ll i=2*k-1;i\u003cn;i++){\rdp[i]=temp+maxv[i-k];\rans=max(ans,dp[i]);\rif(i\u003cn-1){\rtemp+=a[i+1];\rtemp-=a[i+1-k];\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:3:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"位运算 题目 模拟位运算 暴力超时 可优化为 (a1+a2+a3...)*(a1+a2+a3...) a为每一位的1 这样只需要计算每一位1的数量 对于每一位，数量平方乘上二次幂系数 最后求和 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rll a[100005];\rll bin[100];\rint main(){\rcin\u003e\u003en;\rll temp;\rfor(ll i=0;i\u003cn;i++){\rll p=0;\rcin\u003e\u003etemp;\rwhile(temp!=0){\rif(temp%2==1) bin[p]++;\rp++;\rtemp/=2;\r}\r}\rll ans=0;\rfor(ll i=0;i\u003c100;i++){\rans+=(bin[i]*bin[i])*(1\u003c\u003ci);\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:4:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"双端队列 （滑动窗口求最值） 题目 经典的滑动窗口求最大最小值问题 经典的做法就是利用双端队列 可以参考此处的讲解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k;\rint num[1000005];\rdeque\u003cint\u003e dq1;\rdeque\u003cint\u003e dq2;\rvector\u003cint\u003e ans1;\rvector\u003cint\u003e ans2;\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003enum[i];\rfor(int i=0;i\u003cn;i++){\rif(!dq2.empty() and dq2.front()\u003c=i-k){\rdq2.pop_front();\r}\rwhile(!dq2.empty() and num[dq2.back()]\u003c=num[i]){\rdq2.pop_back();\r}\rdq2.push_back(i);\rif(i\u003e=k-1){\rans2.push_back(num[dq2.front()]);\r}\r//-----------------华丽的分割线--------------------------- if(!dq1.empty() and dq1.front()\u003c=i-k){\rdq1.pop_front();\r}\rwhile(!dq1.empty() and num[dq1.back()]\u003e=num[i]){\rdq1.pop_back();\r}\rdq1.push_back(i);\rif(i\u003e=k-1){\rans1.push_back(num[dq1.front()]);\r}\r}\rfor(int i:ans1) cout\u003c\u003ci\u003c\u003c\" \"; cout\u003c\u003cendl;\rfor(int i:ans2) cout\u003c\u003ci\u003c\u003c\" \"; cout\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:5:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dp 题目 dp[i] 表示以i为节点的最小费用 则 dp[i]+=min(dp[ch],w) w表示当前i与ch的费用，即不断更新成最小值然后加上去 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,m,s;\rvector\u003cpair\u003cll,ll\u003e \u003e G[100005];\rll dp[100005];\rll deg[100005];\rconst ll inf=0x3f3f3f3f3f3f;\rvoid dfs(ll s,ll p){\rfor(auto i:G[s]){\rll x=i.first;\rll y=i.second;\rif(x!=p){\rdfs(x,s); dp[s]+=min(dp[x],y);\r}\r}\r}\rint main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003es;\rwhile(m--){\rll u,v,w;\rcin\u003e\u003eu\u003e\u003ev\u003e\u003ew;\rG[u].emplace_back(v,w);\rG[v].emplace_back(u,w);\rdeg[u]++;\rdeg[v]++;\r}\rfor(ll i=1;i\u003c=n;i++)\rif(deg[i]==1 and i!=s) dp[i]=inf;\rdfs(s,-1);\rcout\u003c\u003cdp[s]\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:6:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"二分查找 题目 和abc157-E很像 用集合存26个字母对应的下标 依次查找p中字符在s中的位置 每次对集合二分查找 有一个防止集合为空的小技巧 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rchar s[1000005];\rint n;\rchar p[1000005];\rset\u003cint\u003e st[27];\rint main(){\rscanf(\"%s\",s+1);\rint len=strlen(s+1);\r//preprocess\r for(int i=0;i\u003c27;i++){ //防止为空 st[i].insert(len+1);\r}\rfor(int i=1;i\u003c=len;i++){\rst[s[i]-'a'].insert(i);\r}\rcin\u003e\u003en;\rwhile(n--){\rbool ok=true;\rscanf(\"%s\",p+1);\rint lenp = strlen(p+1);\rint foo=1;\rfor(int i=1;i\u003c=lenp;i++){\rauto ind=st[p[i]-'a'].lower_bound(foo);\rif(*ind==len+1){\rok=false;\rbreak;\r} else{\rfoo=(*ind)+1;\r}\r}\rputs(ok?\"Yes\":\"No\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:7:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dfs 题目 对于一个节点，如果以这个节点为根的树的节点（包含自己）是奇数，则这个节点必须与父节点相连，子节点内部自己配对 如果是偶数，则这个节点与子节点一起参与配对 以下代码的缺点是存储数据和求解不够高效 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll t,n;\rvector\u003cll\u003e G[10005];\rll cn[10005];\rll par[10005];\rmap\u003cll,ll\u003e W[10005];\rvoid dfs_par(ll u,ll p){\rpar[u]=p;\rfor(auto i:G[u]){\rif(i!=p){\rdfs_par(i,u);\r}\r}\r}\rvoid dfs_cn(ll u,ll p){\rfor(auto i:G[u]){\rif(i!=p){\rdfs_cn(i,u);\rcn[u]+=cn[i];\r}\r}\rcn[u]++;\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rll t1,t2,w;\rfor(ll i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2\u003e\u003ew;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\rW[t1].insert(make_pair(t2,w));\rW[t2].insert(make_pair(t1,w));\r} dfs_par(1,0);\rdfs_cn(1,0);\rll ans=0;\rfor(ll i=2;i\u003c=n;i++){\rif(cn[i]\u00261){\rans+=W[i][par[i]];\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r//reset TODO\r memset(cn,0,sizeof(cn));\rfor(ll i=0;i\u003c=n;i++){\rG[i].clear();\rW[i].clear();\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:8:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dp 贪心 dfs 题目 主要是树上dp 从子节点向根一直贪心地染色 这样就会出现一个问题，最优解需要染的顶点已经被染过了 所以要不断地更新两个值 dp[i] 现在在i，往根的方向还能染多少个 k[i] 每个点向根方向还能染多少个 那么 dp[i]=max(dp[i],dp[ch]-1) 如果最后 dp[i]==0 那么新的染色点开启 ans++ 否则处理完一个点后k要更新 k[par]=max(k[par],k[i]-1) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cint\u003e c[100005];\rint ans;\rint dp[100005];\rint k[100005];\rint n;\rvoid dfs(int u,int par){\rfor(auto i:c[u]){\rdfs(i,u);\rdp[u]=max(dp[u],dp[i]-1);\r}\rif(dp[u]==0){\r//can't reach next\r ans++;\rdp[u]=k[u];\r}\relse{\r//updata k\r k[par]=max(k[par],k[u]-1);\r}\r}\rint main(){\rcin\u003e\u003en;\rint tmp;\rfor(int i=2;i\u003c=n;i++){\rcin\u003e\u003etmp;\rc[tmp].push_back(i);\r}\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ek[i];\r}\rdfs(1,0);\rcout\u003c\u003cans\u003c\u003c\"\\n\";\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:9:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"堆 （对顶堆求实时中位数） 题目 经典的对顶堆求实时中位数问题 用两个堆存数据 大顶堆存小的一半 小顶堆存大的一半 这样中位数只在大顶堆或小顶堆的顶部 每次存数据需要将它与顶部（中间数）比较 确认放入哪一堆 每次放数后，需要平衡堆的大小，使大小相差不超过1 最后取堆大的顶部即可 plus：几个很坑的点，容易PE，要用快读才能过（还以为算法有问题。。。） #include\u003ciostream\u003e\r#include\u003cqueue\u003e\rusing namespace std;\rint p,n,m;\rint t;\rint main(){\r//ios::sync_with_stdio(0);\r cin\u003e\u003ep;\rwhile(p--){\rpriority_queue\u003cint\u003e q1; //大顶堆 priority_queue\u003cint,vector\u003cint\u003e,greater\u003cint\u003e\u003e q2; //小顶堆 scanf(\"%d%d\",\u0026n,\u0026m);\rif(n!=1) cout\u003c\u003cendl;\rcout\u003c\u003cn\u003c\u003c\" \"\u003c\u003c(m+1)/2\u003c\u003cendl;\rscanf(\"%d\",\u0026t);\rq1.push(t);\rif(m==1) cout\u003c\u003ct; else cout\u003c\u003ct\u003c\u003c\" \";\rfor(int i=2;i\u003c=m;i++){\rscanf(\"%d\",\u0026t);\rif(t\u003eq1.top()) q2.push(t); //比大顶堆大，放入小顶堆\r else q1.push(t);\rif(q1.size()\u003eq2.size()+1){ //平衡两个堆的大小\r q2.push(q1.top());\rq1.pop();\r}\rif(q2.size()\u003eq1.size()+1){\rq1.push(q2.top());\rq2.pop();\r}\rif(i\u00261){ int x;\rif(q1.size()\u003eq2.size()) x=q1.top(); //中位数在堆大的顶部\r else x=q2.top();\rif( ((i+1)/2)%10==0 and m-i\u003e1){\rcout\u003c\u003cx\u003c\u003cendl;\r}\relse if(m-i\u003e1){\rcout\u003c\u003cx\u003c\u003c\" \";\r}\relse cout\u003c\u003cx;\r}\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:10:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"在线区间预处理 前缀 题目 暴力枚举右区间的左右边界，这样时间复杂度就是 O(n^2) 前缀和预处理 对于每个右区间，O(1) 查询这个区间的异或值，然后找前面有几个区间的异或值等于这个区间 这时候只要计算以右区间左边界-1为右边界的区间中每一个的异或，然后与前面计算好的累加即可 最后直接累加到个数上 （注意区间的边界下标） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,a[1005],b[1000005]; //b要开大一点 否则数组越界\rlong long sum; //sum要用long long\rint main(){\rcin\u003e\u003en;\rint tmp;\ra[0]=0;\rfor(int i=1;i\u003c=n;i++) {\rcin\u003e\u003etmp;\ra[i]=a[i-1]^tmp;\r}\rfor(int i=0;i\u003cn;i++){\rfor(int j=i-1;j\u003e=0;j--){\rb[a[i]^a[j]]++;\r}\rfor(int j=i+1;j\u003c=n;j++){\rsum+=b[a[j]^a[i]];\r}\r}\rcout\u003c\u003csum\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:11:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"图论 dfs 题目 奇数层的点到奇数层的点就是偶数路径 偶数同理 注意同一层也可达 还有long long 的转化 还可以树形dp #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rvector\u003cint\u003e G[100005];\rint dep[100005];\rint ln[100005];\rlong long sum=0;\r//int deg[100005];\rvoid dfs(int u,int v){\rfor(auto i:G[u]){\rif(i!=v){\rdep[i]=dep[u]+1;\rdfs(i,u);\r}\r}\r}\rint main(){\rcin\u003e\u003en;\rint t1,t2;\rfor(int i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdep[1]=0;\rdfs(1,0);\rfor(int i=1;i\u003c=n;i++){\rln[dep[i]]++;\r}\rint maxd=*max_element(dep+1,dep+n+1);\rfor(int i=0;i\u003cmaxd+1;i++){\rfor(int j=i;j\u003cmaxd+1;j+=2){\rif(j==i){\rsum+=(long long)ln[i]*(ln[i]-1)/2;\r}\relse{\rsum+=(long long)ln[i]*ln[j];\r}\r}\r}\rcout\u003c\u003csum\u003c\u003cendl;\r//cout\u003c\u003cmaxd\u003c\u003cendl;\r return 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:12:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"排列组合 题目 对于一个长度为n的二进制串 随便选两个数前面放1后面放0 其他随便放 总共有 C(n,2)*2^(n-2) 种 注意对 n 取模 还有一个卡我的点是“特判”！！！ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = unsigned long long;\rll n;\rconst ll mod = 1e9+7;\rll qpow(ll x,ll t){\rll res=1;\rwhile(t\u003e0){\rif(t\u00261) res=res*x%mod;\rx=x*x%mod;\rt\u003e\u003e=1;\r}\rreturn res;\r}\rint main(){\rcin\u003e\u003en;\rif(n==1) cout\u003c\u003c0\u003c\u003cendl;\relse if(n==2) cout\u003c\u003c1\u003c\u003cendl;\relse{\rcout\u003c\u003cqpow(2,n-3)%mod*(n%mod)%mod*((n-1)%mod)%mod\u003c\u003cendl; //记得给n取模\r }\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:13:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"二分法 尺取 题目 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll t;\rll n,a[100005];\rll m,k;\rll k_th(ll x){\rll num=0;\rll sum=0;\rll l=0,r=0;\rif(a[0]\u003ex) num++;\rwhile(r\u003cn and l\u003cn){\rif(num\u003ck){\rr++;\rif( r\u003cn and a[r]\u003ex) num++;\r}\relse{\rsum += n-r; //不小心+1 就错了\r l++;\rif(l\u003cn and a[l-1]\u003ex ) num--; }\r}\rreturn sum;\r}\rbool check(ll x){\rreturn k_th(x) \u003e m-1 ? true : false;\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek\u003e\u003em;\rfor(ll i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rll l = 1,r=1e10,mid;\rwhile(l\u003cr){\rmid = (l+r)\u003e\u003e1;\rif(check(mid)) l = mid+1;\relse r=mid;\r}\rcout\u003c\u003cl\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:14:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"计数dp 题目 不会做，参考了别人的代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll a[100005];\rll dp[100005][12];\rll ls[100005];\rll n,m,k;\rint main(){\rwhile(cin\u003e\u003en\u003e\u003em\u003e\u003ek){ //TODO reset\r memset(dp,0,sizeof(dp));\rmemset(ls,-1,sizeof(ls));\rfor(ll i=1;i\u003c=n;i++){\rcin\u003e\u003ea[i];\r}\r// TODO init 极端情况\r for(ll i=0;i\u003c=n;i++) dp[i][0] = 1;\rfor(ll i=0;i\u003c=11;i++) dp[i][i] = 1;\rfor(ll i=1;i\u003c=n;i++){\rfor(ll j=1;j\u003c=min(i-1 , m);j++){\rdp[i][j] = (dp[i-1][j] + dp[i-1][j-1])%mod;\rll rm = ls[a[i]] - i +j;\rll part = dp[ls[a[i]] - 1][rm];\rif(ls[a[i]]!=-1 and rm\u003e=0) dp[i][j] = (dp[i][j] - part + mod)%mod; //这里也要模\r }\r//update ls[a[i]] = i;\r}\rcout\u003c\u003cdp[n][m]%mod\u003c\u003cendl;\r} return 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:15:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"贪心 堆 题目 贪心 按截至时间从小到大排序 如果按这个顺序选择，则有可能因为当前建筑耗费的时间比别的长，而错过最优解（即选择耗费时间短的，即使它的截至时间更久） 所以我们可以选择耗费时间更短的（相当于有一次反悔的机会），这样ans都加1，但是有更多的选择空间 用一个大顶堆维护当前选中的建筑的耗费时间 遍历所有建筑，如果能在截至时间内完成，就入堆 否则与堆顶比较（耗费时间最长的） 如果堆顶大，则用当前建筑替换堆顶的建筑，使耗费时间尽可能小 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cpair\u003cint,int\u003e\u003e vt;\rint main(){\rint n;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\rvt.emplace_back(x,y);\r}\rsort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return pii1.second\u003cpii2.second;});\rpriority_queue\u003cint\u003e pq;\rint sum = 0;\rfor(auto i:vt){\rif(sum+i.first\u003c=i.second){\rsum+=i.first;\rpq.push(i.first);\r}else if(pq.top()\u003ei.first){\rsum-=pq.top();\rpq.pop();\rsum+=i.first;\rpq.push(i.first);\r}\r}\rcout\u003c\u003cpq.size()\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:16:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"完全背包问题 题目 目标货币系统是子集，所以对于当前数，判断前面的数能否组合到这个数 这就变成完全背包问题，a[i] 表示体积，背包的最大体积是25000，价值就是是否可达到 (dp[i]=0 or 1) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint a[25005];\rint dp[25005];\rint ans;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rmemset(dp,0,sizeof(dp));\rans=0;\rint n;\rcin\u003e\u003en;\rdp[0]=1;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ea[i];\r}\rsort(a+1,a+1+n);\rfor(int i=1;i\u003c=n;i++){ if(!dp[a[i]]) ans++;\rfor(int j=a[i];j\u003c=25000;j++){\rdp[j] = dp[j] |= dp[j-a[i]];\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:17:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"贪心 题目 贪心，只要定排序规则就行 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cpair\u003cint,int\u003e\u003e vt;\rint main(){\rint n;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\rvt.emplace_back(x,y);\r}\rsort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return pii1.first*pii2.second \u003c pii1.second*pii2.first;});\rlong long ans = 0;\rlong long tm = 0;\rfor(auto i:vt){\rans += i.second*tm;\rtm += 2LL*i.first;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:18:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"dp 思维 题目 dp 第一次做真的很难想到 首先题目这么设计肯定是要把式子转换成物理意义 那就是“有两个装置，同时取到相同的排列的方案数，再求和” 设 dp[k][i][j] 表示两个装置都取出k个，第一个装置的上管道取出i个，第二个装置的上管道取出j个 那么第一个装置的下管道取出k-i个，第二个装置的下管道取出 k-j 个 dp 表示进行到此时的 ans 所以 dp 在传导的过程中用 += 最后的结果就是 dp[n+m][n][n] dp 的初始条件是 dp[0][0][0] = 1 dp 的转移方程考虑四种情况 (a[i]==a[j]) dp[k][i][j] += dp[k-1][i-1][j-1] 即两个装置的上管道 各加一个球结果相同 (a[i]==b[k-j]) dp[k][i][j] += dp[k-1][i-1][j] 即第一个装置的上下两个管道各加一个球结果相同 (b[k-i]==a[j]) dp[k][i][j] += dp[k-1][i][j-1] 同上 (b[k-i]==b[k-j]) dp[k][i][j] += dp[k-1][i][j] 同上 由于数据规模，需要用01滚动数组 注意 assert 注意continue 否则超时 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst int mod = 1024523;\rint n,m;\rint dp[2][505][505];\rchar u[505];\rchar d[505];\rint main(){\rcin\u003e\u003en\u003e\u003em;\rcin\u003e\u003e(u+1)\u003e\u003e(d+1);\rdp[0][0][0] = 1;\rfor(int k=1;k\u003c=n+m;k++){\rmemset(dp[k\u00261],0,sizeof(dp[k\u00261]));\rfor(int i=0;i\u003c=n;i++){\rif(k-i\u003c0 or k-i\u003em) continue; //不加这个超时 for(int j=0;j\u003c=n;j++){\rif(k-j\u003c0 or k-j\u003em) continue; //不加这个超时 if(u[i]==u[j] and i and j) {\rdp[k\u00261][i][j] += dp[(k-1)\u00261][i-1][j-1];\rdp[k\u00261][i][j] %= mod;\r}\rif(u[i]==d[k-j] and i and k-j and k-j\u003c=m){\rdp[k\u00261][i][j] += dp[(k-1)\u00261][i-1][j];\rdp[k\u00261][i][j] %= mod;\r}\rif(u[j]==d[k-i] and j and k-i and k-i\u003c=m){\rdp[k\u00261][i][j] += dp[(k-1)\u00261][i][j-1];\rdp[k\u00261][i][j] %= mod;\r}\rif(d[k-i]==d[k-j] and k-i and k-j and k-i\u003c=m and k-j\u003c=m){\rdp[k\u00261][i][j] += dp[(k-1)\u00261][i][j];\rdp[k\u00261][i][j] %= mod;\r}\r}\r}\r}\rcout\u003c\u003cdp[(n+m)\u00261][n][n]%mod\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:19:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"差分 规律 题目 暴力差分 最重要的是所有的点在 log(n) 时间内都会变成 n 此时停机就不会超时 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k;\rint dat[200005];\rint dif[200005];\rbool check(){\rfor(int i=1;i\u003c=n;i++){\rif(dat[i]\u003cn){\rreturn false;\r}\r}\rreturn true;\r}\rvoid did(int x){\rint L = max(1,x-dat[x]);\rint R = min(n , x+dat[x]);\rdif[L]++;\rdif[R+1]--;\r}\rvoid update(){\rfor(int i=1;i\u003c=n;i++){\rdat[i] = dat[i-1] + dif[i];\r}\r}\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003edat[i];\rwhile(1 and k\u003e0){\rfor(int i=1;i\u003c=n;i++) did(i);\rk--;\rif(check()) break;\rupdate();\rmemset(dif,0,sizeof(dif));\r}\rif(k\u003e0) {\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cn\u003c\u003c\" \";\r}\relse for(int i=1;i\u003c=n;i++) cout\u003c\u003cdat[i]\u003c\u003c\" \";\rcout\u003c\u003c'\\n';\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:20:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"分治（01背包问题 + 枚举） 题目 第一次做分治，太妙了 暴力超时 如果在树上用dp预处理，内存超限 解决方法就是分治 完全二叉树有18层，前9层dp预处理所有的点 后9层枚举，然后将两个结果相加。这样将时间复杂度也分开了 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cint\u003e vt;\rint n,q;\rvector\u003cpair\u003cint,int\u003e\u003e info((1\u003c\u003c18) + 3);\rvector\u003cpair\u003cint,int\u003e\u003e res;\r#define fi first\r#define se second\rconst int MAX = 100001;\rint dp[515][MAX];\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rint v,w;\rcin\u003e\u003ev\u003e\u003ew;\rinfo[i] = make_pair(v,w);\r}\r//preprocess\r const int MAX = 100001;\rint lim = min(512,n);\rfor(int j=0;j\u003cMAX;j++){\rdp[0][j] = (j\u003e=info[0].se ? info[0].fi : 0);\r}\rfor(int i=1;i\u003clim;i++){\rint p = (i-1)/2;\rfor(int j=0;j\u003cMAX;j++){\rif(j\u003cinfo[i].se){\rdp[i][j] = dp[p][j];\r}else{\rdp[i][j] = max(dp[p][j] , dp[p][j - info[i].se] + info[i].fi);\r}\r}\r}\rcin\u003e\u003eq;\rwhile(q--){\rint V,L;\rcin\u003e\u003eV\u003e\u003eL;\rV--;\rvector\u003cint\u003e rem;\rwhile(V\u003e=lim){\rrem.push_back(V);\rV = (V-1)/2;\r}\rint ans = 0;\rint sz = rem.size();\rfor(int i=0;i\u003c(1\u003c\u003csz);i++){\rint sv = 0;\rint sw = 0;\rfor(int j=0;j\u003csz;j++){\rif(i\u003e\u003ej\u00261){\rsv += info[rem[j]].fi;\rsw += info[rem[j]].se;\r}\r}\rif(sw \u003c= L){\rans = max(ans , dp[V][L-sw] + sv);\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:21:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"博弈 题目 如果只有一个串，1的个数是奇数，alice必赢 所以只要有1个串1的个数是奇数，alice就对此操作，占据先机 接下来bob怎么操作，alice只要跟着操作就行 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n;\rcin\u003e\u003en;\rbool ok=false;\rfor(int i=0;i\u003cn;i++){\rstring s;\rcin\u003e\u003es;\rbitset\u003c1005\u003e bs(s);\rif(bs.count()\u00261) ok=true;\r}\rif(ok) puts(\"sdzNB\");else puts(\"kgNB\");\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:22:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"递推 构造 题目 第一个数有两种情况0,1，根据第二例的信息不断往后递推，中途判断格子是否是0或1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rint a[10005];\rint b[10005];\rint sol(int x){\rmemset(b,0,sizeof(b));\rb[0] = 0;\rb[1] = x;\rfor(int i=2;i\u003c=n;i++){\rint tmp = a[i-1] - (b[i-1] + b[i-2]);\rif(tmp == 0 or tmp==1) {\rb[i] = tmp;\r}\relse{\rreturn 0;\r}\rif(i==n){\rif(a[n] == b[n-1] + b[n]){\rreturn 1;\r}\relse{\rreturn 0;\r}\r}\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\rint ans = sol(0) + sol(1);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:23:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"筛法 题目 筛法，注意从 i * i 开始，否则会超时 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 30000005;\rll a[maxn];\rll b[maxn];\rint main(){\rll n;\rcin\u003e\u003en;\r// b[1] = 0;\r// for(ll i = 2; i \u003c maxn;i++){\r// if(a[i] == 0){ // ll q = i;\r// while(q \u003c maxn){\r// if(a[q] == 0){\r// a[q] = i;\r// }q += i;\r// }\r// }\r// b[i] = a[i] + b[i-1]; // }\r ll ans = 0;\rfor(ll i = 2;i \u003c n+1;i++){\rif(a[i] == 0){\rans += i;\rll q = i * i; //从i*i开始，否则会超时 while(q \u003c n+1){\rif(a[q] == 0){\ra[q] = 1;\rans += i;\r}q += i;\r}\r}\r} cout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:24:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"背包问题 dp 题目 由于N=30所以求出所有的方案 类似于完全背包问题 dp[i][k] 表示选 i 个，价值达到 k 的方案数 dp[i][k] = sum(dp[i-1][k-j]) 其中j是每张彩票的面值 最后求 k在 3n 到 4n 之间的方案数 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll dp[35][150];\rint main(){\rint n;\rcin\u003e\u003en;\rdp[0][0] = 1;\rfor(int i=1;i\u003c=n;i++){\rfor(int j=1;j\u003c=4;j++){\rfor(int k=j;k\u003c=4*n;k++){\rdp[i][k] += dp[i-1][k-j];\r}\r}\r}\rll ans = 0;\rfor(int i=3*n;i\u003c=4*n;i++){\rans += dp[n][i];\r}\r//cout\u003c\u003cans\u003c\u003cendl;\r ll tol = pow(4,n);\rll x = __gcd(tol, ans);\rans /= x;\rtol /= x;\rcout\u003c\u003cans\u003c\u003c\"/\"\u003c\u003ctol\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:25:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["codeforces"],"content":"Codeforces Round #644 (Div. 3)","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"可能是最简单的div3（不考dp dfs？） A. Minimal Square ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:0:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给俩相同的长方形，求面积最小的正方形使得容纳两个长方形，且长方形之间不重合 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:1:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 两倍宽或两倍长 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rif(a\u003eb) swap(a,b);\rif(2*a\u003c=b) cout\u003c\u003cb*b\u003c\u003cendl;\relse cout\u003c\u003c4*a*a\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Honest Coach ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:2:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 把一堆数分成两堆，求第一堆最大值和第二堆最小值的差的最小值 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:3:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 排序，求相邻两数差的最小值，以此为分界 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n;\rcin\u003e\u003en;\rint a[55];\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rsort(a,a+n);\rint ans = 1000000000;\rfor(int i=0;i\u003cn-1;i++){\rans = min(ans,a[i+1]-a[i]);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Similar Pairs ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:4:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 定义好数对 (a,b) a,b具有相同的奇偶性或者a,b差为1 给一堆数（偶数个），问是否能被划分成若干个好数对 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:5:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 如果奇数的个数有偶数个就一定可以 否则检测是否有差为1的数对 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n;\rcin\u003e\u003en;\rvector\u003cint\u003e vt1;\rvector\u003cint\u003e vt2;\rfor(int i=0;i\u003cn;i++){\rint x;\rcin\u003e\u003ex;\rif(x\u00261) vt1.push_back(x);else vt2.push_back(x);\r}\rif(vt1.size()%2==0) puts(\"yes\");\relse{\rbool flag=false;\rfor(int i:vt1){\rif(find(vt2.begin(),vt2.end(),i+1)!=vt2.end() || find(vt2.begin(),vt2.end(),i-1)!=vt2.end()){\rflag=true;\rbreak;\r}\r}\rif(flag) puts(\"yes\");\relse puts(\"no\");\r}\r}\rreturn 0;\r}\r D. Buying Shovels ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:6:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 第i种包里有i个铁铲，总共有k种，只能选择一种包，可以买无数个，求最小需要买几包才能获得恰好n个铁铲 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:7:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 k\u003e=n时特判 其他只要遍历到开方，一一检测是否能被整除，不断min #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rll t;\rcin\u003e\u003et;\rwhile(t--){\rll n,k;\rcin\u003e\u003en\u003e\u003ek;\rif(n\u003c=k) cout\u003c\u003c1\u003c\u003cendl;\relse{\rbool flag = false;\rll ans = 1e10;\rfor(ll i=2;i\u003c=(ll)(sqrt(n));i++){\rif(n%i==0 and i\u003c=k){\rans = min(ans , n/i);\rif(n/i\u003c=k) ans = min(ans , i);\rflag=true;\r//break;\r }\r}\rif(!flag) cout\u003c\u003cn\u003c\u003cendl; else cout\u003c\u003cans\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r E. Polygon ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:8:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 判断一个矩阵是否是polygon游戏的产物 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:9:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 对于每一个元素，如果是1就判断右边和下面是否有1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n;\rcin\u003e\u003en;\rchar mat[55][55];\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003emat[i];\r}\rbool ok = true;\rfor(int i=0;i\u003cn;i++)for(int j=0;j\u003cn;j++){\rif(mat[i][j]=='1'){\rif(i==n-1 or j==n-1) continue;\relse{\rif(mat[i+1][j]=='1' or mat[i][j+1]=='1') continue;\relse {\rok = false;\rbreak;\r}\r}\r}\r}\rif(ok) puts(\"yes\");\relse puts(\"no\");\r}\rreturn 0;\r}\r F. Spy-string ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:10:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给一堆长度都是m的字符串，问是否存在一个长度也为m的字符串使得它对每个字符串都有“相同或不同的个数为1” ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:11:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 数据小，暴力枚举 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rvector\u003cstring\u003e vt;\rint n,m;\rbool ck(string q1,string q2){\rint dif = 0;\rfor(int i=0;i\u003cm;i++){\rif(q1[i]!=q2[i]) dif++;\r}\rreturn dif\u003c=1 ? true : false;\r}\rbool check(string ss){\rbool ok = true;\rfor(auto i : vt){\rif(!ck(ss,i)){\rok = false;\rbreak;\r}\r}\rreturn ok;\r}\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em;\rstring s;\rcin\u003e\u003es;\rvt.clear();\rfor(int i=0;i\u003cn-1;i++) {\rstring s1;\rcin\u003e\u003es1;\rvt.push_back(s1);\r}\rbool ok = false;\rstring s3;\rfor(int i=0;i\u003cm;i++){\rfor(int j=0;j\u003c26;j++){\rstring s2 = s;\rs2[i] = 'a' + j;\rif(check(s2)){\rok = true;\rs3 = s2;\rbreak;\r}\r}\r}\rif(ok) cout\u003c\u003cs3\u003c\u003cendl;\relse{\rcout\u003c\u003c-1\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r G. A/B Matrix ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:12:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 是否存在一个n*m的矩阵使得每一行有a个1，每一列有b个1，其他都是0 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:13:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 第一行开头先填a个1，第二行在这个之后填1，然后回到第一个，直到填满a个 第三行以此类推 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n,m,a,b;\rcin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb;\rif(n*a!=m*b) puts(\"no\");\relse{\rint mat[55][55] = {0};\rint one = 0;\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003ca;j++){\rmat[i][one] = 1;\rone++;\rone%=m;\r}\r}\rputs(\"yes\");\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003cm;j++){\rcout\u003c\u003cmat[i][j];\r}puts(\"\");\r}\r}\r}\rreturn 0;\r}\r H. Binary Median ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:14:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给几个长度为m的01串，求对于所有长度为m的01串形成的集合的补集中的中位数（字典序） ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:15:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 将01串转成十进制，最后再转回来 由于数据规模是 2^60 所以不能枚举 以每个给定的数为节点，求补集内比它小的数有几个 求中位数是补集内的第几个 假设是第 i 个，求 i 落在以节点划分的哪个区间内 （几个WA点 要用1LL iota和strtol函数做进制转化时精度太低，是int ） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u003cint,int\u003e;\rusing pll = pair\u003cll,ll\u003e;\rll tot;\rll ans;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rll n,m;\rcin\u003e\u003en\u003e\u003em;\rtot = (1LL\u003c\u003cm); // use 1LL ll rem = tot - n;\rrem--;\rll ind = rem / 2;\rvector\u003cpll\u003e vt;\rvector\u003cstring\u003e vts;\rfor(ll i=0;i\u003cn;i++) {\rstring s;\rcin\u003e\u003es;\rvts.push_back(s);\r}\rsort(vts.begin(),vts.end()); //sort first for(ll i = 0;i\u003cvts.size();i++){\rstring st = vts[i];\rll res=0;\rfor(ll j=0;j\u003cm;j++){\rres+=(st[j]=='1' ? (1LL\u003c\u003c(m-j-1)) : 0);\r}\rvt.emplace_back(res,res-i-1LL);\r}\r//sort(vt.begin(),vt.end());\r vt.emplace_back((1LL\u003c\u003cm),(1LL\u003c\u003cm) - n-1LL);\rfor(ll i=0;i\u003cvt.size();i++){\rif(vt[i].second==ind){\rans = vt[i].first - 1;break;\r}else if(vt[i].second\u003eind){\rif(vt.size()==1 or i==0){\rans = ind;break;\r}else{\rans = vt[i-1].first + (ind - vt[i-1].second);break;\r}\r}\r}\rfor(ll i=m-1;i\u003e=0;i--){\rcout\u003c\u003c(ans\u003e\u003ei\u00261);\r}puts(\"\");\r}\rreturn 0;\r}\r ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:16:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["abc"],"content":"abc168","date":"2020-05-19","objectID":"/abc168/","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"A - ∴ (Therefore) ","date":"2020-05-19","objectID":"/abc168/:0:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-19","objectID":"/abc168/:1:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rstring s;\rcin\u003e\u003es;\rchar c=s[s.length()-1];\rswitch(c){\rcase '2' :case '4': case '5': case '7': case '9': cout\u003c\u003c\"hon\\n\";\rbreak;\rcase '3':\rcout\u003c\u003c\"bon\\n\";\rbreak;\rdefault :cout\u003c\u003c\"pon\\n\"; }\rreturn 0;\r}\r B - … (Triple Dots) ","date":"2020-05-19","objectID":"/abc168/:2:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-19","objectID":"/abc168/:3:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint k;\rcin\u003e\u003ek;\rstring s;\rcin\u003e\u003es;\rif(s.length()\u003c=k)cout\u003c\u003cs\u003c\u003cendl;\relse{\rfor(int i=0;i\u003ck;i++){\rcout\u003c\u003cs[i];\r}cout\u003c\u003c\"...\"\u003c\u003cendl;\r}\rreturn 0;\r}\r C - : (Colon) ","date":"2020-05-19","objectID":"/abc168/:4:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 给定时针和分针的长度，起始为12点，问经过h小时m分钟后，时针和分针不连接的端点的距离 ","date":"2020-05-19","objectID":"/abc168/:5:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 用比例求夹角，然后余弦定理 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst double pi = acos(-1);\rusing db = double;\rdouble toRad(double x){\rreturn x/180*pi;\r}\rdb COS(db x,db y,db d){\rreturn sqrt(x*x+y*y-2*x*y*cos(d));\r}\rdb a,b,m,h;\rint main(){\rcin\u003e\u003ea\u003e\u003eb\u003e\u003eh\u003e\u003em;\rdb ma = ((int)(h*60+m)%60)*(db)6;\rdb ha = ((int)(h*60+m)%720)/(db)2;\rdb delta = fabs(ma-ha);\rdb Rdel = toRad(delta);\rdb ans = COS(a,b,Rdel);\rprintf(\"%.10lf\\n\",ans);\rreturn 0;\r}\r D - .. (Double Dots) ","date":"2020-05-19","objectID":"/abc168/:6:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 由n个点组成的边权为1的双向图，每个点一个标志，从这个点开始沿着标志所指向的点（要有边连接）一直走，就可以到达1号点，且是最短路。问对于所有的点是否都存在这样的标志，存在则输出每个标志。 ","date":"2020-05-19","objectID":"/abc168/:7:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 bfs 求前趋 最无脑的做法应该是单源最短路求前趋 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rconst double pi = acos(-1);\rusing db = double;\rconst int max_v = 200005;\rint n,m;\rint prevv[max_v]; struct edge\r{\rint to,cost;\redge(int to,int cost){\rthis-\u003eto = to;\rthis-\u003ecost = cost;\r}\r};\rtypedef pair\u003cint,int\u003e pii; int V;\rvector\u003cedge\u003e G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V,inf);\rfill(prevv,prevv+V,-1); d[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(int i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rprevv[e.to]=v; q.push(pii(d[e.to],e.to));\r}\r}\r} }\rint main(){\rcin\u003e\u003en\u003e\u003em;\rV=n+1;\rfor(int i=0;i\u003cm;i++){\rint t1,t2;\rcin\u003e\u003et1\u003e\u003et2;\rG[t1].push_back(edge(t2,1));\rG[t2].push_back(edge(t1,1));\r}\rdijkstra(1);\rbool ok=true;\rfor(int i=2;i\u003c=n;i++){\rif(prevv[i]==-1) {\rok=false;break;\r}\r}\rif(ok){\rputs(\"Yes\");\rfor(int i=2;i\u003c=n;i++){\rcout\u003c\u003cprevv[i]\u003c\u003cendl;\r}\r}else{\rputs(\"No\");\r}\r//cout\u003c\u003cd[1]\u003c\u003c\" \"\u003c\u003cd[2]\u003c\u003c\" \"\u003c\u003cd[3]\u003c\u003cd[4];\r return 0;\r}\r E - ∙ (Bullet) ","date":"2020-05-19","objectID":"/abc168/:8:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 给n个数对 (ai,bi) 求满足下列条件的集合个数 集合由数对组成，集合中任意两个数对满足 ai*aj + bi*bj != 0 ","date":"2020-05-19","objectID":"/abc168/:9:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 以上的公式是内积形式，把问题转化成给n个向量，找满足任意两个向量不垂直的集合数 由于零向量和任意向量垂直，所以它只能单独在一个集合内 遍历数对，记录每个斜率（用map存出现的次数） 斜率为0和斜率不存在可以特殊处理 遍历每个斜率（出现次数为num），如果没有和它垂直的（找是否有 -1/k） 那么这个斜率的全集就是num个相同的数 子集有 2^num 个 如果有和它垂直的（个数分别为num1,num2），这两种斜率就不能放在一个集合 内，所以要把它们看成一个整体 从两个集合分开选子集，再合并，总的子集个数为 2^num1 -1+ 2^num2 -1 + 1 减去各自的空集加上总体的空集 然后把每个子集数乘起来（乘法原理）（包括斜率为0和不存在） 最后再加上零向量的个数，减去1（除去空集） 照这个方法做是错的 debug半天一直错6个点，看了下数据，都是大数，看了下程序，觉得自己逻辑一点也没有漏洞，模数也没有溢出 直到看到这句话 1E18 long double 精度不够！！所以只能存原始的数对 (ai,bi) 用gcd处理倍数关系 由于 (-a,b) 和 (a,-b) 是一致的，所以让第一个数始终大于0 想想 long double 确实精度不够，但那时真的没想到 发现一个提供atcoder测试数据的网站 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long ;\rll n,x,y;\rusing ld = long double;\rmap\u003cpair\u003cll,ll\u003e,ll\u003e mp;\rconst ll mod = 1000000007;\rll zero;\rll h;\rll v;\rll ans = 1;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ex\u003e\u003ey;\rif(x==0 and y==0) zero++;\relse if(x==0) v++;\relse if(y==0) h++;\relse {\rll g = __gcd(x,y);\rx/=g;\ry/=g;\rif(x\u003c0) x=-x,y=-y;\rmp[{x,y}]++; } }\rfor(auto i:mp){\rll a = i.first.first;\rll b = i.first.second;\rll c = i.second;\rif(c==0) continue;\rll cnt;\rif(-b\u003c0) b=-b,a=-a;\rpair\u003cll,ll\u003e pll = {-b,a};\rif(!mp.count(pll)){\rcnt = qpow(2,c); ans=(ans*cnt)%mod;\r}else{\rcnt = qpow(2,c)-1LL+qpow(2,mp[pll]);\rcnt %= mod;\rans=(ans*cnt)%mod;\rmp[pll]=0;\r}\r}\rif(h!=0 and v!=0){\rll foo = qpow(2,h)-1LL+qpow(2,v);\rfoo %= mod;\rans = (ans*foo)%mod;\r}else if(h==0 and v!=0){\rll foo = qpow(2,v);\rans = (ans*foo)%mod;\r}else if(h!=0 and v==0){\rll foo = qpow(2,h);\rans = (ans*foo)%mod;\r}\rans = (ans+zero)%mod;\rans-=1LL;\rans+=mod;\rans%=mod;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F - . (Single Dot) ","date":"2020-05-19","objectID":"/abc168/:10:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 待补 好像是细节很多的离散化bfs ","date":"2020-05-19","objectID":"/abc168/:11:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["codeforces"],"content":"Codeforces Round #643 (Div. 2) A~D","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Sequence with Digits ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:0:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 看题目 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:1:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 模拟，minDigit(x) 等于0 时打断 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rll t;\rll a,k;\rll maxD(ll n)\r{\rll res=n%10;\rwhile(n)\r{\rres=max(res,n%10);\rn/=10;\r}\rreturn res;\r}\rll minD(ll n)\r{\rll res=n%10;\rwhile(n)\r{\rres=min(res,n%10);\rn/=10;\r}\rreturn res;\r}\rll cal(ll n)\r{\rreturn n+maxD(n)*minD(n);\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ea\u003e\u003ek;\rfor(ll i=1;i\u003ck;i++)\r{\r//cout\u003c\u003ca\u003c\u003c\" \"\u003c\u003ci\u003c\u003c\" \"\u003c\u003cmaxD(a)\u003c\u003c\" \"\u003c\u003cminD(a)\u003c\u003c\" \"\u003c\u003cendl;\r a=cal(a);\rif(minD(a)==0) break;\r}\rcout\u003c\u003ca\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Young Explorers ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:2:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 有一个数组，将它们划分成n组（不用每一个数字都被划分），保证每一组的每个数字都\u003c=这组数字的个数，求最多划分成几组 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:3:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 贪心 方法有很多，其中之一是 排序，对当前数字x，从它开始选x个，如果有不满足的就继续选，直到满足条件 最后一个区间如果不能满足条件则并到前一个区间内 （之前一直以为只要从头到尾或从尾到头贪心地选择数字对应的区间即可） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rint t;\rint n;\rint a[200005];\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\rsort(a,a+n);\rint ans=0;\rfor(int i=0;i\u003cn;){\rint t=a[i];\rint x=i+t-1;\rwhile(t\u003ca[x] and t\u003c=n and x\u003c=n){\rt++;\rx++;\r}\rif(x\u003cn) ans++;\ri+=t;\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Count Triangles ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:4:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给四个数 abcd （从小到大），划分成三个区间，分别从三个区间中选三个数组成三条边，求组成三角形的个数 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:5:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 由于顺序的特殊性，只要检查前两个区间选出来的数之和有没有大于第三个区间选出来的数 对于前两个区间选出来的数之和落在 [a+b , b+c] 然后再判断第三个区间有几个数满足条件 记录一下每个数出现的次数（找规律） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll a,b,c,d;\rll ran[1000005];\rint main(){\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed;\rll low=a+b;\rll hi=b+c;\rll num=min(b-a,c-b);\rnum++;\rfor(ll i=1;i\u003c=num;i++){\rran[low]=i;\rlow++;\r}\rfor(ll i=a+b+num;i\u003c=hi-num;i++){\rran[i] = num;\r}\rfor(ll i=hi-num+1;i\u003c=hi;i++){\rran[i] = num;\rnum--;\r}\r//for(ll i=3;i\u003c=5;i++) cout\u003c\u003cran[i]\u003c\u003c\" \";\r ll ans=0;\rfor(ll i=a+b;i\u003c=b+c;i++){\rll mul = ran[i];\rif(i-c-1\u003e=0) {\rif(i-1\u003ed){\rans+=(d-c+1)*mul;\r}else{\rans+=mul*(i-c);\r}\r}\r//cout\u003c\u003cans\u003c\u003cendl;\r }\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D. Game With Array ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:6:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给俩数 n s (n\u003c=s) 问是否存在满足下列条件的数组 数组的长度为 n 元素和为 s 存在k使得任何一个子数组的和都不等于 k或s-k ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:7:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 构造 由于 k 或 s-k 所以当 s/2\u003cn 时不存在 由于数的奇偶性，可以构造全是偶数的数组(2) 这样随便选一个奇数就满足条件 但对于s是奇数时，最后一个元素是奇数，如果把前面全部构造成2，且s/2\u003cn 这样最后一个一定\u003e=3 所以k选择1 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n,s;\rcin\u003e\u003en\u003e\u003es;\rif(s/2\u003cn){\rputs(\"no\");\r}\relse{\rputs(\"yes\");\rfor(int i=0;i\u003cn-1;i++){\rcout\u003c\u003c2\u003c\u003c\" \";\r}\rcout\u003c\u003cs-2*n+2\u003c\u003cendl;\rcout\u003c\u003c1\u003c\u003cendl;\r}\rreturn 0;\r}\r ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:8:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"Codeforces Round #641 (Div. 2) A~D","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Orac and Factors ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:0:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数，每一次操作加上他的最小因子（除1外） 问k次操作后，这个数是多少 ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:1:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 奇数找最小因子加一下就变成偶数，偶数最小因子是2 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k,t;\rint ans;\rint f(int x){\rfor(int i=2;i*i\u003c=x;i++){\rif(x%i==0){\rreturn i;\r}\r}\rreturn x;\r}\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek;\rif(n\u00261){\rn+=f(n);\rans = n+(k-1)*2;\r}\relse{\rans = n+k*2; }\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Orac and Models ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:2:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数组，从中选几个数出来，满足严格递增，且对任意相邻下标a,b满足a|b，输出最长子序列的个数 ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:3:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 对于每个数都可以选择x2 x3 x4 x5… 所以对于每个数依次判断x2 x3 x4 x5…是否满足严格递增，由于越大的数越稀疏，所以不会超时 即 if( a[j] \u003e a[i] ) dp[j] = max(dp[j] , dp[i] + 1) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n;\rint dat[100005];\rint dp[100005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003edat[i],dp[i]=1;\rfor(int i=1;i\u003c=n;i++)for(int j=i+i;j\u003c=n;j+=i){\rif(dat[j]\u003edat[i]) dp[j]=max(dp[j],dp[i]+1);\r}\rint ans=-1;\rfor(int i=1;i\u003c=n;i++){\rans=max(ans,dp[i]);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Orac and LCM ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:4:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数组，每两个元素求lcm，把结果放到multi_set中，对multiset求gcd ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:5:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 从a[1]开始依次对后面的数求lcm，然后对结果求gcd gcd(lcm(a1,a2) , lcm(a1,a3) , ... , lcm(a1,an)) = lcm(a1 , gcd(a2,a3, ... , an) 这样就可以利用后缀 最后对所有lcm求gcd #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rll dat[100005];\rvector\u003cll\u003e vt;\rll suf[100005];\rll lcm(ll a,ll b){\rreturn a*b/__gcd(a,b);\r}\rint main(){\rcin\u003e\u003en;\rfor(ll i=1;i\u003c=n;i++) cin\u003e\u003edat[i];\rsuf[n]=dat[n];\rfor(ll i=n-1;i\u003e=2;i--){\rsuf[i]=__gcd(dat[i],suf[i+1]);\r}\rfor(ll i=1;i\u003c=n-2;i++){\rvt.push_back(lcm(dat[i],suf[i+1]));\r}\rvt.push_back(lcm(dat[n-1],dat[n]));\rll gcd=vt[0];\rfor(ll i=1;i\u003cvt.size();i++){\rgcd=__gcd(gcd,vt[i]);\r}\rcout\u003c\u003cgcd\u003c\u003cendl;\rreturn 0;\r}\r D. Orac and Medians ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:6:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数组，可以选择一个区间，将区间内的数变成这个区间的中位数，如果有两个，则选较小，问是否能在若干次操作后把所有数字变成k ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:7:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 特判数组是否有k 对于有k的情况 如果数组中\u003e=k 的个数大于 \u003ck的个数，就可以通过不断选2个数，其中一个是K 同化另一个数，达到同化所有 其他情况如果存在相邻的三个数，满足2个数\u003e=k 就可以实现同化并不断同化 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n,k;\rint dat[100005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rbool ok=false;\rint low=0,hi=0;\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003edat[i];\rif(dat[i]==k) ok=true;\rif(dat[i]\u003ck) low++;\relse hi++;\r}\rif(!ok){\rputs(\"no\");\r}\relse if(hi\u003elow) puts(\"yes\");\relse{\rbool okk = false;\rfor(int i=0;i\u003cn-2;i++){\rint l=0,h=0;\rif(dat[i]\u003ck) l++;else h++;\rif(dat[i+1]\u003ck) l++;else h++;\rif(dat[i+2]\u003ck) l++;else h++;\rif(h\u003el) okk=true;\r}\rif(okk) puts(\"yes\"); else puts(\"no\");\r}\r}\rreturn 0;\r}\r ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:8:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["abc"],"content":"abc167","date":"2020-05-11","objectID":"/abc167/","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"这个比赛尽犯些sb错🙃，先是把 j 写成 i ，然后把2E5写成1E5 A - Registration ","date":"2020-05-11","objectID":"/abc167/:0:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 判断字符串T是不是S后加一个字符 ","date":"2020-05-11","objectID":"/abc167/:1:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rstring s1,s2;\rcin\u003e\u003es1\u003e\u003es2;\rif(s2.substr(0,s2.length()-1)==s1) puts(\"Yes\");\relse puts(\"No\");\rreturn 0;\r}\r 不知道strstr为啥就不行 B - Easy Linear Programming ","date":"2020-05-11","objectID":"/abc167/:2:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 有三种卡片，分别写上数字1，0，-1，选择k张，让数字和最大 ","date":"2020-05-11","objectID":"/abc167/:3:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 贪心 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rint a,b,c,k;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ek;\rint ans=0;\rif(a\u003c=k){\rans+=a;\rk-=a;\rif(b\u003c=k){\rk-=b;\rif(c\u003c=k){\rans-=c;\r}else ans-=k;\r}\relse{\rans+=k;\r}\r}\relse{\rans+=k;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - Skill Up ","date":"2020-05-11","objectID":"/abc167/:4:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 高桥想学m个算法，有n本书，每本书有价格，和对每个算法的提升程度 问高桥想要每个算法都达到X，最少需要花多少钱 ","date":"2020-05-11","objectID":"/abc167/:5:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 数据不是很大，可以暴力模拟，数据大，可以考虑dp #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst long long inf = 0x3f3f3f3f;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r int n,m,x;\rcin\u003e\u003en\u003e\u003em\u003e\u003ex;\rint ans=inf;\rint dat[n+1][m+1+1];\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003edat[i][0];\rfor(int j=1;j\u003c=m;j++) cin\u003e\u003edat[i][j];\r}\rfor(int i=0;i\u003c=(1\u003c\u003cn)-1;i++){\rint e[m+1+1]={0};\rint foo=0;\rfor(int j=0;j\u003cn;j++){\rif(i\u003e\u003ej\u00261){\rfor(int k=1;k\u003c=m;k++){\re[k]+=dat[j][k];\r}\rfoo+=dat[j][0];\r}\r}\rbool ok=true;\rfor(int i=1;i\u003c=m;i++) if(e[i]\u003cx) ok=false;\rif(ok) ans=min(ans,foo);\r//for(int i=1;i\u003c=m;i++) cout\u003c\u003ce[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\r }\rcout\u003c\u003c(ans==inf?-1:ans)\u003c\u003cendl;\rreturn 0;\r}\r D - Teleporter ","date":"2020-05-11","objectID":"/abc167/:6:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 有一个数组（长度最大为2E5），当你在下标为 i 时，可以tp到下标为 a[i] 问 N(N\u003c=1E18) 次tp后在哪里 ","date":"2020-05-11","objectID":"/abc167/:7:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 由于数据很大不能直接算 考虑到数组最大为2E5，所以有最大为2E5的循环节 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rbool vis[200005];\rll tim[200005];\rll ind[2000005];\rll loop=0;\rll a[200005];\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r ll n,k;\rcin\u003e\u003en\u003e\u003ek;\rfor(ll i=1;i\u003c=n;i++){\rcin\u003e\u003ea[i];\r}\rll ans=1;\rvis[1]=true;\rtim[1] = 1;\rind[1] = 1;\rfor(int i=2;i\u003c=k;i++){\rans = a[ans];\rif(vis[ans]){\rloop=i-tim[ans];break;\r}else{\rvis[ans]=true;\rtim[ans]=i;\rind[i]=ans;\r}\r}\rif(loop==0){\rcout\u003c\u003ca[ans]\u003c\u003cendl;\r} else{\rk-=tim[ans];\rk%=loop;\rcout\u003c\u003ca[ind[k+tim[ans]]]\u003c\u003cendl;\r}\r//cout\u003c\u003cloop\u003c\u003cendl;\r return 0;\r}\r E - Colorful Blocks ","date":"2020-05-11","objectID":"/abc167/:8:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 给一排方块涂色，方块有n个，至多m种颜色，要求至多有k对相邻的块涂相同的颜色 求方案数 ","date":"2020-05-11","objectID":"/abc167/:9:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 高中排列组合 $$ ans = \\sum\\limits_{i=0} ^ {k} {m * C_{n-1}^{i} * (m-1)^{n-1-i}} $$ #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll n,m,k;\rll fac[200005];\rll ans = 0;\rll qpow(ll x,ll n){\rll res = 1;\rwhile(n\u003e0){\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rll C(int n,int m){\rreturn fac[n]%mod*qpow(fac[m],mod-2)%mod*qpow(fac[n-m],mod-2)%mod;\r}\rint main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003ek;\rfor(ll i=0;i\u003cn+2;i++) fac[i] = 1;\rfor(ll i=1;i\u003cn+2;i++) fac[i] = i*fac[i-1]%mod;\rfor(ll i=0;i\u003c=k;i++){\rans = ans + m*C(n-1,i)%mod*qpow(m-1,n-1-i)%mod;\r}\rcout\u003c\u003c(ans+mod)%mod\u003c\u003cendl;\rreturn 0;\r}\r F - Bracket Sequencing ","date":"2020-05-11","objectID":"/abc167/:10:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 给n个由 ‘(’ 和 ‘)’ 组成的字符串，将n个字符串连接，问是否存在一种方案使得连接后的字符串是合法括号序列 ","date":"2020-05-11","objectID":"/abc167/:11:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 很好玩的一道题 一开始想用栈，太麻烦 用计数器，每读入一个open +1 否则 -1 ，这样就得到每个字符串的计数 把计数大的放前面，并且检查计数和是否为0 这样做是错的，样例2不给过 那就对连接后的备选字符串遍历，重新计数，查看中途不能有负数且最后为0 但这样也是错的，因为有可能正确的答案不是按从大到小的顺序排的 这种错误是因为（对于每个字符串）前面有几个close，后面一堆open导致计数变大，但其实是不合法的，因为前面几个close没得匹配 所以应该记录由close影响的“计数的最小值” 合理的排序应该是 对于两个字符串a,b 考虑两种情况 a+b b+a 对于每种连接考虑两种情况 遍历到a时，a的计数最小值 遍历到a+b时，a+b的计数最小值 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rstring s;\rvector\u003cpair\u003cint,int\u003e\u003e vt;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en;\rint sum=0;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003es;\rint cnt=0;int low=0; //int cnt,low=0 WA T_T\r for(char c:s){\rif(c=='('){\rcnt++;\r}else cnt--;\rlow=min(low,cnt);\r}\rvt.emplace_back(cnt,low);\rsum+=cnt;\r}\rif(sum!=0) {\rputs(\"No\");return 0;\r}\rsort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return min(pii1.second,pii1.first+pii2.second) \u003e min(pii2.second,pii2.first+pii1.second);});\rint foo=0;\rfor(pair\u003cint,int\u003e pii:vt){\rif(foo\u003c-pii.second){\rputs(\"No\");\rreturn 0;\r}foo+=pii.first;\r}\rputs(\"Yes\");\rreturn 0;\r}\r ","date":"2020-05-11","objectID":"/abc167/:12:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["nowcoder"],"content":"牛客算法周周练5(部分)","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"C - 序列最小化 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:0:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 贪心，每次选择的长度为k的区间首尾重叠 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing Int = long long;\rint main(){\rInt n,k;\rcin\u003e\u003en\u003e\u003ek; n-=k;\rInt ans = ceil((double)n/(k-1));\rcout\u003c\u003cans+1\u003c\u003cendl;\rreturn 0;\r}\r E - 简单瞎搞题 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:1:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 位dp，dp[i] 表示前i个数能达到的数字集合 加上第 i 个区间的数，遍历一遍这个区间对于其中一个数 j 集合的结果变成 dp[i-1]\u003c\u003c(j*j) 所以 dp[i] |= dp[i-1] \u003c\u003c (j*j) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rbitset\u003c1000005\u003e dp[105];\rint n;\rint l[105];\rint r[105];\rint main(){\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++) dp[i].reset();\r//init\r dp[0][0]=1;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003el[i]\u003e\u003er[i];\r}\rfor(int i=1;i\u003c=n;i++){\rfor(int j=l[i];j\u003c=r[i];j++){\rdp[i] |= (dp[i-1]\u003c\u003c(j*j));\r}\r}\rcout\u003c\u003cdp[n].count();\rreturn 0;\r}\r D - 小雨坐地铁 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:2:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 经典图论题 丁老师说过如果由直线构成的图中，转弯需要花费时间，则可以构造虚点 对于本身耗费的金钱a，可以构造虚点，对应于每个点，从实点到虚点有权为0的边，从虚点到实点有权为a的边 把每条地铁线的点独立，这样就有(m+1)*n个点 对于每条地铁线上的点，在对应的图层上连线，而图层之间由虚点连接 最后跑一遍最短路 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,m,s,t;\rint a,b,c;\rint t1,t2;\rconst int inf = 0x3f3f3f3f;\rconst int max_v = 501505;\rstruct edge\r{\rint to,cost;\redge(int to,int cost){\rthis-\u003ecost = cost;\rthis-\u003eto = to;\r}\r};\rtypedef pair\u003cint,int\u003e pii; int V;\rvector\u003cedge\u003e G[max_v];\rint d[max_v];\rinline void add_edge(int a,int b,int c){\rG[a].push_back(edge(b,c));\r}\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(int i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} } int main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003es\u003e\u003et;\rV=(m+1)*n+1;\rs=n*m+s;\rt=n*m+t;\rfor(int i=0;i\u003cm;i++){\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec;\rfor(int j=0;j\u003cc;j++){\rcin\u003e\u003et1;\rif(j\u003e0){\radd_edge(i*n+t2,i*n+t1,b);\radd_edge(i*n+t1,i*n+t2,b);\r}\radd_edge(i*n+t1,m*n+t1,0);\radd_edge(m*n+t1,i*n+t1,a);\rt2=t1;\r}\r}\rdijkstra(s);\rcout\u003c\u003c(d[t]==inf ? -1 : d[t])\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:3:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["note"],"content":"git","date":"2020-05-05","objectID":"/git/","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"git安装 ","date":"2020-05-05","objectID":"/git/:0:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"用户名和邮箱 初始化或切换用户名和邮箱 git config --global user.name \"XXX\" git config --global user.email \"XXX\" 查看当前用户名和邮箱 git config --global user.name git config --global user.email 查看用户名和邮箱列表 git config --list 删除用户名和邮箱 git config --global --unset user.name \"XXX\" git config --global --unset user.email \"XXX\" ","date":"2020-05-05","objectID":"/git/:1:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"git工作原理 ","date":"2020-05-05","objectID":"/git/:2:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"三种状态 modified staged committed ","date":"2020-05-05","objectID":"/git/:3:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"本地操作 ","date":"2020-05-05","objectID":"/git/:4:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"基本操作 从工作目录移动到暂存区 git add XXX 全部移动 git add . 从暂存区移动到本地仓库 git commit -m \"XXX\" 修改提交信息 git commit --amend 打开vim编辑器 只读状态下的保存退出 [esc] :wq! vim使用 查看状态 git status 查看日志 git log 查看更完全的日志并压缩排版 git reflog --oneline ","date":"2020-05-05","objectID":"/git/:4:1","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"版本回退 从暂存区回退到工作目录 git reset XXX 从本地仓库回退到暂存区(后面带数字可以选择回退几个版本) git reset --soft HEAD~ 从本地仓库回退到工作目录 git reset HEAD~ 从本地仓库回退到工作目录，并撤销在工作目录的操作（可能导致删除文件） git reset --hard HEAD~ 对因回退删除掉的文件还原 git reset --hard \u003cfilename\u003e (这时候已经commit) ","date":"2020-05-05","objectID":"/git/:4:2","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"恢复文件 在工作目录中删除，要恢复(把暂存区的恢复过来) git checkout XXX ","date":"2020-05-05","objectID":"/git/:4:3","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"删除文件 删除工作目录和暂存区的文件，取消跟踪，不纳入版本管理（两个区文件要相同） git rm XXX 此时本地仓库还有该文件 通过回退实现彻底删除 git reset --soft HEAD~ 如果两个区文件不同 全都删除 git rm -f XXX 只删除暂存区 git rm --cached XXX ","date":"2020-05-05","objectID":"/git/:4:4","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"重命名 git mv \u003cbefore\u003e \u003cafter\u003e 然后再添加，提交 ","date":"2020-05-05","objectID":"/git/:4:5","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"文件比较 比较两个历史快照 git diff XXX XXX 比较工作目录和暂存区 git diff XXX 比较工作目录和仓库 git diff XXX 比较暂存区和仓库 git diff --cached XXX ","date":"2020-05-05","objectID":"/git/:4:6","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"分支 创建分支 git branch XXX 进入分支 git checkout XXX 创建并进入分支 git checkout -b XXX 列出所有分支 git branch -a 查看当前分支 git branch 图化所有分支 git log --decorate --oneline --graph --all 与当前分支合并 git merge XXX 合并冲突 打开文件，修改文件，重新添加提交 删除分支 git branch -d XXX 分支名删除，文件仍然存在 ","date":"2020-05-05","objectID":"/git/:4:7","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"远程操作 远程项目拷贝到本地 git clone XXX ","date":"2020-05-05","objectID":"/git/:5:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"push/pull 推到远程分支上 git push 需要输入github账号密码 把远程分支更新的内容拉到本地 git pull 连续两次 git push 内容不一样产生冲突 git pull 文件会自动更新，改文件内容，重新添加提交 ","date":"2020-05-05","objectID":"/git/:5:1","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"其他 git push \u003c远程主机名\u003e \u003c远程分支名\u003e git pull \u003c远程主机名\u003e \u003c远程分支名\u003e e.g git push origin master git pull origin master push需要创建upstream连接本地分支和远程分支 git branch --set-upstreamXXX 更常用的是(建立upstream并push)(本地与远程同名) git push -u origin XXX ","date":"2020-05-05","objectID":"/git/:5:2","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"fetch git pull 类似于 git fetch + git merge 和commitId的改动有关 git fetch 更安全 具体参考 这篇文章 ","date":"2020-05-05","objectID":"/git/:5:3","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"remote 远程添加仓库 git remote add \u003cname\u003e \u003curl\u003e 远程删除仓库 git remote remove XXX 查看远程仓库 git remote 查看有关联的远程仓库 git remote -v ","date":"2020-05-05","objectID":"/git/:5:4","tags":["git"],"title":"git","uri":"/git/"},{"categories":["abc"],"content":"abc166","date":"2020-05-04","objectID":"/abc166/","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"A - A?C ","date":"2020-05-04","objectID":"/abc166/:0:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 abc输出arc反之亦然 ","date":"2020-05-04","objectID":"/abc166/:1:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rstring s;\rcin\u003e\u003es;\rs[1]=s[1]=='B'? 'R': 'B';\rcout\u003c\u003cs\u003c\u003cendl;\rreturn 0; }\r B - Trick or Treat ","date":"2020-05-04","objectID":"/abc166/:2:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 snack_i被snuke_1,snuke_2..拥有 问有多少个snuke没有snack ","date":"2020-05-04","objectID":"/abc166/:3:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rset\u003cint\u003e st;\rint main(){\rint n,k;\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=1;i\u003c=k;i++){\rint x;\rcin\u003e\u003ex;\rwhile(x--){\rint y;\rcin\u003e\u003ey;\rst.insert(y);\r}\r}\rcout\u003c\u003cn-st.size()\u003c\u003cendl;\rreturn 0;\r}\r C - Peaks ","date":"2020-05-04","objectID":"/abc166/:4:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 山上有n个观景台，有一些路连接两个观景台，一个观景台是好的当且仅当从它出发走一条路能到达的观景台海拔都比它低，没有路也算 问有多少个好观景台 ","date":"2020-05-04","objectID":"/abc166/:5:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 用二叉树排序 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rpriority_queue\u003cint\u003e p[100005];\rint a[100005];\rint main(){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rfor(int i=1;i\u003c=n;i++) p[i].push(0);\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\rwhile(m--){\rint t1,t2;\rcin\u003e\u003et1\u003e\u003et2;\rp[t1].push(a[t2]);\rp[t2].push(a[t1]);\r}\rint ans=0;\rfor(int i=1;i\u003c=n;i++){\rif(p[i].top()\u003ca[i]) ans++;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - I hate Factorization ","date":"2020-05-04","objectID":"/abc166/:6:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 给定一个数X，求A，B使得A^5 - B^5 = X,A，B是整数 ","date":"2020-05-04","objectID":"/abc166/:7:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 bf #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll x,a,b;\rbool check(ll a,ll b){\rif(a*a*a*a*a - b*b*b*b*b == x) return true;\rreturn false;\r}\rint main(){\rcin\u003e\u003ex;\rfor(ll i = -500;i\u003c=500;i++) for(ll j=-500;j\u003c=500;j++){\rif(check(i,j)){\ra = i,b = j;\rbreak;\r}\r}\rcout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003cendl;\rreturn 0;\r}\r E - This Message Will Self-Destruct in 5s ","date":"2020-05-04","objectID":"/abc166/:8:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 有一个数列，一对数字是好数对，当且仅当下标差等于数值和，求好数对个数 ","date":"2020-05-04","objectID":"/abc166/:9:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 等式移项 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n;\rmap\u003cll,ll\u003e mp;\rll ans;\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++){\rll x;\rcin\u003e\u003ex;\rans+=mp[i-x];\rmp[i+x]++;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F - Three Variables Game ","date":"2020-05-04","objectID":"/abc166/:10:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 有三个数a,b,c，有n轮抉择，每一轮抉择会给出一个字符串\"ab” “bc” ,“ac” 选择其中一个数加，另一个数减，问是否存在一种方案使得所有数最后都不是负数 ","date":"2020-05-04","objectID":"/abc166/:11:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 这题做错了，因为思维局限在dfs找两个数字相同情况下该选哪个，然后不是WA就是TLE，理论上可以，没写好 其实可以全搜索，然后找到一组解就exit(0) 一定要退出，不能返回，因为真的搜索完全就超时 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,a,b,c;\rstring s[100005];\rchar ans[100005];\rbool ok;\rvoid dfs(int ind,int a,int b,int c){\rif(a\u003c0 || b\u003c0 || c\u003c0) return;\rif(ind==n){\rputs(\"Yes\");\rfor(int i = 0;i \u003c n;i++){\rcout\u003c\u003cans[i]\u003c\u003cendl;\r}\rexit(0);\r}\relse{\rif(s[ind]==\"AB\"){\rans[ind]='A';\rdfs(ind+1,a+1,b-1,c);\rans[ind]='B';\rdfs(ind+1,a-1,b+1,c);\r}\relse if(s[ind]==\"AC\"){\rans[ind]='A';\rdfs(ind+1,a+1,b,c-1);\rans[ind]='C';\rdfs(ind+1,a-1,b,c+1);\r}\relse{\rans[ind]='B';\rdfs(ind+1,a,b+1,c-1);\rans[ind]='C';\rdfs(ind+1,a,b-1,c+1);\r}\r}\r}\rint main(){\rcin\u003e\u003en\u003e\u003ea\u003e\u003eb\u003e\u003ec;\rfor(int i = 0;i\u003cn;i++) cin\u003e\u003es[i];\rdfs(0,a,b,c);\rputs(\"No\");\rreturn 0;\r}\r ","date":"2020-05-04","objectID":"/abc166/:12:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"abc165","date":"2020-05-03","objectID":"/abc165/","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"A - We Love Golf ","date":"2020-05-03","objectID":"/abc165/:0:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 询问在A到B之间是否有C的倍数 ","date":"2020-05-03","objectID":"/abc165/:1:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 特判边界是否满足条件，否则判断左右边界除以C的值是否大于等于1 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rint a,b,c;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec;\rif(b/(double)a == b/a) puts(\"OK\");\relse if(c/(double)a == c/a) puts(\"OK\");\relse if(c/a \u003e b/a){\rputs(\"OK\");\r}\relse puts(\"NG\");\rreturn 0;\r}\r B - 1% ","date":"2020-05-03","objectID":"/abc165/:2:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 初始有100円，每年利息1%，每年结算时将小数部分抛弃，问多久能达到A円 ","date":"2020-05-03","objectID":"/abc165/:3:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 计数器模拟 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rll a;\rcin\u003e\u003ea;\rll dy = 0;\rdouble bs = 100;\rwhile(bs\u003ca){\rbs*=1.01;\rbs = floor(bs);\rdy++; }\rcout\u003c\u003cdy\u003c\u003cendl;\rreturn 0;\r}\r C - Many Requirements ","date":"2020-05-03","objectID":"/abc165/:4:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 构造一个数列A每个数不大于10，数列长度不大于M，且递增 有q个四元组 a b c d 如果Ab - Aa == c，则v+=d 求v的最大值 ","date":"2020-05-03","objectID":"/abc165/:5:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 最开始有两种思路，暴力构造（超时），对q个四元组贪心（会错过最优解） 所以dfs，dfs到最后一个数时求v并更新v 传入下标作为参数，不需要回溯 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint a[55],b[55],c[55],d[55];\rint n,m,q;\rint ans;\rint dat[12];\rvoid dfs(int ind , int pre){\rif(ind == n){\rint cnt = 0;\rfor(int i=0;i\u003cq;i++){\rif(dat[b[i] - 1] - dat[a[i] - 1] == c[i]) cnt+=d[i];\r}\rans = max(ans , cnt);\r}\relse{\rfor(int i = pre;i\u003c=m;i++){\rdat[ind] = i;\rdfs(ind + 1 , i);\r}\r}\r}\rint main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003eq;\rfor(int i=0;i\u003cq;i++) cin\u003e\u003ea[i]\u003e\u003eb[i]\u003e\u003ec[i]\u003e\u003ed[i];\rdfs(0,1);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D - Floor Function ","date":"2020-05-03","objectID":"/abc165/:6:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-03","objectID":"/abc165/:7:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 问题转化成在0~N中找一个数x，使得x/B的小数部分最接近0.99999 x = B-1 如果N不允许，找最大N ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rint main(){\rdouble a,b,n;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003en;\rdouble x;\rif(n\u003e=b-1) x =b-1;\relse x=n;\rcout\u003c\u003cfloor(a*x/b) - a*floor(x/b)\u003c\u003cendl;\rreturn 0;\r}\r E - Rotation Matching ","date":"2020-05-03","objectID":"/abc165/:8:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 有N个玩家，M个竞技场（M*2+1\u003c=N） 每个玩家都有一个数字 每个竞技场安排两个数字，不能重复 共有N轮决斗 对于每一轮，每个竞技场中数字对应的两个玩家进行battle 每一轮决斗后，所有玩家的数字都+1 求安排方案使得所有的人都不会和同一个人battle两次 ","date":"2020-05-03","objectID":"/abc165/:9:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 应该是本次比赛最难的题 由于M*2+1\u003c=N 所以合理安排，在进行N轮之后，一定会刚好满足条件 其实就是号码的两两配对 在纸上列出所有的情况，一直尝试、排除 最后会发现，前半段要隔一个对称配对，后半段直接对称配对，这样就能完美错开 ac代码 #include\u003cbits/stdc++.h\u003e\r int dat1[100005],dat2[100005];\rusing namespace std;\rint main(){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rif(!(n\u00261)) n--;\rint mm = (n-1)/2;\rif(mm\u00261){\rfor(int i=1;i\u003c=mm/2;i++){\rdat1[i] = i;\rdat2[i] = (n+1)/2 - i;\r}\rfor(int j=(n+1)/2,i = mm/2+1,k=0;i\u003c=mm;i++,j++,k++){\rdat1[i] = j;\rdat2[i] = n - k;\r}\r}\relse{\rfor(int i=1;i\u003c=mm/2;i++){\rdat1[i] = i;\rdat2[i] = (n+3)/2 - i;\r}\rfor(int i=(n+3)/2,j=n,k=mm/2+1;k\u003c=mm;i++,j--,k++){\rdat1[k] = i;\rdat2[k] = j;\r}\r}\r//for(int i=1;i\u003c=6;i++) cout\u003c\u003cdat1[i]\u003c\u003c\" \"\u003c\u003cdat2[i]\u003c\u003cendl;\r for(int i=1;i\u003c=m;i++) cout\u003c\u003cdat1[i]\u003c\u003c\" \"\u003c\u003cdat2[i]\u003c\u003cendl;\rreturn 0;\r}\r F - LIS on Tree ","date":"2020-05-03","objectID":"/abc165/:10:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 给一棵树，每个点有一个数字属性，求1到X的最短路径中，按1到X的顺序排列数字属性得到的序列中的最长上升子序列（LIS） 对所有的X ","date":"2020-05-03","objectID":"/abc165/:11:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 dfs + lis 注意回溯 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint dp[200005];\rvector\u003cint\u003e G[200005];\rint n;\rint a[200005];\rint ans[200005];\rconst int inf = 0x3f3f3f3f;\rvoid dfs(int u,int p){\rint ind = (int)(lower_bound(dp,dp+n,a[u]) - dp);\rint cnt = dp[ind];\rdp[ind] = a[u];\rans[u] = (int)(lower_bound(dp,dp+n,inf) - dp);\rfor(int i:G[u]){\rif(i!=p){\rdfs(i,u);\r}\r}\r//undo\r dp[ind] = cnt;\r}\rint main(){\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\rfor(int i=0;i\u003cn-1;i++){\rint t1,t2;\rcin\u003e\u003et1\u003e\u003et2;\rt1--,t2--;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rfill(dp,dp+n+2,inf);\rdfs(0,-1);\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cans[i]\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-05-03","objectID":"/abc165/:12:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"abc164","date":"2020-05-02","objectID":"/abc164/","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"A - Sheep and Wolves ","date":"2020-05-02","objectID":"/abc164/:0:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 判断两个数的大小 ","date":"2020-05-02","objectID":"/abc164/:1:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 ac代码 n,m = map(int,input().split())\rif n\u003em:\rprint('safe')\relse :\rprint('unsafe')\r B - Battle ","date":"2020-05-02","objectID":"/abc164/:2:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给定两个人的生命值和攻击力，两个人回合制battle，谁的生命值先小于等于0 ","date":"2020-05-02","objectID":"/abc164/:3:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 模拟 ac代码 a,b,c,d = map(int,input().split())\rwhile a\u003e0 and c\u003e0:\rc=c-b\rif c\u003c=0:\rbreak\ra=a-d\rif a\u003c=0:\rbreak\rif a\u003c=0:\rprint('No')\relse:\rprint('Yes')\r C - gacha ","date":"2020-05-02","objectID":"/abc164/:4:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给一堆字符串，求有多少种 ","date":"2020-05-02","objectID":"/abc164/:5:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n;\rset\u003cstring\u003e st;\rcin\u003e\u003en;\rstring s;\rwhile(n--){\rcin\u003e\u003es;\rst.insert(s);\r}\rcout\u003c\u003cst.size()\u003c\u003cendl;\rreturn 0;\r}\r D - Multiple of 2019 ","date":"2020-05-02","objectID":"/abc164/:6:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给一数字串，求多少个连续子串组成的数字是2019的倍数 ","date":"2020-05-02","objectID":"/abc164/:7:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 后缀，和abc158E几乎一致 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rstring s;\rint a[2020]={0};\rcin\u003e\u003es;\rint ans = 0;\rint t = 1;\rint cnt = 0;\ra[0]++;\rfor(int i=s.length()-1;~i;i--){\rcnt = (cnt+t*(s[i]-'0'))%2019;\rans+=(a[cnt]++);\rt=(t*10)%2019;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r E - Two Currencies ","date":"2020-05-02","objectID":"/abc164/:8:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 有n个城市，m条路（无向），每条路有两个属性（通过这条路要花费的时间和金 钱），每个城市有两个属性（可以花费时间购买金钱），给初始的金钱数量，求 从1城市到每个城市花费的最少时间 ","date":"2020-05-02","objectID":"/abc164/:9:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 dijkstra算法的变形 把时间当做最短路 当金钱超过最大值时，就不需要考虑是否在每个城市购买金钱 套一个dijkstra算法板子，加上对每个城市是否购买金币的判断 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rusing tp = tuple\u003cll,ll,ll\u003e;\rll n,m,s;\rll a,b; ll c[55],d[55]; //存获得的银币和消耗的时间 ll dp[55][2505]; //到达i时还有j银币的最小时间 vector\u003ctp\u003e G[55]; //目标点 a b tp info; //时间 目标点 当前的钱 const ll inf = 0x3f3f3f3f3f3f3f3f;\rint main(){\rcin\u003e\u003en\u003e\u003em\u003e\u003es;\rs = min(s,2504LL);\rfor(ll i=0;i\u003cm;i++){\rll ta,tb,tc,td;\rcin\u003e\u003eta\u003e\u003etb\u003e\u003etc\u003e\u003etd;\rG[ta].push_back(tp(tb,tc,td));\rG[tb].push_back(tp(ta,tc,td)); }\rfor(ll i=1;i\u003c=n;i++){\rll tc,td;\rcin\u003e\u003etc\u003e\u003etd;\rc[i] = tc;\rd[i] = td;\r}\rfill(dp[0] , dp[0] + 54*2504 , inf);\rdp[1][s] = 0;\rpriority_queue\u003ctp,vector\u003ctp\u003e,greater\u003ctp\u003e\u003e pq;\rpq.push(tp(0,1,s));\rwhile(!pq.empty()){\rinfo = pq.top();\rpq.pop();\rll t = get\u003c0\u003e(info) , u = get\u003c1\u003e(info) , w = get\u003c2\u003e(info);\rif(dp[u][w] \u003e t) continue;\rfor(auto i:G[u]){\rll v = get\u003c0\u003e(i) , aa = get\u003c1\u003e(i) , bb = get\u003c2\u003e(i);\rif(w\u003e=aa and dp[v][w-aa] \u003e t + bb){\rdp[v][w-aa] = t + bb;\rpq.push(tp(t+bb , v , w-aa));\r}\r}\rif(dp[u][min(w + c[u] , 2504LL)] \u003e t + d[u]){\rdp[u][min(w + c[u] , 2504LL)] = t + d[u];\rpq.push(tp(t + d[u] , u , min(w + c[u] , 2504LL)));\r}\r} for(ll i=2;i\u003c=n;i++){\rll ans = inf;\rfor(ll j=0;j\u003c2504;j++){\rans = min(ans , dp[i][j]);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r F - I hate Matrix Construction 似乎是位运算的构造。。。🤔 ","date":"2020-05-02","objectID":"/abc164/:10:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["nowcoder"],"content":"NC17134","date":"2020-05-02","objectID":"/nc17134/","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"Symmetric Matrix ","date":"2020-05-02","objectID":"/nc17134/:0:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"题目描述 Count the number of n x n matrices A satisfying the following condition modulo m. Ai, j ∈ {0, 1, 2} for all 1 ≤ i, j ≤ n. Ai, j = Aj, i for all 1 ≤ i, j ≤ n. Ai, 1 + Ai, 2 + … + Ai, n = 2 for all 1 ≤ i ≤ n. A1, 1 = A2, 2 = … = An, n = 0. ","date":"2020-05-02","objectID":"/nc17134/:1:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"输入描述 The input consists of several test cases and is terminated by end-of-file. Each test case contains two integers n and m. ","date":"2020-05-02","objectID":"/nc17134/:2:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"输出描述 For each test case, print an integer which denotes the result. ","date":"2020-05-02","objectID":"/nc17134/:3:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"样例输入 3 1000000000 100000 1000000000 ","date":"2020-05-02","objectID":"/nc17134/:4:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"样例输出 1 507109376 ","date":"2020-05-02","objectID":"/nc17134/:5:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"限制 1 ≤ n ≤ 105 1 ≤ m ≤ 109 The sum of n does not exceed 107. ","date":"2020-05-02","objectID":"/nc17134/:6:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"题解 挺好一道题目 这个题分三个步骤 1.根据题意转化成图的邻接矩阵 2.使用dp，找dp递推式 3.化简递推式 1.把题目转化成求n个点的无向图个数满足，没有自环，如果组成圈则边权为1 如果是两个点相连则权值为2（参考下面的图片） 2.f[n] 表示 n 个点时的方案数 那么第 n 个点依赖于前 n-1 个点 考虑两种情况 ① 将 n-1 个点中的一个点拉出来与第 n 个点组成边权为2的点对，对于每一种方 案都有 n-1 个点可选，剩下的 n-2 个点方案数为 f[n-2] 所以 f[n] += (n-1)*f[n-2] ② 把第 n 个点与前 n-1 个点组成圈 考虑选 k 个点出来，那么就有 $$ C_{n-1}^{k} $$ 种选法 对于选出来的 k 个点全排列，有 $$ A_{k}^{k} $$ 种，剩下的情况有 f[n-1-k] 种 由于圈的首位相连，所以 /2 那么所有的方案是 $$ \\frac{1}{2} \\sum\\limits_{k=2} ^ {n-1} {C_{n-1}^{k}A_{k}^{k}f[n-1-k]} $$ 这样并不会重复，因为每次参与形成圈的点数是不同的，这一定互异 3.化简 最终式 f[n] = (n-1) * (f[n-1] + f[n-2]) - 1/2 * (n-1) * (n-2) * f[n-3] ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll ans[100005];\rint main(){\rll n,m;\rans[0] = 1;\rans[1] = 0;\rans[2] = 1;\rans[3] = 1;\rwhile(cin\u003e\u003en\u003e\u003em){\rfor(ll i=4;i\u003c=n;i++){\rans[i] = 0;\r}\rfor(ll i = 4;i\u003c=n;i++){\rans[i] += ((i-1)*((ans[i-1]+ans[i-2])%m)%m);\rans[i] -= (((i-1)*(i-2)/2%m)*ans[i-3])%m;\rans[i] += m;\rans[i] %= m;\r}\rcout\u003c\u003cans[n]%m\u003c\u003cendl;\r}\rreturn 0;\r}\r ","date":"2020-05-02","objectID":"/nc17134/:7:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["codeforces"],"content":"Codeforces Round #636 (Div. 3) A~E","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"A. Candies ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:0:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一个数n，找一个数x，满足 x+2x+4x+8x+… = n ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:1:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 等比数列求和，变成2^m 然后枚举，看哪个能整除 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rlong long n,t;\rint main(){\rcin\u003e\u003et;\rlong long a[32];\rfor(long long i=1;i\u003c=30;i++){\ra[i] = (1\u003c\u003ci) - 1;\r}\rwhile(t--){\rcin\u003e\u003en;\rfor(long long i=2;i\u003c=30;i++){\rif((double)n/a[i] == n/a[i]){\rcout\u003c\u003cn/a[i]\u003c\u003cendl;\rbreak;\r}\r}\r}\rreturn 0;\r}\r B. Balanced Array ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:2:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一数n，问是否可以构造一个数列 数列的个数是偶数 前半部分都是偶数，后半部分都是奇数 前半部分的和等于后半部分 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:3:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 按照样例那样有规律地构造 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,t;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rif((n/2) \u0026 1) puts(\"NO\");\relse {\rputs(\"YES\");\rfor(int i=1;i\u003c=n/2;i++){\rcout\u003c\u003ci*2\u003c\u003c\" \"; }\rfor(int i=1;i\u003c=n/4;i++){\rcout\u003c\u003ci*2-1\u003c\u003c\" \";\r}\rfor(int i=n/4+1;i\u003c=n/2;i++){\rcout\u003c\u003ci*2+1\u003c\u003c\" \";\r}\rcout\u003c\u003c\"\\n\";\r}\r}\rreturn 0;\r}\r C. Alternating Subsequence ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:4:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 在一个数列中找一个子序列（可以不连续）满足奇偶穿插 对于满足这个条件的最长子序列中，求元素和最大值 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:5:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 将数列按奇偶性分割，每一部分取最大值 可以用双指针锁定区间 我的写法需要再最后添一个相反数，否则加不到最后一块区域 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,t,a[200005];\rconst ll inf = 0x3f3f3f3f3f3f3f3f;\rconst ll ninf = 0xc0c0c0c0c0c0c0c0;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\rvector\u003cll\u003e ans;\rfor(ll i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rif(a[n-1]\u003e0) a[n]=-1;\relse a[n]=1;\rbool pos;\rif(a[0]\u003e0){\rpos=true;\r}else pos=false;\rll l = 0;\rll r = 0;\rfor(int i=0;i\u003c=n;i++){\rif(pos){\rif(a[i]\u003e0) r++;\relse {\rpos^=1;\rll cnt = *max_element(a+l , a+r);\rans.push_back(cnt);\rl = r;\rr++;\r}\r}\relse{\rif(a[i]\u003c0) r++;\relse{\rpos^=1;\rll cnt = *max_element(a+l , a+r);\rans.push_back(cnt);\rl = r;\rr++;\r}\r}\r}\rll foo = 0;\rfor(ll i:ans){\r//cout\u003c\u003ci\u003c\u003cendl;\r foo+=i;\r}\rcout\u003c\u003cfoo\u003c\u003cendl;\r}\rreturn 0;\r}\r D. Constant Palindrome Sum ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:6:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 对于一个长度为n的数列（n为偶数） 对于数列中的每个数可以进行替换，使得所有的对称的一组数字和相等 且所有数字不超过k 求最小替换数 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:7:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 对于每组数，可以替换1次，2次0次 由于数字不超过k，所以和的范围为[2,2*k] 因为k的数据较小，所以可以枚举，对于每个x 求替换数，然后一直min 如果两个数和为x，则替换数为0 如果替换一个数，则替换之后和的范围是[min(x1,x2)+1 , max(x1,x2)+k] 所以检查x是否落在这个范围内 除此之外要替换2个 所以用一个容器存数字和的个数（目的是求0个） 存左右区间的个数（目的是不断迭代求1个）（如果用这种方法1个的个数会覆盖0个） 剩下就是2个 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n,k;\rint a[200005];\rint eq[2*200005];\rint l[2*200005];\rint r[2*200005];\rint one[2*200005]; //只替换一个 int ans;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ea[i];\r}\rfor(int i=1;i\u003c=n/2;i++){\req[a[i]+a[n-i+1]]++;\rl[min(a[i],a[n-i+1])+1]++;\rr[max(a[i],a[n-i+1])+k]++;\r}\rfor(int i=1;i\u003c=2*k+3;i++){\rone[i] = one[i-1]+l[i]-r[i-1];\r}\rans = n+2;\rfor(int i=1;i\u003c=2*k+3;i++){\rans = min(ans , n - one[i] - eq[i]); //不能用2*eq，因为one会重复计算一个eq所以要再加上一个eq }\rcout\u003c\u003cans\u003c\u003cendl;\r//TODO reset\r\rfor(int i=0;i\u003c2*k+2;i++) { //这里用memeset就会超时 eq[i]=l[i]=r[i]=0;\r}\r}\rreturn 0;\r}\r E. Weights Distributing ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:8:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一没有权值的无向图和权值序列 问怎样给边赋值（一一对应）使得从a到b再到c的权值和最小 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:9:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 由于行走路径会重复的问题 所以可以把问题转化成从a到 i ，从i到b，从b到 I ，从 i 到c 遍历所有的点 i 保证 i 到 b ，a 到 i ， i 到 c 都是最短路径（路径数最少） 将权值最小的部分赋给 b到 i 的路径上，再将较小的权值赋给 a到 i 和 i 到 c 要让路径数最少，直接bfs预处理 然后给权值排序，因为要不断选一段有序的权值，所以前缀和预处理 最后要特判 如果在样例1中，i 在 a 上，那么 i 到 b 和 i 到 c 路径重复，这种情况是绝对不可 能最优的（总能找到反例） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll t,n,m,a,b,c;\rll mm[200005];\rll d[3][200005];\rll spre[200005];\rvector\u003cll\u003e G[200005];\rconst ll inf = 0x3f3f3f3f3f3f3f3f;\rvoid bfs(ll st,ll r){\rqueue\u003cll\u003e q;\rq.push(st);\rwhile(!q.empty()){\rll cnt = q.front();\rq.pop();\rfor(auto i : G[cnt]){\rif(d[r][i] == -1){\rd[r][i] = d[r][cnt]+1;\rq.push(i);\r}\r}\r}\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb\u003e\u003ec;\r//TODO reset\r for(ll i=0;i\u003c3;i++)for(ll j=0;j\u003c=n;j++) d[i][j]=-1;\rfor(ll i=0;i\u003c=n;i++) G[i].clear();\rfor(ll i=1;i\u003c=m;i++){\rcin\u003e\u003emm[i];\r}\rsort(mm+1,mm+m+1);\rspre[1] = mm[1];\rfor(ll i=2;i\u003c=m;i++){\rspre[i]=spre[i-1]+mm[i];\r}\rll t1,t2;\rfor(ll i=1;i\u003c=m;i++){\rcin\u003e\u003et1\u003e\u003et2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rd[0][a]=0;d[1][b]=0,d[2][c]=0;\rbfs(a,0);\rbfs(b,1);\rbfs(c,2);\rll ans = inf;\rfor(ll i=1;i\u003c=n;i++){\rif(d[0][i] + d[1][i] + d[2][i] \u003e m) continue;\rans = min(ans , spre[ d[1][i] ] + spre[ d[0][i] + d[1][i] + d[2][i] ]);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\r// for(ll i=1;i\u003c=7;i++){\r //cout\u003c\u003cd[2][2]\u003c\u003c\" \";\r// }\r\r//for(ll i=1;i\u003c=8;i++) cout\u003c\u003cspre[i]\u003c\u003c\" \";\r //cout\u003c\u003cd[1][1]\u003c\u003cendl;\r //cout\u003c\u003ca\u003c\u003cb\u003c\u003cc;\r return 0;\r}\r ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:10:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["abc"],"content":"abc163","date":"2020-04-22","objectID":"/abc163/","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"A - Circle Pond ","date":"2020-04-22","objectID":"/abc163/:0:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 求圆周长 ","date":"2020-04-22","objectID":"/abc163/:1:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 print(int(input())*2*3.14159265)\r B - Homework ","date":"2020-04-22","objectID":"/abc163/:2:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 给定假期的时间和每一项作业完成的时间，求这个假期能玩几天 ","date":"2020-04-22","objectID":"/abc163/:3:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 n,m = map(int , input().split())\ra = list(map(int , input().split()))\rs = sum(a)\rif n\u003e=s:\rprint(n-s)\relse:\rprint(-1)\r C - management ","date":"2020-04-22","objectID":"/abc163/:4:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 告诉每个员工的老板，询问每个老板有多少个员工 ","date":"2020-04-22","objectID":"/abc163/:5:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 n=int(input())\ra=input().split()\rw=[0]*n\rfor i in a:\rw[int(i)-1]+=1\rfor i in w:\rprint(i)\r D - Sum of Large Numbers ","date":"2020-04-22","objectID":"/abc163/:6:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-22","objectID":"/abc163/:7:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 由于10^100次方的作用，这个题目就转化成求从中选n个数，有几种求和的结果 种数就是最大的n个减最小的n个 再遍历所有的n ac代码 n , k = map(int , input().split())\rsum = 0\rmod = 1e9+7\rdef func(x):\rreturn (2 * n - x + 1) * x / 2 - (x - 1) * x / 2 + 1\rfor i in range(k , n+2):\rsum = (sum + func(i)) % mod\rprint(int(sum))\r E - Active Infants ","date":"2020-04-22","objectID":"/abc163/:8:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-22","objectID":"/abc163/:9:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 贪心策略，尽可能地把值最大的点放到边边上,所以可以按降序排，然后从左到右 遍历 dp[i][j] 表示区间 [ i , j ] 确定的最大值 cnt\u003cvalue,index\u003e 表示当前点，即比它大的点都已安置过 那么 dp[i[[j] = max(dp[i+1][j] + cnt.first * | cnt.second - i| , dp[i][j-1] + cnt.first * |cnt.second - j| ) 对于 dp[i+1][j] 和 dp[i][j-1] 都需要用函数进行计算，就形成dfs ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\r#define fi first\r#define se second\rusing pll = pair\u003cll,ll\u003e;\rll n;\rll ans=0;\rvector\u003cpll\u003e vt; //存value和index ll dp[2005][2005];\rll cal(ll a,ll b,ll cnt){\rif(a\u003eb) return 0;\rif(dp[a][b]!=-1) return dp[a][b];\rreturn dp[a][b] = max(cal(a+1 , b , cnt+1) + vt[cnt].fi*abs(vt[cnt].se-a) , cal(a,b-1,cnt+1) + vt[cnt].fi*abs(vt[cnt].se -b));\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en;\rll t;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003et;\rvt.emplace_back(t,i) ;\r}\rsort(vt.begin() , vt.end() , [](pll x,pll y){if(x.fi != y.fi) return x.fi\u003ey.fi; return x.se\u003ey.se;}); //可以直接用greater\r memset(dp,-1,sizeof(dp));\rcout\u003c\u003ccal(0,n-1,0)\u003c\u003cendl;\rreturn 0;\r}\r F - path pass i ","date":"2020-04-22","objectID":"/abc163/:10:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 一个n个节点的树，每个节点都有一种颜色，可能重复 对于每种颜色，输出包含这种颜色的简单路径数量 ","date":"2020-04-22","objectID":"/abc163/:11:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 挺好一道树上dfs求路径的题 把问题转化成所有路径 - 不包含这种颜色的路径数 所有路径数为 C(2,n)+n 不包含这种颜色 i 的路径可以分成两部分 以颜色 i 作为父节点的子树，任意一条都是满足的（注意子树可能有颜色 i ） 将 i 节点作为父节点的子树切去的剩余部分 如果暴力求连通块的话会超时，所以要dfs（回溯思想） 因为分成两个部分，所以维护两种信息 path_num[i] 以i为颜色的点作为父节点中子树里面不包含此颜色的路径数量 ch_num[i] 以 i 为颜色的点作为父节点中子树的大小，包含 i 颜色 最后 k = n - cn_num[i] ans = all - path_num[i] - k(k+1)/2 对于dfs的细节在代码中标注 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint c[200005];\rvector\u003clong long\u003e G[200005];\rlong long path_num[200005]; //以i为颜色的点作为父节点中子树里面不包含此颜色的路径数量 long long ch_num[200005]; //以i为颜色的点作为父节点中子树的大小，包含i颜色 long long n;\rlong long ans;\rlong long dfs(long long u,long long v){\rlong long pre = ch_num[c[u]]; //dfs到u时，ch_num[i]的大小 long long cnt_ch_num = 1; //记录以u为父节点，子树的大小，包含自己所以起始为1 long long update = ch_num[c[u]]; //每次访问一个子节点就更新，目的是实时地计算路径数（需要用到残差） for(auto i:G[u]){ if(i!=v){\rlong long cntt = dfs(i,u); //返回的是以这个点为父节点的子节点数 cnt_ch_num += cntt; //扩充新的子节点数 long long delta = ch_num[c[u]] - update; //计算下一个子节点对于上一个子节点该颜色子树点的数量差 long long k = cntt - delta; //对于每个点都要更新路径数，路径数就是多出来的剩余部分(切去该颜色的点为父节点的所有子树，因为之前算过一部分\r //所以这里算残差) path_num[c[u]] += (k+1)*k/2; update = ch_num[c[u]]; //为了残差，需要更新 }\r}\rch_num[c[u]] = pre + cnt_ch_num; //子树大小为之前的部分 + 以u为父节点子树的部分 return cnt_ch_num; }\rint main(){\rcin\u003e\u003en;\rfor(long long i=0;i\u003cn;i++) {\rcin\u003e\u003ec[i];\rc[i]--;\r}\rlong long t1,t2;\rfor(long long i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\rt1--;t2--;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdfs(0,-1);\rfor(long long i=0;i\u003cn;i++){\rlong long k=n-ch_num[i];\rans = (n+1)*n/2 - path_num[i] - (k+1)*k/2; //所有路径 - 子树部分 - 剩余部分 cout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r 吃了一发爆long long debug很久发现，“简单路径”居然可以是自己到自己 一直在做android作业，debug快疯掉 debug一天多，发现recyclerview里面没有呈现cardview居然是getItemCount(){return 0;} ","date":"2020-04-22","objectID":"/abc163/:12:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["codeforces"],"content":"Codeforces Round #634 (Div. 3) A~E","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"A. Candies and Two Sisters ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:0:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 将一堆糖果分给两个女孩，其中一个要比另一个多，问有几种分法 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:1:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 可以看出规律 ac代码 t=int(input())\rfor i in range(t):\rn=int(input())\rprint((int)((n-1)/2))\r B. Construct the String ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:2:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 输入a,b,c 构造字符串，使字符串的长度为a，任意b个字符有c个不同字符 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:3:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 如果b=6,c=4就构造类似于aaabcdaaabcd.. 其他同理 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n,a,b;\rchar s[2005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ea\u003e\u003eb;\rfor(int i=0;i\u003ca-b+1;i++){\rs[i]='a';\r}\rchar x;\rfor(int i=a-b+1, x='b';i\u003ca;i++,x++){\rs[i]=x;\r}\rfor(int j=0,i=0;j\u003cn;j++){\rif(i==a) i=0;\rcout\u003c\u003cs[i++];\r}\rcout\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Two Teams Composing ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:4:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 从一个数列中，选一些数组成两个数列，使这两个数列长度相等，一个数列数字 全部相同，一个数列数字全部不同，求最长长度 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:5:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 求数列中出现次数最多的个数和总共有多少种数字，瞎比较一下即可 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rmap\u003cint,int\u003e mp;\rint t,n;\rint num;\rint m;\rint dat[200005];\rint ans;\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rset\u003cint\u003e st;mp.clear();\rm=-1;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003edat[i];\rmp[dat[i]]++;\rif(mp[dat[i]]\u003em){\rm=mp[dat[i]];\rnum=dat[i];\r}\rst.insert(dat[i]);\r}\rint rem=n-m;\rif(m\u003c=st.size()-1) ans=m;\relse if(m==st.size()) ans=m-1;\relse ans=st.size();\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r D. Anti-Sudoku ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:6:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 输入一个数独 每行每列每宫格只能改变一个数，使每行每列每宫格有两个数相同 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:7:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 思维题 把所有的1改成2 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rchar s[9][10];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rfor(int i=0;i\u003c9;i++){\rcin\u003e\u003es[i];\r}\rfor(int i=0;i\u003c9;i++){\rfor(int j=0;j\u003c9;j++){\rif(s[i][j]=='1') s[i][j]='2';\r}\r}\rfor(int i=0;i\u003c9;i++){\rputs(s[i]);\r}\r}\rreturn 0;\r}\r E. Three Blocks Palindrome (hard version) ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:8:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 求一个字符串的子串（可以不连续）使得这个子串是三块回文串 三块回文串：字符串被分成三块（长度可以为0），第一块和第三块必须相同 第二块可以和第一块相同也可以不同 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:9:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 简单版的可以暴力枚举中间块的左边界和右边界 然后前缀存每个数字出现的次数 设长度为n，数字最大为m 则时间复杂度O(n*n*m*m) 困难版时间复杂度必须降到O(k*n) 这时候不再遍历两个边界 而是固定一个边界，遍历一个边界，这样时间复杂度为O(k*n) 如此只能遍历第一块的右边界（对应第三块的左边界） 对于一个特定的数 i 假设共有 x 个 第一块含有这个数的个数从1遍历到 x/2 个 这就需要一个容器存储数字 i 出现 j 次对应的下标 确定第一块和第三块后就要找第二块哪种数字出现得最多 这和简单版的一样，用前缀存数字 i 在下标为 j 时出现的次数 遍历一遍所有数字 再总体遍历一遍所有数字 时间复杂度O(m*m*n*lgn) 看起来会超时，但实际不会 (跑了400ms) 本来在存储下标pos时开二维静态数组，MLE(266K) 改成动态map (166K) 对于时间复杂度和空间复杂度都可以再优化 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint n;\rint num[205][200005]; //num[i][j]存数字i在下标为j时出现的次数 map\u003cint,int\u003e pos[205]; //map\u003cj,index\u003e存数字i出现第j次的下标 int main(){\r//freopen(\"in.txt\",\"r\",stdin);\r scanf(\"%d\",\u0026t);\rwhile(t--){\r//TODO reset\r /*for(int i=0;i\u003c202;i++) {\rnum[i][0]=0;\rpos[i][0]=0;\r}*/\rfor (int i=0;i\u003c205;i++) pos[i].clear();\rscanf(\"%d\",\u0026n);\rint tmp;\rfor(int i=1;i\u003c=n;i++){\rscanf(\"%d\",\u0026tmp);\rfor(int j=1;j\u003c=200;j++){\rif(j==tmp){\rnum[j][i]=num[j][i-1]+1;\r}\relse{\rnum[j][i]=num[j][i-1];\r}\r}\rpos[tmp].insert(make_pair(num[tmp][i],i));\r}\rint ans=1;\rfor(int i=1;i\u003c=200;i++){\rfor(int j=1;j\u003c=num[i][n]/2;j++){\rint l=pos[i][j]+1;\rint r=pos[i][num[i][n]-j+1]-1;\rfor(int k=1;k\u003c=200;k++){\rans=max(ans,num[k][r]-num[k][l-1]+2*j);\r}\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\r//for(int i=1;i\u003c=4;i++) cout\u003c\u003cnum[i][8]\u003c\u003c\" \";\r //for(int i=1;i\u003c=4;i++) cout\u003c\u003cpos[3][i]\u003c\u003c\" \";\r }\rreturn 0;\r}\r F. Robots on a Grid ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:10:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:11:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:12:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["abc"],"content":"abc162","date":"2020-04-13","objectID":"/abc162/","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"A - Lucky 7 ","date":"2020-04-13","objectID":"/abc162/:0:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 问一个整数中是否含有数字7！ ","date":"2020-04-13","objectID":"/abc162/:1:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 ac代码 s = input()\rif '7' in list(s):\rprint('Yes')\relse:\rprint('No')\r B - FizzBuzz Sum ","date":"2020-04-13","objectID":"/abc162/:2:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 找出不大于n的自然数中不能被3和5整除的数的和 ","date":"2020-04-13","objectID":"/abc162/:3:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 模拟或者集成成公式O(1) ac代码 n = int(input())\rans=0\rfor i in range(1,n+1):\rif i%3==0 or i%5==0:\rcontinue\relse:\rans+=i\rprint(ans)\r C - Sum of gcd of Tuples (Easy) ","date":"2020-04-13","objectID":"/abc162/:4:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:5:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 ac代码 from math import gcd\rk=int(input())\rans=0\rfor i in range(1,k+1):\rfor j in range(1,k+1):\rfor m in range(1,k+1):\rans+=gcd(i,gcd(j,m))\rprint(ans)\r D - RGB Triplets ","date":"2020-04-13","objectID":"/abc162/:6:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:7:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 存rgb对应的下标 每次for循环两个颜色，在第三种颜色的下标中二分查找 时间复杂度O(n^2lgn) 这种方法不是很高效，跑了1600ms 利用乘法原理，跑一遍字符串应该可以O(n) ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rchar s[4005];\rvector\u003cint\u003e c[3];\rlong long ans=0;\rvoid sol(int q,int w,int e){\rfor(int i:c[q]) for(int j:c[w]){\rif(j\u003ei){\rvector\u003cint\u003e::iterator it = upper_bound(c[e].begin(),c[e].end(),j);\rif(it!=c[e].end()){\rans+=(int)(c[e].end()-it);\rint tgt=j+j-i;\rif(find(c[e].begin(),c[e].end(),tgt)!=c[e].end()) ans--;\r}else break;\r}\r}\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003es[i];\rswitch(s[i]){\rcase 'R':c[0].push_back(i);break;\rcase 'G':c[1].push_back(i);break;\rcase 'B':c[2].push_back(i);break;\r}\r}\rsol(0,1,2);\rsol(0,2,1);\rsol(1,2,0);\rsol(1,0,2);\rsol(2,1,0);\rsol(2,0,1);\rcout\u003c\u003cans\u003c\u003cendl;\r//cout\u003c\u003cs+1\u003c\u003cendl;\r return 0;\r}\r E - Sum of gcd of Tuples (Hard) ","date":"2020-04-13","objectID":"/abc162/:8:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 C题的升级版，个人觉得出得很好 官方题解，巧妙易懂 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll =long long;\rll n,k;\rll ans;\rll dp[1\u003c\u003c17];\rconst ll mod = 1e9+7;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(ll i=k;i\u003e0;i--){\rdp[i]=qpow(k/i , n);\rfor(ll j=i+i;j\u003c=k;j+=i){\rdp[i]-=dp[j]; //+mod%mod防溢出 }\r}\rfor(ll i=1;i\u003c=k;i++) ans=(ans+dp[i]*i)%mod;\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r}\r F - Select Half ","date":"2020-04-13","objectID":"/abc162/:9:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:10:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 贪心dp 对于当前数，有两种情况，选和不选 如果前一个数选了，这个数就不能选 如果前一个数不选，这个数可选可不选，取决于选了是否会贡献 对于下标的奇偶性需要分开判断 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll dat[1\u003c\u003c18];\rll sum[1\u003c\u003c18];\rll dp[1\u003c\u003c18];\rll n;\rint main(){\rcin\u003e\u003en;\rfor(ll i=0;i\u003cn;i++) {\rcin\u003e\u003edat[i];\rif(i\u003e=2 and i%2==0) sum[i]=dat[i]+sum[i-2];\relse if(i==0) sum[i]=dat[i];\r}\rfor(ll i=0;i\u003cn;i++){\rif(i\u00261){\rdp[i]=max(dp[i-2]+dat[i] , sum[i-1]);\r}\relse{\rdp[i]=max(dp[i-2]+dat[i] , dp[i-1]);\r}\r}\rcout\u003c\u003cdp[n-1]\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-04-13","objectID":"/abc162/:11:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["algorithm","hduoj"],"content":"hduoj1796","date":"2020-04-11","objectID":"/hduoj1796/","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"How many integers can you find ","date":"2020-04-11","objectID":"/hduoj1796/:0:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Problem Description Now you get a number N, and a M-integers set, you should find out how many integers which are small than N, that they can divided exactly by any integers in the set. For example, N=12, and M-integer set is {2,3}, so there is another set {2,3,4,6,8,9,10}, all the integers of the set can be divided exactly by 2 or 3. As a result, you just output the number 7. ","date":"2020-04-11","objectID":"/hduoj1796/:1:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Input There are a lot of cases. For each case, the first line contains two integers N and M. The follow line contains the M integers, and all of them are different from each other. 0\u003cN\u003c2^31,0\u003cM\u003c=10, and the M integer are non-negative and won’t exceed 20. ","date":"2020-04-11","objectID":"/hduoj1796/:2:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Output For each case, output the number. ","date":"2020-04-11","objectID":"/hduoj1796/:3:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Sample Input 12 2 2 3 ","date":"2020-04-11","objectID":"/hduoj1796/:4:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Sample Output 7 ","date":"2020-04-11","objectID":"/hduoj1796/:5:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Solution 容斥原理 ac代码 几个注意点 data可能为0(这时候可以忽略) 要开long long(一直没想到) #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rlong long n,m;\rlong long dat[11];\rlong long ans=0;\rvector\u003clong long\u003e vt;\rlong long mm;\rmain(){\rwhile(~scanf(\"%d%d\",\u0026n,\u0026mm)){\rans=0; vt.clear();\rn--;\rlong long temp;\rfor(long long i=0;i\u003cmm;i++) {\rcin\u003e\u003etemp;\rif(temp!=0)\rvt.push_back(temp);\r}\rm=vt.size();\rlong long x=0;\rfor(auto i:vt){\rdat[x++]=i;\r}\rfor(long long i=1;i\u003c(1\u003c\u003cm);i++){ //i从1开始 long long lcm=1;\rfor(long long j=0;j\u003cm;j++){\rif(i\u003e\u003ej\u00261){\rlcm=(lcm*dat[j])/__gcd(lcm,dat[j]);\r}\rif(lcm\u003en) break;\r}\rif(__builtin_popcount(i)\u00261) ans+=n/lcm;\relse ans-=n/lcm;\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\r}\r ","date":"2020-04-11","objectID":"/hduoj1796/:6:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["nowcoder"],"content":"牛客练习赛61(部分)","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"A . 打怪 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:0:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r int t,a,b,c,d;\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed;\rif(b\u003e=c || d\u003c=0) cout\u003c\u003c-1\u003c\u003cendl;\relse{\rint num=0;\rint cx=c;\rbool me=true;\rwhile(a\u003e0){\rif(me){\rcx-=b; me^=1;\r}\relse{\ra-=d;me^=1;\r}\rif(cx\u003c=0) {\rcx=c;num++;me=true;\r}\r}\rif(num\u003e10000) cout\u003c\u003c-1\u003c\u003cendl;else cout\u003c\u003cnum\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r B . 吃水果 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:1:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 贪心 其实就是找一些操作使两数相等，如果小的数*2比大的数小就*2，否则随着数的 递减，y/x增大，需要乘很多次2才能相等 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rint c=0;\rwhile(n!=m){\rif(n\u003em) swap(n,m);\rif(2*n\u003c=m) {\rn*=2;c++;\r}\relse{\rn--;m--;c++;\r}\r}\rcout\u003c\u003cc+n\u003c\u003cendl;\r}\rreturn 0;\r}\r C . 四个选项 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:2:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 z[12]用来存12道题的选项，每次停留在一道题时，根据剩余选项数进行dfs 每次搜索到末尾时判断是否满足第i题和第j题答案相同，都相同则方案数+1 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint num[5];\rint z[13];\rvector\u003cpair\u003cint,int\u003e\u003e vt;\rint ans=0;\rint m;\rvoid dfs(int ind){\rif(ind==13){\rbool flag=true;\rfor(auto i:vt){\rif(z[i.first]!=z[i.second]) {\rflag=false;break;\r}\r}\rif(flag) {\rans++;return;\r}\r}\rfor(int i=1;i\u003c=4;i++){\rz[ind]=i;\rif(num[i]){\rnum[i]--;\rdfs(ind+1);\rnum[i]++;\r}\r}\r}\rint main(){\rcin\u003e\u003enum[1]\u003e\u003enum[2]\u003e\u003enum[3]\u003e\u003enum[4]\u003e\u003em;\rint t1,t2;\rwhile(m--) {\rcin\u003e\u003et1\u003e\u003et2;\rvt.emplace_back(t1,t2);\r}\rdfs(1);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D . 最短路变短了 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:3:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 设d1[x]是1到x的最短距离 d2[x]是x到n的最短距离 则每次反向一条边（u-\u003ev,w） 如果变短，那么一定是 1-\u003ev-\u003eu-\u003en 所以只需要判断 d1[v]+w+d2[u] \u003c d1[n] 反向边的改变可能会影响d1,d2原始的数值 但不影响结果 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst long long max_v=100005;\rconst long long max_q=200005;\rconst long long max_e=200005;\rconst long long inf=0x3f3f3f3f3f3f3f3f;\rstruct edge\r{\rlong long to,cost;\redge(long long to,long long cost){\rthis-\u003eto=to;\rthis-\u003ecost=cost;\r}\r};\rtypedef pair\u003clong long,long long\u003e pii; vector\u003cedge\u003e G1[max_v];\rvector\u003cedge\u003e rG[max_v];\rlong long V;\rlong long d1[max_v];\rlong long d2[max_v];\rlong long n,m,q;\rlong long t1,t2,t3;\rlong long x;\rlong long dat[max_e][3];\rvoid dijkstra(long long s,long long d[],vector\u003cedge\u003e G[])\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V+2,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rlong long v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(long long i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} } main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em;\rV=n;\rfor(long long i=1;i\u003c=m;i++){\rcin\u003e\u003et1\u003e\u003et2\u003e\u003et3;\redge e(t2,t3);\rG1[t1].push_back(e);\redge e1(t1,t3);\rrG[t2].push_back(e1);\rdat[i][0]=t1,dat[i][1]=t2,dat[i][2]=t3;\r}\rdijkstra(1,d1,G1);\rdijkstra(n,d2,rG);\rcin\u003e\u003eq;\rwhile(q--){\rcin\u003e\u003ex;\rlong long u=dat[x][0],v=dat[x][1],w=dat[x][2];\rif(d1[v]+d2[u]+w\u003cd1[n]) puts(\"YES\"); else puts(\"NO\");\r}\r// for(long long i=1;i\u003c4;i++) cerr\u003c\u003cd1[i]\u003c\u003c\" \"; cerr\u003c\u003c\"\\n\";\r// for(long long i=1;i\u003c4;i++) cerr\u003c\u003cd2[i]\u003c\u003c\" \"; cerr\u003c\u003c\"\\n\";\r}\r E . 相似的子串 F . 苹果树 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:4:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["codeforces"],"content":"Codeforces Round #632 (Div. 2) A~C","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"A. Little Artem ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:0:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 给一网格染色，黑或白。要求满足以下条件的黑方块比白方块少1 如果是黑方块，则至少与一白方块边相邻，否则不计数 反之亦然 ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:1:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 左上角染白，其他全黑 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--){\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++){\rfor(int j=0;j\u003cm;j++){\rif(i==0 and j==0){\rcout\u003c\u003c'W';\r}\relse cout\u003c\u003c'B';\r}\rcout\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r B. Kind Anton ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:2:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 两数组a,b a初始时只由{0,-1,1}的子集组成 操作方式：将一个数前面的某一个数加到这个数上 问能否经过一些操作后得到数组b ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:3:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 由于一个数只会被前面的数影响，且前面的数不受影响 再加上0,-1,1的特殊性，只需要考虑b[i]\u003ea[i]时，前面是否有1 或b[i]\u003ca[i]时前面是否有-1 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint n;\rint a[100005];\rint b[100005];\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rbool one=false;\rbool none=false;\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rfor(int i=0;i\u003cn;i++) cin\u003e\u003eb[i];\rif(a[0]!=b[0]) {\rcout\u003c\u003c\"NO\\n\"; continue;\r}\rif(a[0]==1) one=true;\rif(a[0]==-1) none=true;\rbool ok=true;\rfor(int i=1;i\u003cn;i++){\rif(b[i]\u003ea[i] and !one) {\rok =false;break;\r}\rif(b[i]\u003ca[i] and !none){\rok=false;break;\r}\rif(a[i]==1) one=true;\rif(a[i]==-1) none=true;\r}\rif(ok) cout\u003c\u003c\"YES\\n\"; else cout\u003c\u003c\"NO\\n\";\r}\rreturn 0;\r}\r C. Eugene and an array ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:4:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 给一数组，问有多少个“好子数组“ 定义，好子数组：这个数组是原数组的子集，元素之和不等于0，其子集都是好子 数组 ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:5:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 类似于依赖前缀和动态规划 从左向右遍历，查看是否有和为0的区间，其中区间的右边界为当前数 查看是否有和为0的区间只需要查看是否有前缀和为当前数的区间 如果有则取最右端（因为好子数组的子集也是好子数组） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long; ll n;ll x;ll sum=0;map\u003cll,ll\u003e pos;ll cp=-1;ll ans=0;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r\rcin\u003e\u003en;\rpos[0]=0;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ex;\rsum+=x;\rif(pos.count(sum)) cp=max(cp,pos[sum]);\rans+=i-cp-1;\rpos[sum]=i;\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r D. Challenges in school №41 E. Road to 1600 F. Kate and imperfection ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:6:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["nowcoder"],"content":"NC13611","date":"2020-04-06","objectID":"/nc13611/","tags":["cpp","number_theory","dp"],"title":"NC13611","uri":"/nc13611/"},{"categories":["nowcoder"],"content":"题目描述 shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。 输入描述: 第一行两个整数n，k代表点数和颜色数； 接下来n-1行，每行两个整数x,y表示x与y之间存在一条边； 输出描述: 输出一个整数表示方案数（mod 1e9+7）。 sample input 4 3 1 2 2 3 2 4 sample output 39 solution 动态规划 dp[i][j] 表示现在在第 i 个点，用 j 中颜色染色的方案数 那么对于下一个点有两种情况 1.染同一种颜色 dp[i][j]=dp[i-1][j] 2.染不同颜色 dp[i][j]+=dp[i-1][j-1]*(k-j+1) 最后对所有的 dp[n][i] 1\u003c=i\u003c=k 求和 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n,k;\rll dp[305][305];\rconst ll mod = 1e9+7;\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rdp[0][0]=1;\rfor(int i=1;i\u003c=n;i++)\rfor(int j=1;j\u003c=k;j++){\rdp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-j+1))%mod;\r}\rll ans=0;\rfor(int i=1;i\u003c=k;i++){\rans=(ans+dp[n][i])%mod;\r}\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r}\r 排列组合 把问题转化成将树分解成不大于 k 个连通块的方案数 将树分解成 i 个连通块，就要删掉 i-1 条边 总共有 $$\\ C_{n-1}^{i-1}$$ 种方案 对于每一种方案，染 i 中颜色 就有 $$\\ A_{k}^{i}$$ 种方案 所以一共有 $$ \\sum\\limits_{i=1} ^ {min(n,k)} {\\ C_{n-1}^{i-1}\\ A_{k}^{i}} $$ 然后模拟 逆元法 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n,k;\rconst ll mod = 1e9+7;\rll inv[305];\rll fac[305];\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinline ll A(ll m,ll n){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(ll i=0;i\u003c=n;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u003c=n;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\r//for(int i=1;i\u003c=9;i++) cout\u003c\u003cfac[i]\u003c\u003cendl;\r inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u003c=n;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rll ans=0;\rfor(ll i=1;i\u003c=min(n,k);i++){\rans=(ans+C(i-1,n-1)*A(i,k)%mod)%mod;\r}\rcout\u003c\u003cans%mod;\rreturn 0;\r}\r 快速幂法 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n,k;\rconst ll mod = 1e9+7;\rll fac[305];\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rinline ll cal(ll i){\rreturn fac[n-1]*fac[k]%mod*qpow(fac[i-1],mod-2)%mod*qpow(fac[n-i],mod-2)%mod*qpow(fac[k-i],mod-2)%mod;\r}\rint main(){\rcin\u003e\u003en\u003e\u003ek;\rfor(ll i=0;i\u003c=n;i++){ //fac[0]=1!!!\r fac[i]=1;\r}\rfor(ll i=2;i\u003c=n;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rll ans=0;\rfor(ll i=1;i\u003c=min(k,n);i++){\rans=(ans+cal(i))%mod;\r}\rcout\u003c\u003cans%mod;\rreturn 0;\r}\r ","date":"2020-04-06","objectID":"/nc13611/:0:0","tags":["cpp","number_theory","dp"],"title":"NC13611","uri":"/nc13611/"},{"categories":["abc"],"content":"abc161","date":"2020-04-05","objectID":"/abc161/","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"A - ABC Swap ","date":"2020-04-05","objectID":"/abc161/:0:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给三个数a,b,c，交换ab的值，交换ac的值，输出 ","date":"2020-04-05","objectID":"/abc161/:1:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint a,b,c;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec;\rswap(a,b);\rswap(a,c);\rcout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003c\" \"\u003c\u003cc\u003c\u003cendl;\rreturn 0;\r}\r B - Popular Vote ","date":"2020-04-05","objectID":"/abc161/:2:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 有n件商品，每种商品有一价格，给一数m 求能否从中选出m件商品使得它们的价格都不小于商品总价格（n件）/(4*m) ","date":"2020-04-05","objectID":"/abc161/:3:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 对价格求和，求出界限，对商品价格排序，检查前m件商品价格是否都满足这个限 制 ac代码 #include\u003ciostream\u003e\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\r//using ll = long long;\rint n,m;\rint a[1005];\rbool cmp(int a,int b){\rreturn a\u003eb;\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++)cin\u003e\u003ea[i];\rint sum=0;\rfor(int i=0;i\u003cn;i++) sum+=a[i]; int b=ceil((double)sum/(4*m));\r//cout\u003c\u003csum;\r //cout\u003c\u003cb;\r bool ok=true;\rsort(a,a+n,cmp);\r//int ans=0;\r for(int i=0;i\u003cm;i++){\r//ans+=a[i];\r if(a[i]\u003cb){\rok=false;\rbreak;\r}\r}\rputs(ok? \"Yes\":\"No\");\rreturn 0;\r}\r C - Replacing Integer ","date":"2020-04-05","objectID":"/abc161/:4:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给俩数n,k 一直做如右操作，将n替换成|n-k| 求这个过程中n能达到的最小值 ","date":"2020-04-05","objectID":"/abc161/:5:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 找规律，不断地去迎合所有的情况，就会莫名其妙ac 或者用数学方法做 ac代码 #include\u003ciostream\u003e\rusing namespace std;\rusing ll = long long;\rll n,k;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003ek;\rif(n==k){\rcout\u003c\u003c0\u003c\u003cendl;\r}\relse{\rif(n\u003ck) n=k+(k-n);\rcout\u003c\u003cmin((k-n%k)%k,n-k)\u003c\u003cendl;\r}\rreturn 0;\r}\r D - Lunlun Number ","date":"2020-04-05","objectID":"/abc161/:6:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 定义“lunlun数”：对于一个数，相邻两个位数的数字差不大于1 给一数n，求第n个“lunlun数” ","date":"2020-04-05","objectID":"/abc161/:7:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 预处理最大的情况 dfs，dp都行 数字，字符串都行 此处用bfs做 对于一个数，在它的末尾增加新的数字，9和0有两种情况，其他有三种情况 先处理一位数，再处理两位数。。。 用bfs经典方法队列实现 用maxn进行循环退出判断 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cstring\u003e vt;\rint num=0;\rqueue\u003cstring\u003e q;\rbool cmp(string s1,string s2){\rif(s1.length()==s2.length()){\rreturn s1\u003cs2;\r}\relse return s1.length()\u003cs2.length();\r}\rint main(){\rq.push(\"1\");\rq.push(\"2\");\rq.push(\"3\");\rq.push(\"4\");\rq.push(\"5\");\rq.push(\"6\");\rq.push(\"7\");\rq.push(\"8\");\rq.push(\"9\");\rwhile(!q.empty() and num\u003c100005){\rstring s=q.front();\rq.pop();\rvt.push_back(s);\rnum++;\rint len=s.length();\rchar ch=s[len-1];\rif(ch=='9'){\rq.push(s+'8');\rq.push(s+'9');\r}\relse if(ch=='0'){\rq.push(s+'0');\rq.push(s+'1');\r}\relse{\rchar ch1= ch-1,ch2=ch,ch3=ch+1;\rstring s1=s,s2=s,s3=s;\rs1.insert(s1.end(),ch1);\rs2.insert(s2.end(),ch2);\rs3.insert(s3.end(),ch3);\rq.push(s1);\rq.push(s2);\rq.push(s3);\r}\r}\rsort(vt.begin(),vt.end(),cmp);\rint n;cin\u003e\u003en;\rn--;\rcout\u003c\u003cvt[n]\u003c\u003cendl;\rreturn 0;\r}\r cmp可以用lambda表达式写 E - Yutori ","date":"2020-04-05","objectID":"/abc161/:8:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给两个数k,c和一串由ox组成的字符串，表示每一天 从中选k天上班 限制条件：x不能上班，上完一天班后要连续休息c天 求所有可能的上班方案中，哪一天是必须上班的 ","date":"2020-04-05","objectID":"/abc161/:9:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 枚举必超时 其实只要贪心地从第一个开始选k个，从最后开始贪心地往前选k个 查看是否有交集就可 小证明 如果交集为空集，则不存在，因为这两种情况是所有情况的子集 如果存在（数量不大于k，下证），则对于所有中间取的情况一定会和左右两种情 况重叠，左右取产生的交集是最苛刻的满足条件 有几个细节 1.可以特判n==2 2.当从最左边开始选可以选到k+1个，则不存在必须上班的那一天 小证明 如果有k+1天，则随便从中选一天不上班，其余的天数都上班 对于所有的情况，它们的交集为空集，与右边的交集为空集（空集与任何集合 的交集都为空集） 3.同理右边也不能选到k+1个 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k,c;\rchar s[200005];\rset\u003cint\u003e st;\rset\u003cint\u003e st2;\rset\u003cint\u003e st3;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r scanf(\"%d%d%d%s\",\u0026n,\u0026k,\u0026c,s);\rint cnt=0;\rfor(int i=0;i\u003cn;i++){\rif(s[i]=='o') {\rst.insert(i+1);\rcnt++;\ri+=c;\r}\rif(cnt\u003ek) return 0; //一定不存在必须工作的一天 }\rcnt=0;\rfor(int i=n-1;i\u003e=0;i--){\rif(s[i]=='o'){\rst2.insert(i+1);\rcnt++;\ri-=c;\r}\rif(cnt\u003ek) return 0; //一定不存在必须工作的一天 }\rset_intersection(st.begin(),st.end(),st2.begin(),st2.end(),ostream_iterator\u003cint\u003e(cout,\"\\n\"));\rreturn 0;\r}\r F - Division or Substraction ","date":"2020-04-05","objectID":"/abc161/:10:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给俩数n,k（2\u003c=k\u003c=n） 不断进行如下操作 如果k能整除n，则n/=k 否则n-=k 当n\u003ck时停机 问满足最后n==1的k的个数 ","date":"2020-04-05","objectID":"/abc161/:11:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 设置一个计数器，遍历所有的k进行判断 这样会T，所以进行优化 首先只需遍历到√n（下证） 对于每个k 分两种情况 如果n%k==1，则满足条件 且(n-1)/k也满足条件 如果n%k==0则不断进行n/=k 最后判断是否n%k==1 这种情况下只有k满足条件，计数器计数 注意k*k=n-1只能计一个数 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r ll n;\rcin\u003e\u003en;\rif(n==2) {\rcout\u003c\u003c1\u003c\u003cendl;return 0;\r}\rll ans=2; //n和n-1 for(ll i=2;i*i\u003c=n;i++){\rif(n%i==1){\rif(i*i==n-1) ans++; else ans+=2;\r}\relse if (n%i==0){\rll t=n;\rwhile(t%i==0) t/=i;\rif(t%i==1) ans++;\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-04-05","objectID":"/abc161/:12:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["codeforces"],"content":"Codeforces Round #631 (Div. 2) A~D","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Dreamoon and Ranking Collection ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:0:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给n个数和数字k，你可以对数列进行扩充k个数，使得扩充后的数列出现1~m的 数字至少一次，求m的最大值 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:1:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 用计数器对原始数列计数，如果不连续，则k递减，直到k耗光，最后还要判断 原始数列能否再连续下去，直到断开 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,x;\rint a[105];\rint t;\rset\u003cint\u003e s;\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\r//reset\r s.clear();\rcin\u003e\u003en\u003e\u003ex;\rfor(int i=0;i\u003cn;i++)\rcin\u003e\u003ea[i];\r//sort(a,a+n);\r for(int i=0;i\u003cn;i++){\rs.insert(a[i]);\r}\rint cnt=1;set\u003cint\u003e::iterator it;\rfor(it =s.begin();it!=s.end();){\rif((*it)!=cnt){\rx--;cnt++;\r}\relse {\rit++;\rcnt++;\r}\rif(x==0) break;\r}\rif(it==s.end() and x!=0){\rcnt+=x;\r}\rwhile(*it==cnt){\rit++;cnt++;\r}\rcout\u003c\u003ccnt-1\u003c\u003cendl;\r}\rreturn 0;\r}\r B. Dreamoon Likes Permutations ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:2:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 定义“排列”为一个长度为n的数列，数列中1~n的数字必须且只能出现一次 给一数列，对数列进行切割，将数列分成两部分，使得两部分都是“排列” 求分割方案数 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:3:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 用两个集合存左右两部分 如果两个集合的最大值都等于数量，则这种分割可以得到排列 遍历数组，同时对俩集合进行增删操作 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint n;\rint a[200005];\rset\u003cint\u003e s1;\rset\u003cint\u003e s2;\rvector\u003cint\u003e ans;\rint num[200005];\rint main(){\rios::sync_with_stdio(0);cin.tie(0);\r// freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\r//TODO reset\r s1.clear();\rs2.clear();\rans.clear();\rmemset(num,0,sizeof(num));\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\r}\r//preprocess\r s1.insert(a[0]);\rfor(int i=1;i\u003cn;i++){\rs2.insert(a[i]);\rnum[a[i]]++;\r}\rfor(int i=1;i\u003cn;i++){\rif(s1.size()==i and s2.size()==n-i and *(--s1.end())==i and *(--s2.end())==n-i){\rans.push_back(i);\r}\rs1.insert(a[i]);\rif(num[a[i]]==1){\rs2.erase(a[i]);\r}\rnum[a[i]]--;\r}\rif(ans.size()!=0)\r{\rcout\u003c\u003cans.size()\u003c\u003cendl;\rfor(auto i:ans){\rcout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cn-i\u003c\u003cendl;\r}\r}\relse cout\u003c\u003c0\u003c\u003cendl;\r}\rreturn 0;\r}\r C. Dreamoon Likes Coloring ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:4:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数列，每次可以对其中连续的li个元素进行染色，每次染的颜色都不相同，问 所有染色结束后，能否使所有数字都染色，且每种颜色都存在 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:5:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 首先特判 如果区间的长度和小于数列长度，则不存在 如果对于第i个长度，区间的起始位置小于i，则不存在 贪心法 让第一个区间从第一个数开始，第二个区间从第二个数开始。。。 这样就能保证至少有一个数染这种颜色 但这样会出现一个问题 当所有区间都用完之后，右边的数可能不会染色 这时候就要将某些区间右移（不能在放在第i个） 判断条件就是，对于这个区间，是否存在右边为空的情况（即n-sum\u003ei） 其中sum为剩余部分长度和 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,m;\rll l[100005];\rll sum=0;\rll ans[100005];\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em;\rbool ok=true;\rfor(int i=0;i\u003cm;i++) {\rcin\u003e\u003el[i];\r//l[i];\r sum+=l[i];\rif(n-l[i]+1\u003c=i){\rok=false;\r}\r}\rif(!ok or sum\u003cn) {\rcout\u003c\u003c-1\u003c\u003cendl;\rreturn 0;\r}\relse{\rfor(int i=0;i\u003cm;i++){\rif(n-sum\u003ei){\rans[i]=n-sum;\r}\relse ans[i]=i;\rsum-=l[i];\r}\rfor(int i=0;i\u003cm;i++) cout\u003c\u003cans[i]+1\u003c\u003c\" \"; cout\u003c\u003cendl;return 0;\r}\r}\r D. Dreamoon Likes Sequences ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:6:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给俩数d,m 求满足下列条件的数列的个数%m 1\u003c= a1 \u003c a2 \u003c… \u003c an \u003c=d a1 XOR a2 \u003e a1 a1 XOR a2 XOR a3 \u003e a1 XOR a2 a1 XOR a2 XOR a3 XOR a4 \u003e a1 XOR a2 XOR a3 ……. ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:7:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 二进制构造 + 动态规划 对于一个数a，构造一个数b，使得b\u003ea ，且 b XOR a \u003e a a的二进制首位为0（可以添加0，没影响） b的二进制首位为1 那么b XOR a 的首位一定为1，满足条件 b的首位为1，其他位随便填 所以dp[i]表示长度为i的个数 那么dp[i] = (2^i) * dp[i-1] + dp[i-1] （加上之前的个数） 但这样一直做可能会超过d 所以要判断条件2^i\u003c=d 剩余的部分不再有2^i种 而是d-2^i+1种 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll d,m,t;\rll dp[30];\rll init=2;\rint main(){\r// freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ed\u003e\u003em;\rif(d==1){\rcout\u003c\u003c1%m\u003c\u003cendl;\r}\relse{\rdp[0]=init;\rint i;\rfor( i=1;(1\u003c\u003ci)\u003c=d;i++){\rdp[i]=(1\u003c\u003ci)*dp[i-1]%m+dp[i-1]%m;\r}\ri--;\rdp[i]=(d-(1\u003c\u003ci)+1)*dp[i-1]%m+dp[i-1]%m;\rcout\u003c\u003c(dp[i]-1+m)%m\u003c\u003cendl; //加m防止溢出 }\r}\rreturn 0;\r}\r ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:8:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["note","courses"],"content":"浮点数加减法","date":"2020-04-03","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/","tags":["cs"],"title":"浮点数加减法","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/"},{"categories":["note","courses"],"content":"#0 0操作数检查 如果有一个数为0，则可以直接得出结果 #1 用补码表示阶码，尾数 阶码的符号位为两位 尾数的个位为符号位 #2 对阶 小阶向大阶对齐（看原码），被对阶的数尾数右移阶差个 #3 尾数加 将两个尾数相加得到新的尾数 #4 溢出处理 太复杂，不作考虑 #4 规格化处理 先检查是否规格化，如果尾数符号位与最高位相同则非规格化 尾数左移直到规格化为止，阶码减少左移的位数（不含符号位） #5 舍入处理 最低有效位为0舍去，为1则尾数+1 #6 还原 将补码还原成原码 E.G. 1.设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y] x= 2^(-011) * (0.100101) y = 2^(-010) * (-0.011110) 解： 第一步，补码表示 x :11 101 , 0.100101 y : 11 110 , 1.100010 第二步 对阶，x阶小，y阶大，x向y对阶，阶差为1，所以x尾数右移一个 x阶码变成与y相同，阶码为 11 110 尾数0.010010(1) 第三步 尾数加 0. 0 1 0 0 1 0 (1)\r1. 1 0 0 0 1 0\r-------------------------\r1. 1 1 0 1 0 0 (1) 结果为 1.110110(1) 符号位与最高位都是1，非规格化 第四步 规格化 尾数左移两位变成 1.010010 阶码减2（符号位不变），变成 11 100 第五步 舍入处理 没得舍入 第六步 还原 x+y = 2^(-4) * (-0.101110) 对于[x-y] 根据[x-y]补码 = [x]补码 + [-y]补码 在第三步尾数加时 0. 0 1 0 0 1 0 (1)\r0. 0 1 1 1 1 0\r-------------------------\r0. 1 1 0 0 0 0 (1) 结果为 0.110000(1) 最高有效位和符号位不同，是规格化 最低有效位为1 尾数+1变成 0.110001 还原 x-y = 2^(-2) * (0.110001) ========================================================= 设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y] x=2^(-101) × （-0.010110） y=2^(-100) × （0.010110） 解： 第一步 补码表示 x : 11 011 , 1.101010 y : 11 100 , 0.010110 第二步 对阶，x阶小，y阶大 x阶码变成y，阶差1，x尾数右移1位 x : 11100 , 1.110101(0) 第三步 尾数加 1. 1 1 0 1 0 1 (0)\r0. 0 1 0 1 1 0\r-------------------------\r0. 0 0 1 0 1 1 (0) 结果为 0.001011(0) 符号位与最高有效位相同，非规格化 第四步 规格化 尾数左移两位，阶码减2 尾数 0.101100 阶码 11 010 第五步 舍入处理 无需舍入 第六步 还原 x+y = 2^(-6) * (0.101100) 同理x-y的尾数加为 1. 1 1 0 1 0 1 (0)\r1. 1 0 1 0 1 0\r-------------------------\r1. 0 1 1 1 1 1 (0) 结果为 1.011111(0) 符号位和最高有效位不同，为规格化 最低有效位为0，全舍弃 还原 x-y = 2^(-4) * (-0.100001) （有缺漏，待改正） ","date":"2020-04-03","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/:0:0","tags":["cs"],"title":"浮点数加减法","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/"},{"categories":["codeforces"],"content":"Codeforces Round #630 (Div. 2) A~E","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"A. Exercising Walk ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:0:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一坐标范围，初始位置，和左右上下移动的步数，问是否会出界 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:1:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 加各种条件判断即可 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint a,b,c,d,x,y,x1,y1,x2,y2;\rbool ok;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rok=true;\rcin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed\u003e\u003ex\u003e\u003ey\u003e\u003ex1\u003e\u003ey1\u003e\u003ex2\u003e\u003ey2;\rif( (a-b\u003e=0 and x-x1\u003ca-b) or (b-a\u003e0 and x2-x\u003cb-a) or (c-d\u003e0 and y-y1\u003cc-d) or (d-c\u003e0 and y2-y\u003cd-c) or (a==b and a!=0 and x1==x and x2==x) or (c==d and c!=0 and y1==y and y2==y) )\rok = false;\rif(ok) puts(\"yes\"); else puts(\"no\");\r}\rreturn 0;\r}\r B. Composite Coloring ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:2:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给n个合数上色，要求相同颜色的数字必须不互质，求最小着色数和着色方案 （题目保证着色数不大于11，且值不大于1000） ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:3:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 两个合数不互质，即最小质因子相同 对每个数求最小质因子 相同则染同一种颜色（贪心） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n;\rint a[1005];\rint c[1005];\rint p[]={1,2,3,5,7,11,13,17,19,23,29,31};\rset\u003cint\u003e st;\rbool vi[1005];\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en;\r//reset\r memset(c,0,sizeof(c));\rst.clear();\rmemset(vi,0,sizeof(vi));\rfor(int i=0;i\u003cn;i++) cin\u003e\u003ea[i];\rfor(int i=0;i\u003cn;i++){\rfor(int j=1;j\u003c=12;j++){\rif(a[i]%p[j]==0){\rc[i]=j;\rst.insert(j);\rbreak;\r}\r}\r}\rint num=st.size();\rint index=0;\rint cnt;\rfor(int i=0;i\u003cn;i++){\rif(!vi[i]){\rcnt=c[i];\rvi[i]=true;\rindex++;\rc[i]=index;\rfor(int j=i+1;j\u003cn;j++){\rif(!vi[j] and c[j]==cnt){\rc[j]=index;\rvi[j]=true;\r}\r}\r}\r}\rcout\u003c\u003cnum\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003cc[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\r}\rreturn 0;\r}\r C. K-Complete Word ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:4:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一字符串和k，要求改其中一些字符，使字符串是回文串且周期为k，求最小改 动数 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:5:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 把字符串分成k个部分，每个部分都是回文串 字符串中的一些字符是相互捆绑的（即要相同），与其他字符相互独立 对于相互捆绑的字符，查询出现次数最多的字符，然后都替换成它 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,n,k;\rstring s;\rint kp;\rint z[27];\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek;\rcin\u003e\u003es;\r//reset\r //memset(z,0,sizeof(z));\r kp=0;\rfor(int i=0;i\u003c=k-i-1;i++){\rmemset(z,0,sizeof(z));\rfor(int j=i;j\u003cn;j+=k){\rz[s[j]-'a']++;\r}\rif(i\u003ck-i-1)\r{\rfor(int j=k-i-1;j\u003cn;j+=k){\rz[s[j]-'a']++;\r}\r}\rkp+=*max_element(z,z+27);\r//cout\u003c\u003c*max_element(z,z+27)\u003c\u003cendl;\r }\rcout\u003c\u003cn-kp\u003c\u003cendl;\r}\r}\r D. Walk on Matrix ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:6:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一矩阵，从矩阵的左上角走到右下角，只能往右和往下走 走到一个元素上，则自身的值变为当前自身的值\u0026元素上的值 存在一种走法使得最后得到的值最大 给一dp算法和k，求满足经dp算法算出的值和最大值差k的矩阵 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:7:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 构造矩阵 让最大值为k 经dp算法输出的值为0 根据(m+k)\u0026k=k , (m+k)\u0026m=m , m\u0026k=0 其中m的二进制位1000… 进行构造（不唯一） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint m=(1\u003c\u003c17);\rint k;\rint main(){\rcin\u003e\u003ek;\rcout\u003c\u003c2\u003c\u003c\" \"\u003c\u003c3\u003c\u003cendl;\rcout\u003c\u003cm+k\u003c\u003c\" \"\u003c\u003cm\u003c\u003c\" \"\u003c\u003c0\u003c\u003cendl\u003c\u003ck\u003c\u003c\" \"\u003c\u003cm+k\u003c\u003c\" \"\u003c\u003ck\u003c\u003cendl;\rreturn 0;\r}\r E. Height All the Same ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:8:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一n*m的网格，和L，R 在网格上进行初始化放方块，要求每一格的方块数在L到R之间 有两种操作 1.在两（边相邻）相邻网格上各增加一块 2.在一个网格上增加两块 求能够使所有网格高度相等的初始化方案数 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:9:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 dif=R-L+1 当网格数量为奇数时，随便放，有dif^(n*m)种 当网格数量为偶数时，如果dif为偶数，则有一半情况不满足（每个满足的都对应 一个不满足的），有dif^(n*m)/2 当dif为奇数时，则中间会多出一个没有对应的方案，有(dif^(n*m)+1)/2 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rconst ll mod = 998244353;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r ll n,m,l,r;\rcin\u003e\u003en\u003e\u003em\u003e\u003el\u003e\u003er;\rll ans;\rll dif=r-l+1;\rif((n*m)\u00261) ans=qpow(dif,n*m)%mod;\relse if(dif%2==0) {\rans=qpow(dif,n*m)%mod*qpow(2,mod-2)%mod;\r}\relse{\rans=(qpow(dif,n*m)+1)%mod*qpow(2,mod-2)%mod;\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\r ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:10:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["abc"],"content":"abc160","date":"2020-03-29","objectID":"/abc160/","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"A - Coffee ","date":"2020-03-29","objectID":"/abc160/:0:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 判断一个长度为6的字符串，第3位和第4位是否相等，第5位和第6位是否相等 ","date":"2020-03-29","objectID":"/abc160/:1:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rstring s;\rcin\u003e\u003es;\rif(s[2]==s[3] and s[4]==s[5]) cout\u003c\u003c\"Yes\";\relse cout\u003c\u003c\"No\";\rreturn 0;\r}\r B - Golden Coins ","date":"2020-03-29","objectID":"/abc160/:2:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 高桥有许多钱，可以兑换成各种硬币，每获得一枚500円的硬币，就能获得1000 点快乐值，每获得一枚5円的硬币，就能获得5点快乐值，问最多能获得多少快乐 值 ","date":"2020-03-29","objectID":"/abc160/:3:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 贪心地兑换成500円的硬币，然后再兑换成5円的 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll x;\rll ans=0;\rint main(){\rcin\u003e\u003ex;\rans+=x/500;\rans*=1000;\rx%=500;\rans+=(x/5)*5;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - Traveling Salesman around Lake ","date":"2020-03-29","objectID":"/abc160/:4:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 在一个圆上有n个点，给定每个点的位置，问沿圆周访问所有点的最短长度 ","date":"2020-03-29","objectID":"/abc160/:5:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 访问所有点的路径就是圆周长减去一段隔阂 求隔阂的最大值，依次遍历即可 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,k;\rint dist[200005];\rint c;\rint ans=-1;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003ek\u003e\u003en;\rc=k;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003edist[i];\rsort(dist+1,dist+n+1);\rfor(int i=1;i\u003c=n-1;i++){\rans=max(ans,dist[i+1]-dist[i]);\r}\rans=max(ans,c-dist[n]+dist[1]); //n是double不能当作index cout\u003c\u003cc-ans\u003c\u003cendl;\rreturn 0;\r}\r D - Line++ ","date":"2020-03-29","objectID":"/abc160/:6:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 有n个点，依次连线，再把其中两个未连线的点连线 求最短路径长度等于k的路径条数（对于所有的k=1,2,3..） ","date":"2020-03-29","objectID":"/abc160/:7:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 看似是图论题，其实只需要考虑两种情况 枚举所有点对的最短距离 1.直接按顺序走 2.走过特殊的连线 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,x,y;\rmap\u003cint,int\u003e mp;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003ex\u003e\u003ey;\rfor(int i=1;i\u003c=n;i++) for(int j=i+1;j\u003c=n;j++)\rmp[min(j-i,abs(i-x)+abs(j-y)+1)]++;\rfor(int i=1;i\u003cn;i++) cout\u003c\u003cmp[i]\u003c\u003cendl;\rreturn 0;\r}\r E - Red and Green Apples ","date":"2020-03-29","objectID":"/abc160/:8:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 DIO有a个红苹果（X）红面包（√）和b片绿面包，c片白面包 每片面包都有时停时间，聪明的DIO可以将白面包涂成红色或者绿色 现在DIO要吃x片红面包和y片绿面包（！DIO居然记得吃几片面包） DIO的最终目的就是无限时停，问DIO最多能时停几秒 ","date":"2020-03-29","objectID":"/abc160/:9:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 贪心地选取时停时间最多的面包 但是有限制条件就是x和y（白色是不受限制的） 所以从红色中选前x个，绿色中选前y个，与白色混合排序 最后选前x+y个 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll x,y,aa,bb,cc;\rvector\u003cll\u003e a,b,c;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003ex\u003e\u003ey\u003e\u003eaa\u003e\u003ebb\u003e\u003ecc;\rll temp;\rfor(ll i=0;i\u003caa;i++) {\rcin\u003e\u003etemp;\ra.push_back(temp);\r}\rfor(ll i=0;i\u003cbb;i++) {\rcin\u003e\u003etemp;\rb.push_back(temp);\r}\rsort(a.rbegin(),a.rend());\rsort(b.rbegin(),b.rend());\rfor(ll i=0;i\u003cx;i++) c.push_back(a[i]);\rfor(ll i=0;i\u003cy;i++) c.push_back(b[i]);\rfor(ll i=0;i\u003ccc;i++) {\rcin\u003e\u003etemp;\rc.push_back(temp);\r}\rsort(c.rbegin(),c.rend());\rll sum=0;\rfor(ll i=0;i\u003cx+y;i++) sum+=c[i];\rcout\u003c\u003csum\u003c\u003cendl;\rreturn 0;\r}\r F - Distributing Integers ","date":"2020-03-29","objectID":"/abc160/:10:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 给一棵树，对于树上的一个顶点，赋值为1，然后对于已赋值顶点的相邻顶点依次 赋值2,3,4..，求有多少种赋值方案，对于所有的顶点 ","date":"2020-03-29","objectID":"/abc160/:11:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 又是不会做的一题 树的拓扑序计数 + 换根 （感谢出题人和这道题让我认识了“树的拓扑序计数”，然后第二次遇见了“换根”） 对于某个顶点，方案数就是以这个点为根的“树的拓扑序的个数” 树的拓扑序的个数为 $$ {\\frac{n!}{\\prod\\limits_{} ^ {} {num}}} $$ num为每个节点的子节点数（含自己） 小证明： 如果没有限制，则排列组合有n!种 由于子节点要排在父节点的的后面 以根节点为例，它要排在第一个 由于排序是随机的，所以排在第一个的概率为1/num 同理所有的节点作为父节点时都与子节点等概率排序，所以每个都是1/num 全部就是product(num) n!可以直接求 现在要求product(num) 为避免超时，可以用类似于记忆化搜索的思想 先选取一个点为根（以1为例）求每个节点的子节点个数 直接dfs 然后求product(num[1]) 最后换根求不同节点的product(num) 直接dfs 此处换根product(num[i])=product(num[par])*(n-child[i])/child[i] ac代码 //#include\"bits/stdc++.h\"\r#include\u003ciostream\u003e\r#include\u003cvector\u003e\rusing namespace std;\rtypedef long long ll;\r// using pAr = product_as_root;\rconst ll mod = 1e9+7;\rll n;\rll sn[200005];\rll pAr[200005];\rvector\u003cll\u003e G[200005];\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\rvoid dfs_sn(ll u,ll v){\rfor(auto i:G[u]){\rif(i!=v){\rdfs_sn(i,u); sn[u]+=sn[i];\r}\r}\rsn[u]++;\r}\rvoid dfs_cr(ll u,ll v){\rfor(auto i:G[u]){\rif(i!=v){\rpAr[i]=pAr[u]*qpow(sn[i],mod-2,mod)%mod*(n-sn[i])%mod;\rdfs_cr(i,u);\r}\r}\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rll t1,t2;\rfor(ll i=0;i\u003cn-1;i++) {\rcin\u003e\u003et1\u003e\u003et2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdfs_sn(1,0);\r//init\r pAr[1]=1;\rfor(ll i=1;i\u003c=n;i++) pAr[1]=pAr[1]*sn[i]%mod;\rdfs_cr(1,0);\r//factorial\r ll fac=1;\rfor(ll i=2;i\u003c=n;i++) fac=fac*i%mod;\rfor(ll i=1;i\u003c=n;i++){\rcout\u003c\u003cfac*qpow(pAr[i],mod-2,mod)%mod\u003c\u003cendl;\r}\r//for(int i=1;i\u003c=8;i++) cout\u003c\u003cpAr[i]\u003c\u003c\" \";\r return 0;\r}\r have a good day ^_^ ","date":"2020-03-29","objectID":"/abc160/:12:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["anime"],"content":"星际牛仔","date":"2020-03-29","objectID":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/","tags":[],"title":"星际牛仔","uri":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/"},{"categories":["anime"],"content":"《星际牛仔》（カウボーイビバップ；Cowboy Bebop），是日本SUNRISE动画 公司制作的原创电视动画，于1998年10月23日-1999年4月23日在东京电视台和 WOWOW播出，同年夺得第三回神户动画奖的年度最佳电视动画奖，并于2000年 获得日本科幻大会星云奖。 –百度百科 故事背景设定在2071 年。随着超光速航行技术的实现，人类得以在太阳系范围 内方便的自由移动，但是由于设计上的失误，这一技术引发了月球的爆炸，无数 月球碎片被吸引向地球，造成了空前绝后的大灾难。存活下来的人类逃离地球， 并开始在太阳系各地建立家园。 由于这次灾难，国家、政府等权力机构都极为不稳定，治安问题也成为了大难 题。 为了在人力资源不足的情况下抓捕罪犯，有些组织开始允许个人抓捕通缉的罪犯 并换取奖金，“赏金猎人”这个职业也就由此诞生了。–百度百科 ","date":"2020-03-29","objectID":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/:0:0","tags":[],"title":"星际牛仔","uri":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/"},{"categories":["codeforces"],"content":"Codeforces Round #629 (Div. 3)","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"A. Divisibility Problem ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:0:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 求一个数加上多少能被另一个数整除 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:1:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果b|(a+k) 则k=b-a%b注意k=0特判 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t,a,b;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ea\u003e\u003eb;\rcout\u003c\u003c(b-(a%b)==b?0:b-(a%b))\u003c\u003cendl;\r}\rreturn 0;\r}\r B. K-th Beautiful String ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:2:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 一个长度为n的字符串，由n-2个a组成和2个b组成 求所有按字典序排列组合的第k个 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:3:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 只要定位b的位置就行 b的位置是有规律的，模拟这个规律 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rlong long t,n,k;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003ek;\rlong long fi=ceil((sqrt(1+8*k)-1)/2);\rlong long se=fi*(fi-1)/2;\rse=k-se;\rse=n-se; fi=n-1-fi;\rfor(long long i=0;i\u003cn;i++) if(i==fi or i==se) cout\u003c\u003c'b'; else cout\u003c\u003c'a';\rcout\u003c\u003cendl;\r}\r}\r 没开long long WA掉一发 C. Ternary XOR ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:4:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 定义一种异或运算 ai XOR bi = (ai+bi)%3 给一数c，求a,b使得(a XOR b)=c，使得max(a,b)尽可能小 c由0,1，2组成，且首位为2 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:5:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 从左到右遍历 以是否出现过1作为判断条件 第一次出现1时，一边为0，一边为1 之后把大的数填到之前填0的那一边 就能保证max最小 如果没有出现1则2分成1和1 出现后2分成0和2 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint t;\rint n;\rshort up[50005];\rshort down[50005];\rbool one;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rone = false;\rcin\u003e\u003en;\rchar temp1;\rint temp2;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003etemp1;\rtemp2=temp1-'0';\rif(one){\rif(temp2==1){\rup[i]=1;down[i]=0;\r}\rif(temp2==2){\rup[i]=2;down[i]=0;\r}\rif(temp2==0){\rup[i]=0;down[i]=0;\r}\r}\relse{\rif(temp2==1) {\rone=true;up[i]=0;down[i]=1;\r} if(temp2==2){\rup[i]=1;down[i]=1;\r}\rif(temp2==0) {\rup[i]=0;down[i]=0;\r}\r}\r}\rfor(int i=0;i\u003cn;i++) cout\u003c\u003cup[i]; cout\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003cdown[i]; cout\u003c\u003cendl;\r}\rreturn 0;\r}\r D. Carousel ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:6:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 旋转木马的马上有很多图案，给它们涂色，要求相邻不同图案要涂不同的颜色 问最少需要几种颜色，并求涂色方案（注意旋转木马是个环） ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:7:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果所有的图案都相同，只需要一种 如果图案不同则有可能需要2种或3种，但不超过3种 如果必须3种，则涂色可以为1,2,3,1,2,3…（注意最后一个不能与第一个相同）（不一定） 现在验证是否只需要2种 因为不同的图案必须涂不同的颜色 所以以不同的图案为点，用边连起来 判定是否为二分图就行（同种图案涂色不受限，所以不需要考虑同种图案） 还可以通过木马的奇偶性分类讨论 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint q;\rint n;\rint a[200005];\rint color[200005];\rvector\u003cint\u003e G[200005];\rbool dfs(int v,int c)\r{\rcolor[v]=c; for(int i=0;i\u003cG[v].size();i++)\r{\rif(color[G[v][i]]==c) return false; if(color[G[v][i]]==0 \u0026\u0026 !dfs(G[v][i],3-c)) return false; } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=1;i\u003c=n;i++)\r{\rif(color[i]==0) if(!dfs(i,1)) return false; }\rreturn true;\r} int main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003eq;\rwhile(q--){\r//reset TODO\r memset(color,0,sizeof(color));\rfor(int i=0;i\u003c=n;i++) G[i].clear();\rcin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\r//特判\r bool flag=true;\rfor(int i=1;i\u003cn;i++) if(a[i]!=a[i+1]) flag=false; if(a[n]!=a[1]) flag=false;\rif(flag) {\rcout\u003c\u003c1\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003c1\u003c\u003c\" \"; cout\u003c\u003cendl;\r}\relse{\r//preprocess\r for(int i=1;i\u003cn;i++){\rif(a[i]!=a[i+1]) {\rG[i].push_back(i+1);G[i+1].push_back(i);\r}\r}\rif(a[n]!=a[1]) {\rG[n].push_back(1);G[1].push_back(n);\r}\rif(bipartite_graph()){\rcout\u003c\u003c2\u003c\u003cendl;\rfor(int i=1;i\u003c=n;i++) cout\u003c\u003ccolor[i]\u003c\u003c\" \"; cout\u003c\u003cendl;\r}\relse{\rcout\u003c\u003c3\u003c\u003cendl;\rif((n-1)%3==0) {\rfor(int i=1;i\u003cn;i++) cout\u003c\u003c(i%3==0? 3 : i%3 )\u003c\u003c\" \"; cout\u003c\u003c2\u003c\u003cendl; }\relse{\rfor(int i=1;i\u003c=n;i++) cout\u003c\u003c(i%3==0? 3 : i%3 )\u003c\u003c\" \"; cout\u003c\u003cendl; }\r}\r}\r}\rreturn 0;\r}\r E. Tree Queries ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:8:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 给一棵树和几个树上的顶点 问是否存在从根出发的一条简单路径 使得所有的点都在这条路径上或离路径的距离为1 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:9:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果存在，这条路径一定是从根到深度最大的顶点 接下来依次判断这些点是否满足这些条件 对于某个点 求这个点和最深的点的LCA 判断这个点是否是LCA或LCA的子节点 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint V;\rint m;\rconst int maxv=200005;\rconst int max_logv=20;\rint data[maxv];\rint n;\rvector\u003cint\u003e G[maxv];\rint root=0;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i=0;i\u003cG[v].size();i++){\rif(G[v][i]!=p) dfs(G[v][i],v,d+1);\r}\r}\rvoid init(int V){\rdfs(root,-1,0);\rfor(int k=0;k+1\u003cmax_logv;k++){\rfor(int v=0;v\u003cV;v++){\rif(parent[k][v]\u003c0) parent[k+1][v]=-1;\relse parent[k+1][v]=parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u]\u003edepth[v]) swap(u,v);\rfor(int k=0;k\u003cmax_logv;k++){\rif((depth[v]-depth[u])\u003e\u003ek\u00261) v=parent[k][v];\r}\rif(u==v) return u;\rfor(int k=max_logv-1;k\u003e=0;k--){\rif(parent[k][u]!=parent[k][v]){\ru=parent[k][u];\rv=parent[k][v];\r}\r}\rreturn parent[0][u];\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003eV\u003e\u003em;\rint temp1,temp2;\rfor(int i=0;i\u003cV-1;i++){\rcin\u003e\u003etemp1\u003e\u003etemp2;\rG[temp1-1].push_back(temp2-1);\rG[temp2-1].push_back(temp1-1);\r}\rinit(V);\rwhile(m--){\rcin\u003e\u003en;\rint maxdi;\rint maxd=-1e9;\rint temp;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003etemp;\rdata[i]=temp-1;\rif(depth[data[i]]\u003e=maxd) {\rmaxd=depth[data[i]];\rmaxdi=data[i];\r}\r}\r//cout\u003c\u003cmaxdi\u003c\u003cendl;\r bool flag=true;\rfor(int i=0;i\u003cn;i++){\rif(data[i]!=maxdi)\r{\rint foo=lca(maxdi,data[i]);\rif(!(data[i]==foo || foo==parent[0][data[i]])) {\rflag=false;break;\r}\r}\r}\rif(flag) cout\u003c\u003c\"YES\"\u003c\u003cendl; else cout\u003c\u003c\"NO\"\u003c\u003cendl; }\r//cout\u003c\u003clca(2,4)\u003c\u003cendl;\r //for(int i=1;i\u003c=4;i++) cout\u003c\u003cdepth[i]\u003c\u003cendl;\r return 0;\r}\r 因为max_logv开太小，WA了7次，一直停留在第80个测试点（我记得明明还往多了开的，难道是计算失误，还是记忆丧失） F. Make k Equal ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:10:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 给一数列 每次可进行这样的操作 1.把最小的数+1 2.把最大的数-1 求最少需要多少次操作使数列中有k个相等的数 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:11:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 一开始想的是，这个数应该是中位数，然后从它往两边扩散，把两边的数往里压 结果这应该不是最优解 太困了（X）太菜了（√），直接看了别人的题解恍然大悟 最后得到的这k个相同的数一定在数列中（由于两边往里压，中间的数可看成不变，最后的结果一定是压向不变的数） 首先排序 过一遍数列 每次针对一片相同数字域 求以此为目标需要进行的操作数 不断min更新 对于某块相同数字域 遍历过程中维护数字域左边的数量lnum 左边的和lsum 右边的数量rnum 右边的和rsum 这样是便于计算操作数，降低时间复杂度 考虑三种情况 左边压到中间 右边压到中间 两边压到中间 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,k;\rll a[200005];\rmap\u003cll,ll\u003e mp;\rll lsum=0;\rll rsum=0;\rll lnum=0;\rll rnum;\rll re;\rll ans=1e15;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003ek;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003ea[i];\rmp[a[i]]++;\rrsum+=a[i];\r}\r//特判\r for(auto i:mp) if(i.second\u003e=k) {cout\u003c\u003c0\u003c\u003cendl;return 0;}\rrnum=n;\rfor(auto i:mp) {\rrnum-=i.second;\rrsum-=(i.first*i.second); re=k-i.second;\rif(lnum\u003e=re){\rans=min(ans,(i.first-1)*lnum-lsum+re);\r}\rif(rnum\u003e=re){\rans=min(ans,rsum-(i.first+1)*rnum+re);\r}\rif(re\u003e=2){\rans=min(ans,(i.first-1)*lnum-lsum+re+rsum-(i.first+1)*rnum);\r}\rlsum+=(i.first*i.second);\rlnum+=i.second;\r} cout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r} hava a good day ^_^ ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:12:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["GAME"],"content":"杀手2","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["GAME"],"content":"杀手2由IO Interactive开发，2018年发行的潜行刺杀游戏，与羞辱不同的是这是第三人称 杀手2最大的特点是刺杀方法的丰富性 游玩过程中会发现特别多的可能性 里面有一个适合手残党的玩法，就是被敌人盯上时，可以一直藏着，只要等的下去，危险就会解除 剧情很丰富，延续了杀手1 但是剧情太短了 玩一会就完了（指不开辟新的刺杀方式） 地图是分区的，每一块地图也太小了 风景做的很好，但是与NPC的互动太少了 换装式的伪装也是一大特色 通过这种伪装可以派生很多的玩法 吐槽一下一种线下的狙击模式，非常的sb，简直就是4399小游戏搬过来的 ","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/:0:0","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["GAME"],"content":"剧情 游戏剧情衔接《杀手》的剧情，戴安娜为了得到神意秘会的代理人“永恒常量”手中有关47出身来历的一切信息，说服了ICA董事会接受了来自神意秘会的契约：消灭“影子客户”并瓦解他的民兵组织。 根据47曾经在科罗纳多获取的情报，ICA找到了关于民兵组织成员的线索：阿尔玛·雷纳德，肖恩·罗斯的前女友，当过生态恐怖分子并且是一名很有才华的外勤潜入者，目前与她的新搭档奥森·米尔斯躲 藏在新西兰霍克斯湾的一处海滨别墅。 47为搜寻情报而前往调查关于“影子客户”与民兵的线索。 –百度百科 ","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/:1:0","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["android"],"content":"Android Fragment","date":"2020-03-24","objectID":"/android-fragment/","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"生命周期 在containerActivity的布局中放入一个fragment，然后点击按钮，切换成另一个fragment containerActivity的布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".fragment.containerActivity\"\u003e\r\u003cButton\randroid:id=\"@+id/ctnbtn1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"change_fragment\"\randroid:textSize=\"25sp\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.1\" /\u003e\r\u003cFrameLayout\randroid:id=\"@+id/ctn1\"\randroid:layout_width=\"match_parent\"\rapp:layout_constraintTop_toBottomOf=\"@+id/ctnbtn1\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\randroid:layout_height=\"0dp\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r containerActivity.java package com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity {\rprivate Afragment afragment;\rprivate Bfragment bfragment;\rprivate Button ctnbtn1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rctnbtn1 = findViewById(R.id.ctnbtn1);\rctnbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rgetSupportFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).commitAllowingStateLoss();\r}\r});\rafragment = new Afragment();\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment).commitAllowingStateLoss();\r}\r}\r Afragment.java package com.example.test.fragment;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\r}\r}\r fragment_a.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/fatv1\"\randroid:text=\"fragment_a\"\randroid:textSize=\"25sp\"\randroid:gravity=\"center\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.4\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r Bfragment.java和fragment_b.xml与A类似 ","date":"2020-03-24","objectID":"/android-fragment/:1:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"传数据给fragment Afragment.java package com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\"tk\",title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\"tk\"));\r}\r}\r@Override\rpublic void onAttach(Context context) {\rsuper.onAttach(context);\r}\r@Override\rpublic void onDetach() {\rsuper.onDetach();\r}\r}\r 通过这种方法实例化 afragment = Afragment.newInstance(\"hello world\");\r ","date":"2020-03-24","objectID":"/android-fragment/:2:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"fragment的回退栈 fragment_a.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\u003e\r\u003cButton\randroid:id=\"@+id/fabtn1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"change_to_Bfragment\"\randroid:textSize=\"25sp\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.1\" /\u003e\r\u003cButton\randroid:id=\"@+id/fabtn2\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"updata_text\"\randroid:textSize=\"25sp\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.2\" /\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/fatv1\"\randroid:text=\"fragment_a\"\randroid:textSize=\"25sp\"\randroid:gravity=\"center\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.4\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r Afragment.java package com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\"tk\",title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\"Afragment\",\"----------onCreateView--------\");\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\"updated\");\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\"tk\"));\r}\r}\r}\r fragment_b.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/fbtv1\"\randroid:text=\"fragment_b\"\randroid:textSize=\"25sp\"\randroid:gravity=\"center\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.4\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r Bfragment.java package com.example.test.fragment;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rim","date":"2020-03-24","objectID":"/android-fragment/:3:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"传递数据给activity 通过接口回调 Afragment.java package com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate msgclick listener;\rpublic interface msgclick{\rvoid onclick(String s);\r}\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2,fabtn3;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\"tk\",title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Override\rpublic void onAttach(Context context) {\rsuper.onAttach(context);\rlistener = (msgclick) context;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\"Afragment\",\"----------onCreateView--------\");\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn3 = view.findViewById(R.id.fabtn3);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rFragment fragment = null;\rif (getFragmentManager() != null) {\rfragment = getFragmentManager().findFragmentByTag(\"a\");\r}\rif(fragment!=null) {\rgetFragmentManager().beginTransaction().hide(fragment).add(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\relse{\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\"updated\");\r}\r});\rfabtn3.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rlistener.onclick(\"dedsec\");\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\"tk\"));\r}\r}\r}\r containerActivity.java package com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity implements Afragment.msgclick {\rprivate Afragment afragment;\r//private Bfragment bfragment;\r private TextView ctntv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rafragment = Afragment.newInstance(\"hello world\");\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment,\"a\").commitAllowingStateLoss();\rctntv1 = findViewById(R.id.ctntv1);\r}\r@Override\rpublic void onclick(String s) {\rctntv1.setText(s);\r}\r}\r ","date":"2020-03-24","objectID":"/android-fragment/:4:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"Android 属性动画","date":"2020-03-24","objectID":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","tags":["java","xml"],"title":"Android 属性动画","uri":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"},{"categories":["android"],"content":"简单演示 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".anim2Activity\"\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"70dp\"\randroid:id=\"@+id/a2tv1\"\randroid:textSize=\"30sp\"\randroid:text=\"animation_test\"\randroid:gravity=\"center\"\randroid:textColor=\"#FFFFFF\"\randroid:background=\"#AAAAAA\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.widget.TextView;\rpublic class anim2Activity extends AppCompatActivity {\rprivate TextView a2tv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_anim2);\ra2tv1 = findViewById(R.id.a2tv1);\ra2tv1.animate().translationYBy(500).setDuration(2000).start();\r}\r}\r package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.animation.ObjectAnimator;\rimport android.animation.ValueAnimator;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.widget.TextView;\rpublic class anim2Activity extends AppCompatActivity {\rprivate TextView a2tv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_anim2);\ra2tv1 = findViewById(R.id.a2tv1);\r//a2tv1.animate().translationYBy(500).setDuration(2000).start();\r //a2tv1.animate().alpha(0).setDuration(2000).start();\r\r// ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100);\r// valueAnimator.setDuration(2000);\r// valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r// @Override\r// public void onAnimationUpdate(ValueAnimator animation) {\r// Log.d(\"test\",animation.getAnimatedValue()+\"\");\r// Log.d(\"test\",animation.getAnimatedFraction()+\"\");\r// }\r// });\r// valueAnimator.start();\r ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(a2tv1,\"translationY\",1500,200,500,300,1000);\robjectAnimator.setDuration(5000);\robjectAnimator.start();\r}\r}\r ","date":"2020-03-24","objectID":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:0:0","tags":["java","xml"],"title":"Android 属性动画","uri":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"},{"categories":["GAME"],"content":"看门狗2","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["GAME"],"content":"Watch_dogs2是ubisoft于2016年11月发行的角色扮演游戏 骇入系统是其游戏特色 玩了130+小时 看门狗2的这个特色很新颖，但是剧情很平淡，后面的玩法基本与前面重复 难度也不是很高，很快就能通关，dlc就是支线剧情的复制。但是旧金山的风景还是 很不错的，就是地图太小了。线上模式的hack玩的最多，开始被虐，后来找到技巧，虐别人就索然无味了 线上赛车自从玩了GTA5之后真的就无趣了，经常有人莫名其妙退出 经常受到土豆服务器的制约 现在是真的没空玩看门狗3了 ","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/:0:0","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["GAME"],"content":"剧情 《看门狗2》将游戏设定在距离《看门狗》故事发生之后，ctOS由1.0升级成为2.0，同时也获得了许多功能。然而，ctOS并不是像宣传的那样单纯只是为市民服务，它被不法公司，团体和个人用来监视市民，收集并出售他们个人的数据，操纵选举和扰乱社会秩序等等。游戏需要玩家跟随主人公一点一点进入《看门狗2》的庞大电子世界，揭开并粉碎敌人的阴谋。 《看门狗2》的总监表示，游戏开发团队想在这一作上尝试一些新的点子，比如位于旧金山的游戏场景，整体色调更鲜活明亮，再搭配故事的主题、建筑风格、网络世界以及先进科技。在这样的架构中，故事风格不适合艾登‧皮尔斯，因此让马可仕担任主角来叙述故事是很合适的。 –百度百科 ","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/:0:1","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["abc"],"content":"abc159","date":"2020-03-23","objectID":"/abc159/","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"A - The Number of Even Pairs ","date":"2020-03-23","objectID":"/abc159/:0:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (awk语言) $0=$1*--$1/2+$2*--$2/2_\r B - String Palindrome ","date":"2020-03-23","objectID":"/abc159/:1:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) print\u003c\u003e=~/^(.+).\\1$/?Yes:No\r C - Maximum Volume ","date":"2020-03-23","objectID":"/abc159/:2:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) print\u003c\u003e**3/27\r D - Banned K ","date":"2020-03-23","objectID":"/abc159/:3:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) \u003c\u003e;print$.-@$_,$/for grep$.+=++$#$_,glob`dd`\r E - Dividing Chocolate ","date":"2020-03-23","objectID":"/abc159/:4:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题意 一块巧克力由h行w列的方块组成，每个方块为白或黑 你可以对巧克力进行切割，切割只能沿着方块边缘横切或竖切切到底 问最少需要切几刀，使每个独立块都有不多于k个白巧克力方块 ","date":"2020-03-23","objectID":"/abc159/:5:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ","date":"2020-03-23","objectID":"/abc159/:6:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"贪心 枚举 和牛客小白月赛26的A题很像 由于h的数据不大，枚举行的所有可能情况，先考虑横切，横切不够再竖切 考虑竖切时，如果最大的块大于k，就实施竖切 遍历所有情况求最小值 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint h,w,k;\rstring s[12];\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r int coun=0;\rcin\u003e\u003eh\u003e\u003ew\u003e\u003ek;\rfor(int i=0;i\u003ch;i++){\rcin\u003e\u003es[i];\r}\r//特判 //没有特判，用u=0代替 WA for(int i=0;i\u003ch;i++) for(int j=0;j\u003cw;j++) if(s[i][j]=='1') coun++;\rif(coun\u003c=k) cout\u003c\u003c0\u003c\u003cendl;\relse{\rint ans=1e9;\rfor(int u=1;u\u003c(1\u003c\u003c(h-1));u++){\rint x=__builtin_popcount(u);\rint cut_num=x;\rint block[x+1]={0};\rint p=0;\rint mx=0;\rbool flag=true; //没有设置flag WA for(int j=0;j\u003cw;j++){\rfor(int i=0;i\u003ch;i++){\rblock[p]+=s[i][j]-'0';\rmx=max(mx,block[p]);\rif(u\u003e\u003ei\u00261) p++;\r}\r//mx=max(mx,block[p]);\r if(mx\u003ek) {\rif(j==0) { flag=false;break; }\rcut_num++;\rmx=0;\rmemset(block,0,sizeof(block));\rp=0; //没有重置p WA for(int i=0;i\u003ch;i++){ //没有记忆（重新计算） WA block[p]+=s[i][j]-'0';\rmx=max(mx,block[p]);\rif(u\u003e\u003ei\u00261) p++;\r}\r}\rp=0; //没有重置p WA }\rif(flag) ans=min(ans,cut_num);\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\rreturn 0;\r}\r 这道题做了快一个小时，WA了特别多次，每次都WA两三个测试点，主要是细节，WA点在代码中已标注 F - Knapsack for All Segments ","date":"2020-03-23","objectID":"/abc159/:6:1","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题意 给一数列，求对每一可能区间，其子区间内的数和等于s的子区间个数 对所有可能区间求和 ","date":"2020-03-23","objectID":"/abc159/:7:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ","date":"2020-03-23","objectID":"/abc159/:8:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"动态规划 奇妙的动态规划 dp[i][j] = sum(f(left,i)) 当和为 j 时 可以的得到递推式 dp[i][j]=dp[i-1][j] dp[i][j]+=dp[i-1][j-data[i]] 有一个很重要的点在代码中标出 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rll n,s;\rll data[3005];\rll dp[3005][3005];\rconst ll mod=998244353;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003es;\rfor(ll i=1;i\u003c=n;i++) cin\u003e\u003edata[i];\rdp[0][0]=1;\rfor(ll i=1;i\u003c=n;i++) for(ll j=0;j\u003c=s;j++)\r{\rdp[i][j]=dp[i-1][j];\rif(j-data[i]\u003e=0) dp[i][j]+=dp[i-1][j-data[i]];\rif(j==0) dp[i][j]++; //当j-data[i]==0时，a[i]这一个也要算上 dp[i][j]%=mod;\r}\rll ans=0;\rfor(ll i=1;i\u003c=n;i++) ans=(ans+dp[i][s])%mod;\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r}\r 一遍过，芜湖~ have a good day ^_^ ","date":"2020-03-23","objectID":"/abc159/:8:1","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["android"],"content":"Android 数据存储","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["android"],"content":"SharedPreferences sharedpreferences的布局 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".datastorage.sharedPreferencesActivity\"\u003e\r\u003cEditText\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/spet1\"\randroid:hint=\"input\"\randroid:textSize=\"25sp\"\rapp:layout_constraintTop_toTopOf=\"parent\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.1\"\r/\u003e\r\u003cButton\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25sp\"\randroid:text=\"sava\"\rapp:layout_constraintTop_toBottomOf=\"@+id/spet1\"\randroid:layout_marginTop=\"20dp\"\randroid:id=\"@+id/spbtn1\"/\u003e\r\u003cButton\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25sp\"\randroid:text=\"show\"\rapp:layout_constraintTop_toBottomOf=\"@+id/spbtn1\"\randroid:layout_marginTop=\"20dp\"\randroid:id=\"@+id/spbtn2\"/\u003e\r\u003cTextView\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/sptv1\"\randroid:textSize=\"25sp\"\rapp:layout_constraintTop_toBottomOf=\"@+id/spbtn2\"\randroid:layout_marginTop=\"20dp\"\r/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r 输入内容，存储到sharedpreferences,并呈现 package com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.Intent;\rimport android.content.SharedPreferences;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class sharedPreferencesActivity extends AppCompatActivity {\rprivate Button spbtn1,spbtn2;\rprivate EditText spet1;\rprivate TextView sptv1;\rprivate SharedPreferences mysp;\rprivate SharedPreferences.Editor myspe;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_shared_preferences);\rspbtn1 = findViewById(R.id.spbtn1);\rspbtn2 = findViewById(R.id.spbtn2);\rspet1 = findViewById(R.id.spet1);\rsptv1 = findViewById(R.id.sptv1);\r//实例化\r mysp = getSharedPreferences(\"data\",MODE_PRIVATE);\rmyspe = mysp.edit();\rspbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rmyspe.putString(\"name\",spet1.getText().toString());\rmyspe.apply(); //相当于提交\r\r}\r});\rspbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsptv1.setText(mysp.getString(\"name\",\"\"));\r}\r});\r}\r}\r sharedpreferences把数据存在xml文件中 在路径 data\\data\\\u003capplicationId\u003e\\shared_prefs下有一个xml文件 真机要root查看 模拟器直接在终端打开monitor 要查看这个文件可以点击右上角的 pull a file from the device 下载下来 打开之后 File 内部存储 布局和功能几乎与sharedpreferences相同 java文件 package com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rimport java.io.FileInputStream;\rimport java.io.FileOutputStream;\rimport java.io.IOException;\rpublic class fileActivity extends AppCompatActivity {\rprivate Button fibtn1,fibtn2;\rprivate EditText fiet1;\rprivate TextView fitv1;\rprivate final String filename = \"test.txt\";\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_file);\rfibtn1 = findViewById(R.id.fibtn1);\rfibtn2 = findViewById(R.id.fibtn2);\rfiet1 = findViewById(R.id.fiet1);\rfitv1 = findViewById(R.id.fitv1);\rfibtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsave(fiet1.getText().toString());\r}\r});\rfibtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfitv1.setText(read());\r}\r});\r}\rpub","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:0","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["android"],"content":"权限申请 \u003cuses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/\u003e\r\u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/\u003e\r ","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:1","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["nowcoder"],"content":"牛客小白月赛23(部分题解)","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"A 膜法记录 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:0","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 贪心 枚举 集合的整数表示 由于n的数据较小，直接枚举n的所有情况，有2^n种 对于每种情况判断剩下的点列blast能否用完 其实就是贪心思想（把行blast用完，再用列blast） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rchar s[23][100005];\rll t;\rll n,m,a,b;\rll cl[1\u003c\u003c21];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb;\rfor(ll i=0;i\u003c(1\u003c\u003cn);i++) cl[i]=0;\rfor(ll i=1;i\u003c=n;i++) scanf(\"%s\",s[i]+1);\r//memset(cl,0,sizeof(cl));\r for(ll j=1;j\u003c=m;j++) {\rll temp=0;\rfor(ll i=1;i\u003c=n;i++) if(s[i][j]=='*') temp|=(1\u003c\u003ci-1);\rcl[temp]++;\r}\rfor(ll i=1;i\u003c=n;i++)\rfor(ll j=0;j\u003c(1\u003c\u003cn);j++){\rif((j\u0026(1\u003c\u003ci-1))==0) cl[j|1\u003c\u003ci-1]+=cl[j];\r}\rbool ok=false;\rfor(ll i=0;i\u003c(1\u003c\u003cn);i++){\rif(__builtin_popcount(i)\u003c=a and m-cl[i]\u003c=b){\rok=true;break;\r}\r}\rif(ok) puts(\"yes\");\relse puts(\"no\");\r}\rreturn 0;\r}\r 这里用memset会迷之超时，要用for循环 一个神奇的函数 __builtin_popcount(int x) 返回x的二进制1的个数 B 阶乘 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:1","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二分 数论 用二分法获得最小值 检测一个数n的阶乘是否能被p整除 对p进行质因数分解 遍历p的质因数 如果对于所有的质因数 n！被这个质因数整除的个数都不小于p中的个数 那么n！就能被p整除 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll t;\rll p;\rll fac[1000005];\rll num[1000005];\rll tt;\rvoid decompose(ll p){\rtt=0;\rfor(ll i=2;i*i\u003c=p;i++){\rif(p%i==0){\rfac[tt]=i;\rnum[tt]=0;\rwhile(p%i==0) p/=i,num[tt]++;\rtt++;\r}\r}\rif(p\u003e1) {\rfac[tt]=p;num[tt]=1;tt++;\r}\r}\rbool check(ll x){\rfor(ll i=0;i\u003ctt;i++){\rll cnt=0,t=x;\rwhile(t) {\rcnt+=t/fac[i];\rt/=fac[i];\r}\rif(cnt\u003cnum[i]) return false;\r}\rreturn true;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003ep;\rdecompose(p);\rll l=1,r=1e10; //开1e6会wa\r while(l\u003cr){\rll mid=l+r\u003e\u003e1;\rif(check(mid)) r=mid;\relse l=mid+1;\r}\rcout\u003c\u003cr\u003c\u003cendl;\r}\rreturn 0;\r}\r C 完全图 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:2","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二分 图论 规律 很容易能找到规律 要分裂出 x 个连通块，就要拆掉 x*n-(x+1)*x/2 条边 然后用二分找到 x 注意 r 的初始值不大于 n 据说解一元二次方程也可以，我随便写了个，失败了 用python可以防溢出，但是我出现了2.9999999！=3的情况 用c++就要用__int128防止爆long long 不过__int128不能用标准输入输出 一种解决方法是自己写输入输出 但是这题只需要在特定的地方转成__int128就行 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing Int = __int128;\rusing ll = long long;\rll t,n,m;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em;\rll l=0,r=n;\rll mid;\rfor(int i=0;i\u003c10000;i++){\rmid=(l+r)/2;\rif(((Int)mid*n-(1+mid)*(Int)mid/2)\u003c=(Int)m)\rl=mid;\relse\rr=mid;\r}\rcout\u003c\u003cr\u003c\u003cendl;\r}\rreturn 0;\r}\r D 病毒传染 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:3","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 不会 E A+B问题 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:4","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 总共能表示的数有2^32个，每一个数都能找到另一个数与之相加等于答案 ac代码 用PHP写的（求比这更短的代码）（再一次证明了PHP是世界上最好的语言） 4294967296\r F 美丽的序列I 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:5","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 不会 G 树上求和 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:6","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 图论 DFS 求出每条边对于所有的简单路径经过了几次 然后按次数从大到小排序，依次赋值1,2,3… 求遍历次数就是求这条边的左右各有几个点，然后相乘 对于每个点再递归求它的子节点 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n;\rvector\u003cll\u003e p[100005];\rll ch[100005];\rbool visit[100005];\rusing pll=pair\u003cll,ll\u003e;\rvector\u003cpll\u003e vt;\rvector\u003cll\u003e w;\rmap\u003cpll,ll\u003e mp;\rbool cmp(ll a,ll b){return a\u003eb;}\rll dfs(ll k){\rvisit[k]=true;\rll ans=1;\rfor(auto it:p[k]){\rif(!visit[it]){\rans+=dfs(it);\r}\r}\rw.push_back(ans*(n-ans));\rreturn ans;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rll t1,t2;\rfor(ll i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\rp[t1].push_back(t2); ch[t1]++;\rp[t2].push_back(t1); ch[t2]++;\r}\rfor(ll i=1;i\u003c=n;i++) ch[i]--;\rdfs(1);\rsort(w.begin(),w.end(),cmp);\rll i=1;\rll ans2=0;\rfor(auto it:w){\rans2+=it*i++;\r//cout\u003c\u003cit\u003c\u003cendl;\r }\rcout\u003c\u003cans2\u003c\u003cendl;\rreturn 0;\r}\r 用另外一种传入父节点的方法就超时，记忆化搜索也超时 这是TLE/RE代码，不知道为什么错了（对80%），等有空或实力更强一点再看 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rll n;\rvector\u003cll\u003e p[100005];\rll ch[100005];\rusing pll=pair\u003cll,ll\u003e;\rvector\u003cpll\u003e vt;\rvector\u003cll\u003e w;\rmap\u003cpll,ll\u003e mp;\rbool cmp(ll a,ll b){return a\u003eb;}\rll dfs(ll k,ll par){\rif(mp[make_pair(k,par)]!=0) return mp[make_pair(k,par)];\rif(ch[k]==0) {mp[make_pair(k,par)]=0;return 0;} ll ans=0;\rans+=ch[k];\rfor(auto it:p[k]){\rif(it!=par){\rans+=dfs(it,k);\r}\r}\rmp[make_pair(k,par)]=ans;\rreturn ans;\r}\rll cal(ll x,ll y){\rll resx=dfs(x,y);\rll resy=dfs(y,x);\rreturn resx+resy+resx*resy+1;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rll t1,t2;\rfor(int i=0;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\rp[t1].push_back(t2); ch[t1]++;\rp[t2].push_back(t1); ch[t2]++;\rvt.emplace_back(t1,t2);\r}\rfor(int i=1;i\u003c=n;i++) ch[i]--;\rfor(int i=0;i\u003cn-1;i++){\rw.push_back(cal(vt[i].first,vt[i].second));\r}\rsort(w.begin(),w.end(),cmp);\rll i=1;\rll ans2=0;\rfor(auto it:w){\rans2+=it*i++;\r}\rcout\u003c\u003cans2\u003c\u003cendl;\rreturn 0;\r}\r H 奇怪的背包问题增加了 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:7","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二进制 由二进制01串的性质可以发现 如果物品总重量没有2^30就输出impossible 否则从大到小排序，依次增加就可以 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll =long long;\rll t;\rll n;\rll num[100005];\rusing pll=pair\u003cll,ll\u003e;\rint check[100005];\rint main(){\rcin\u003e\u003et;\rwhile(t--){\rvector\u003cpll\u003e vt; //因为这个wa了好久\r cin\u003e\u003en;\rll ans=0;\rll temp;\rfor(ll i=0;i\u003cn;i++){\rcin\u003e\u003etemp;\rnum[i]=(1\u003c\u003ctemp);\rvt.emplace_back(num[i],i);\rans+=num[i];\r}\rif(ans\u003c(1\u003c\u003c30)) puts(\"impossible\");\relse{\rsort(vt.begin(),vt.end(),greater\u003cpll\u003e());\rll ans=0;\rll i=0;\rll rr=(1\u003c\u003c30);\rfor(ll i=0;i\u003cn;i++) check[i]=0;\rwhile(ans!=rr){\rans+=vt[i].first;\rcheck[vt[i].second]=1;\ri++;\r}\r//for(ll i=0;i\u003cn;i++) cout\u003c\u003cvt[i].first\u003c\u003c\" \";\r for(ll i=0;i\u003cn;i++) cout\u003c\u003ccheck[i];\rcout\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r 有个wa点，就是没有清空容器 T_T I 寻找字串 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:8","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 枚举后缀，比较即可 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rvector\u003cstring\u003e vt;\rstring s;\rbool cmp(string s1,string s2){\rreturn s1\u003es2;\r}\rint main(){\rcin\u003e\u003es;\rint len=s.length();\rfor(int i=0;i\u003clen;i++){\rvt.push_back(s.substr(i,len-i));\r}\rsort(vt.begin(),vt.end(),cmp);\rcout\u003c\u003cvt[0]\u003c\u003cendl;\rreturn 0;\r}\r J 最大的差 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:9","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 最大值减最小值 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n;\rint mi=100005;\rint ma=-1;\rcin\u003e\u003en;\rint t;\rfor(int i=0;i\u003cn;i++){\rcin\u003e\u003et;\rmi=min(t,mi);\rma=max(t,ma);\r}\rcout\u003c\u003cma-mi\u003c\u003cendl;\rreturn 0;\r}\r 本次比赛官方说难度对标cf div2 a~c，可是根据大家的做题情况除签到题至少应该d吧 不知道为什么有好多题都迷之超时 总体来说，题目还行 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:10","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["android"],"content":"Android 事件处理机制","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"事件处理 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:0:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"基于监听的事件处理机制 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"匿名内部类 mbt1.setOnTouchListener(new View.OnTouchListener() {\r@Override\rpublic boolean onTouch(View v, MotionEvent event) {\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\"listener\",\"touch\");\rbreak;\r}\rreturn false;\r}\r});\r ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:1","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"事件源所在类（activity类） public class eventActivity extends AppCompatActivity implements View.OnClickListener\r ebt1 = findViewById(R.id.ebt1);\rebt1.setOnClickListener(eventActivity.this);\r @Override\rpublic void onClick(View v) {\rswitch (v.getId()){\rcase R.id.ebt1:\rToast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show();\rbreak;\r}\r}\r ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:2","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"在布局文件中设置 \u003cButton\randroid:id=\"@+id/ebt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"click\"\randroid:textSize=\"20sp\"\rapp:layout_constraintTop_toTopOf=\"parent\"\randroid:layout_marginTop=\"50dp\"\randroid:onClick=\"show\"\r/\u003e\r public void show(View view){ //一定是public void\r switch (view.getId()){\rcase R.id.ebt1:\rToast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show();\rbreak;\r}\r}\r ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:3","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"基于回调的事件处理机制 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".eventActivity\"\u003e\r\u003cButton\randroid:id=\"@+id/ebt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"click\"\randroid:textSize=\"20sp\"\rapp:layout_constraintTop_toTopOf=\"parent\"\randroid:layout_marginTop=\"50dp\"\r/\u003e\r\u003ccom.example.test.Mybotton\randroid:id=\"@+id/mbt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"20sp\"\randroid:text=\"Mybotton\"\randroid:textAllCaps=\"false\"\rapp:layout_constraintTop_toBottomOf=\"@+id/ebt1\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r Mybotton类 package com.example.test;\rimport android.content.Context;\rimport android.util.AttributeSet;\rimport android.util.Log;\rimport android.view.MotionEvent;\rimport android.widget.Button;\rimport androidx.appcompat.widget.AppCompatButton;\rpublic class Mybotton extends AppCompatButton {\rpublic Mybotton(Context context) {\rsuper(context);\r}\rpublic Mybotton(Context context, AttributeSet attrs) {\rsuper(context, attrs);\r}\rpublic Mybotton(Context context, AttributeSet attrs, int defStyleAttr) {\rsuper(context, attrs, defStyleAttr);\r}\r@Override\rpublic boolean onTouchEvent(MotionEvent event) {\rsuper.onTouchEvent(event);\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\"Mybotton\",\"touch\");\rbreak;\r}\rreturn false; //return true即onTouchEvent到此终止\r }\r}\r eventactivity.java package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.MotionEvent;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.Toast;\rpublic class eventActivity extends AppCompatActivity {\rprivate Button ebt1;\rprivate Mybotton mbt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_event);\rmbt1 = findViewById(R.id.mbt1);\rmbt1.setOnTouchListener(new View.OnTouchListener() {\r@Override\rpublic boolean onTouch(View v, MotionEvent event) {\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\"listener\",\"touch\");\rbreak;\r}\rreturn false;\r}\r});\r// ebt1 = findViewById(R.id.ebt1);\r// ebt1.setOnClickListener(eventActivity.this);\r\r}\r// @Override\r// public void onClick(View v) {\r// switch (v.getId()){\r// case R.id.ebt1:\r// Toast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show();\r// break;\r// }\r// }\r\r// public void show(View view){ //一定是public void\r// switch (view.getId()){\r// case R.id.ebt1:\r// Toast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show();\r// break;\r// }\r// }\r\r@Override\rpublic boolean onTouchEvent(MotionEvent event) {\rsuper.onTouchEvent(event);\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\"activity\",\"touch\");\rbreak;\r}\rreturn false;\r}\r}\r 触摸Mybotton触发事件 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:2:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"Android 四大组件之Activity","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"Activity ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:0:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity的生命周期 运行以下代码可以看到activity经历的生命周期 package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.util.Log;\rpublic class lifeCircleActivity extends AppCompatActivity {\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_life_circle);\rLog.d(\"lifecircle\",\"-----onCreate----\");\r}\r@Override\rprotected void onStart() {\rsuper.onStart();\rLog.d(\"lifecircle\",\"-----onStart----\");\r}\r@Override\rprotected void onResume() {\rsuper.onResume();\rLog.d(\"lifecircle\",\"-----onResume----\");\r}\r@Override\rprotected void onPause() {\rsuper.onPause();\rLog.d(\"lifecircle\",\"-----onPause----\");\r}\r@Override\rprotected void onStop() {\rsuper.onStop();\rLog.d(\"lifecircle\",\"-----onStop----\");\r}\r@Override\rprotected void onRestart() {\rsuper.onRestart();\rLog.d(\"lifecircle\",\"-----onRestart----\");\r}\r@Override\rprotected void onDestroy() {\rsuper.onDestroy();\rLog.d(\"lifecircle\",\"-----onDestroy----\");\r}\r}\r 启动这个activity之后 按返回键退出activity 再启动activity,并按主页键或者菜单键 在cache中重新进入activity ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:1:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity之间的跳转 方法有很多 以下是设置点击事件来跳转 private Button bt11;\rbt11 = findViewById(R.id.bt11);\rbt11.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(MainActivity.this , broadActivity.class);\rstartActivity(intent);\r}\r});\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:2:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"隐式intent 目标activity在manifest文件中应这样注册 \u003cactivity android:name=\".implicitIntentActivity\"\u003e\r\u003cintent-filter\u003e\r\u003caction android:name=\"com.example.test.124\"/\u003e\r\u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\r\u003c/intent-filter\u003e\r\u003c/activity\u003e\r 点击事件的设置 bt14 = findViewById(R.id.bt14);\rbt14.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent();\rintent.setAction(\"com.example.test.124\");\rstartActivity(intent);\r}\r});\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:3:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity之间的数据传输 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:4:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"将activity的数据传输到目标activity 发送数据 @Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump);\rjumpbt1 = findViewById(R.id.jumpbt1);\rjumpbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(jumpActivity.this , jump2Activity.class);\rBundle bundle = new Bundle();\rbundle.putString(\"name\",\"henry\");\rbundle.putInt(\"number\",11);\rintent.putExtras(bundle);\rstartActivity(intent);\r//startActivityForResult(intent,0); //写在点击事件里\r\r}\r});\r}\r 接收数据并呈现 @Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump2);\rjump2tv1 = findViewById(R.id.jump2tv1);\rBundle bundle = new Bundle();\rbundle = getIntent().getExtras();\rString name = bundle.getString(\"name\");\rint number = bundle.getInt(\"number\");\rjump2tv1.setText(name+\",\"+number);}\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:4:1","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"启动一个activity,结束后返回结果 jump界面 jump2界面 点击back返回结果（一个toast） jumpactivity package com.example.test;\rimport androidx.annotation.Nullable;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.Toast;\rpublic class jumpActivity extends AppCompatActivity {\rprivate Button jumpbt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump);\rjumpbt1 = findViewById(R.id.jumpbt1);\rjumpbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(jumpActivity.this , jump2Activity.class);\rBundle bundle = new Bundle();\rbundle.putString(\"name\",\"henry\");\rbundle.putInt(\"number\",11);\rintent.putExtras(bundle);\r//startActivity(intent);\r startActivityForResult(intent,0); //写在点击事件里\r\r}\r});\r}\r@Override\rprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\rsuper.onActivityResult(requestCode, resultCode, data);\rToast.makeText(jumpActivity.this,data.getExtras().getString(\"msg\"),Toast.LENGTH_LONG).show() ;\r}\r}\r jump2activity package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.app.Activity;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rpublic class jump2Activity extends AppCompatActivity {\rprivate TextView jump2tv1;\rprivate Button jump2bt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump2);\rjump2tv1 = findViewById(R.id.jump2tv1);\rBundle bundle = new Bundle();\rbundle = getIntent().getExtras();\rString name = bundle.getString(\"name\");\rint number = bundle.getInt(\"number\");\rjump2tv1.setText(name+\",\"+number);\rjump2bt1 = findViewById(R.id.jump2bt1);\rjump2bt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent();\rBundle bundle1 = new Bundle();\rbundle1.putString(\"msg\",\"i'm back\");\rintent.putExtras(bundle1);\rsetResult(Activity.RESULT_OK,intent);\rfinish();\r}\r});\r}\r}\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:5:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"Android 四大组件之Broadcast Receiver","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"Broadcast Receiver ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:0:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"通过LoaclBroadcastManager发送广播并接收广播 点击broadactivity的click,跳转到broad2activity 点击broad2activity的clickme,发送广播 broadactivity接收广播，将abc改成123 broadactivity broad2activity 点击clickme后返回到broadactivity 代码 broadactivity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".broad.broadActivity\"\u003e\r\u003cButton\randroid:id=\"@+id/bcbt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\rapp:layout_constraintTop_toTopOf=\"parent\"\randroid:layout_marginTop=\"40dp\"\randroid:textSize=\"30sp\"\randroid:text=\"click\"/\u003e\r\u003cTextView\randroid:id=\"@+id/bctv1\"\randroid:layout_width=\"wrap_content\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"abc\"\randroid:textSize=\"60sp\"\rapp:layout_constraintBottom_toBottomOf=\"parent\"\rapp:layout_constraintTop_toBottomOf=\"@+id/bcbt1\"\rapp:layout_constraintLeft_toLeftOf=\"parent\"\rapp:layout_constraintRight_toRightOf=\"parent\"\rapp:layout_constraintVertical_bias=\"0.3\"\r/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r broadactivity_java package com.example.test.broad;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\rimport android.content.BroadcastReceiver;\rimport android.content.Context;\rimport android.content.Intent;\rimport android.content.IntentFilter;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class broadActivity extends AppCompatActivity {\rprivate Button bcbt1;\rprivate TextView bctv1;\rprivate Mybroad mybroad;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_broad);\rbcbt1 = findViewById(R.id.bcbt1);\rbctv1 = findViewById(R.id.bctv1);\rbcbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(broadActivity.this , broad2Activity.class);\rstartActivity(intent);\r}\r});\rmybroad = new Mybroad();\rIntentFilter intentFilter = new IntentFilter();\rintentFilter.addAction(\"sss\");\rLocalBroadcastManager.getInstance(broadActivity.this).registerReceiver(mybroad,intentFilter);\r}\rprivate class Mybroad extends BroadcastReceiver{\r@Override\rpublic void onReceive(Context context, Intent intent) {\r//接收到广播要处理的事\r switch(intent.getAction()){\rcase \"sss\":\rbctv1.setText(\"123\");\rbreak;\r}\r}\r}\r@Override\rprotected void onDestroy() {\rsuper.onDestroy();\rLocalBroadcastManager.getInstance(broadActivity.this).unregisterReceiver(mybroad);\r}\r}\r broad2activity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".broad.broad2Activity\"\u003e\r\u003cButton\randroid:id=\"@+id/bc2bt1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\rapp:layout_constraintTop_toTopOf=\"parent\"\randroid:layout_marginTop=\"30dp\"\randroid:textSize=\"30sp\"\randroid:text=\"click me\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r broad2activity_java package com.example.test.broad;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class broad2Activity extends AppCompatActivity {\rprivate Button bc2bt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_broad2);\rbc2bt1 = findViewById(R.id.bc2bt1);\rbc2bt1.setOnC","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:1:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"一些系统操作对应的action ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:2:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"Android 四大组件之Content Provider","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"Content Provider ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:0:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"获取外部应用的信息 以获取通讯录为例 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".contentProviderActivity\"\u003e\r\u003cButton\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/cpbtn1\"\randroid:textSize=\"25sp\"\randroid:text=\"get_contacts\"/\u003e\r\u003cButton\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:id=\"@+id/cpbtn2\"\randroid:text=\"getdata\"\randroid:textSize=\"25dp\"\rapp:layout_constraintTop_toBottomOf=\"@+id/cpbtn1\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r 点击get_contacts获取联系人信息 手机里存储的联系人信息 在manifest里获取权限 \u003cuses-permission android:name=\"android.permission.READ_CONTACTS\" /\u003e\r 利用content resolver获取 package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ContentResolver;\rimport android.database.Cursor;\rimport android.net.Uri;\rimport android.os.Bundle;\rimport android.provider.ContactsContract;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport java.util.HashSet;\rimport java.util.List;\rpublic class contentProviderActivity extends AppCompatActivity {\rprivate Button cpbtn1,cpbtn2;\r//private List\u003cString\u003e contactlist=null;\r\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_content_provider);\rcpbtn1 = findViewById(R.id.cpbtn1);\rcpbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rContentResolver contentResolver = getContentResolver();\rCursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);\rwhile(cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\rString number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\rLog.d(\"tag\",name+\" \"+number);\r//contactlist.add(name+\" \"+number);\r }\rcursor.close();\r//System.out.println(contactlist.toString());\r }\r});\r// \r}\r}\r 获取到的信息 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:1:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"获取系统权限指令大全 点击此处 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:1:1","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"提供自己的应用信息 在sqlite数据库中创建表 package com.example.test;\rimport android.content.Context;\rimport android.database.sqlite.SQLiteDatabase;\rimport android.database.sqlite.SQLiteOpenHelper;\rimport androidx.annotation.Nullable;\rpublic class Myopenhelper extends SQLiteOpenHelper {\rprivate static final String CREATE_TABLE_PERSON = \"create table person (id integer primary key autoincrement,name text,age integer)\";\rpublic Myopenhelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) {\rsuper(context, name, factory, version);\r}\r@Override\rpublic void onCreate(SQLiteDatabase db) {\rdb.execSQL(CREATE_TABLE_PERSON);\r}\r@Override\rpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\r}\r}\r 插入数据，提供content provider package com.example.test;\rimport android.content.ContentProvider;\rimport android.content.ContentValues;\rimport android.content.UriMatcher;\rimport android.database.Cursor;\rimport android.database.sqlite.SQLiteDatabase;\rimport android.database.sqlite.SQLiteOpenHelper;\rimport android.net.Uri;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rpublic class Myprovider extends ContentProvider {\rprivate static final String PACKAGE_NAME = \"com.example.test\";\rprivate static UriMatcher uriMatcher;\rprivate Myopenhelper myopenhelper;\rprivate SQLiteDatabase sqLiteDatabase;\rstatic {\ruriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\ruriMatcher.addURI(PACKAGE_NAME,\"person\",0);\r}\r@Override\rpublic boolean onCreate() {\rmyopenhelper = new Myopenhelper(getContext(),\"database\",null,1);\rsqLiteDatabase = myopenhelper.getWritableDatabase();\rContentValues contentValues = new ContentValues();\rcontentValues.put(\"name\",\"jingjing\");\rcontentValues.put(\"age\",15);\rsqLiteDatabase.insert(\"person\",null,contentValues);\rcontentValues.put(\"name\",\"kakulukia\");\rcontentValues.put(\"age\",15);\rsqLiteDatabase.insert(\"person\",null,contentValues);\rreturn true;\r}\r@Nullable\r@Override\rpublic Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {\rint code = uriMatcher.match(uri);\rswitch (code){\rcase 0:\rCursor cursor = sqLiteDatabase.query(\"person\",null,null,null,null,null,null);\rreturn cursor;\r}\rreturn null;\r}\r@Nullable\r@Override\rpublic String getType(@NonNull Uri uri) {\rreturn null;\r}\r@Nullable\r@Override\rpublic Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {\rreturn null;\r}\r@Override\rpublic int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {\rreturn 0;\r}\r@Override\rpublic int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {\rreturn 0;\r}\r}\r 在manifest注册 \u003cprovider\randroid:name=\".Myprovider\"\randroid:authorities=\"com.example.test\"\randroid:exported=\"true\" /\u003e\r 到此已经提供了自己的应用信息 现在通过点击“get_data”来查询（利用content resolver） package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ContentResolver;\rimport android.database.Cursor;\rimport android.net.Uri;\rimport android.os.Bundle;\rimport android.provider.ContactsContract;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport java.util.HashSet;\rimport java.util.List;\rpublic class contentProviderActivity extends AppCompatActivity {\rprivate Button cpbtn1,cpbtn2;\r//private List\u003cString\u003e contactlist=null;\r\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_content_provider);\rcpbtn1 = findViewById(R.id.cpbtn1);\rcpbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rContentResolver contentResolver = getContentResolver();\rCursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);\rwhile(cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAM","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:2:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"Android 四大组件之Service","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"Service ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:0:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"Service的生命周期 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:1:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"通过启动Service传递数据 在serviceactivity的输入框中输入数据，启动Myservice并传递数据，打印到日志 serviceactivity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\r\u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\rxmlns:app=\"http://schemas.android.com/apk/res-auto\"\rxmlns:tools=\"http://schemas.android.com/tools\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"match_parent\"\rtools:context=\".serviceActivity\"\u003e\r\u003cButton\randroid:id=\"@+id/sbtn1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:text=\"startservice\"\randroid:textSize=\"25sp\"/\u003e\r\u003cButton\randroid:id=\"@+id/sbtn2\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25dp\"\randroid:text=\"stopservice\"\rapp:layout_constraintTop_toBottomOf=\"@+id/sbtn1\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003cButton\randroid:id=\"@+id/sbtn3\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25dp\"\randroid:text=\"bindservice\"\rapp:layout_constraintTop_toBottomOf=\"@+id/sbtn2\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003cButton\randroid:id=\"@+id/sbtn4\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25dp\"\randroid:text=\"unbindservice\"\rapp:layout_constraintTop_toBottomOf=\"@+id/sbtn3\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003cEditText\randroid:id=\"@+id/set1\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\rapp:layout_constraintTop_toBottomOf=\"@+id/sbtn4\"\randroid:textSize=\"20sp\"\randroid:layout_marginTop=\"20dp\"/\u003e\r\u003cButton\randroid:id=\"@+id/sbtn5\"\randroid:layout_width=\"match_parent\"\randroid:layout_height=\"wrap_content\"\randroid:textSize=\"25dp\"\randroid:text=\"syncdata\"\rapp:layout_constraintTop_toBottomOf=\"@+id/set1\"\randroid:layout_marginTop=\"30dp\"/\u003e\r\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\r serviceactivity.java sbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rintent.putExtra(\"data\",set1.getText().toString());\rstartService(intent);\r}\r});\r Myservice.java private String data=\"cat\";\rprivate boolean running=false;\r @Override\rpublic int onStartCommand(Intent intent, int flags, int startId) {\rdata = intent.getStringExtra(\"data\");\r//Log.d(\"tag\",data);\r return super.onStartCommand(intent, flags, startId);\r}\r @Override\rpublic void onCreate() {\rsuper.onCreate();\r//Log.d(\"tag\",data);\r running=true;\rnew Thread(){\r@Override\rpublic void run() {\rsuper.run();\rwhile (running){\rSystem.out.println(data);\rtry {\rsleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}.start();\r}\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:2:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"通过绑定来同步数据 点击bindservice 输入数据，点击syncdata service.java package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ComponentName;\rimport android.content.Context;\rimport android.content.Intent;\rimport android.content.ServiceConnection;\rimport android.os.Bundle;\rimport android.os.IBinder;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rpublic class serviceActivity extends AppCompatActivity implements ServiceConnection {\rprivate Button sbtn1,sbtn2,sbtn3,sbtn4;\rprivate EditText set1;\rprivate Button sbtn5;\rprivate MyService.mybinder binder;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_service);\rsbtn1 = findViewById(R.id.sbtn1);\rsbtn2 = findViewById(R.id.sbtn2);\rsbtn3 = findViewById(R.id.sbtn3);\rsbtn4 = findViewById(R.id.sbtn4);\rset1 = findViewById(R.id.set1);\rsbtn5 = findViewById(R.id.sbtn5);\rsbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rintent.putExtra(\"data\",set1.getText().toString());\rstartService(intent);\r}\r});\rsbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rstopService(intent);\r}\r});\rsbtn3.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rbindService(intent,serviceActivity.this, Context.BIND_AUTO_CREATE);\r}\r});\rsbtn4.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\r//Intent intent = new Intent(serviceActivity.this,MyService.class);\r unbindService(serviceActivity.this);\r}\r});\rsbtn5.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(binder!=null){\rbinder.setdata(set1.getText().toString());\r//System.out.println(MyService.data);\r }\r}\r});\r}\r@Override\rpublic void onServiceConnected(ComponentName name, IBinder service) {\rLog.d(\"service123\",\"connected123\");\rbinder = (MyService.mybinder) service;\r}\r@Override\rpublic void onServiceDisconnected(ComponentName name) {\r}\r}\r Myservive.java package com.example.test;\rimport android.app.Service;\rimport android.content.Intent;\rimport android.os.Binder;\rimport android.os.IBinder;\rimport android.util.Log;\rpublic class MyService extends Service {\rprivate String data=\"cat\";\rprivate boolean running=false;\rpublic MyService() {\r}\r@Override\rpublic IBinder onBind(Intent intent) {\r// TODO: Return the communication channel to the service.\r //throw new UnsupportedOperationException(\"Not yet implemented\");\r //return new Binder();\r return new mybinder();\r}\rpublic class mybinder extends Binder{ //是binder不是 ibinder\r public void setdata(String data){\rMyService.this.data = data;\r}\r}\r@Override\rpublic int onStartCommand(Intent intent, int flags, int startId) {\r//data = intent.getStringExtra(\"data\");\r\r//Log.d(\"tag\",data);\r return super.onStartCommand(intent, flags, startId);\r}\r@Override\rpublic boolean onUnbind(Intent intent) {\rreturn super.onUnbind(intent);\r}\r@Override\rpublic void onCreate() {\rsuper.onCreate();\r//Log.d(\"tag\",data);\r running=true;\rnew Thread(){\r@Override\rpublic void run() {\rsuper.run();\rwhile (running){\rSystem.out.println(data);\rtry {\rsleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}.start();\r}\r@Override\rpublic void onDestroy() {\rsuper.onDestroy();\rLog.d(\"tag\",\"dog\");\rrunning=false;\r}\r}\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:3:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"在manifest里的注册 \u003cactivity\randroid:name=\".serviceActivity\"\randroid:exported=\"true\" /\u003e\r\u003cservice\randroid:name=\".MyService\"\randroid:enabled=\"true\"\randroid:exported=\"true\" /\u003e\r ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:4:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["algorithm","hduoj"],"content":"hduoj1711(kmp)","date":"2020-03-17","objectID":"/hduoj1711kmp/","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Number Sequence ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:0","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Problem Description Given two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 \u003c= M \u003c= 10000, 1 \u003c= N \u003c= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:1","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Input The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 \u003c= M \u003c= 10000, 1 \u003c= N \u003c= 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000]. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:2","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Output For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:3","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Sample Input 2 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 1 3 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 2 1 ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:4","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Sample Output 6 -1 ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:5","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Solution 测一下kmp板子 ac代码 #include\u003ciostream\u003e\rusing namespace std;\rint n,m,t;\rint s[1000005];\rint p[10005];\rint nextt[10005];\rvoid get_next(){\rint i=0,j=-1;\rnextt[0]=-1;\rwhile(i\u003cm){\rif(j==-1 || p[i]==p[j]) nextt[++i]=++j;\relse j=nextt[j]; //!!!\r }\r}\rint kmp(){\rint i=0,j=0;\rwhile(1){\rif(s[i]==p[j]) i++,j++;\relse{\rint t=nextt[j];\rif(t==-1) i++,j=0;\relse j=t;\r}\rif(j\u003e=m) return i-m+1; //根据题目要求返回 if(i\u003e=n) return -1;\r}\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(0);cin.tie(0);\rcin\u003e\u003et;\rwhile(t--){\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003es[i];\rfor(int i=0;i\u003cm;i++) cin\u003e\u003ep[i];\rget_next();\rcout\u003c\u003ckmp()\u003c\u003cendl;\r}\rreturn 0;\r}\r ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:6","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["codeforces"],"content":"Codeforces Round #628 (Div. 2) A~D","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. EhAb AnD gCd ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:0","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一正整数x，求正整数a,b满足gcd(a,b)+lcm(a,b)=x ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:1","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 数论思维题，a=1，b=x-1满足条件 ac代码 #include\u003ciostream\u003e\rusing namespace std;\rint main(){\rint t;\rcin\u003e\u003et;\rwhile(t--) {\rint k;\rcin\u003e\u003ek;\rcout\u003c\u003c1\u003c\u003c\" \"\u003c\u003ck-1\u003c\u003cendl;\r}\rreturn 0;\r}\r B. CopyCopyCopyCopyCopy ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:2","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数列，将数列无限复制，求最长严格单调子序列的个数 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:3","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 计算数列有多少种数字就行 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll =long long;\rll t;\rll n;\rset\u003cll\u003e st;\rll tmp;\rinline ll read(){\rll x=0;ll f=1;char s=getchar();\rwhile(s\u003c'0' or s\u003e'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u003e='0' and s\u003c='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rint main(){\r//freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et;\rwhile(t--){\rst.clear();\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++){\rtmp=read();\rst.insert(tmp);\r} cout\u003c\u003cst.size()\u003c\u003cendl; } return 0;\r}\r C. Ehab and Path-etic MEXs ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:4","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一棵n个节点的树，求边权重的赋值方案（权重为0~n-2互异） 使得max(mex(u,v))最小 其中mex(u,v)为连接顶点u,v的简单路径中“不”包含边权重的最小值 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:5","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 当树为一条链时，随便赋值 否则，树必然有一个顶点的度数为3 所有简单路径中必然经过0和1的边 要让最大值最小，就要让所有简单路径不同时存在0，1，2的边（这样max(mex)=2） 只需要把0，1，2分散在三度顶点的三条边上 其他随便赋值 以第2个样例为例 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rint deg[100005];\rusing pii=pair\u003cint,int\u003e;\rvector\u003cpii\u003e vt;\rbool lis;\r//bool lef;\rint p;\rint main(){\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(0);cin.tie(0);\rlis=true;\rcin\u003e\u003en;\rfor(int i=0,t1,t2;i\u003cn-1;i++){\rcin\u003e\u003et1\u003e\u003et2;\r//if(t1\u003et2) swap(t1,t2);\r deg[t1]++;\rdeg[t2]++;\rvt.emplace_back(t1,t2);\r}\rfor(int i=1;i\u003c=n;i++) {\rif(deg[i]\u003e2){\rlis=false;\rp=i;\rbreak;\r}\r}\rif(lis){\rfor(int i=0;i\u003cn-1;i++) cout\u003c\u003ci\u003c\u003cendl;\r}\relse{\rint a=0,b=3;\rfor(int i=0;i\u003cn-1;i++){\rif((vt[i].first==p or vt[i].second==p ) and (a\u003c3)){\rcout\u003c\u003ca++\u003c\u003cendl;\r}\relse cout\u003c\u003cb++\u003c\u003cendl;\r} }\rreturn 0;\r}\r D. Ehab the Xorcist ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:6","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 Given 2 integers u and v, find the shortest array such that bitwise-xor of its elements is u, and the sum of its elements is v. ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:7","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 如果是3个数，则这3个数可以是u , (v-u)/2 , (v-u)/2 (利用异或性质) 如果是2个数，p，q 则考虑p+q和p^q的关系 利用以下性质可求得p,q 注意题目说的正整数和样例，进行特判 ac代码 #include\u003cbits/stdc++.h\u003e\rusing ll = long long;\rusing namespace std;\rll u,v;\rint main(){\rcin\u003e\u003eu\u003e\u003ev;\rif((v-u)\u00261 || v-u\u003c0) puts(\"-1\");\relse if(v==0 \u0026\u0026 u==0) puts(\"0\");\relse if(v==u) cout\u003c\u003c1\u003c\u003cendl\u003c\u003cu;\relse{\rll p=(v-u)/2;\rll q=u^p;\rif(p+q==v) cout\u003c\u003c2\u003c\u003cendl\u003c\u003cp\u003c\u003c\" \"\u003c\u003cq\u003c\u003cendl;\relse cout\u003c\u003c3\u003c\u003cendl\u003c\u003cu\u003c\u003c\" \"\u003c\u003cp\u003c\u003c\" \"\u003c\u003cp\u003c\u003cendl;\r} return 0;\r}\r E. Ehab’s REAL Number Theory Problem ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:8","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:9","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 不会 F. Ehab’s Last Theorem ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:10","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:11","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:12","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["note","courses"],"content":"二进制编码","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"二进制转十进制 除2取余 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:0","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"十进制转二进制 乘2次幂 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:1","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"小数进制转换 e.g. 3.59375 整数部分3的二进制位11 小数部分0.59375 0.59375*2=1.1875 ———————— 1 0.1875*2=0.375 —————————0 0.375*2=0.75 ——————————0 0.75*2=1.5 ——————————–1 0.5*2=1 ———————————–1 二进制位0.10011 所以3.59375的二进制表示为11.10011 有些小数不能测出现循环 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:2","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"IEEE754标准的浮点数与十进制数的转换 32位和64位标准 通过全1和全0来划定它的表示范围 E.G. ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:3","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"原码 即正常的二进制码（带符号位） ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:4","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码 正数（包括+0）的补码和原码一样 负数（包括-0）的补码在原码的基础上“按位取反，末尾加1” 补码转原码的一种方法 还可以用逆过程法，即减1取反 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:5","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"反码 正数（包括+0）的补码和原码一样 负数（包括-0）的补码在原码的基础上“按位取反” ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:6","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码的加法运算 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:7","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码的减法运算 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:8","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["codeforces"],"content":"Codeforces Round #627 (Div. 3)","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"A. Yet Another Tetris Problem link B. Yet Another Palindrome Problem link C. Frog Jumps link D. Pair of Topics link E. Sleeping Schedule link ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:0","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题意 假设一天有h个小时，DIO一共要睡n次，每次睡ai个小时（按顺序睡觉），每次刚睡醒，就要继续睡觉，一直睡下去，直至睡眠次数耗光。 给定一个一天中的区间[l,r]，如果有一次睡醒时刻在区间内，则这次睡眠为“好睡眠” 对于每次睡眠时间ai,可以选择睡ai小时或ai-1小时 问一开始就进行睡眠的情况下，“好睡眠”的次数最多有几次 ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:1","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题解 动态规划 dp[i][j] i表示已经进行了i次睡眠 j表示现在在时刻j dp表示最大“好睡眠”次数 初始化 ：dp[i][j]=-inf , dp[0][0]=0 分别讨论下面两种情况 to=(j+a[i])%h to=(j+a[i]-1)%h 状态转移方程 ：dp[i+1][to] = max(dp[i+1][to] , dp[i][j] + flag) flag当to在区间内为1，否则为0 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,h,l,r;\rint dp[2005][2005];\rint data[2005];\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(0);cin.tie(0);\rcin\u003e\u003en\u003e\u003eh\u003e\u003el\u003e\u003er;\rfor(int i=0;i\u003cn;i++) cin\u003e\u003edata[i];\r//preprocess\r memset(dp,0xc0,sizeof(dp)); //0xc0c0c0c0 0x3f3f3f3f\r dp[0][0]=0;\rfor(int i=0;i\u003cn;i++)\rfor(int j=0;j\u003ch;j++) // \u003c即可\r {\rint to=(j+data[i])%h;\rdp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u003c=to and to\u003c=r));\rto =(j+data[i]-1)%h;\rdp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u003c=to and to\u003c=r));\r}\rint ans=-1; for(int i=0;i\u003ch;i++)\rans=max(ans,dp[n][i]);\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r 小技巧 inf = 0x3f3f3f3f memset可以用0x3f ninf=0xc0c0c0c0 memset可以用0xc0 F. Maximum White Subtree link ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:2","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题意 给一棵树（比赛当天是植树节！！） 节点有黑的，白的 对于这棵树的某一子图 定义这个子图所有节点的dif=白色节点数-黑色节点数 求每一个节点的最大dif值 ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:3","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题解 深度优先搜索+动态规划 首先考虑以每个节点为父节点的子图的最大dif 然后每个节点的的最大dif=作为父节点的最大dif+作为子节点的最大dif 如何求以每个节点为父节点的子图的最大dif？ 遍历子节点 判断每个子节点以下（作为父节点）是否白色比黑色多，多则累加对应的数值，否则不累加 这样就形成和了dfs 如何求最终的dif？ 作为子节点的部分的dif，可以用该节点的父节点的dif（最终）- 作为父节点的dif 需要判断是否有必要增加“额外部分” 要让该节点的父节点的dif为最终值，需要从根开始，一层层遍历子节点 这样又形成了dfs ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rint dif_orig[200005];\rvector\u003cint\u003e adj[200005];\rint dif_par[200005];\rint ans[200005];\rvoid dfs_par(int u,int par)\r{\rdif_par[u]=dif_orig[u];\rfor(auto v:adj[u])\r{\rif(v!=par)\r{\rdfs_par(v,u);\rdif_par[u]+=max(dif_par[v],0); //如果黑色比白色多，则丢弃 }\r}\r}\rvoid dfs_final(int u,int par,int el)\r{\rans[u]=dif_par[u]+el;\rfor(auto v:adj[u])\r{\rif(v!=par)\r{\rdfs_final(v,u,max(0,ans[u]-max(dif_par[v],0))); //里面的max和上面一样，外面的max判断是否有必要增加其他部分（作为子节点的部分） }\r}\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(0);cin.tie(0);\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++) {\rcin\u003e\u003edif_orig[i];\rif(!dif_orig[i]) dif_orig[i]=-1; //如果是黑色，则白色-黑色=-1 }\rfor(int i=1,u,v;i\u003cn;i++)\r{\rcin\u003e\u003eu\u003e\u003ev;\ru--,v--;\radj[u].emplace_back(v);\radj[v].emplace_back(u);\r}\rdfs_par(0,-1);\rdfs_final(0,-1,0);\rfor(int i=0;i\u003cn;i++)\rcout\u003c\u003cans[i]\u003c\u003c\" \";\rreturn 0;\r}\r ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:4","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["anime"],"content":"ef - a tale of melodies","date":"2020-03-09","objectID":"/ef-a-tale-of-melodies/","tags":[],"title":"ef - a tale of melodies","uri":"/ef-a-tale-of-melodies/"},{"categories":["anime"],"content":"《ef - a tale of melodies.》由日本动画公司SHAFT制作电视动画，并于2008年10月6日开始播放，是动画《悠久之翼》系列的第二季。故事内容由原作游戏《ef - the latter tale.》的第四章及终章改篇而成，终章的修改幅度比较大，加入了一些原创的情节。共12话。 剧情 圣诞节，雨宫优子与火村夕两人在教会里重逢。两人怀缅过去，由雨宫优子开始说过去发生过的种种事情。 广野纮是个高中生兼少女漫画家，每一天度过忙碌的生活。在圣诞节的夜晚，遇到追逐小偷的宫村宫子。两人再次在学校见面后，宫村宫子对广野纮开始产生兴趣，而开始纠缠在广野纮身边。 身为青梅竹马的新藤景看到这种场景而感到焦虑。几个月后的夏天。喜欢电影制作的堤京介，在体育馆看到新藤景的射篮的动作时，想要拍摄以她为主的电影。因为失恋与郁闷而退出社团的新藤景，受到热爱电影的堤京介的影响，慢慢走出阴霾。–百度百科 ","date":"2020-03-09","objectID":"/ef-a-tale-of-melodies/:0:0","tags":[],"title":"ef - a tale of melodies","uri":"/ef-a-tale-of-melodies/"},{"categories":["abc"],"content":"abc158","date":"2020-03-08","objectID":"/abc158/","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"A - Station and Bus ","date":"2020-03-08","objectID":"/abc158/:0:0","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:1","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给一长度为3的，只含AB的字符串，问是否存在相邻两个字符不同的情况 ","date":"2020-03-08","objectID":"/abc158/:0:2","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 签到题 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main()\r{\rstring s;\rcin\u003e\u003es;\rif((s[0]=='A' and s[1]=='A' and s[2]=='A') or(s[0]=='B' and s[1]=='B' and s[2]=='B'))\rcout\u003c\u003c\"No\"\u003c\u003cendl;\relse cout\u003c\u003c\"Yes\"\u003c\u003cendl;\rreturn 0;\r}\r B - Count Balls ","date":"2020-03-08","objectID":"/abc158/:0:3","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:4","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 有蓝球和红球若干，将他们排成一排，不断通过以下操作排列，在尾部加a个蓝球，在尾部加b个红球，问前n个球有多少个蓝球 ","date":"2020-03-08","objectID":"/abc158/:0:5","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 签到题 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r ll a,b,n;\rcin\u003e\u003en\u003e\u003ea\u003e\u003eb;\rll m=n/(a+b);\rll ans;\rif(n\u003e0) ans=m*a;\relse ans=0;\rn-=m*(a+b);\rif(n\u003ea) ans+=a;\relse ans+=n;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r C - Tax Increase ","date":"2020-03-08","objectID":"/abc158/:0:6","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:7","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给俩数a,b，问是否存在整数x使得，floor(x0.08)=a \u0026\u0026 floor(x0.1)=b，若存在，输出满足这种条件的最小数，否则输出-1 ","date":"2020-03-08","objectID":"/abc158/:0:8","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 由于数据不大，遍历x，判断是否满足条件 或者求满足条件的两个区间，判断是否有交集 ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r int l1,r1,l2,r2;\rint a,b;\rcin\u003e\u003ea\u003e\u003eb;\rl1=ceil(a/0.08);\rdouble t;\rt=(a+1)/0.08;\rif(t*0.08==a+1)\rr1=t-1;\relse\rr1=floor((a+1)/0.08);\rl2=ceil(b/0.1);\rt=(b+1)/0.1;\rif(t*0.1==b+1)\rr2=t-1;\relse\rr2=floor((b+1)/0.1);\rbool flag=true;\rint ans;\rif(r1\u003cl2 or r2\u003cl1) flag=false;\relse if(l2\u003e=l1 and r2\u003c=r1) ans=l2;\relse if(l1\u003e=l2 and r1\u003c=r2) ans=l1;\relse ans=max(l1,l2);\rif(flag) cout\u003c\u003cans\u003c\u003cendl;\relse cout\u003c\u003c-1\u003c\u003cendl;\r//cout\u003c\u003cl1\u003c\u003c\" \"\u003c\u003cr1\u003c\u003c\" \"\u003c\u003cl2\u003c\u003c\" \"\u003c\u003cr2;\r return 0;\r}\r D - String Formation ","date":"2020-03-08","objectID":"/abc158/:0:9","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:10","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 对于一个字符串，有三种操作，倒置，在头部添加字符，在尾部添加字符，求最后得到的字符串 ","date":"2020-03-08","objectID":"/abc158/:0:11","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 分别存储前缀和后缀，用一个bool来判断顺序，倒置操作给bool取反。 在头部加，如果是顺序的就加在前缀，其他情况同理。 最后通过bool量来控制输出顺序 （直接模拟也可以） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rstring s;\rint q;\rchar c;\rint f;\rint t;\rstring pre,suf;\rbool order;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r order=true;\rcin\u003e\u003es;\rcin\u003e\u003eq;\rwhile(q--)\r{\rcin\u003e\u003et;\rif(t==1) order^=1; //!!\r else\r{\rcin\u003e\u003ef;\rif(f==1) {\rcin\u003e\u003ec;\rif(order) pre+=c;\relse suf+=c;\r}\relse\r{\rcin\u003e\u003ec;\rif(order) suf+=c;\relse pre+=c;\r}\r}\r}\rif(order)\r{\rreverse(pre.begin(),pre.end());\rcout\u003c\u003cpre\u003c\u003cs\u003c\u003csuf\u003c\u003cendl;\r}\relse\r{\rreverse(suf.begin(),suf.end());\rreverse(s.begin(),s.end());\rcout\u003c\u003csuf\u003c\u003cs\u003c\u003cpre\u003c\u003cendl;\r}\rreturn 0;\r}\r 知识点 1.bool的取反不能flag=-flag，可以用flag^=1 2.string 在的插入函数 e.g. s.insert(s.begin(),c) or s.insert(s.end(),c) 3.string的拼接 s=(string)“aaa\"+\"bbb”; （一定要强制类型转换） s='a'+(string)“kkk”; （string要强制类型转换，char是不能转成string） E - Divisible Substring ","date":"2020-03-08","objectID":"/abc158/:0:12","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:13","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给一个仅由数字组成的字符串和质数p，问有几个子串（连续字符组成的）能够被p整除 ","date":"2020-03-08","objectID":"/abc158/:0:14","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 个人感觉出的特别好的一道题 动态规划+后缀 从最后开始向前遍历每个数 ans+=（以当前数为开头，满足条件的个数） 要求以当前数开头，满足条件的个数，就是个区间问题 这个区间问题可以用后缀来求 当两个后缀模p的余数相等时，这个区间内的数能被p整除（2和5除外） 所以问题转化成求此时的后缀（余数），查询之前和这个余数相等的个数 然后ans+=个数 注意特殊处理一下2和5 以下是对上面结论的证明（实际并不需要严格证明） ac代码 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll=long long;\rint n,p;\rstring s;\rmap\u003cint,int\u003e mp; //存余数和对应的个数 ll ans=0;\rint main()\r{\rios::sync_with_stdio(false); cin.tie(0);\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003ep\u003e\u003es;\rif(p==2 or p==5)\r{\rint pt=p;\rfor(int i=0;i\u003cn;i++)\rif((s[i]-'0')%pt==0) ans+=i+1;\r}\relse\r{\rmp[0]++;\rint num=0;\rint m=1;\rfor(int i=n-1;~i;i--)\r{\rnum=(num+(s[i]-'0')*m)%p;\rans+=mp[num];\rmp[num]++;\rm=(m*10)%p;\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r F - Removing Robots ","date":"2020-03-08","objectID":"/abc158/:0:15","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:16","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 数轴上有n个点，每个点有两个属性（坐标和能够向右移动的距离），随意地激活其中几个点，激活的点必须向右移动该距离，若移动过程中碰到点则那个点被激活，求对于所有的激活情况，最后的结果有多少种 ","date":"2020-03-08","objectID":"/abc158/:0:17","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 动态规划+栈优化 从右往左遍历每个点 给每个点设置一个数值，表示遍历到该点的集合数量（即答案） 判断这个点是否可以覆盖右边的点，可以覆盖，则这个点的数值乘上覆盖点的数值 用栈维护每个遍历的点，如果栈顶没有被覆盖，则栈里面都无需遍历 被覆盖的点就出栈 新的点入栈（因为旧的点被新的点覆盖，集合数已经被新的点记录） 最后遍历一遍栈，累乘数值 ac代码 #include \"bits/stdc++.h\"\rusing namespace std;\rusing ll = long long;\rll n;\rconst ll mod=998244353;\rvector\u003cpair\u003cint,int\u003e\u003e vt; //存输入 stack\u003cpair\u003cint,int\u003e\u003e stk; //将不覆盖的点入栈 ，用栈优化（对于正在检测的点，如果栈顶不满足，则栈里面的都不满足） //存点的坐标（identifier）和扫描到这个点时，它满足的集合数量 int t1,t2;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r ios::sync_with_stdio(false);cin.tie(0);\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\r{\rcin\u003e\u003et1\u003e\u003et2;\rt2+=t1;\rvt.emplace_back(t1,t2);\r}\rsort(vt.rbegin(),vt.rend()); //这种题目几乎都要sort 此处逆序遍历 for(int i=0;i\u003cn;i++)\r{\rll t=1;\r//cout\u003c\u003cstk.empty()\u003c\u003cendl;\r while(!stk.empty() \u0026\u0026 vt[i].second\u003estk.top().first) //遍历栈 注意开区间 {\rt=(t*stk.top().second)%mod;\rstk.pop();\r}\r//cout\u003c\u003ct\u003c\u003cendl;\r stk.push(make_pair(vt[i].first,t+1)); //!!!!! 一定要加1，因为枚举集合数的时候，对于每个点分两种情况（激活和不激活） } ll ans=1;\rwhile(!stk.empty())\r{\rans=(ans*stk.top().second)%mod;\rstk.pop();\r//cout\u003c\u003cans\u003c\u003cendl;\r }\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r} debug了一小时 发现自己手贱，在声明vector的时候给它分配了空间，然后就出现迷之错误 （我一定是有病才会这么做） 感觉自己的思维和英语都退步了 oh shake it 又没有学习android ","date":"2020-03-08","objectID":"/abc158/:0:18","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["GAME"],"content":"光环1","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"halo1是微软于2001年发行的第一人称射击游戏 halo是一个很注重武器选择的游戏，合适的武器会非常高效 ","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/:0:0","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"剧情 2160-2200：早期冲突 这一时期的人类历史充斥着太阳系中各大政府和派别之间的一系列血腥冲突。具有重大历史意义的冲突包括：木卫战役（Jovian Moons Campaign）、雨林争霸（The Rain Forest Wars）和一系列的火星遭遇战。 随着地球上人口过剩和政局动荡的愈演愈烈，许多新的政治运动兴起了。这一时期最值得注意的政治异端运动是“科思洛维克”（“Koslovics”)和 “福里登”（“Frieden”)运动。“科思洛维克”是指新共产主义者的强权领袖福拉德米亚·科思洛夫(Vladimir Koslov）的拥护者，他们致力于回到共产主义的光荣岁月，要消灭公司和资本家的流毒，特别是要肃清近地轨道和地外殖民地。 “福里登”运动是法西斯主义的复兴，该运动起源于反“科思洛维克”情绪，扎根木星殖民地为据点（很大程度上受到了统一德意志共和国企业的支持，这些企业常常成为科思洛维克“工人起义”的对象）。“福里登”的字面意思是“和平”－－这就是说，他们相信只有消灭了“人类的暴君”（oppressors on Terra Firma），才可能达成和平。 2160 三月－六月：木卫战役开始 木星分裂主义者袭击了位于木卫一爱莪（Io）的联合国殖民地总署（United Nations Colonial Advisors），导致了地球军与木星“福里登”部队之间展开了长达三个月的激战。虽然这并非我们太阳系中的第一起武装冲突，但此役成了最为血腥的战斗之一，也被普遍认为是引发接下来的摩擦和军国主义大潮的导火索。 木卫战役也升级了地球各国政府间的紧张关系－－许多国家在太阳系中都建立了殖民地，开始为各自在地外的利益而开战。殖民地战争的持续，使得地球上的紧张关系一触即发，引发了地球本土的数起武装冲突。 2162：雨林争霸 武装冲突横扫南美大陆，科思洛维克、福里登和联合国军之间因为不同的意识形态而开战。而这又加剧了地外冲突。 2163 十二月：在火星的战斗 地球三股主要派别将雨林争霸中燃起的战火烧到了火星上。一系列在火星Argyre Planitia附近对科思洛维克军的闪电战，是第一次非地军队的部署。战斗取得了决定性胜利。作为结果，后来的军事指导战略，惯用大编制的地面部队突袭配合舰船登陆行动。 2164：星际大战 联合国军开始形成大规模集结的格局，终于迎来了第一次真正的星际大战。继火星的军队部署告捷后，大规模的征兵行动和宣传策略极大地鼓舞了UNSC (United Nations Space Command，联合国太空司令部）军队的士气。联合国军挫败了地球上的科思洛维克和福里登军队，接着开始系统地专注于驱逐其在太阳系内其他行星上建立起来的残存势力。在这些局部战争后，福里登和科思洛维克军队被庞大、统一而强大的联合国军悉数剿灭。 2170：膨胀 2160年代的战乱促使人们建立了统一的地球政府。现在，胜利者必须处理不太引人注目却同样严重的威胁：人口过剩和无仗可打的庞大军队。 战后的岁月里，大量人口急剧膨胀；雨林争霸遗留的资源破坏和饥荒更是雪上加霜，世界经济岌岌可危。 2291：超越光速 一支由研究人员、物理学家和数学家组成的团队正在秘密研发“肖恩·藤川”超光速引擎（Shaw-Fujikawa Translight Engine，SFTE），一种驱动太空船穿越辽远星际的特殊手段。 这种新型引擎允许飞船钻入“跃迁空间”（“the Slipstream\"或\"Slipspace”，又称为“迁跃断层空间”）。“断层”一个变通的物理法则下的空间，允许超光速旅行而避免相对论的副作用。超光速旅行并不是瞬间完成的；“短程”的跳跃一般要花两个月，而“长程”的跳跃则能持续六个月甚至更久。 SFTE能生成一个共振场，当与迁跃空间的物理特性结合时，就能大大缩短跨越星际的时间；然而，科学家们也注意到在迁跃空间内部会有暂时的涌流这一奇怪的“变数”。尽管人类科学家都无法确定为何星际旅行所需的时间不是一个常量，但有理论指出在迁跃空间内部存在“漩涡”或“涌动” －－正是这造成了星际旅行所需的时间会有百分之五到十的出入。这一暂时的不一致性使军事战术家和战略家颇为恼火－－这会妨碍许多协同作战的进行。 2310：初潮 地球政府向公众公布了一系列殖民船中的第一艘－－应征者相当踊跃。地球上的状况因为人口过剩而不断恶化，搭乘飞船去外星殖民自然成了诱人的选择。 每艘殖民船都配备了军队人员和护卫舰，这样有助于更好地利用现有的庞大舰队。在异端武装瓦解后，军队正消耗着庞大的军费和物资。 因为超光速旅行在此阶段还十分新鲜而又昂贵，殖民地居民和军队人员都要通过生理和心理的严格测试。原则上，只有最优秀的公民和士兵才能获准去“邻近”的世界殖民。这就是近地殖民地（Inner Colonies）的诞生。 2362：远征号 远征号（The Odyssey）于2362年1月1日发射。作为浩浩荡荡的殖民舰队的领头舰船，远征号满载着部队和地貌改造装置，殖民的矛头直指新世界。人类超越太阳系的边界向外扩展的初潮由此拉开帷幕。 2390：近地殖民地 到了2390年，近地殖民地的殖民化运动正如火如荼。总计有210个人类占据的世界在进行不同程度的地貌改造，而在人类掌控的太空里，人口负担得到了巨大的缓解。 2490：远地殖民地的诞生 扩张仍在马不停蹄地进行，到2490年已经有800多个人类世界遍布银河系猎户座星臂了（这些世界形形色色，既有高度开化的星际要塞，也有偏僻的小定居点）。随着向外扩张的继续，近地殖民地成了政治和经济重镇，虽然他们极其仰赖远地殖民地提供的原材料。 在这一时期，致远星（planet Reach，围绕波江座第五恒星（Epsilon Eridani）运转，正当地球的咽喉要道）成为了UNSC的主要舰船制造厂和训练营地。致远星是战舰和殖民船的主要制造地，也是训练秘密特工和特种部队的所在地。 2525：星盟战争开始 2525年4月20日，与远地殖民地丰饶星（Harvest）的联络中断了。在试图重新建立联络的努力失败后，殖民军总参谋部 (the Colonial Military Administration，CMA）派遣了一艘侦查舰，金羊毛号（the Argo）前去调查。可是金羊毛号一到达丰饶星系，与飞船的联络也突然中断了。 CMA火速派遣了一支三艘战舰组成的战列舰队前往丰饶星。只有战列舰队领航的旗舰大力神号（the Heracles）返回了致远星，战痕累累，伤亡惨重。战舰的指挥官报告说，出现了一艘配备了强大武器的外星战舰，已经践踏了丰饶星，血洗了殖民地（很可能也已摧毁了金羊毛号）。 战列编队很快遭遇了外星战舰，并被紧密跟踪。在两艘战舰被击毁后，大力神号迅速跳出了星系，但因为受损严重，几周之后大力神号才回到了致远星。 地球军立即提升了警报级别，开始积极准备收复丰饶星的作战计划。当年12月，由普雷斯顿·科尔（Preston Cole）中将率领的地球军舰队浩浩荡荡地出发了，如此快地派出如此庞大的远征军，在人类历史上实数罕见。 2525：丰饶星战役 科尔率领的舰队誓报殖民星沦陷之仇，在与外星战舰的遭遇战中告捷－－尽管胜利的代价是损失了科尔军三分之二的有生力量。扭转战局的，只是科尔在最后几分钟，战术上的灵光乍现罢了。 军队回师地球之后，晋升为上将的科尔才获悉：许多外围殖民地已经沦陷，无人生还。科尔开始排兵布阵，准备对入侵者展开截击。地面战和舰船战相当惨烈，战火绵延到了整个远地殖民地。在一次地面遭遇中，人类部队俘虏了一个外星入侵者。在负伤过重死亡之前，人类得知这些外星人自称为“星盟” (the Covenant）。 远地殖民地大屠杀 在接下来的几年中，科尔部遭到了重创，他个人出色的领导力和战略才华也无济于事。这完全是一场实力悬殊的较量，星盟在舰船战中的胜率甚至接近四比一。 到了2535年11月，事实上所有的远地殖民地都已经惨遭星盟屠戮。“科尔协议”（Cole Protocol）作为军事命令确立了如下原则：所有的地球舰船必须确保星盟军不会发现地球。当地球舰船被迫撤退时，必须远离环地航线，甚至不做计算就进行超时空跳跃也在所不惜。 如果存在被星盟俘虏的危险，连“盲跳”都不可行时，船长必须下令船只自毁。此外，强大的舰船人工智能（AI）核心数据也切不可落入敌军之手。所以，科尔条款的部分内容也指出：在紧急状态下，必须转移或销毁舰船人工智能。 2536-2552：近地殖民地之围 星盟的铁蹄已经踏入近地殖民地。多年来的战事渐成定局：人类只是以极其高昂的代价赢得局部战斗的胜利，尤其是在地面行动中。而在太空对战中，人类的失利猝不及防，殖民地就这样接二连三地沦陷了。 2552：致远星的沦陷 星盟军终于到达了致远星－－这个离地球最近的重大军事要塞覆灭了。秋风之墩号（the Pillar of Autumn）巡洋舰，载着最后一个二期 (SPARTAN）斯巴达战士士官长逃出生天，幸免于难。所谓“斯巴达战士”指的是超级特种兵的一种精英作战单位，装备了令人望而生畏的雷神锤装甲。他们是人造的终极兵种。 现在，仅存一个斯巴达战士能与敌对决了。秋风之墩号的舰长雅各布·凯斯（Jacob Keyes）为了遵守“科尔条款”下令进行目的地未知的长程跳跃，希冀着能让星盟追兵始终远离地球。 引擎熄火后，秋风之墩发现自己落入了一个辽远未知的星系。星系中也有一支星盟舰队，他们附近有一个行星般大小的环状结构－－“光晕”。 2552-2553：地球战役 解决了“光晕”的问题之后，秋风之敦号一小部分幸存者和致远星上的部分幸存者合流，经过一系列艰辛的征战回到了地球。然而，此时星盟舰队也大举入侵。人类不得不为自己最后","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/:0:1","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"刺客信条2","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"ac2由育碧蒙特利尔工作室开发 十年前玩的游戏，环境渲染和剧情真的超棒 背景音乐选的十分用心 后来主角ezio也成为了刺客信条系列的标志 刺客信条系列基本延续着刺客和圣殿骑士（现在的abstergo）的斗争，进入animus为追求祖先记忆，寻找金苹果讯息。。。 续作兄弟会的剧情显得有些乏味，不过以组建兄弟会为主线的游戏安排还是很可以的 线上有更丰富的内容 ","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/:0:0","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"剧情 刺客信条2： Desmond在刺客信条1之后本来是准备要处死的，但是Lucy帮他逃了出来，和另外两个现代刺客会合。为了找到伊甸园圣器的下落，Desmond不得不再次进入刺客兄弟会的机器Animus 2.0，这一次他成为了中世纪佛罗伦萨的贵族Ezio Auditore(艾奇奥)。Ezio的父亲和两个兄弟被陷害以后，他在自己的叔叔Mario Auditore(马里奥)的帮助下脱离险境，并且知道自己的家族是刺客家族。于是他开始自己的复仇之路。在复仇的过程中，Ezio慢慢知道了伊甸园圣器的事，并且自己也在慢慢成长，直到有一次圣殿骑士从外地运回威尼斯一件很重要的物品，被Ezio夺到，原来就是金苹果。 于是Ezio发现一个事实，就是在罗马有一件伊甸园圣器“教皇权杖”，它和“金苹果”结合就能打开一些秘密。于是刺客们就前往罗马，一来为了杀死陷害Ezio一家的罗马教皇Rodrigo Borgia(罗德里格·波奇亚)，二来为了抢夺教皇权杖。谁知Rodrigo早有准备，反刺伤了Ezio，抢了他的金苹果。但是Rodrigo没有刺客的血统，结合了教皇权杖和金苹果，但却无法激活。而后Ezio赶来，两人赤手空拳搏斗，Ezio最终胜利，但心一软没有杀死这位陷害自己一家的幕后主使。Rodrigo逃脱。Ezio身为正统刺客，发现自己的血统使两件伊甸园圣器合体激活，打开了罗马教堂地下的一间密室，而密室中出现的影像却是给后来人，也就是给现代正统刺客Desmond的信息。然而回到现代，正在此时，圣殿骑士出现，Lucy和Desmond不得不展开战斗，Desmond通过Animus的血统效应已经学会了Ezio的一些技能，击退了圣殿骑士以后逃离。 刺客信条兄弟会： Desmond和Lucy一行人一直逃到蒙特奥吉欧尼，也就是中世纪Ezio叔叔Mario的庄园。他们开始继续搜索金苹果的下落。回到Animus中，Ezio打败Rodrigo之后载誉归来，回到Mario的庄园，但不想第二天凌晨，Rodrigo的儿子Cesare Borgia带兵攻打庄园，并最终抢夺了金苹果，还杀死了Mario。Ezio也只能带伤逃离。逃离了以后，他孤身一人来到罗马，再次踏上了复仇之路。在Machiavelli(马基雅维利)、Da Vinci(达芬奇)和罗马当地的佣兵、交际花和盗贼的帮助下，Ezio解放了罗马，拿回了金苹果，并最终杀死了Cesare。夺回金苹果后，Ezio把它埋在了罗马大剧场地下的一间密室里。回到现代，Desmond等人立即赶往罗马大剧场遗址，并进入密室，拿到了金苹果。但Desmond一碰到金苹果之后就被控制，不由自主走向Lucy，刺杀了她，随后陷入了昏迷。 刺客信条启示录： Desmond昏迷之后，其他刺客急忙将他放回了Animus，希望通过Animus能让他苏醒。在Animus中，Desmond的意识和肉体已经分离，他的意识遇见了另一位在Animus中游荡的“16号”意识，来自一位现代已经遇害的刺客。16号告诉他只有在Altair(阿泰尔，刺客信条1主角)、Ezio和Desmond完全同步的时候才能让Desmond找回自我。于是Desmond第三次进入了Ezio的记忆。 Ezio为了寻找古老刺客的知识，来到了Altair所在的马西亚夫城堡，发现一间Altair建造的密室。为了打开密室，Ezio必须找到五把Altair留下的钥匙，而这些钥匙已经被当时马可波罗的父亲带去君士坦丁堡埋藏。到了君士坦丁堡之后Ezio卷入了宫廷斗争，还认识了一位有魅力的女人Sofia(索菲亚)。找到五个钥匙之后，Ezio和Sofia一起回到了马西亚夫城堡，打开了密室，见到了Altair的遗体和Altair留下的另一个力量更强大的金苹果。这时金苹果又被激活，Altair、Ezio和Desmond的意识完全同步，Desmond聆听了人类诞生前的文明留下的信息，需要Desmond拯救世界。在那之后，Ezio扔下了身上的武器，把它们和金苹果放在一起留在了密室，结束了自己的刺客生涯。回到现代，Desmond从Animus中苏醒了过来。 刺客信条-余烬：Ezio老年和Sofia生活在佛罗伦萨郊外的一片农庄里，他们有两个孩子。有一天来了一个中国女刺客，为了刺杀残暴的嘉靖皇帝来向Ezio求教。帮助了女刺客之后，有一天Ezio在和Sofia逛街的时候疾病突发，安详仙去。 当我还年轻时，我身怀自由，但我并未看出它的存在，我有大把的时间，可我不懂得珍惜，我还拥有爱，但是从未真实地感受过它，我花了好几十年才明白这三者的真正意义，但现在，在我生命中的黄昏，这些认知逐渐转变成了幸福。爱，自由，时间,曾经随意丢弃的这些，原来正是驱使我前行的动力，而在这三者中，爱尤其宝贵。以此献给你和我们的孩子，以及我们的兄弟姐妹，还有这个赋予我们生命与好奇的广袤世界。索菲亚，我对你的爱永无止境——无论何时都属于你的——艾吉奥·奥迪托雷 Ezio写给Sofia Sorto的遗书 —来自网络 ","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/:0:1","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"刻痕","date":"2020-03-08","objectID":"/%E5%88%BB%E7%97%95/","tags":[],"title":"刻痕","uri":"/%E5%88%BB%E7%97%95/"},{"categories":["GAME"],"content":"《刻痕》是由蓝天使制作组制作的2D动画游戏，于2008年发行，是一款恐怖推理解谜游戏 《刻痕》是国内原创推理悬疑解谜（猎奇）游戏的始祖，国内第一个以R15作为GALGAME正式标准的游戏，也是国内第一个R15类型的推理悬疑解谜（猎奇）类游戏，刻痕系列首次在国内提出了带有悬疑、血腥、恐怖或者猎奇要素的游戏，要以R15作为分类标准的概念，此分类概念在后来在国内整个GALGAME行业业界被得以广泛认可，并被普遍流传使用。 ","date":"2020-03-08","objectID":"/%E5%88%BB%E7%97%95/:0:0","tags":[],"title":"刻痕","uri":"/%E5%88%BB%E7%97%95/"},{"categories":["GAME"],"content":"波斯王子","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["GAME"],"content":"波斯王子 prince of persia是ubisoft于1989年发行的一款单机游戏 波斯王子有好多部，前3部是一个完整的故事，后面则是一些衍生 这是我2010年玩的游戏，pop1通关了4遍 作为上个世纪的游戏，画质不能与现在的3A大作比 但是，有一说一画质也不差 环境的渲染也特别棒，很符合故事背景，有很多细节 游玩的时候不禁会让人驻足联想 剧情真的很不错，以时间倒流作为主要技能是很大的创新 也增加了游玩的乐趣 值得一提的是，据官方称，这个游戏有六百多种动作 按键的组合确实可以打出很多不同的动作，但前期在战斗的时候基本只需要靠几个动作 pop2应该是最难的一部，小boss血量巨厚 如果我没记错的话，pop3应该是加入了刺杀系统，在当时是一个很大的创新，而且感觉还不错 对于boss来讲，要一遍过还挺难 黑暗王子的20倍攻击力用的太爽了 pop的跑酷系统在当时做的着实优秀 ","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/:0:0","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["GAME"],"content":"游戏剧情 很多人都认为，时间就像一条河流，永远朝着一个方向不断的前进。 印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，并带走了时间女皇的遗物——时之沙漏和时之匕首。 后来，为了将这两件宝物据为己有，以达到长生不老的目的，维瑟尔背叛了穆罕默德。他怂恿波斯国王沙拉曼攻打印度，并承诺作为内应会打开印度的城门。战争结束，沙拉曼得到了时之沙漏，并且俘虏了印度国的公主法拉。而波斯王子由于在战争中的杰出表现，得到了他的第一件战利品——时之匕首。 波斯大军凯旋在阿扎德苏丹皇宫暂时停留时，心怀怨恨的维瑟尔诱惑波斯王子用匕首打开时之沙漏，释放的时之砂瞬间吞噬了整个皇宫，并且将沙拉曼变成了砂之怪物。 王子不得已杀死了自己的父亲，在悲痛欲绝中，逃脱的印度公主法拉告诉王子，只要将时之匕首重新插进时之沙漏，那么时间就会倒退，回到一切的开始。于是王子和法拉开始了他们的冒险。 随着冒险的不断深入，王子和法拉的情感也在发生微妙的变化。最后，法拉悄悄的带着时之匕首离开了王子。王子找到了法拉，但却眼睁睁的看着法拉坠楼身亡。哀伤的王子夺回了匕首并将其插进了沙漏里。 伴随着维瑟尔绝望的呼叫，时间倒退到了波斯军队进攻印度之前。保留着记忆的王子在进攻的前夜悄悄的潜进了公主法拉的卧室，告诉了她一切，包括维瑟尔的背叛。被揭穿的维瑟尔恼羞成怒，想要杀掉法拉嫁祸给王子，但被王子消灭了。后来，王子劝说他的父亲沙拉曼撤走了军队，一切好像都恢复了平静。但是谁也没有料到的是，王子的命运已经被诅咒：任何使用过时之匕首的人，只有死路一条。 “因为王子使用了时之匕首破坏了时间的平衡。而达哈卡就是为了恢复时间的平衡而诞生的，他就像时间一样是不可战胜的。达哈卡会像影子一样追杀着王子，直到王子的生命走到尽头。” 王子是从一位盲眼老人那里得到了自己的命运被诅咒这个消息的。为了改变自己悲惨的命运，王子打算去时之岛，回到过去，回到时间女皇制造时之沙的那一刻，去阻止时之沙的诞生。 历经艰难的王子终于到达了时之岛，并且通过岛上的时间传送点回到了过去。在那里，王子遇到了一位名叫凯琳娜的红衣少女。凯琳娜帮助了王子，她告诉了王子如何去打开时间女皇所在房间的门的机关。 在冒险的过程中，一个神秘的黑衣人不时在王子周围出现，不知是敌是友。更让人感到诡异的是，最后时间的守护者达哈卡突然在王子和黑衣人的面前出现，但是达哈卡却杀掉那个黑衣人，然后没有理会王子就走了！纳闷的王子按照凯琳娜的帮助打开了时间女皇房间的大门，却又愕然发现原来凯琳娜就是时间女皇！怨愤的凯琳娜告诉王子，她之所以帮助王子，就是想让王子在打开大门的过程中被那些机关杀死，或者被时间守护者达哈卡杀死。原来凯琳娜也通过时间线预知到了自己的命运：她将会被波斯王子亲手杀死！同样为了改变自己悲惨的命运，时间女皇和王子展开了一场生死战，最后王子逼不得已只好杀掉了凯琳娜！ 凯琳娜在临死之前告诉王子：没有人能改变自己的命运，你也会像我一样去奋力，但你也会像我一样死去！随后，凯琳娜的尸体迸发出了金色的光芒。 王子通过时间传送点回到了杀死父亲之前。本以为一切都结束的王子突然发现时间的守护者达哈卡仍然在追杀他。这时王子才想起来，凯琳娜死后那些金色的光芒就是时之沙！（王子本以为时之沙是时之女皇凯琳娜制造的，杀死凯琳娜就可以阻止时之沙的诞生，但事实是时之沙的诞生正是因为王子杀死了凯琳娜，时之沙就是凯琳娜死后尸体变成的）绝望的王子被达哈卡困在了一个地下墓穴里。就在万念俱灰之时，墙壁上的文字吸引了王子的注意。 根据文字记载：当年印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，在夺取时之沙漏的过程中，穆罕默德不幸被时之守卫杀死，但幸运的是，一件黑色的面具让他有了第二次机会…… 就像在黑暗中看到了一丝曙光一样，王子暂时摆脱了达哈卡的追杀，去寻找那件黑色面具。终于在时之岛的尽头，王子找到了黑色面具。戴上了面具的王子回到了他刚到时之岛的那一刻，并且变成了一个黑衣人——原来在他冒险的过程中时隐时现的黑衣人其实就是他自己。 又经过一番努力，王子最后阻止了自己被达哈卡杀掉（本来达哈卡杀掉了黑衣人，但王子没有让这件事情发生，达哈卡转而杀掉了原来的王子），王子又变回了原来的样子。由于知道了接下来将要发生的事情，王子决定利用时间传送点把时间女皇凯琳娜带到之前。这样即使凯琳娜死了时之沙也不会威胁到自己。变身回来的王子成功的把凯琳娜带到了之前，但是时间的守护者达哈卡再度现身，只不过这次他的目标换成了凯琳娜。这是理所当然的，凯琳娜本来不属于这个时代，为了维护时间的平衡，达哈卡自然把矛头对准了她。因为不忍心凯琳娜就这样被达哈卡杀死，王子利用从过去带回来的一把水之刃（此刀可以伤害到达哈卡），与达哈卡展开了一场肉搏战。 最后在凯琳娜和王子的配合下，达哈卡居然奇迹般的被消灭了。胜利的王子打算带着凯琳娜一起回到他的故乡——波斯的巴比伦城，想从此过着平静的生活。但此时的巴比伦城正被战火所蹂躏……盲眼老人的声音仍在萦绕在王子心头：你不可能改变自己的命运，没有任何人可以。 几个星期后，王子带着凯琳娜离开了时之岛回到了他故乡巴比伦城，却发现整个巴比伦城陷入一片火海中。震惊和愤怒的王子不敢相信眼前的一切，但随后他的船就被飞来的火球打翻，并且和凯琳娜失散。 昏迷的凯琳娜被侵略军带到了巴比伦皇宫里。王子紧随其后想要去救她。在皇宫中，愤怒的王子不幸被敌人擒住，但他却愕然发现侵略军的首领居然是那个“已经被自己杀死的”邪恶法师维瑟尔！而维瑟尔居然又不认识自己？原来，当王子把时间女皇凯琳娜带到之前的一霎那，历史就已经发生了改变：由于没有时之沙，维瑟尔也就不会去背叛穆罕默德，也就没有了波斯进攻印度的历史，维瑟尔也就不会认识王子，当然也不会被王子杀死了。 历史已经改变，但依然改变不了维瑟尔邪恶的欲望。 多年以前，印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，与原先的历史不同，他们只找到了一把时之匕首，至于传说中的时间女皇和时之沙则没有任何存在过的痕迹。已经对时之沙快要放弃的维瑟尔却突然发现时之匕首在最近几个星期变得活跃了起来，维瑟尔很快明白了究竟发生了什么事情：时间女皇来到了之前！被长生欲望熏昏了头脑的维瑟尔杀死了穆罕默德，囚禁了印度公主法拉，控制了印度的军队来进攻巴比伦城！企图寻找时间女皇！时间女皇凯琳娜终于落在了维瑟尔手中！残忍的维瑟尔用时之匕首杀死了凯琳娜，释放出了时之砂，他又将匕首插进自己的身体里，随后变成了一个金黄色的怪物——维瑟尔终于达到了他长生不老的愿望。整个巴比伦城被时之沙吞没，那些侵略军全部被感染到了时之砂，变成了沙之怪物，就连王子自己的手臂也被时之砂侵入。危急时刻，王子挣脱了束缚，抢走了时之匕首，离开了巴比伦皇宫。时之沙唤起了王子最大的敌人…… 被时之沙感染的王子感觉到体内产生另一个邪恶的人格——黑暗王子。黑暗王子狡猾，残忍，对弱者没有同情心，但在冒险的时候王子却需要变身成黑暗王子来渡过难关。 在这种奇怪的组合下，王子又遇到了自己爱慕的印度公主法拉。法拉被维瑟尔囚禁后也被带到了巴比伦城。后来法拉在时之沙的混乱中逃脱，遇到了游荡在巴比伦城的王子。起初法拉对波斯王子的双重身份深感怀疑，但在随后的冒险中逐渐与王子重新建立了信任和友情（法拉再次遇见王子的时候也和维瑟尔一样不认识他了）。但在冒险的过程中，黑暗王子的感染变得越来越严重，这让王子本身深感不安。不幸的是，冒失的法拉又被维瑟尔抓住，而王子被打入了一个黑暗的深洞里。 最后，在巴比伦城黑暗的地下宫殿里，王子找到了他父亲波斯王沙拉曼的尸体。悲痛的王子拿起父亲的宝剑，抑制住了邪恶的黑暗王子的意识，决心找维瑟尔复仇。 在巴比伦的空中花园，左手持波斯帝王宝剑，右手持时之匕首的王子与维瑟尔展开了一场决战！胜利的王子将时之匕首插进了维瑟尔的心脏，彻底的终结了这个邪恶的灵魂。 已经变成时之沙的凯琳娜再度幻化成人形来跟王子告别：这个世界本不属于我，自有我所归属的世界……王子将时之匕首交给凯琳娜，凯琳娜化做时之砂，向远方飘散而去。 凯琳娜消失之后，黑暗王子从王子的内心世界中分裂出来，企图夺走王子的一切，但王子走出内心的阴霾，最终在虚幻的世界中消灭了黑暗王子。 时之砂消逝，邪恶力量破灭，波斯帝国的子民为王子所拯救，一切都结束了。 在巴比伦的空中花园，王子再次向法拉讲起了那个时间的故事。–百度百科 ","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/:0:1","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["abc"],"content":"abc157","date":"2020-03-02","objectID":"/abc157/","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"A - Duplex Printing 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:0","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 每一页正反两面可以分别写一个数，问有n个不同的数可以写几页 ","date":"2020-03-02","objectID":"/abc157/:0:1","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 简单模拟 ac代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main()\r{\rint a;\rcin\u003e\u003ea;\rif(a\u00261)\rcout\u003c\u003ca/2+1\u003c\u003cendl;\relse\rcout\u003c\u003ca/2;\rreturn 0;\r}\r B - Bingo 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:2","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 有一个3*3的网格填满数字，接下来给出一些数字，如果网格中有，就标记。 问是否存在一行或一列或对角线满足它们都被标记 ","date":"2020-03-02","objectID":"/abc157/:0:3","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 由于数据不是很大，所以暴力模拟 ac代码如下 #include\u003ciostream\u003e\rusing namespace std;\rbool b[3][3];\rint main()\r{\rint d[3][3];\rint n;\rfor(int i=0;i\u003c3;i++)\rfor(int j=0;j\u003c3;j++)\rcin\u003e\u003ed[i][j];\rcin\u003e\u003en;\rint t;\rwhile(n--)\r{\rcin\u003e\u003et;\rfor(int i=0;i\u003c3;i++)\rfor(int j=0;j\u003c3;j++)\r{\rif(d[i][j]==t)\r{\rb[i][j]=true;\rbreak;\r}\r}\r}\rbool flag=false;\rfor(int i=0;i\u003c3;i++)\r{\rif(b[0][i]== true and b[1][i]==true and b[2][i]==true) {\rflag=true;\rbreak;\r}\r}\rfor(int i=0;i\u003c3;i++)\r{\rif(b[i][0]== true and b[i][1]==true and b[i][2]==true) {\rflag=true;\rbreak;\r}\r}\rif(b[0][0]==true and b[1][1]==true and b[2][2]==true) {\rflag=true;\r}\rif(b[0][2]==true and b[1][1]==true and b[2][0]==true)\r{\rflag=true;\r}\rif(flag) cout\u003c\u003c\"Yes\"\u003c\u003cendl;\relse cout\u003c\u003c\"No\"\u003c\u003cendl;\rreturn 0;\r}\r C - Guess The Number 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:4","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 给一个数位n，和若干个条件，条件类型为ai位必须是数字bi，求满足这些条件的最小n 位数，不满足输出-1 ","date":"2020-03-02","objectID":"/abc157/:0:5","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 数据很小，简单模拟，有很多的细节，注意一位数、前导0等特殊情况 由于边打代码边想，所以代码很乱 ac代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rbool use[3];\rint main()\r{\rint d[3];\rint n,m;\rcin\u003e\u003en\u003e\u003em;\rint s,c;\rbool flag=true;\rfor(int i=0;i\u003cm;i++)\r{ cin\u003e\u003es\u003e\u003ec;\rs--;\rif(n!=1 and s==0 and c==0)\r{\rflag=false;\rbreak;\r}\relse if(s\u003en)\r{\rflag=false;\rbreak;\r}\relse if(use[s] and c!=d[s])\r{\rflag=false;\rbreak;\r}\relse\r{\rd[s]=c;\ruse[s]=true;\r}\r}\rif(n!=1 and !use[0]) {\rd[0]=1;\rfor(int i=1;i\u003cn;i++)\r{\rif(!use[i]) d[i]=0;\r}\r}\relse\r{\rfor(int i=0;i\u003cn;i++)\r{\rif(!use[i])\rd[i]=0;\r}\r}\rif(!flag) cout\u003c\u003c-1\u003c\u003cendl;\relse {\rfor(int i=0;i\u003cn;i++)\r{\rcout\u003c\u003cd[i];\r}\rcout\u003c\u003cendl;\r}\r//cout\u003c\u003cuse[2]\u003c\u003cendl;\r return 0;\r}\r D - Friend Suggestions 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:6","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 有n个人和两种关系（双向的）friendship 和 blockship 定义：一个人为另一个人的friend candidate 当且仅当满足他们没有这两种关系且他们之间存在着friendship的传导链 问每个人的friend candidate数量 ","date":"2020-03-02","objectID":"/abc157/:0:7","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 由于需要friendship传导链，又存在friendship的双向关系，所以考虑并查集 再遍历一遍信息，如果是直接的friendship和blockship关系就减掉这个人（数量减1） （需要计算集合元素个数） ac代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,m,k;\r//union find\rint par[100005]; int rankk[100005]; int sizz[100005];\rint ans[100005];\rint a[100005];\rint b[100005];\rint c[100005];\rint d[100005];\rvoid init(int n) {\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} int find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); } void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y,sizz[y]+=sizz[x]; else\r{\rpar[y]=x;\rsizz[x]+=sizz[y];\rif(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\rios::sync_with_stdio(0);cin.tie(0);\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em\u003e\u003ek;\rinit(n);\rfill(sizz,sizz+n,1);\rfor(int i=0;i\u003cm;i++)\r{\rcin\u003e\u003ea[i]\u003e\u003eb[i];\r}\rfor(int i=0;i\u003ck;i++)\r{\rcin\u003e\u003ec[i]\u003e\u003ed[i];\r}\rfor(int i=0;i\u003cm;i++)\r{\runite(a[i],b[i]);\r}\rfor(int i=1;i\u003c=n;i++)\r{\rans[i]=sizz[find(i)];\r}\rfor(int i=0;i\u003cm;i++)\r{\rif(same(a[i],b[i]))\r{\rans[a[i]]--;\rans[b[i]]--;\r}\r}\rfor(int i=0;i\u003ck;i++)\r{\rif(same(c[i],d[i]))\r{\rans[c[i]]--;\rans[d[i]]--;\r}\r}\rcout\u003c\u003cans[1]-1;\rfor(int i=2;i\u003c=n;i++)\r{\rcout\u003c\u003c\" \"\u003c\u003cans[i]-1;\r}\rcout\u003c\u003cendl;\rreturn 0;\r}\r E - Simple String Queries 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:8","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 给一个只有小写字母的字符串s，和两种操作 将ai下标的字符替换成bi 查询l到r区间内有多少个不同的字母，输出结果 ","date":"2020-03-02","objectID":"/abc157/:0:9","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 数据太大，不能简单模拟 用合理的数据结构 用26个集合存储有这个字母对应的下标 对于查询区间，遍历26个集合，查询这个区间是否存在该字母（如果存在 ans++） 只需要对每个集合二分搜索左边界的标号，如果这个标号在右边界内，即存在 ac代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n,q;\rstring s;\rset\u003cint\u003e st[27];\rint main()\r{\rios::sync_with_stdio(false);cin.tie(false);\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rcin\u003e\u003es;\rcin\u003e\u003eq;\rfor(int i=0;i\u003c26;i++)\r{\rst[i].insert(n); //防止使用lower_bound时集合为空 }\rfor(int i=0;i\u003cn;i++)\r{\rst[s[i]-'a'].insert(i);\r}\rint t;\rfor(int i=0;i\u003cq;i++)\r{\rcin\u003e\u003et;\rif(t==1)\r{\rint a;char b;\rcin\u003e\u003ea\u003e\u003eb;\rst[s[a-1]-'a'].erase(a-1);\rst[b-'a'].insert(a-1);\rs[a-1]=b;\r}\relse\r{\rint l,r;\rcin\u003e\u003el\u003e\u003er;\rint ans=0;\rfor(int i=0;i\u003c26;i++)\r{\rauto it=st[i].lower_bound(l-1);\rif(*it\u003c=r-1) ans++;\r}\rcout\u003c\u003cans\u003c\u003cendl;\r}\r}\rreturn 0;\r}\r F - Yakiniku Optimization Problem 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:10","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 平面上有n个点，每个点有一个属性ci，坐标上至少存在一个点使得这个点到其中k个点 的距离*ci（只对k个点中的一点）的值的最大值最小 输出最小值 ","date":"2020-03-02","objectID":"/abc157/:0:11","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 有趣的计算几何 很难通过找到点来求最小值 很常见的做法是用二分法 区间的值为“最大值“ 每一次检查满足“最大值”的点是否超过k个 超过则将最大值减小 否则将最大值增大（理论上直到满足k个点） 通过精度来停机 怎样检查？ 每个点的属性=当前“最大值” / ci 以点为圆心，每个点的属性为半径，每两个圆可能存在交点 遍历每个点，如果交点在某个点的属性范围内，这个点也满足条件 遍历所有情况，求最多有多少个点满足条件 以此来检查是否超过k 注意点 1.只有一个点的特判 2.要有eps，而且eps不能太大也不能太小 3.为避免重复计算，j从i开始，但不能从i+1开始，因为有可能目标点就在某一点上 从i+1开始会wa掉1个测试点 ac代码如下 #include \u003cbits/stdc++.h\u003e\rusing namespace std;\rint n, k;\rdouble x[65], y[65], c[65], r[65];\rdouble eps = 1e-8; //!!!\r\rdouble dist(pair\u003cdouble, double\u003e p, pair\u003cdouble, double\u003e q) {\rdouble xx = (p.first - q.first)*(p.first - q.first);\rdouble yy = (p.second - q.second)*(p.second - q.second);\rreturn sqrt(xx + yy);\r}\rvector\u003cpair\u003cdouble, double\u003e\u003e circle_circle_intersection(double x1, double y1, double r1, double x2, double y2, double r2) {\rvector\u003cpair\u003cdouble, double\u003e \u003e ans;\rdouble d = dist(make_pair(x1, y1), make_pair(x2, y2));\rif (d \u003e r1 + r2) {\rreturn ans;\r}\rif (x1 == x2 \u0026\u0026 y1 == y2) {\rans.push_back(make_pair(x1, y1)); return ans;\r}\rif (d \u003c abs(r1 - r2)) {\rans.push_back(make_pair(x1, y1)); return ans;\r}\rdouble a = (r1*r1 - r2*r2 + d*d)/(2*d);\rdouble h = sqrt(r1*r1 - a*a);\rdouble x3 = (x2 - x1)*(a/d) + x1;\rdouble y3 = (y2 - y1)*(a/d) + y1;\rans.emplace_back(x3 + h*(y2 - y1)/d, y3 - h*(x2 - x1)/d);\rans.emplace_back(x3 - h*(y2 - y1)/d, y3 + h*(x2 - x1)/d);\rreturn ans;\r}\rint check(double t) {\rint ans = 0;\rfor (int i = 0; i \u003c n; i++) {\rr[i] = t/c[i];\r}\rfor (int i = 0; i \u003c n; i++) {\rfor (int j = i; j \u003c n; j++) { //!!!\r vector\u003cpair\u003cdouble, double\u003e \u003e pts = circle_circle_intersection(x[i], y[i], r[i], x[j], y[j], r[j]);\rfor (auto p: pts) {\rint cnt = 0;\rfor (int k = 0; k \u003c n; k++) {\rif (dist(p, make_pair(x[k], y[k])) \u003c= r[k] +eps) cnt++;\r}\rans = max(ans, cnt);\r}\r}\r}\rreturn ans;\r}\rint main() {\rios::sync_with_stdio(0); cin.tie(0);\rcin \u003e\u003e n \u003e\u003e k;\rif (k == 1) {\rcout \u003c\u003c \"0\\n\"; exit(0);\r}\rfor (int i = 0; i \u003c n; i++) {\rcin \u003e\u003e x[i] \u003e\u003e y[i] \u003e\u003e c[i];\r}\rdouble l = 0, r = 100000000;\rwhile(r-l\u003e=1e-8)\r{\rdouble mid = (l + r)/2;\rif (check(mid) \u003e= k) {\rr = mid;\r} else {\rl = mid;\r}\r}\rcout \u003c\u003c fixed \u003c\u003c setprecision(9) \u003c\u003c r \u003c\u003c '\\n'; return 0;\r}\r 个人感觉abc很考验思维和对数据结构的熟练度 ","date":"2020-03-02","objectID":"/abc157/:0:12","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["test"],"content":"test for music and video","date":"2020-03-02","objectID":"/test-for-music-and-video/","tags":["test"],"title":"test for music and video","uri":"/test-for-music-and-video/"},{"categories":["test"],"content":"paste a music below [video(video-HXuIKyFl-1583157343324)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=93185992)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/393b26d243ae8f1c7b3cf4d1ba0bea2fd4015d85.jpg)(title-【暴走大事件】致 杠 精)] [video(video-QTmoAEnp-1585132330863)(type-undefined)(url-undefined)(image-https://img-blog.csdnimg.cn/editor-video.png)(title-undefined)] ","date":"2020-03-02","objectID":"/test-for-music-and-video/:0:0","tags":["test"],"title":"test for music and video","uri":"/test-for-music-and-video/"},{"categories":["test"],"content":"test","date":"2020-02-27","objectID":"/test/","tags":["test"],"title":"test","uri":"/test/"},{"categories":["note"],"content":"用hugo搭建个人博客网站","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"效果展示 在hugo官网也有说明如何搭建个人网站 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:0","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"注册github账号 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:1","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"创建github仓库 仓库的名字必须是 用户名.github.io 建议全小写 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:2","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"安装git bash（非必须，但建议） 点击此处 选择计算机对应的规格 一步一步安装 在使用前要进行初始化用户名和邮箱 打开终端（以powershell为例） 输入git命令，没有异常就可以 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:3","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"安装hugo 点击此处 选择计算机对应的规格 下载zip压缩包 解压后会得到 hugo.exe（这个是主要的） ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:4","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"创建博客 打开powershell 转到存放hugo.exe的文件夹下（hugo指令只能在这个目录下执行） 如果hugo指令识别不出来，可以配置环境变量 如果还是不行，那就用绝对路径，一直到hugo.exe 要启动hugo.exe就要用 .\\hugo 在存放hugo.exe的文件夹下，执行以下代码 \u003ehugo new site myblog\r myblog是自己起的名字，是一个identifier 之后会生成myblog文件夹 里面已经有一些东西了（大部分都是建立网站必须的） ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:5","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"下载主题 点击此处 选一个主题下载 下载有两种方式 1.点击download，转到作者github，下载zip 把zip转到myblog/theme下，需要改文件夹一些名字 2.在主题下面有git clone(推荐使用这种) 直接在powershell下面输入（一定要 cd 到myblog） 个别主题下载的慢，可以在不同时间不同地点多试试 下载完，myblog/theme 就会多出一个主题对应的文件夹（很重要） 以下是无论哪一种都要进行的操作 根据作者在hugo网页中写的文档进行初始化配置（就是把主题文件夹中的东西搬出来，替换什么的）（很重要，没有这一步，可能本地都打不开，疯狂报错）（但有些主题没有此过程） 尝试在本地打开 输入以下代码(以pure主题为例）(这个主题名字是theme下对应文件夹的名字) myblog\u003ehugo server -t pure\r 会得到一个本地网址 用浏览器打开这个网址 就可以在本地看到自己的网页 局域网内的用户也可以看到你的网页 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:6","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"部署到服务器上（github pages） 建议先在本地查看，确认无误之后再推到服务器 输入以下代码 注意不要写错 myblog\u003ehugo --theme=pure --baseUrl=\"https://你的用户名.github.io\" --buildDrafts\r myblog下会生成public文件夹 输入以下代码 myblog\u003ecd public\rpublic\u003egit init\rpublic\u003egit add .\rpublic\u003egit commit -m \"输入你自己的提交信息\"\rpublic\u003egit remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u003egit push -u origin master\rpublic\u003e\r 此过程中有可能需要输入github的账号和密码 访问 用户名.github.io就可以看到你的网页 会有延迟，需要等一会 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:7","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"配置主题和增加内容 配置因主题而异 通法就是认真仔细地阅读作者的文档 hugo/theme上的或者README.md（可见文档有多重要） 增加的内容一般都放在content文件夹下，当然也可以删掉内容 一般是markdown格式 写markdown可以用markdownpad / visual studio code / csdn自带的等等 但是发现一个问题，不同的编辑器预览的效果不一样 比如markdownpad不能很好的识别latex公式 有可能主题自带的markdown也不能很好的呈现出效果 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:8","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"更新网站内容 ！！！文件名字不能有 # 建议首先在本地预览，确认无误再上传 然后执行以下代码（含本地预览） myblog\u003ehugo server -t pure\rmyblog\u003ehugo --theme=pure --baseUrl=\"https://你的用户名.github.io\" --buildDrafts\rmyblog\u003ecd public\rpublic\u003egit init\rpublic\u003egit add .\rpublic\u003egit commit -m \"输入你自己的提交信息\"\rpublic\u003egit remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u003egit pull origin master\rpublic\u003egit push -u origin master\rpublic\u003e\r 一定要写git pull origin master 有延迟 打开 用户名.github.io 可以看到内容已经更新 之后更新网站内容就一直重复上述操作 =================== 以下是自定义域名（附加内容）===================== 在阿里云上面注册账号 实名制 购买域名 域名实名制 购买SSL证书（有免费的） 确定SSL证书有效 配置DNS服务器 在域名解析中添加记录 记录类型为CNAME 记录值填写 用户名.github.io（或者记录类型为A，记录值填写IP地址） 打开github对应的仓库 在settings中找到custom domain 输入新域名 在github pages下显示绿色的√就可以 访问新域名就可以看到网页了 之后更新的内容，都可以通过访问新域名实现 以上操作都需要时间，需耐心等待 个人博客网站基本搭建完毕 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:9","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"about","date":"2020-02-26","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"this is dyh from hhu major in cs love swimming,coding,poppin it’s the first time to set up a site(fyi:just for fun as the domain)(based on hugo and github server) thanks to “dillonzq” offering me theme template i set up this site as a self blog and paste some study experience but maybe i’m not gonna manage it if u wanna leave a message you can reach me by qq “244882973” or number “+86 15850656951” or github account etc hope to receive your advice and talk 2 u ^_^ 2020.02.26 end ","date":"2020-02-26","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"cloud","date":"2020-02-26","objectID":"/cloud/","tags":null,"title":"Cloud","uri":"/cloud/"},{"categories":null,"content":"test test ","date":"2020-02-26","objectID":"/cloud/:0:0","tags":null,"title":"Cloud","uri":"/cloud/"},{"categories":null,"content":"music","date":"2020-02-26","objectID":"/music/","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"music zone is testing … =================================================================== =================================================================== =================================================================== =================================================================== ","date":"2020-02-26","objectID":"/music/:0:1","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"poppin","date":"2020-02-26","objectID":"/poppin/","tags":null,"title":"Poppin","uri":"/poppin/"},{"categories":null,"content":"poppin zone is testing \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r=================================================================== =================================================================== \r","date":"2020-02-26","objectID":"/poppin/:0:1","tags":null,"title":"Poppin","uri":"/poppin/"},{"categories":["note"],"content":"二进制表示集合","date":"2020-02-24","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/","tags":["cpp","binary"],"title":"二进制表示集合","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/"},{"categories":["note"],"content":"以二进制的原理表示集合，以整数呈现 1表示在集合内，0表示不在集合内 一位运算优先于按位逻辑运算 空集 0 只含有第i个元素的集合{i} 1«i 含有全部n个元素的集合 {0,1,2,…n-1} (1«n) - 1 判断第i个元素是否属于集合S if ( s»i \u0026 1 ) 原来的集合变了 向集合中加入第i个元素 S∪{i} S|1«i 从集合中去除第i个元素 S{i} S\u0026~(1«i) 集合S和T的并集 S|T 集合S和T的交集 S\u0026T 按顺序枚举集合的子集 for(int S=0;S\u003c1\u003c\u003cn;S++)\r 枚举某个集合sup的子集 int sub=sup;\rdo\r{\rsub=(sub-1)\u0026sup;\r}while(sub!=sup); //处理完0之后，会有-1\u0026sup=sup 枚举{0,1,2,…n-1}所包含的大小为k的子集 int comb=(1\u003c\u003ck)-1;\rwhile(comb\u003c1\u003c\u003cn)\r{\rint x=comb \u0026 -comb , y=comb+x;\rcomb=((comb \u0026 ~y) / x\u003e\u003e1) | y;\r}\r ","date":"2020-02-24","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/:0:0","tags":["cpp","binary"],"title":"二进制表示集合","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/"},{"categories":["algorithm"],"content":"Number Theory","date":"2020-02-22","objectID":"/number-theory/","tags":["cpp","number_theory"],"title":"Number Theory","uri":"/number-theory/"},{"categories":["algorithm"],"content":"求最大公约数和最小公倍数 辗转相除法 时间复杂度O(log(max(a,b))) int gcd(int a,int b)\r{\rif(b==0) return a;\relse return gcd(b,a%b);\r}\rint lcm(int a,int b)\r{\rreturn a*b/gcd(a,b);\r}\r 或直接调用algorithm库中的__gcd(int a,int b) 扩展欧几里得算法 求满足 ax+by=gcd(a,b) 的整数解 x ，y 时间复杂度O(log(max(a,b))) int ex_gcd(int a,int b,int\u0026 x,int\u0026 y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\r  求n以内质数个数 很多种方法，以下是埃氏筛 时间复杂度O(nloglogn) int prime[maxn]; //ith prime number\rbool isprime[maxn+1] //is i a prime number\rint e_sieve(int n)\r{\rint p=0; //position\r for(int i=0;i\u003c=n;i++) isprime[i]=true; //initialize\r isprime[0]=isprime[1]=false;\rfor(int i=2;i\u003c=n;i++)\r{\rif(isprime[i])\r{\rprime[p++]=i;\rfor(int j=2*i;j\u003c=n;j+=i) isprime[j]=true;\r}\r}\rreturn p;\r}\r  数论的一些性质 Premise: a≡c (mod m) and b≡d (mod m) Conclusion: a±b≡c±d (mod m) a*b≡c*d (mod m) d|a \u0026\u0026 d|b ⇒ d|gcd(a,b) gcd(an,bn) = n*gcd(a,b) 任意正整数n，n|ab \u0026\u0026 a,n互质 ⇒ n|b a,p 互质 ， b,p互质 ⇒ ab,p互质 任意一个合数都可以分解成唯一的质数幂积的形式，即 $$ a=\\prod\\limits_{i=1} ^ {n} {pi ^ ei} $$ 因子个数为 $$ \\sum\\limits_{i=1} ^ {n} {(1+e_i)} $$ 积性函数 f(ab) = f(a)f(b) 欧拉函数 莫比乌斯函数 gcd 狄利克雷函数  快速幂 时间复杂度O(logn) typedef long long ll;\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u003e0)\r{\rif(n\u00261) res=res*x%mod;\rx=x*x%mod;\rn\u003e\u003e=1;\r}\rreturn res;\r}\r  逆元 $$ 逆元\\quad y=a^{-1}\\quad满足\\quad ay≡1(mod\\ m) ~\\ y为a在模m下的逆元 $$ $$ 对于\\quad ax≡b(mod\\ m) ~\\ x=a^{-1}*b $$ 求逆元 $$ ax≡1(mod\\ m) ~\\ ax-mk=1 ~\\ ax+my=1 ~\\ ax+my=gcd(a,m) ~\\当a,m不互质的时候，逆元不存在 $$ int mod_inverse(int a,int m)\r{\rint x,y;\rex_gcd(a,m,x,y);\rreturn (m+x%m)%m;\r}  线性时间内预处理逆元 inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\r 欧拉函数 设\\quad n =\\prod\\limits_{i=1} ^ {n} {pi ^ ei} ~\\ 则欧拉函数\\quad φ(n)=n*\\prod\\limits_{i=1} ^ {n} {\\frac{p_i-1}{p_i}} 欧拉函数的数值等于不超过n且与n互质的数的个数 当n时质数时，φ(n)=n-1 如果n=p^k , φ(n)=p^k - p^(k-1) = (p-1)p^(k-1) 如果m,n互质，则φ(mn)=φ(m)φ(n) φ(n)的值都为偶数，φ(2)除外 质因子之和 (φ(n)*n)/2 欧拉定理 $$ 当a,m互质时 ~\\ a^{φ(m)}≡1(mod \\ m) $$ 费马小定理 $$ 当p是质数时， 对任意整数x 都有 ~\\ x^p≡x(mod \\ p) ~\\~\\ 当x,p互质时 ~\\ x^{p-1}≡1(mod \\ p) ~\\ 这就是欧拉定理的特殊形式 $$ 求欧拉函数 时间复杂度O(√(n)) 求欧拉函数值的表，类似于埃氏筛，时间复杂度O(n) int phi(int n)\r{\rint res=n;\rfor(int i=2;i*i\u003c=n;i++)\r{\rif(n%i==0)\r{\rres=res/i*(i-1);\rwhile(n%i==0) n/=i;\r}\r}\rif(n!=1) res=res/n*(n-1);\rreturn res;\r}\rint euler_phi[maxn];\rvoid phi_arr()\r{\rfor(int i=0;i\u003cmaxn;i++) euler_phi[i]=i;\rfor(int i=2;i\u003cmaxn;i++)\r{\rif(euler_phi[i]==i)\r{\rfor(int j=i;j\u003cmaxn;j+=i) euler_phi[j]=euler_phi[j]/i*(i-1);\r}\r}\r}\r  线性同余方程组 $$ a_ix≡b_i(mod \\ m_i) $$ 如果方程组有解，一定有无穷多解 解的全集可以写成 x≡b(mod m) 所以将问题转化为求b,m 可以对如下方程组依次求解 $$ x≡b_1(mod \\ m_1) ~\\ ax≡b_2(mod\\ m_2) $$ $$ x≡b_1(mod \\ m_1) ~\\ x=b_1+m_1t ~\\a(b_1+m_1t)≡b_2(mod\\ m_2) ~\\am_1t≡b_2-ab_1(mod \\ m_2) ~\\a’t≡b’(mod \\ m_2) $$ 当gcd(m₂,am₁)与b₂-ab₁互质时，方程组无解 时间复杂度O(n) pair\u003cint,int\u003e linear_congruence(const vector\u003cint\u003e\u0026 A,const vector\u003cint\u003e\u0026 B,const vector\u003cint\u003e\u0026 M)\r{\r//最开始没有限制，把解设为所有整数 x ≡0(mod 1)\r int x=0,m=1;\rfor(int i=0;i\u003cA.size();i++)\r{\rint a=A[i]*m , b=B[i]-A[i]*x , d=gcd(M[i],a); //d!!!\r if(b%d!=0) return make_pair(0,-1); //无解\r int t=b / d * mod_inverse(a/d,M[i]/d) % (M[i]/d) ;\rx=x+m*t;\rm*=M[i]/d; //*= !!!\r }\rreturn make_pair(x%m,m);\r}\r  中国剩余定理(CRT) crt是线性同余方程组ai=0，mi互质的特殊形式 这时，x≡b(mod Πmi) crt的思想是余数的加性和模数的乘性，当模数为合数时，可以拆成质因数的积 crt定理如下 对于x≡b_i(mod \\ m_i) \\ \\ \\ \\ \\ \\ m_i互质 ~\\ ~\\令M=\\prod{m_i} ~\\M_i=\\frac{M}{m_i} ~\\M_i ^ {-1} 为M_i模m_i的逆元 ~\\ 则 \\ x≡(\\sum\\limits_{i=1} ^ {n} {b_iM_iM_i ^{-1}}) \\ (mod \\ M) // x=x+(Πmi)*t\r//return minimum int crt(const vector\u003cint\u003e\u0026 b,const vector\u003cint\u003e \u0026m)\r{\rint M=1,x=0;\rfor(int i=0;i\u003cm.size();i++) M*=m[i];\rfor(int i=0;i\u003cm.size();i++){\rint Mprime=M/m[i];\rint M_p_i=mod_inverse(Mprime,m[i]);\rx=(x + b[i] * Mprime * M_p_i)%M;\r}\rreturn (x+M)%M;\r}\r  Lucas定理 求 \\ C_{n}^{k} \\ (mod \\ p) , p是质数 ~\\ 当k,n较小时，利用杨辉三角形的性质 ~\\ C_{n}^{k}=C_{n-1}^k+C_{n-1}^{k-1} ~\\ ~\\当n,k较大时 ~\\ n=\\sum{n_ip^i} \\quad \\quad k=\\sum{k_ip^i} \\quad\\quad表示成p进制~\\ C_n^k≡\\prod{C_{n_i}^{k_i}} \\ (mod \\ p) ll pow_mod(ll a, ll n)\r{\rif(n == 0) return 1;\rll x = pow_mod(a, n/2);\rll ans = x * x % mod;\rif(n % 2 == 1) ans = ans *a % mod;\rreturn ans%mod;\r}\rll C(ll n,ll m) ","date":"2020-02-22","objectID":"/number-theory/:0:0","tags":["cpp","number_theory"],"title":"Number Theory","uri":"/number-theory/"},{"categories":["algorithm","hduoj"],"content":"hduoj2089(数位dp + 记忆化搜索)","date":"2020-02-20","objectID":"/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"categories":["algorithm","hduoj"],"content":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input 输入的都是整数对n、m（0\u003cn≤m\u003c1000000），如果遇到都是0的整数对，则输入结束。 Output 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input 1 100 0 0 Sample Output 80 Solution 与数位的组成有关，可以用数位dp。 利用前缀即 solve(m)-solve(n-1) dp[i][j] 表示 符合条件的个数[当前操作的数位(倒序排)][当前操作的数位的前一个数] $$ dp[pos][pre] = \\sum\\limits_{i=0} ^ {maxd} dp[pos-1][i] $$ maxd可以由一个boolean变量limit控制，是否是9还是dig[pos] 为了不重复计算（重复计算也可以），可以用记忆化搜索，也就是可以利用计算好的dp。为了使dp普适，dp必须是稳定，经全搜索得到的（即maxd=9）。所以通过limit控制dp的存储和dp的读取 通过dp递推式，可以用dfs实现（理论上来说可以不用dfs，但不能记忆化且dp可能要增加维度，且要特殊初始化。没有实践过，有时间可以去试试） int dfs(int pos,int pre,bool limit) 通过limit和返回值来使dp结果普适 AC代码如下 #include\u003ciostream\u003e\r#include\u003ccstring\u003e\rusing namespace std;\rint n,m;\rint dp[10][10]; //dp[i][j] i:总共有i位 , j:前导数字为j , dp:满足条件（不含4和62）的个数 int dig[10];\rint dfs(int pos,int pre,bool limit) //pos 当前位置 ， pre 当前位置的前一个数字 {\rif(pos==-1) return 1; //只有0（1个数字）满足\r if(dp[pos][pre]!=-1 \u0026\u0026 !limit) return dp[pos][pre]; //已经搜索过则直接返回 //!!!!\r int ans=0;\rint maxd;\rif(limit) maxd=dig[pos];\relse maxd=9;\rfor(int i=0;i\u003c=maxd;i++)\r{\rif(i==4 || (pre==6 \u0026\u0026 i==2)) ;\relse ans+=dfs(pos-1,i,limit \u0026\u0026 i==dig[pos]); //这里需要传limit !!!!!!!!!! }\rif(!limit) //只有在全搜索的时候才能给dp赋值，这样可以保证dp适用于所有情况，从而实现记忆化搜素 dp[pos][pre]=ans;\rreturn ans;\r}\rint solve(int x)\r{\rint len=0;\rwhile(x)\r{\rdig[len++]=x%10;\rx/=10;\r}\rreturn dfs(len-1,0,1);\r} int main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r memset(dp,-1,sizeof(dp)); //不需要每次都初始化，因为要记忆化搜索 //不需要对dp特殊初始化，因为dfs中有return 1 while(scanf(\"%d%d\",\u0026n,\u0026m)==2 \u0026\u0026 (n || m))\r{\rcout\u003c\u003csolve(m)-solve(n-1)\u003c\u003cendl;\r}\rreturn 0;\r} 第一次写数位dp，参考了别人的代码，也调试了很久，思考了很多，才弄懂其中的细节 ","date":"2020-02-20","objectID":"/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/:0:0","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"categories":["algorithm","nowcoder"],"content":"Segment Tree","date":"2020-02-20","objectID":"/segment-tree/","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"/segment-tree/"},{"categories":["algorithm","nowcoder"],"content":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树 用一个例子来介绍线段树 RMQ（range minimum query） 实现功能 对于一个数列 1.给定s,t求[s,t)区间的最小值（最大值） 2.给定i和x,把ai改成x const int maxn = 1\u003c\u003c17;\rint n,dat[2*maxn+1];\rvoid init(int n_)\r{\r//为了计算方便,把元素个数扩大到2的幂次方的个数\r n=1;\rwhile(n\u003cn_) n*=2;\rfill(dat,dat+2*n-1,inf);\r}\r//将从0开始的第k个值，改成a void update(int k,int a)\r{\rk+=n-1;\rdat[k]=a;\r//向上更新\r while(k\u003e0)\r{\rk=(k-1)/2;\rdat[k]=min(dat[2*k+1],dat[2*k+2]);\r} }\r//求[a,b)区间的最小值(从0开始数)\r//后面的参数是为了计算方便传入的\r//k是节点编号，l，r是k节点对应的区间\r//在外部调用是用query(a,b,0,0,n)\rint query(int a,int b,int k,int l,int r)\r{\rif(r\u003c=a || b\u003c=l) return inf;\rif(a\u003c=l \u0026\u0026 r\u003c=b) return dat[k];\relse\r{\rint vl=query(a,b,2*k+1,l,(l+r)/2);\rint lr=query(a,b,2*k+2,(l+r)/2,r);\rreturn min(vl,vr);\r}\r} 初始化的时间复杂度O(n) 更新和查询的时间复杂度O(logn) 如果dat以1开头，则可以利用这些性质 \u003e\u003e1 : /2取整 «1 : 乘2 «1|1 : (*2+1) 以这题为例 给出一个长度为 n 的数列，a1,a2,…,an,求其长度为 k 的连续子段的乘积对 998244353 取模余数的最大值。 solution:这道题可以用尺取法、线段树、逆元 线段树的做法不需要update函数，最底层存每个数，父节点存子节点的乘积，最后query每一段区间 AC代码如下 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rconst ll mod = 998244353;\rll n_,k;\rll n;\rll dat[4*200005+2];\r//[a,b)\rll query(ll a ,ll b,ll k,ll l,ll r)\r{\rif(r\u003c=a || b\u003c=l) return 1;\rif(a\u003c=l \u0026\u0026 r\u003c=b) return dat[k];\rreturn (query(a,b,k*2+1,l,(l+r)/2) * query(a,b,k*2+2,(l+r)/2,r))%mod;\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r scanf(\"%lld%lld\",\u0026n_,\u0026k);\rn=1;\rwhile(n\u003cn_) n*=2;\rfor(ll i=n-1;i\u003cn_-1+n;i++)\r{\rscanf(\"%lld\",\u0026dat[i]);\r}\rfor(ll i=n-2;i\u003e=0;i--)\r{\rdat[i]=(dat[i*2+1]*dat[i*2+2]) % mod;\r}\rll ans=-1;\rfor(ll i=0;i+k\u003c=n_;i++)\r{\rans=max(ans,query(i,i+k,0,0,n));\r}\rcout\u003c\u003cans%mod\u003c\u003cendl;\rreturn 0;\r}\r 有几个点导致WA 1.要用long long 不能用int 2.dat的的大小要用4乘，否则会断错误，因为在query时，最底层的也有可能访问子节点 边界条件是线段树容易出错的地方，以上代码的区间是左闭右开，在判断条件里面用等号注意n_和n的使用 线段树的lazy思想 参考这里 =========================================================================================================== 在这里补一个线段树板子 支持区间加、区间乘、区间求和、区间求平方和 如果求最值可以用上面那个模板 这个模板还没有融合进去 其实线段树的基本操作就是区间查询和区间更新，其他的操作都可以通过两个基本的区间加（区间求最值）、区间求和操作转化 平方和就是通过等式转化、类似地还可以求立方和、不过四次方应该会很麻烦 测板子题 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rusing ll = long long;\rconst int maxn = 10005;\rstruct tnode{ ll w,l,r,siz,alazy;\rll sq,mlazy=1;\r}tn[maxn\u003c\u003c2]; ll n,m;\rconst ll mod = 0x3f3f3f3f3f3f3f3f;\rll wt[maxn];\rvoid pushup(ll u){ tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod;\rtn[u].sq = (tn[u\u003c\u003c1].sq + tn[u\u003c\u003c1|1].sq) % mod;\r}\rvoid build(ll u,ll l,ll r){ tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[l]; tn[u].sq = wt[l] * wt[l];\rreturn ;\r}\rll mid = (l+r) \u003e\u003e 1;\rbuild(u\u003c\u003c1 , l , mid); build(u\u003c\u003c1|1 , mid+1 , r);\rpushup(u); }\rvoid pushdown(ll u){ if(tn[u].alazy != 0 or tn[u].mlazy != 1){\rtn[u\u003c\u003c1].sq = ((tn[u\u003c\u003c1].sq + 2LL * tn[u\u003c\u003c1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1].siz % mod) % mod; tn[u\u003c\u003c1|1].sq = ((tn[u\u003c\u003c1|1].sq + 2LL * tn[u\u003c\u003c1|1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1|1].siz % mod) % mod;\rtn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1].siz * tn[u].alazy % mod) % mod;\rtn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1|1].siz * tn[u].alazy % mod) % mod;\rtn[u\u003c\u003c1].alazy = (tn[u\u003c\u003c1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u003c\u003c1|1].alazy = (tn[u\u003c\u003c1|1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod;\rtn[u\u003c\u003c1].mlazy = (tn[u\u003c\u003c1].mlazy * tn[u].mlazy) % mod;\rtn[u\u003c\u003c1|1].mlazy = (tn[u\u003c\u003c1|1].mlazy * tn[u].mlazy) % mod;\rtn[u].alazy = 0; tn[u].mlazy = 1;\r}\r}\rll query(ll u,ll l,ll r,ll t){ if(l\u003c=tn[u].l and r\u003e=tn[u].r) {\rif(t == 1) return tn[u].w;\rif(t == 2) return tn[u].sq;\r} ll ans = 0;\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1;\rif(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r , t)) % mod;\rif(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r , t)) % mod;\rreturn ans;\r}\rvoid update(ll u,ll l,ll r,ll wa,ll wm){ if(l\u003c=tn[u].l and r\u003e=tn[u].r){ tn[u].sq = ((tn[u].sq + 2LL * tn[u].w * wa % mod) % mod + wa * wa % mod * tn[u].siz % mod) % mod;\rtn[u].w = (tn[u].w * wm % mod + tn[u].siz * wa % mod) % mod;\rtn[u].alazy = (tn[u].alazy * wm % mod + wa) % mod;\rtn[u].mlazy = (tn[u].mlazy * wm) % mod;\rreturn ;\r}\rpushdown(u);","date":"2020-02-20","objectID":"/segment-tree/:0:0","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"/segment-tree/"},{"categories":["nowcoder"],"content":"牛客基础训练营5B","date":"2020-02-14","objectID":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/"},{"categories":["nowcoder"],"content":"题目在这 这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快 三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2 求mid midmid与n个点的距离，然后依据较小值缩减区间 代码如下 //三分法 最快的应该是0.618法\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rstruct point {\rdouble x,y;\r}p[100005];\rdouble eps = 5e-5;\rdouble check(double x)\r{\rdouble dist = -1;\rfor(int i=0;i\u003cn;i++)\r{\rdist = max(dist,(x-p[i].x)*(x-p[i].x) + p[i].y*p[i].y); }\rreturn sqrt(dist);\r}\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\rscanf(\"%lf %lf\",\u0026p[i].x,\u0026p[i].y);\rdouble l = -10000.0;\rdouble r = 10000.0;\rwhile(r-l\u003eeps)\r{\rdouble mid = l + (r -l)/2; //这里的三分\r double midmid = mid+(r-mid)/2;\rif(check(mid)\u003echeck(midmid)) l=mid;\relse r=midmid;\r}\rprintf(\"%.5lf\\n\",check(l));\rreturn 0;\r}\r ","date":"2020-02-14","objectID":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/:0:0","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/"},{"categories":["algorithm"],"content":"Graph Theory","date":"2020-02-05","objectID":"/graph-theory/","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等 ","date":"2020-02-05","objectID":"/graph-theory/:0:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"链式前向星存图 struct edge{\rint to , w , next;\r}e[maxn];\rint tot,head[maxn];\rvoid add_edge(int u,int v,int w){\re[tot].to = v;\re[tot].w = w;\re[tot].next = head[u];\rhead[u] = tot++;\r}\rfor(int i=head[u];~i;i=e[i].next){\rint v = e[i].to;\rint w = e[i].w;\r}\r//init\rmemset(head , -1 , sizeof(head));\r ","date":"2020-02-05","objectID":"/graph-theory/:1:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"二分图判定 通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图 用dfs判断每个点是否可染色，如果每个点都是可染色的，就是二分图 //input\rvector\u003cint\u003e G[max_v];\rint V;\rint color[max_v] //顶点i的颜色 1或-1\r\rbool dfs(int v,int c)\r{\rcolor[v]=c; //染色\r for(int i=0;i\u003cG[v].size();i++)\r{\rif(color[v][i]==c) return false; //相邻顶点同色\r if(color[G[v][i]]==0 \u0026\u0026 !dfs(G[v][i],-c)) return false; //对于还没染色的点，如果不能染色则返回false } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=0;i\u003cV;i++)\r{\rif(color[i]==0) //还未着色//如果是连通图，遍历一次就够\r if(!dfs(i,1)) return false; }\rreturn true;\r} 把顶点和边都算的话，时间复杂度是O(|V|+|E|) ","date":"2020-02-05","objectID":"/graph-theory/:2:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"求DAG的拓扑序 求拓扑序可以dfs，删边法（通过栈或队列） 求每个点的入度，将入度为0的点入栈，遍历栈里的点，将于这些点相邻的点的入度减1，如果有点入度为0，则入栈。依靠这个顺序，得到的就是拓扑序。如果点访问两次，则有圈。可以通过这个方法判断有向图是否有圈 //input\rvector\u003cint\u003e G[max_v]\rint V;\rint indgree[max_v] //每个顶点的入度\rvector\u003cint\u003e res; //拓扑排序的结果\r\rbool topological_sort() //判断是否能拓扑排序 ，若果有圈就不能 {\rstack\u003cint\u003e s;\r//int counter=0; //遍历的点的个数 for(int i=0;i\u003cV;i++) if(indegree[i]==0) s.push(i); //入度为0 的顶点入栈\r while(!s.empty())\r{\rint v=s.top(); s.pop();\rres.push_back(v);\r//counter++;\r for(int i=0;i\u003cG[v].size();i++)\r{\rint k=G[v][i];\rif(--indegree[k] == 0) s.push(k); //遍历到的点入度间1，入度为0则入栈 }\r} if(res.size()==n) return true;\relse return false;\r}\r 时间复杂度是O(|V|+|E|) ","date":"2020-02-05","objectID":"/graph-theory/:3:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Bellman-Ford算法 求单源最短路 d[i]=min{d[j]+e(j,i)} 只要图中不存在负圈，这样的更新操作是有限的（由于最短路不会经过一个顶点两次，所以这种操作只会重复|v|-1次） 时间复杂度O(|V|*|E|) struct edge\r{\rint from,to,cost;\r}es[max_e];\rint d[max_v];\rint V,E;\rvoid bellman_ford(int s)\r{\rfor(int i=0;i\u003cV;i++) d[i]=inf; //把最短距离初始化成无限\r d[s]=0; while(true)\r{\rbool update=false; //判断while是否进行了更新操作，没有更新操作则退出循环 for(int i=0;i\u003cE;i++) //根据公式，遍历边\r {\redge e=es[i];\rif(d[e.from]!=inf \u0026\u0026 d[e.to]\u003ed[e.from]+e.cost)\r{\rd[e.to]=d[e.from]+e.cost;\rupdate=true;\r}\r}\rif(!update) break;\r}\r}\r 如果更新操作（while循环）进行了超过|V|-1次，则存在负圈 所以判断负圈的一个方法可以是 把所有d[i]都变成0，如果有负圈，则一定执行超过|V|-1次 bool find_negative_loop()\r{\rmemset(d,0,sizeof(d));\rfor(int i=0;i\u003cV;i++)\r{\rfor(int j=0;j\u003cE;j++)\r{\redge e=es[j];\rif(d[e.to]\u003ed[e.from]+e.cost)\r{\rd[e.to]\u003ed[e.from]+e.cost;\rif(i==V-1) return true; //这条语句不能放在if外，如果放在if外需要加update }\r}\r}\rreturn false; }\r ","date":"2020-02-05","objectID":"/graph-theory/:4:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Dijkstra算法 求单源最短路，适用于没有负边的情况 将已求出最短路的点，放入一个集合中 ，每次从集合外找到一个和集合距离最近的点，加入集合 int cost[max_v][max_v]; //权值，不存在时为inf\rint d[max_v];\rbool used[max_v];\rint V;\rvoid dijkstra(int s)\r{\rfill(d,d+v,inf);\rfill(used,used+v,false);\rd[s]=0;\rwhile(true)\r{\rint v=-1;\r//从尚未使用过的点中选一个距离最小的点\r for(int u=0;u\u003cV;u++)\r{\rif(!used[u] \u0026\u0026 (v==-1 || d[u]\u003cd[v])) v=u;\r} if(v==-1) break;\rused[v]=true;\rfor(int u=0;u\u003cV;u++)\rd[u]=min(d[u],d[v]+cost[v][u]); }\r} 时间复杂度O(V^2) 优化 如果将点放入优先队列中，这要查找和更新就会节省很多时间，时间复杂度O(ElgV) struct edge\r{\rint to,cost;\r}\rtypedef pair\u003cint,int\u003e pii; //first 是距离 ，second是点编号\rint V;\rvector\u003cedge\u003e G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; //使小的在上面\r fill(d,d+V,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(int i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} } ","date":"2020-02-05","objectID":"/graph-theory/:5:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Floyd-Warshall算法 求任意两点最短路，暴力枚举思想 d[i][j]=min(d[i][j],d[i][k]+d[k][j]) 遍历所有的k 时间复杂度O(V^3) int d[max_v][max_v]; //存储权值，边不存在时为inf，d[i][i]=0 int V;\rvoid floyd_warshall()\r{\rfor(k=0;k\u003cV;k++)\rfor(int i=0;i\u003cV;i++)\rfor(int j=0;j\u003cV;j++)\rd[i][j]=min(d[i][j],d[i][k]+d[k][j]);\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:6:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"路径还原 通过找满足d[j]=d[k]+cost[k][j]的顶点k，来寻找前趋节点，不断寻找前趋节点来还原路径，时间复杂度O(E) 还可以用prev[j]在算法内直接记录前趋节点，最后遍历数组即可，时间复杂度O(V) //算法内记录前趋节点 (优化的dijkstra算法)\rint prev[max_v] //前趋节点\rstruct edge\r{\rint to,cost;\r}\rtypedef pair\u003cint,int\u003e pii; //first 是距离 ，second是点编号\rint V;\rvector\u003cedge\u003e G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; //使小的在上面\r fill(d,d+V,inf);\rfill(prev,prev+V,-1); //!!!! d[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u003cp.first) continue;\rfor(int i=0;i\u003cG[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u003ed[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rprev[e.to]=v; //!!!!\r q.push(pii(d[e.to],e.to));\r}\r}\r} }\rvector\u003cint\u003e get_path(int t)\r{\rvector\u003cint\u003e path;\rfor(;t!=-1;t=prev[t]) path.push_back(t);\rreverse(path.begin(),path.end());\rreturn path;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:7:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Prim算法 求最小生成树 prim算法和dijkstra算法很像，也是把已确定的点放入一个集合中，贪心地选取集合和未确定的点相连的最小权边，并加入到集合中，得到一棵生成树，可以证明是MST(minimum spanning tree) //也可以堆优化 int cost[max_v][max_v] //权值\rint mincost[max_v]; //从集合出发到其他点的最小权值,!!!这个权值是 集合 和 点 之间的 bool used[max_v]; //是否在集合中\rint V;\rint prim() //返回MST的权值\r{\rfill(mincost,mincost+V,inf); //初始化 fill(used,used+V,false);\rmincost[0]=0; //从0开始 int res=0;\rwhile(true)\r{\rint v=-1;\rfor(int u=0;u\u003cV;u++)\r{\rif(!used[u] \u0026\u0026 (v==-1 || mincost[u]\u003cmincost[v])) v=u;\r}\rif(v==-1) break;\rused[v]=true;\rres+=mincost[v];\rfor(int u=0;u\u003cV;u++)\r{\rmincost[u]=min(mincost[u],cost[v][u]); //每次往集合中加入一个点，所有点的mincost都有可能改变 }\r}\rreturn res; } 时间复杂度与dijkstra算法一样 ","date":"2020-02-05","objectID":"/graph-theory/:8:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Kruskal算法 求MST 将边的权值按大小排序，如果不产生圈和重边，就依次把边加入到生成树中 要判断是否产生圈和重边，只需要判断加入这条边前，这条边的两个端点是否已在同一个连通分量里，这样就可以用并查集 Kruskal在边的排序上最费时，算法复杂度O(ElgV) Kruskal适用于sparse graph Prim适用于dense graph 在实际应用中，Kruskal更普遍 struct edge\r{\rint u,v,cost;\r}es[max_e];\rint V,E;\rint par[max_v]; //union find需要 int rankk[max_v]; //key word \"rank\"\rbool cmp(const edge\u0026 e1,const edge\u0026 e2)\r{\rreturn e1.cost\u003ce2.cost;\r}\rvoid init_union_find(int x)\r{\rfor(int i=0;i\u003cx;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x)\rreturn x;\relse\rreturn par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return;\rif(rankk[x]\u003crankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint kruskal()\r{\rsort(es,es+E,cmp);\rinit_union_find(V);\rint res=0;\rfor(int i=0;i\u003cE;i++)\r{\redge e=es[i];\rif(!same(e.u,e.v))\r{\runite(e.u,e.v);\rres+=e.cost;\r}\r}\rreturn res;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:9:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Kosaraju算法 强连通分量(strongly connected component)分解高效的算法有kosaraju算法， tarjan算法，gabow算法 kosaraju算法通过随便选一点dfs，给点标号 把边的方向反过来，再一次dfs 由于在强连通分量中的点，其可达性不受边反向的影响 所以最后需独立进行k次搜索 即分裂出k个强连通分量 时间复杂度 O(V+E) //kosaraju int V; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv];\rvector\u003cint\u003e vs; //后序遍历顺序的顶点列表（标号） bool used[maxv]; //是否访问 int cmp[maxv]; //所属强连通分量的拓扑序（序号） \rvoid add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u003cG[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u003crG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u003cV;i++) if(!used[i]) dfs(i);\rmemset(uesd,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:10:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Tarjan算法 （scc部分） 求scc的tarjan算法是给一个点赋上两个属性 dfn low分别表示dfs的访问时间和该点可追踪到的最小访问时间 dfs过程中先访问自己，再访问邻接点，最后对自己进行操作 在访问自己时，将两个属性初始化为当前时间，并且进栈 接下来访问未被访问过的邻接点，并且更新low属性 如果已被访问过且在栈里也更新low属性 最后对自己的操作就是判断dfn 和 low是否相等 相等说明它是连通块的头，已经无法再更新了 这时候不断出栈直到自己也出栈 总的操作就是遍历每个点，没访问就dfs tarjan算法和kosaraju算法有点类似，都是利用了反向边的性质，本质上是强连通分量中反向边的可达性，依此对每个点都最小化点的属性，而属性选择dfs序较高效 tarjan算法要dfs一次，邻接表的时间复杂度是 O(V+E) 求连通块的出度和入度就是判断原本连接的两个点是否在同一个强连通分量中 int V;\rvector\u003cint\u003e G[maxv];\rint dfn[maxv],low[maxv],cmp[maxv];\rbool in_stack[maxv];\rstack\u003cint\u003e s;\rint tim;\rint num=0; //最后的num是连通块数量 int in[maxv];\rint out[maxv];\rvoid tarjan_dfs(int x){\rdfn[x] = low[x] = ++tim;\rs.push(x);\rin_stack[x] = true;\rfor(int i=0;i\u003cG[x].size();i++){\rint to = G[x][i];\rif(dfn[to] == 0){\rtarjan_dfs(to);\rlow[x] = min(low[x] , low[to]);\r}\relse if(in_stack[to]){\rlow[x] = min(low[x] , low[to]);\r}\r}\rint tmp;\rif(dfn[x] == low[x]){\rdo{\rtmp = s.top();\rcmp[tmp] = num;\rs.pop();\rin_stack[tmp] = false;\r}while(tmp != x);\rnum++;\r}\r}\rvoid tarjan_scc(){\rfor(int i=0;i\u003cV;i++){\rif(!dfn[i]){\rtarjan_dfs(i);\r}\r}\r}\rvoid in_out_d(){\rfor(int i=0;i\u003cV;i++){\rfor(int j=0;j\u003cG[i].size();j++){\rint to = G[i][j];\rif(cmp[i] != cmp[to]){\rin[cmp[to]]++;\rout[cmp[i]]++;\r}\r}\r}\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:11:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Tarjan算法 （割点、桥部分） 利用dfn和low判定割点和桥，注意更新 int V;\rvector\u003cint\u003e G[maxv];\rint dfn[maxv],low[maxv],cmp[maxv];\rbool in_stack[maxv];\rstack\u003cint\u003e s;\rint tim;\rint num=0; //最后的num是连通块数量 set\u003cint\u003e cut;\rint Rchild;\rint cnt_root;\rset\u003cpair\u003cint,int\u003e\u003e bridge; void tarjan_dfs(int x,int p){\rdfn[x] = low[x] = ++tim; s.push(x);\rin_stack[x] = true;\rfor(int i=0;i\u003cG[x].size();i++){\rint to = G[x][i];\rif(to != p){\rif(dfn[to] == 0){\rif(x == cnt_root) Rchild++;\rtarjan_dfs(to , x);\rlow[x] = min(low[x] , low[to]);\rif(x != cnt_root and low[to] \u003e= dfn[x]) cut.insert(x); //不是根，求割点 if(low[to] \u003e dfn[x]) bridge.insert({min(x,to),max(x,to)}); //求桥 }\relse if(in_stack[to]){\rlow[x] = min(low[x] , dfn[to]); //注意这里是dfn，而不是求scc的low }\r}\r}\rint tmp;\rif(dfn[x] == low[x]){\rdo{\rtmp = s.top();\rcmp[tmp] = num;\rs.pop();\rin_stack[tmp] = false;\r}while(tmp != x);\rnum++;\r}\r}\rvoid tarjan_scc(){\rfor(int i=0;i\u003cV;i++){\rif(!dfn[i]){\rcnt_root = i;\rRchild = 0;\rtarjan_dfs(i,-1);\rif(Rchild \u003e 1) cut.insert(cnt_root); //是根，求割点 }\r}\r}\r 割点的模板测试 这个题的数据好像有森林 桥的模板测试 ","date":"2020-02-05","objectID":"/graph-theory/:12:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"LCA 大致的做法就是直接法，直接向上追溯 对于多次查询通过跳级预处理，利用二分的思想 单次查询，O(n) vector\u003cint\u003e G[maxv];\rint root;\rint parent[maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[v] = p;\rdepth[v] = d;\rfor(int i=0;i\u003cG[v].size();i++){\rif(G[v][i] != p) dfs(G[v][i] , v , d+1);\r}\r}\rvoid init(){\rdfs(root , -1 , 0);\r}\rint lca(int u,int v){\rwhile(depth[u] \u003e depth[v]) u = parent[u];\rwhile(depth[v] \u003e depth[v]) v = parent[v];\rwhile(u != v){\ru = parent[u];\rv = parent[v];\r}\rreturn u;\r}\r 多次查询 O(nlogn) vector\u003cint\u003e G[maxv];\rint root;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i=0;i\u003cG[v].size();i++){\rif(G[v][i]!=p) dfs(G[v][i],v,d+1);\r}\r}\rvoid init(int V){\rdfs(root,-1,0);\rfor(int k=0;k+1\u003cmax_logv;k++){\rfor(int v=0;v\u003cV;v++){\rif(parent[k][v]\u003c0) parent[k+1][v]=-1;\relse parent[k+1][v]=parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u]\u003edepth[v]) swap(u,v);\rfor(int k=0;k\u003cmax_logv;k++){\rif((depth[v]-depth[u])\u003e\u003ek\u00261) v=parent[k][v];\r}\rif(u==v) return u;\rfor(int k=max_logv-1;k\u003e=0;k--){\rif(parent[k][u]!=parent[k][v]){\ru=parent[k][u];\rv=parent[k][v];\r}\r}\rreturn parent[0][u];\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:13:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"dfs序 (与线段树和树状数组结合) vector\u003cint\u003e G[maxv]; //图的领接表 int od[maxv]; //dfs序 int L[maxv]; //子树区间左边界 int R[maxv]; //子树区间有边界 int cnt = 1; //当前是第几个节点（dfs序） void dfs(int x,int p){\rod[x] = cnt++;\rL[x] = cnt - 1;\rfor(int i:G[x]){\rif(i!=p){\rdfs(i,x);\r}\r}\rR[x] = cnt - 1;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:14:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"树链剖分 树链剖分利用重孩子的定义和dfs序将树上路径权值和子树整体权值的修改和查询压缩成连续的区间的查询，对于区间的修改和查询可以利用线段树 以这道题为例 （无注释代码点击此处） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst int maxn = 1e5+10;\rstruct edge{ //链式前向星存图 int to,nxt;\r}e[maxn\u003c\u003c1]; //用双向边代替无向边 \rstruct tnode{ //线段树的节点 节点权值，覆盖的左区间，覆盖的右区间，覆盖的范围，lazy标签 int w,l,r,siz,lazy;\r}tn[maxn\u003c\u003c2]; // 大小要*4 \r//wch：重孩子 sz：子树大小 head：链式前向星的head //wt：原来树上节点的权值 dep：深度 dfn：dfs序 //par：父节点 top：树上节点所属链的链首 rdfn：dfs序的反映射 \rint wch[maxn],sz[maxn],head[maxn],wt[maxn],dep[maxn],dfn[maxn],par[maxn],top[maxn],rdfn[maxn];\rint n,m,r,mod; int cnt_e; //链式前向星的计数器 int cnt_d; //dfs序的计数器 \rvoid add_edge(int u,int v){ //链式前向星的建图函数 e[++cnt_e].to = v; e[cnt_e].nxt = head[u]; //头插法 head[u] = cnt_e;\r}\rvoid dfs1(int u,int p){ //获得子树大小 ，深度，父节点，重孩子 sz[u] = 1;\rfor(int i = head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p){\rdep[t] = dep[u] + 1;\rpar[t] = u;\rdfs1(t,u);\rsz[u] += sz[t];\rif(sz[t] \u003e sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid dfs2(int u,int p,int tp){ //剖分重链和轻链 top[u] = tp;\rdfn[u] = ++cnt_d; //dfs序 rdfn[cnt_d] = u; //反dfs序 if(wch[u]){ //先操作重孩子，目的是让重链节点的dfs序连续，便于在线段树上的区间操作 dfs2(wch[u],u,tp);\r}\rfor(int i=head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p and t != wch[u]){\rdfs2(t,u,t); //操作轻孩子 }\r}\r}\rvoid pushup(int u){ //通过两个孩子，更新自己的权值 由于题目要求，所以是求和形式 tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod;\r}\rvoid build(int u,int l,int r){ //建立线段树 tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[rdfn[l]]; //此时获得线段树节点的权值 return ;\r}\rint mid = (l+r) \u003e\u003e 1;\rbuild(u\u003c\u003c1 , l , mid); //递归建树 build(u\u003c\u003c1|1 , mid+1 , r);\rpushup(u); //每建一层就通过两个孩子更新自己 }\rvoid pushdown(int u){ //通过迟滞，下放lazy，在需要的时候更新，这样会减少操作量 if(tn[u].lazy){\rtn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1].siz * tn[u].lazy) % mod; //通过迟滞来更新子节点的权值 tn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w + tn[u\u003c\u003c1|1].siz * tn[u].lazy) % mod;\rtn[u\u003c\u003c1].lazy = (tn[u\u003c\u003c1].lazy + tn[u].lazy) % mod; //下放迟滞 tn[u\u003c\u003c1|1].lazy = (tn[u\u003c\u003c1|1].lazy + tn[u].lazy) % mod;\rtn[u].lazy = 0; //该节点迟滞的作用结束，清空 }\r}\rvoid update(int u,int l,int r,int w){ //更新区间 if(l\u003c=tn[u].l and r\u003e=tn[u].r){ // 当目标区间包含了节点区间时，无法往下操作，更新节点的权值和迟滞 tn[u].w += tn[u].siz * w;\rtn[u].lazy += w;\rreturn ;\r}\rpushdown(u); // 下放迟滞准备对子节点的更新操作 int mid = (tn[u].l + tn[u].r) \u003e\u003e 1; //这里是节点区间的一半 if(l\u003c=mid) update(u\u003c\u003c1, l , r , w);\rif(r\u003emid) update(u\u003c\u003c1|1, l , r , w);\rpushup(u); //子树更新完毕,通过子节点更新自己 }\rvoid add_path(int u,int v,int w){ //对路径的更新操作 while(top[u]!=top[v]){ //如果不属于一条重链 if(dep[top[u]] \u003c dep[top[v]]) swap(u,v); //现在它们属于两条链，始终对链头深度大的进行操作 update(1,dfn[top[u]],dfn[u],w); //更新这条链 u = par[top[u]]; //这条链更新完毕，跳到链头的父节点，这样最终它们会相遇，处在同一条链上 }\rif(dep[u] \u003e dep[v]) swap(u,v); //让深度低的节点在左，才可以区间操作 update(1,dfn[u],dfn[v],w); //根据dfs序 }\rint query(int u,int l,int r){ //区间查询 if(l\u003c=tn[u].l and r\u003e=tn[u].r) return tn[u].w; //已经缩到最小区间，直接返回值 int ans = 0;\rpushdown(u); //下放迟滞，以备后续操作 int mid = (tn[u].l + tn[u].r) \u003e\u003e 1;\rif(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r)) % mod;\rif(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r)) % mod;\rreturn ans;\r}\rint query_path(int u,int v){ //路径上的查询 int ans = 0;\rwhile(top[u] != top[v]){ //与路径上的更新相同 if(dep[top[u]] \u003c dep[top[v]]) swap(u,v);\rans = (ans + query(1, dfn[top[u]] , dfn[u])) % mod;\ru = par[top[u]];\r}\rif(dep[u] \u003e dep[v]) swap(u,v);\rans = (ans + query(1,dfn[u],dfn[v])) % mod;\rreturn ans;\r}\rint main(){\r//freopen(\"in.txt\",\"r\",stdin);\r cin\u003e\u003en\u003e\u003em\u003e\u003er\u003e\u003emod;\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ewt[i];\r}\rfor(int i=0;i\u003cn-1;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\radd_edge(x,y);\radd_edge(y,x);\r}\rdfs1(r,0); //初始化 dfs2(r,0,r);\rbuild(1,1,n);\rfor(int i=0;i\u003cm;i++){\rint tp;\rcin\u003e\u003etp;\rswitch(tp){\rcase 1:{\rint x,y,z;\rcin\u003e\u003ex\u003e\u003ey\u003e\u003ez;\radd_path(x,y,z%mod);\rbreak;\r}\rcase 2:{\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\rcout\u003c\u003cquery_path(x,y)\u003c\u003cendl;\rbreak;\r}\rcase 3:{\rint x,z;\rcin\u003e\u003ex\u003e\u003ez;\rupdate(1,dfn[x],dfn[x]+sz[x]-1,z%mod);\rbreak;\r}\rcase 4:{\rint x;\rcin\u003e\u003ex;\rcout\u003c\u003cquery(1,dfn[x],dfn[x]+sz[x]-1)\u003c\u003cendl;\rbreak;\r}\r}\r}\rreturn 0;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:15:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"树上启发式合并 dsu on tree 并查集的按秩合并是启发式，即小的往大的合并，减少查询难度 树上启发式合并通过树链剖分中重孩子的定义，在对子树查询时，先处理所有轻孩子，然后撤销（消除轻孩子对父节点的影响），再处理重孩子，不撤销，最后再处理一遍轻孩子，把对父节点的贡献和重孩子合并 撤销的目的在于对节点信息查询时会开辟一个数组，对于不同子节点，这个数组要再开辟一次，这样会MLE 以这道题为例 （无注释代码点击此处） #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rconst int maxn = 1e5 + 10;\rstruct edge{\rint to,nxt;\r}e[maxn\u003c\u003c1];\rint sz[maxn],par[maxn],c[maxn],head[maxn],wch[maxn],ans[maxn],num[maxn]; //这些变量见树链剖分部分 int n,m;\rint sum; //子树颜色数 int cnt; //计数器 \rvoid add_edge(int u,int v){\re[++cnt].to = v;\re[cnt].nxt = head[u];\rhead[u] = cnt;\r}\rvoid dfs(int u,int p){\rsz[u] = 1;\rfor(int i = head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p){\rdfs(t,u);\rsz[u] += sz[t];\rif(sz[t] \u003e sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid cal(int u,int p,int wch,int val){\rif(!num[c[u]]) sum++; //如果之前数量为0，说明是新颜色 num[c[u]] += val;\rfor(int i=head[u]; i ; i=e[i].nxt){ int t = e[i].to;\rif(t != p and t != wch){ //跳过重孩子 cal(t,u,wch,val); }\r}\r}\rvoid dsu(int u,int p,int kp){ //kp表示是否撤销 for(int i=head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p and t != wch[u]){\rdsu(t,u,0); //先处理轻孩子，需要撤销 }\r}\rif(wch[u]) dsu(wch[u] , u , 1); //处理重孩子，需要保留 cal(u,p,wch[u],1); //计算轻孩子 ans[u] = sum;\rif(!kp){ cal(u,p,0,-1); //撤销操作 sum = 0;\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u003e\u003en;\rfor(int i=0;i\u003cn-1;i++){\rint x,y;\rcin\u003e\u003ex\u003e\u003ey;\radd_edge(x,y);\radd_edge(y,x);\r}\rfor(int i=1;i\u003c=n;i++){\rcin\u003e\u003ec[i];\r}\rdfs(1,0); //初始化 dsu(1,0,1);\rcin\u003e\u003em;\rwhile(m--){\rint foo;\rcin\u003e\u003efoo;\rcout\u003c\u003cans[foo]\u003c\u003cendl;\r}\rreturn 0;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:16:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Dinic算法 用来解决最大流问题 有两类算法 增广路算法（dinic ek isap ff） 预流推进算法 （hlpp） dinic算法是经典算法，hlpp可能更快一点 dinic算法的本质还是贪心+暴力 通过不断地对残余网络(residual networks)求增广路(augmenting paths)，对每一条增广路求流量，然后把流量加起来就是最大流 有一个问题：在对增广路下放流量时，可能错过最优解 解决的方法是，对每条边加一条反向边，流量在原来的边减多少，就在反向边加多少，这样可以通过流入反向边来达到撤销的操作 dinic的操作过程分两步 bfs建立分层图，通过最短路的原则分层，每次在最短路的前提下找增广路，这是贪心的思想，这样会使找增广路高效且达到可行解 dfs找增广路，不断对边进行流量增减操作，暴力枚举思想 不断迭代每次产生的残余网络 三种优化（主要是后两者）参考文章 当前弧优化 ： 增广路搜索中不再考虑之前搜索过的边 多路增广优化： 对于某一条边减去的流量，因增广路覆盖的次数会进行多次操作，现在只需要一次操作就行（操作总的流量），从一次bfs，多次dfs到多次bfs，一次dfs 炸点优化 ： 当某一条增广路中流量为0时，这个点在当前dfs搜索增广路中将不可达，所以直接炸点 时间复杂度 O(n*n*m) 实际合理运用优化之后，很难达到这样的时间复杂度，dinic算法还是很高效的，甚至可以跑十万个点 根据最大流最小割定理(maximum flow minimum cut theorem) 最大流就是有源汇最小割 对于无源汇最小割和全局最小割可以用Stoer Wagner算法 对于有源汇无源汇上下界最大流，参考此处 对于时间要求苛刻的最大流可以用HLPP算法 对于费用流，可以用spfa 对于最大流的各种变体，参考其他资料 测模板题 无注释代码 //有时需改成long long \r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rconst int maxn = 205;\rconst int maxm = 5005;\rint n,m,s,t;\rconst int inf = 0x3f3f3f3f; struct edge{\rint to , w , nex;\r}e[maxm\u003c\u003c1]; //maxm int tot=2,head[maxn]; // tot = 2 !!\r\rint dep[maxn],cur[maxn]; //dep : dfs得到的最短距离 cur : 当前弧优化需要拷贝的数组 \rvoid add_edge(int u,int v,int w){\re[tot].to = v;\re[tot].w = w;\re[tot].nex = head[u];\rhead[u] = tot++;\r}\rbool bfs(){\rmemset(dep , 0 , sizeof(dep)); //memset(dep , 0 , (tot+2)\u003c\u003c2); queue\u003cint\u003e q;\rq.push(s);\rdep[s] = 1; int u , v;\rwhile(q.size()){\ru = q.front();\rq.pop();\rfor(int i = head[u] ; i ; i = e[i].nex){\rv = e[i].to;\rif(dep[v] or e[i].w \u003c= 0) continue; //v 已达到不能作为dfs的增广路 ， 断流的点不能作为dfs的增广路 dep[v] = dep[u] + 1;\rq.push(v);\r}\r} for(int i=0;i\u003c=n;i++) cur[i] = head[i]; //拷贝作为当前弧优化 return dep[t]; //是否到达汇点 }\rint dfs(int u , int flow){\rif(u == t) return flow;\rint nowflow = 0; //当前流量 for(int\u0026 i = cur[u] , v ; i ; i = e[i].nex){ //当前弧优化 v = e[i].to;\rif(dep[v] != dep[u] + 1 or e[i].w \u003c= 0) continue; //不满足深度递增或断流就不能作为增广路 if(int delta = dfs(v , min(flow - nowflow , e[i].w))){ e[i].w -= delta;\re[i^1].w += delta;\rnowflow += delta; //多路增广优化，for循环一直进行，nowflow一直增加 if(nowflow == flow) break; //已达到最大流量 }\r}\rif(!nowflow) dep[u] = -2; //炸点优化 return nowflow;\r}\rll dinic(){\rll ans = 0 ;\rwhile(bfs()){ //对残余网络不断分层，以备之后dfs求增广路，当汇点不可达时，残余网络将永远不可达 ans += dfs(s , inf);\r}\rreturn ans;\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u003e\u003en\u003e\u003em\u003e\u003es\u003e\u003et;\rfor(int i=0;i\u003cm;i++){\rint x,y,z;\rcin\u003e\u003ex\u003e\u003ey\u003e\u003ez;\radd_edge(x,y,z);\radd_edge(y,x,0);\r}\rll ans = dinic();\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-02-05","objectID":"/graph-theory/:17:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["poj"],"content":"poj","date":"2020-01-27","objectID":"/poj/","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"线段相交 1127 ","date":"2020-01-27","objectID":"/poj/:1:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 判断两条线段是否相交，对于N条线段，间接相交也算相交。对于每次询问，判 断给定的两条线段是否相交 ","date":"2020-01-27","objectID":"/poj/:1:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 这个题目分成两部分，一部分是基础的判断两条线段是否相交，用一个bool数组来存储信息。另一部分是判断间接相交，可以用floyd-warshall（比较巧妙）或者并查集.第一部分就是套模板。 点可以用结构体存储（推荐），线段也可以用结构体存储或pair 判断两条线段相交有多重模板，比如判是否平行、重合、求两条直线交点，判断交点是否在线段上，还有ccw（counter clock wise）函数，可参考discuss 比较常见的是快速排斥和跨立检验 以线段为对角线，作平行于x轴、y轴的射线，使之形成矩形，若两个矩形没有相交，则线段不相交（可以排除大部分） 不满足快速排斥进入跨立检验,判断两个点是否在线段的两侧（即跨立），判断方法是外积的符号是否相反，等于0说明在线上 如果两两互相跨立，则线段相交 #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint n;\rbool con[15][15];\rint p,q;\rstruct point\r{\rdouble x,y;\r//point(double a,double b) : x(a),y(b) {} //!!!!!会发生编译错误 };\rpair\u003cpoint,point\u003e seg[15];\rdouble dir(point a,point b,point c) //用外积 {\rreturn (c.x-a.x)*(c.y-b.y) - (c.y-a.y)*(c.x-b.x); }\rbool judge(pair\u003cpoint,point\u003e p1,pair\u003cpoint,point\u003e p2)\r{\rpoint a,b,c,d;\ra=p1.first; b=p1.second;\rc=p2.first;\rd=p2.second;\r//快速排斥\r if(min(a.x,b.x)\u003emax(c.x,d.x) or min(c.x,d.x)\u003emax(a.x,b.x) or\rmin(a.y,b.y)\u003emax(c.y,d.y) or min(c.y,d.y)\u003emax(a.y,b.y))\rreturn false;\r//跨立检验 (int 可改成double)\r else\r{\rint d1,d2,d3,d4;\rd1=dir(a,b,c);\rd2=dir(a,b,d);\rd3=dir(c,d,a);\rd4=dir(c,d,b);\rreturn d1*d2\u003c=0 and d3*d4\u003c=0; //!!!\r }\r}\rint main()\r{\rwhile(scanf(\"%d\",\u0026n)==1 and n!=0)\r{\rfor(int i=1;i\u003c=n;i++) con[i][i]=true;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%lf%lf%lf%lf\",\u0026seg[i].first.x,\u0026seg[i].first.y,\u0026seg[i].second.x,\u0026seg[i].second.y);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=1;j\u003ci;j++)\r{\rif(judge(seg[i],seg[j])) con[i][j]=con[j][i]=true;\relse con[i][j]=con[j][i]=false;\r}\rfor(int k=1;k\u003c=n;k++) //Floyd-Warshall算法或并查集都可以 for(int i=1;i\u003c=n;i++)\rfor(int j=1;j\u003c=n;j++)\rcon[i][j] |= con[i][k] and con[k][j];\rwhile(scanf(\"%d%d\",\u0026p,\u0026q)==2 and p!=0)\rputs(con[p][q] ? \"CONNECTED\" : \"NOT CONNECTED\");\r}\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:1:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"艰难的debug 计算几何有些很麻烦，代码太相似，debug比较难，有时还要考虑精度问题（即误差eps） debug一个上午 写完代码CE，seg[i].first.x错误，把stl_pair.h中的代码小改一下可以通过，但放到oj上肯定不行，怕污染代码还是不这样做。最后发现把构造函数去掉可以通过 自测，最后一个样例没过，发现是边界情况，把跨立检验最后一步的等号加上 自测，中间有一个样例没过，作图，把样例分离出来，过了。说明可能不是judge函数的问题。 单测样例，没过，说明错误不是受别组影响 编译器debug，把函数内的局部变量，变成全局变量，add watch 发现d1 d2 d3 d4都等于0，a.x a.y b.x b.y ….有问题 继续add watch 发现seg[1].first的内容就有问题，是double边界数，然后发现最终问题 %d 赋值给了double型变量 ","date":"2020-01-27","objectID":"/poj/:1:3","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 提高debug能力，少犯白痴错误。 写代码要有清晰性和完整性，这样鲁棒性更强。 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:1:4","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"并查集 1182 ","date":"2020-01-27","objectID":"/poj/:2:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 并查集 看到信息的内容，有并查集的影子 依次遍历信息，对于每一条信息，因为没有说种类，所以设置三个种类，把每一种情况都加上去，比如：x和y属于同一类，则合并x和y属于A类，B类，C类 判断是否是错误信息，只要判断是否与前面信息矛盾即可 并查集的时间复杂度O(α(n)) α(n)是阿克曼函数的反函数，比O(lgn)还快 代码如下（并查集的模板 + 并查集的应用） #include\u003ciostream\u003e\rusing namespace std;\rint T[100005],X[100005],Y[100005];\rint n,k;\r//union find\rint par[150005]; //父亲 int rankk[150005]; //树的高度,!!!元素是根 （优化用）//reference to \"rank\" is ambiguous\r//初始化，要用并查集前要初始化\rvoid init(int n) {\rfor(int i=0;i\u003cn;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} //查询树的根\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); //return find(par[x]);也可以 。par[x]=find(par[x]) 是路径压缩优化 } //合并x,y //优化高度（如果rankk不同，那么从rankk小的向大的连边 void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; //判断是否已在同一个集合内\r if(rankk[x]\u003crankk[y]) par[x]=y; //!!!利用它们的 根 进行合并 else\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++; //这时候rankk还是原来的高度 } } //判断是否在同一个集合内\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\rcin\u003e\u003en\u003e\u003ek;\rfor(int i=0;i\u003ck;i++)\rscanf(\"%d%d%d\",\u0026T[i],\u0026X[i],\u0026Y[i]);\rinit(n*3);\rint ans=0;\rfor(int i=0;i\u003ck;i++)\r{\rint t=T[i],x=X[i]-1,y=Y[i]-1;\r//错误的编号\r if(x\u003c0 || x\u003e=n || y\u003c0 || y\u003e=n)\r{\rans++;\rcontinue;\r} else if(t==1) //第一种类型\r {\rif(same(x,y+n) || same(x,y+2*n)) ans++; //判断是否矛盾 //!!!只需要判断x在A类就行，因为每次unite都\r //涵盖所有情况，它们是平行影响的，判断一个就相当于判断所有 else\r{\runite(x,y);\runite(x+n,y+n);\runite(x+n+n,y+n+n);\r}\r} else if(t==2)\r{\rif(same(x,y) || same(x,y+2*n)) ans++;\relse\r{\runite(x,y+n);\runite(x+n,y+2*n);\runite(x+2*n,y);\r}\r}\r}\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:2:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"完全背包问题 1384 ","date":"2020-01-27","objectID":"/poj/:3:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 题意：完全背包问题求最小价值 时间复杂度O(nm) 二维数组如下，MLE #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint dp[505][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\rcin\u003e\u003et;\rwhile(t--)\r{\rcin\u003e\u003ee\u003e\u003ef;\rm=f-e;\rcin\u003e\u003en;\r//init\r fill(dp[0],dp[0]+n*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026v[i],\u0026w[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=0;j\u003c=m;j++)\rif(j\u003cw[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=min(dp[i-1][j],dp[i][j-w[i]]+v[i]);\rif(dp[n][m]!=inf)\rprintf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[n][m]);\relse\rprintf(\"This is impossible.\\n\");\r}\rreturn 0;\r}\r 改一维数组，AC #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint dp[10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\rcin\u003e\u003et;\rwhile(t--)\r{\rcin\u003e\u003ee\u003e\u003ef;\rm=f-e;\rcin\u003e\u003en;\r//init\r fill(dp,dp+m+1,inf); //!!!!!\r dp[0]=0;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026v[i],\u0026w[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=w[i];j\u003c=m;j++)\rdp[j]=min(dp[j],dp[j-w[i]]+v[i]);\rif(dp[m]!=inf)\rprintf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[m]);\relse\rprintf(\"This is impossible.\\n\");\r}\rreturn 0;\r}\r 这个地方要注意 fill 到 dp+m+1 滚动数组好啊 AC代码 #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint dp[2][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003et;\rwhile(t--)\r{\rcin\u003e\u003ee\u003e\u003ef;\rm=f-e;\rcin\u003e\u003en;\r//init\r fill(dp[0],dp[0]+2*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026v[i],\u0026w[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=0;j\u003c=m;j++)\rif(j\u003cw[i])\rdp[i\u00261][j]=dp[(i-1)\u00261][j];\relse\rdp[i\u00261][j]=min(dp[(i-1)\u00261][j],dp[i\u00261][j-w[i]]+v[i]);\rif(dp[n\u00261][m]!=inf)\rprintf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[n\u00261][m]);\relse\rprintf(\"This is impossible.\\n\");\r}\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:3:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 这种类型的dp有两个重点，初始化边界条件，找递推式 求最小，一般初始化为inf，dp[0][0]=0; 求最大，一般初始化为0 必要时可用滚动数组 完全背包递推式的证明（这里证明求最大值的情况） dp[i][j]=max{dp[i-1][j-k*w[i]]+k*v[i] | k\u003e=0} =max(dp[i-1][j] , max{dp[i-1][j-k*w[i]]+k*v[i] | k\u003e=1} =max(dp[i-1][j] , max{dp[i-1][(j-w[i])-k*w[i]]+k*v[i] | k\u003e=0}+v[i]) =max(dp[i-1][j] , dp[i][j-w[i]]+v[i]) 这种分离思想很常见 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:3:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"线性dp LCS 1458 ","date":"2020-01-27","objectID":"/poj/:4:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 水一题线性dp裸题–LCS(longest common subsequence) 因为没加string头文件CE了3次（被error误导了） ac代码 #include\u003ciostream\u003e\r#include\u003ccstring\u003e\r#include\u003cstring\u003e\rusing namespace std;\rstring s1,s2;\rint dp[1000][1000]; //dp[i][j] 表示s1到i，s2到j的lcs长度\rint len1,len2; int lcs(string s1,string s2)\r{\rlen1=s1.length();\rlen2=s2.length();\rmemset(dp,0,sizeof(dp));\rfor(int i=0;i\u003clen1;i++)\rfor(int j=0;j\u003clen2;j++)\rif(s1[i]==s2[j])\rdp[i+1][j+1]=dp[i][j]+1;\relse\rdp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);\rreturn dp[len1][len2];\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r while(cin\u003e\u003es1\u003e\u003es2)\rcout\u003c\u003clcs(s1,s2)\u003c\u003cendl; return 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:4:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"凸包 2187 ","date":"2020-01-27","objectID":"/poj/:5:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 平面上有n个不重合的点，求两个点的最远距离 ","date":"2020-01-27","objectID":"/poj/:5:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 由于点的个数为50000，所以暴力超时 构造凸包，遍历凸包上的点即可 坐标范围在n内的凸多边形（顶点在格点上）的顶点个数最多为O（√n）（尝试不严谨的画图证明，和公差为1的等差数列求和有关，所以是平方关系） 所以构造凸包后，暴力遍历的时间复杂度为O（n） 构造凸包可以用模板 此处介绍的是时间复杂度O(nlgn）的graham扫描法 外积是很常用的工具，此处利用外积的坐标公式的符号判断凹凸性 可以对点先排序，然后按逆时针方向依次遍历点，先构造凸包的下侧，到达最右端时，构造凸包的上侧 代码如下 #include\u003ciostream\u003e\r#include\u003cvector\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rdouble s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u003cb.x;\rreturn a.y\u003cb.y;\r}\rdouble out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u003cpoint\u003e convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\r int k=0; // 凸包点的index vector\u003cpoint\u003e qs(n*2); //构造凸包\r //逆时针构造凸包\r //构造凸包的下侧\r for(int i=0;i\u003cn;i++)\r{\rwhile(k\u003e1 \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\r for(int i=n-2,t=k;i\u003e=0;i--)\r{\rwhile(k\u003et \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--; //这里有个k\u003et 和 k\u003e1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\r{\rpoint p;\rscanf(\"%lf%lf\",\u0026p.x,\u0026p.y);\rps[i]=p;\r}\rvector\u003cpoint\u003e qs=convex_hull(ps,n);\rdouble res=0;\rfor(int i=0;i\u003cqs.size();i++)\rfor(int j=0;j\u003ci;j++)\rres=max(res,s_dist(qs[i],qs[j]));\rcout\u003c\u003c(int)res\u003c\u003cendl; //!!!不加int 或不用printf(\"%.0lf\\n\",res); 就会WA return 0;\r}\r 还有一种时间复杂度更低的方法 convex hull + rotating calipers 这是一种常见、经典的方法 对踵点：如果凸包上过两个点画两条平行线，使凸包所有的点都夹在这两条线之间，这两个点就叫对踵点，称为一对对踵点对 对于一个凸包，最远距离一定是对踵点对 所以先找一对对踵点对，根据判断凹凸性，确定哪个点向后面的点移动（如图）（图懒得画），宏观来看就是对踵点对的连线旋转了180° 这样就总时间复杂度就是O（√n） 代码如下 #include\u003ciostream\u003e\r#include\u003cvector\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rinline double s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u003cb.x;\rreturn a.y\u003cb.y;\r}\rinline double out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u003cpoint\u003e convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\r int k=0; // 凸包点的index vector\u003cpoint\u003e qs(n*2); //构造凸包\r //逆时针构造凸包\r //构造凸包的下侧\r for(int i=0;i\u003cn;i++)\r{\rwhile(k\u003e1 \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\r for(int i=n-2,t=k;i\u003e=0;i--)\r{\rwhile(k\u003et \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--; //这里有个k\u003et 和 k\u003e1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\r{\rpoint p;\rscanf(\"%lf%lf\",\u0026p.x,\u0026p.y);\rps[i]=p;\r}\rvector\u003cpoint\u003e qs=convex_hull(ps,n);\rdouble res=0; int m=qs.size();\rif(m==2) //特殊处理凸包退化情况\r {\rcout\u003c\u003c(int)s_dist(qs[0],qs[1])\u003c\u003cendl; return 0; } int i=0,j=0; //表示左右俩对踵点\r //求x轴方向上的对踵点对\r for(int k=0;k\u003cm;k++)\rif(cmp(qs[j],qs[k])) j=k;\r//rotating calipers\r int si=i,sj=j;\rwhile(!(i==sj \u0026\u0026 j==si)) //旋转180°，注意判断条件 {\r//cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cj\u003c\u003cendl;\r res=max(res,s_dist(qs[i],qs[j])); //这条语句放在while循环体的前端，可以把x轴方向上的对踵点对都比较\r //通过外积判断凹凸性，判断是i移到i+1，还是j移到j+1\r if(out_product(qs[(i+1)%m].x-qs[i].x , qs[(i+1)%m].y-qs[i].y , qs[(j+1)%m].x-qs[j].x , qs[(j+1)%m].y-qs[j].y)\u003c0) //\u003c0 或\u003c=0都可以\r i=(i+1)%m; //把m错写成n,tle好久 else\rj=(j+1)%m; //!!!要%m 这样转一圈才能回到起点，退出循环 } //之前添加的debug条件忘记屏蔽，WA了特久 cout\u003c\u003c(int)res\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:5:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"bfs dfs 2386 ","date":"2020-01-27","objectID":"/poj/:6:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 bfs dfs都行 基础dfs 时间复杂度 O(mn) //dfs\r#include\u003ciostream\u003e\rusing namespace std;\rchar field[105][105];\rint n,m;\rvoid dfs(int x,int y)\r{\rfield[x][y]='.';\rfor(int dx=-1;dx\u003c=1;dx++)\rfor(int dy=-1;dy\u003c=1;dy++)\r{\rint nx=x+dx,ny=y+dy;\rif(0\u003c=nx \u0026\u0026 nx\u003cn \u0026\u0026 0\u003c=ny \u0026\u0026 ny\u003cm \u0026\u0026 field[nx][ny]=='W')\rdfs(nx,ny);\r}\rreturn ;\r}\rint main()\r{\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u003e\u003en\u003e\u003em;\rfor(int i=0;i\u003cn;i++)\rfor(int j=0;j\u003cm;j++)\r{\rcin\u003e\u003efield[i][j];\r}\rint res=0;\rfor(int i=0;i\u003cn;i++)\rfor(int j=0;j\u003cm;j++)\r{\rif(field[i][j]=='W') {\rdfs(i,j);\rres++;\r}\r}\rcout\u003c\u003cres\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:6:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 经典dfs就是递归思想 如果图外面是可达且连通的，就在图外面加一圈 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:6:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"状态压缩dp 2686 ","date":"2020-01-27","objectID":"/poj/:7:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 TSP问题 不能在多项式时间内求解 暴力求解是阶乘数量级的 在数据不是很大的时候可以用状态压缩dp 对于这道题时间复杂度O((2^n)*m*m*n) 基础状态压缩dp 以3.667为例 道路图为 dp[S][x] S表示剩余车票集合 x表示从a出发到达x（单源最短路） dp表示最小花费 这样就变成DAG求最短路问题，不需要使用dijkstra算法，用dp就可以 dp的初始条件是 dp=inf , dp[U][a]=0 dp的状态转移方程 dp[S/{i}][u] = min{dp[S][v]+d[v][u]/t[i] (i∈S)} 将集合用整数的二进制表示 根据状态转移方程，可以用记忆化搜索+递归 这个问题可以用循环嵌套求解 约束条件很重要 这道题的约束条件是“车票” 如果题目要求每个点只能走一遍的话 那么又有一个约束条件是“点”（即判断这个点是否走过） 循环嵌套的写法就是按照套路 遍历所有子集，嵌套遍历每种子集的操作情况 遍历集合的所有情况（逆序） 嵌套遍历每个点 再嵌套遍历每个点 依题意再嵌套遍历剩下的所有车票（顺序可与上一步调换） 最后遍历所有的dp[S’][b] S'⊆U，获得最小值 ac代码 #include\u003ciostream\u003e\r#include\u003ccstring\u003e\r#define maxn 8\r#define maxm 30\r#define inf 0x3f3f3f3f\rusing namespace std;\rint n,m,p,a,b;\rint t[maxn];\rint d[maxm][maxm];\rdouble dp[1\u003c\u003cmaxn][maxm]; //dp[剩下的车票集合][目标城市]=从a到达目标城市的最短时间 int main()\r{\rwhile(scanf(\"%d%d%d%d%d\",\u0026n,\u0026m,\u0026p,\u0026a,\u0026b)==5 and !(n==0 and m==0 and p==0 and a==0 and b==0))\r{\rfor(int i=0;i\u003cn;i++) scanf(\"%d\",\u0026t[i]);\rmemset(d,-1,sizeof(d));\rint temp1,temp2,temp3;\rfor(int i=0;i\u003cp;i++)\r{\rscanf(\"%d%d%d\",\u0026temp1,\u0026temp2,\u0026temp3);\rd[temp1-1][temp2-1]=temp3;\rd[temp2-1][temp1-1]=temp3;\r}\rfor(int i=0;i\u003c1\u003c\u003cn;i++) fill(dp[i],dp[i]+m,inf); //注意这里要用循环初始化二维数组 //inf是因为要用到min dp[(1\u003c\u003cn)-1][a-1]=0;\rdouble res=inf; //inf是因为要用到min for(int s=(1\u003c\u003cn)-1;s\u003e=0;s--)\r{\rres=min(res,dp[s][b-1]);\rfor(int v=0;v\u003cm;v++)\r{\rfor(int u=0;u\u003cm;u++)\r{\rif(d[v][u]\u003e=0)\r{\rfor(int i=0;i\u003cn;i++)\r{\rif(s\u003e\u003ei\u00261)\r{\rdp[s\u0026~(1\u003c\u003ci)][u]=min(dp[s\u0026~(1\u003c\u003ci)][u],dp[s][v]+(double)d[u][v]/t[i]);\r}\r}\r}\r}\r}\r}\rif(res==inf) printf(\"Impossible\\n\");\relse printf(\"%.3lf\\n\",res); //discuss里面说poj用lf会wa,用f就ac ，但我试了lf也可以ac\r }\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:7:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"强连通分量 2816 ","date":"2020-01-27","objectID":"/poj/:8:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 如果一头牛被其他所有牛认为是红牛，那么和它在同一个强连通分量的所有牛都 是红牛，所以scc分解，拓扑序最后一个强连通分量是红牛群，最后检查这个连通 块中的一头红牛是否对所有牛可达 #include\u003ciostream\u003e\r#include\u003cvector\u003e\r#include\u003ccstring\u003e\rusing namespace std;\rint V,m;\rint t1,t2; #define maxv 10005 vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv];\rvector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; void add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u003cG[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u003crG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u003cV;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u003e\u003eV\u003e\u003em;\rwhile(m--){\rcin\u003e\u003et1\u003e\u003et2;\radd_edge(t1-1,t2-1);\r}\rint k=kosaraju_scc();\rint u=0,num=0; //备选个数 u取得正序最后一个 for(int i=0;i\u003cV;i++){\rif(cmp[i]==k-1){\ru=i;\rnum++;\r}\r}\rmemset(used,0,sizeof(used));\rrdfs(u,0); //反向判断是否都可达\r for(int i=0;i\u003cV;i++){\rif(!used[i]){\rnum=0;\rbreak;\r}\r} cout\u003c\u003cnum\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:8:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"扫描线 2932 ","date":"2020-01-27","objectID":"/poj/:9:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 坐标上有n个不相交的圆，求最外层圆的index ","date":"2020-01-27","objectID":"/poj/:9:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 由于数据规模，暴力超时 sweeping line 一般有两种，平移扫描，环形扫描 对于这一题，从左到右平移扫描 用一个容器维护每个圆的左右两个端点，代表扫描到圆和扫描出圆 对于扫描到的圆，判断它是否在别的圆内 只需要判断上下最近的两个圆（可画图证明，不严谨） 用一个容器维护还没扫描出的最外圆，可以排序，再查找。总时间复杂度O(nlgn) 可以选用set 当扫描到右时，把圆从set中去除，意味着扫描过了 #include\u003ciostream\u003e\r#include\u003cset\u003e\r#include\u003cvector\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rdouble x[40005],y[40005],r[40005];\rint n;\rtypedef pair\u003cdouble ,int\u003e pdi;\rbool inside(int i,int j)\r{\rdouble dx=x[i]-x[j],dy=y[i]-y[j];\rreturn dx*dx+dy*dy\u003c=r[j]*r[j];\r}\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\rscanf(\"%lf%lf%lf\",\u0026r[i],\u0026x[i],\u0026y[i]);\rvector\u003cpdi\u003e vt; //存左右两边界 for(int i=0;i\u003cn;i++)\r{\rvt.push_back(make_pair(x[i]-r[i],i));\rvt.push_back(make_pair(x[i]+r[i],i+n));\r}\rsort(vt.begin(),vt.end());\r//扫描\r set\u003cpdi\u003e outers; //set为了排序 vector\u003cint\u003e res; //存放结果 for(int i=0;i\u003cvt.size();i++)\r{\rint id=vt[i].second%n;\rif(vt[i].second\u003cn) //扫描到左 {\rset\u003cpdi\u003e::iterator it=outers.lower_bound(make_pair(y[id],id));\rif(it!=outers.end() \u0026\u0026 inside(id,it-\u003esecond)) continue; //上面最近的圆 if(it!=outers.begin() \u0026\u0026 inside(id,(--it)-\u003esecond)) continue; //下面最近的圆 res.push_back(id);\routers.insert(make_pair(y[id],id));\r}\relse //扫描到右 outers.erase(make_pair(y[id],id));\r} sort(res.begin(),res.end());\rcout\u003c\u003cres.size()\u003c\u003cendl;\rfor(int i=0;i\u003cres.size();i++)\rprintf(\"%d%c\",res[i]+1,i+1==res.size()? '\\n' : ' ');\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:9:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"贪心 3069 ","date":"2020-01-27","objectID":"/poj/:10:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 一条路上有n个路灯，每个路灯都能照亮左右的一段距离，问最少需要多少路灯才能使街道都亮着 ","date":"2020-01-27","objectID":"/poj/:10:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 greedy 从最左开始向右延伸r，在r的范围内将最右的路灯点亮，此时这盏路灯将照亮左边和右边，从暗处的最左路灯开始，已知重复下去。 时间复杂度 O(n) !!!!需要将路灯位置排序 #include\u003ciostream\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint r,n;\rint x[1006];\rint main()\r{\rwhile(scanf(\"%d%d\",\u0026r,\u0026n)==2 \u0026\u0026 r!=-1)\r{\rfor(int i=0;i\u003cn;i++)\rscanf(\"%d\",\u0026x[i]);\rsort(x,x+n); // ！！！记得排序\r int j=0,ans=0;\rwhile(j\u003cn)\r{\rint s=x[j++];\rwhile(j\u003cn \u0026\u0026 x[j]\u003c=s+r) j++;\rint p=x[j-1];\rwhile(j\u003cn \u0026\u0026 p+r\u003e=x[j]) j++;\rans++;\r} printf(\"%d\\n\",ans);\r}\rreturn 0;\r} =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:10:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"贪心 3617 ","date":"2020-01-27","objectID":"/poj/:11:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 给一个字符串s和空字符串p，每次进行以下操作之一 删除s的头部字符，加入到p的尾部 删除s的尾部字符，加入到p的尾部 最后s为空，p的字典序最小 ","date":"2020-01-27","objectID":"/poj/:11:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 greedy 时间复杂度最坏 O($n^2$) #include\u003ciostream\u003e\rusing namespace std;\rint n;\rchar s[2005];\rint c=0;\rint main()\r{\rcin\u003e\u003en;\rfor(int i=0;i\u003cn;i++)\r{\rcin\u003e\u003es[i];\r}\rint a=0,b=n-1;\rbool left=false;\rwhile(a\u003c=b)\r{\rfor(int i=0;a+i\u003c=b;i++)\r{\rif(s[a+i]\u003cs[b-i])\r{\rleft=true;\rbreak;\r}\relse if(s[a+i]\u003es[b-i])\r{\rleft=false;\rbreak;\r}\r}\rif(left) putchar(s[a++]);\relse putchar(s[b--]);\rc++;\rif(c%80==0) putchar('\\n');\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:11:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"01背包问题 3624 ","date":"2020-01-27","objectID":"/poj/:12:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 基础01背包问题 如果用二维数组写的话就会MLE 猜测测试数据可能不会满，就随着数据动态申请内存，想侥幸过（可以用new/delete 或 malloc/free）结果还是MLE 这是MLE代码 #include\u003ciostream\u003e\rusing namespace std;\r//int dp[3410][12885];\rint n,m;\r//int w[3410];\r//int v[3410];\rint main()\r{\rcin\u003e\u003en\u003e\u003em;\rint **dp,*w,*v;\rdp=new int*[n+3];\rfor(int i=0;i\u003cn+3;i++)\rdp[i]=new int[m+3];\rw=new int[n+3];\rv=new int[n+3];\rfor(int i=1;i\u003c=n;i++)\r{\rscanf(\"%d%d\",\u0026w[i],\u0026v[i]);\r}\r//initialized\r for(int i=0;i\u003c=n;i++)\rdp[i][0]=0;\rfor(int i=0;i\u003c=m;i++)\rdp[0][i]=0;\rfor(int i=1;i\u003c=n;i++)\rfor(int j=0;j\u003c=m;j++)\rif(j\u003cw[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);\rcout\u003c\u003cdp[n][m];\rdelete dp,w,v;\rreturn 0;\r}\r 在discuss找了一圈也没有二维数组过的 优化成一维数组（节省内存，容易出bug） AC代码 #include\u003ciostream\u003e\rusing namespace std;\rint n,m;\rint dp[12885];\rint w[3410];\rint v[3410];\rint main()\r{\rcin\u003e\u003en\u003e\u003em;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026w[i],\u0026v[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=m;j\u003e=w[i];j--)\rdp[j]=max(dp[j],dp[j-w[i]]+v[i]);\rcout\u003c\u003cdp[m];\rreturn 0;\r}\r 这个内层循环是递减的，如果是递增则解决完全背包问题 由于01背包问题的dp[i]只依赖于dp[i-1]，内层循环递减时，dp[j]依赖的dp[j]为i-1的dp[j] 由于原来在二维数组中就是递增的，是同一个i，所以内层循环递增时，dp[j]依赖的dp[j]为i的dp[j]，符合完全背包问题 由于有两种状态（i和i-1），所以可利用奇偶性滚动数组实现 AC代码 #include\u003ciostream\u003e\rusing namespace std;\rint n,m;\rint dp[2][12885];\rint w[3410];\rint v[3410];\rint main()\r{\rcin\u003e\u003en\u003e\u003em;\rfor(int i=1;i\u003c=n;i++)\rscanf(\"%d%d\",\u0026w[i],\u0026v[i]);\rfor(int i=1;i\u003c=n;i++)\rfor(int j=0;j\u003c=m;j++)\rif(j\u003cw[i])\rdp[i\u00261][j]=dp[(i-1)\u00261][j];\relse\rdp[i\u00261][j]=max(dp[(i-1)\u00261][j],dp[(i-1)\u00261][j-w[i]]+v[i]);\rcout\u003c\u003cdp[n\u00261][m];\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:12:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"2-SAT 3683 ","date":"2020-01-27","objectID":"/poj/:13:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 xi表示某一婚礼 xi为真表示在开始举行 xi为假表示在结束举行 对于两个婚礼 如果同在开始时间举行会产生冲突 则 ¬xi ∨ ¬xj 为真 遍历所有的关系对，检查是否产生冲突 如果产生冲突则有一个析取式成立 遍历完之后得到一个合取范式 这样就把问题转换成2-SAT 根据蕴含等值式 a ∨ b ⇒ (a ∨ b) ∧ (b ∨ a) ⇒ (¬a → b) ∧ (¬b → a) 对于每一个蕴含式都可以构造一条有向边 最后scc分解 判断合取范式是否是可满足式，只需要检查¬xi 和 xi 是否在同一个强连通分量中 最后对于所在强连通分量的拓扑序，依次给出真值 ac代码 #include\u003ciostream\u003e\r#include\u003cvector\u003e\r#include\u003ccstring\u003e\rusing namespace std;\rint n;\rint V; const int maxv=2005; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv];\rvector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; int s[1005],t[1005],d[1005];\rvoid add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u003cG[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u003crG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u003cV;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u003e\u003en;\rint t1,t2,t3,t4,t5;\rfor(int i=0;i\u003cn;i++){\rscanf(\"%d:%d%d:%d%d\",\u0026t1,\u0026t2,\u0026t3,\u0026t4,\u0026t5);\rs[i]=t1*60+t2;\rt[i]=t3*60+t4;\rd[i]=t5;\r}\rV=n*2;\rfor(int i=0;i\u003cn;i++)for(int j=i+1;j\u003cn;j++){\rif( min( s[i]+d[i] , s[j]+d[j] ) \u003e max(s[i] , s[j])){\radd_edge(i,n+j);\radd_edge(j,n+i);\r}\rif(min(s[i]+d[i] , t[j]) \u003e max(s[i] , t[j]-d[j])){\radd_edge(i,j);\radd_edge(n+j,i+n);\r}\rif(min(t[i] , s[j]+d[j]) \u003e max(s[j] , t[i]-d[i])){\radd_edge(i+n,j+n);\radd_edge(j,i);\r}\rif(min(t[i] , t[j]) \u003e max(t[i]-d[i] , t[j]-d[j])){\radd_edge(n+i,j);\radd_edge(n+j,i);\r}\r}\rkosaraju_scc();\rfor(int i=0;i\u003cn;i++){\rif(cmp[i]==cmp[i+n]){\rcout\u003c\u003c\"NO\\n\";\rreturn 0;\r}\r}\rcout\u003c\u003c\"YES\\n\";\rfor(int i=0;i\u003cn;i++){\rif(cmp[i]\u003ecmp[i+n]){\rprintf(\"%02d:%02d %02d:%02d\\n\",s[i]/60,s[i]%60,(s[i]+d[i])/60,(s[i]+d[i])%60);\r}\relse{\rprintf(\"%02d:%02d %02d:%02d\\n\",(t[i]-d[i])/60,(t[i]-d[i])%60,t[i]/60,t[i]%60);\r}\r}\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:13:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"bfs dfs 3984 ","date":"2020-01-27","objectID":"/poj/:14:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 dfs/bfs都行 基础bfs （这个测试点只有一个，就是样例） 时间复杂度O(mn) #include\u003ciostream\u003e\r#include\u003cmap\u003e\r#include\u003cvector\u003e\r#include\u003cqueue\u003e\r#include\u003calgorithm\u003e\rusing namespace std;\rint n,m;\rint maze[7][7];\rint d[7][7];\rconst int inf=0x3f3f3f3f;\rtypedef pair\u003cint,int\u003e pii; //表示坐标 int sx,sy,gx,gy; //起点终点 int dx[]={0,0,1,-1};\rint dy[]={1,-1,0,0};\rmap\u003cpii,pii \u003e mp; //记录前驱节点,目的是记录路径 （如果记录路径就可以不用求最短距离） vector\u003cpii \u003e vt; //记录路径 void bfs()\r{\rqueue\u003cpii\u003e q;\rfill(d[0],d[0]+7*7,inf);\rq.push(pii(sx,sy));\rd[sx][sy]=0;\rwhile(q.size())\r{\rpii p=q.front();\rq.pop();\rif(p.first==gx and p.second==gy) break; //很重要的终止判断条件\r for(int i=0;i\u003c4;i++)\r{\rint nx=p.first+dx[i],ny=p.second+dy[i];\rif(nx\u003e=0 and ny\u003e=0 and nx\u003cn and ny\u003cm and maze[nx][ny]==0 and d[nx][ny]==inf) //inf的判断很重要\r {\rq.push(pii(nx,ny));\rd[nx][ny]=d[p.first][p.second]+1;\rmp[pii(nx,ny)]=pii(p.first,p.second);\r} } }\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r n=5;\rm=5;\rfor(int i=0;i\u003cn;i++)\rfor(int j=0;j\u003cm;j++)\rcin\u003e\u003emaze[i][j];\rsx=0,sy=0,gx=4,gy=4;\rbfs();\r//cout\u003c\u003cd[gx][gy]\u003c\u003cendl;\r pii p;\rp=pii(gx,gy);\rwhile(p!=pii(sx,sy))\r{\rvt.push_back(p);\rp=mp[p];\r}\rreverse(vt.begin(),vt.end());\rprintf(\"(%d, %d)\\n\",sx,sy);\rfor(vector\u003cpii\u003e::iterator it=vt.begin();it!=vt.end();it++)\r{\rprintf(\"(%d, %d)\\n\",it-\u003efirst,it-\u003esecond);\r}\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:14:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 一个经典的bfs模板就是用队列来控制广度优先 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:14:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"强连通分量 1236 ","date":"2020-01-27","objectID":"/poj/:15:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 第一问就是求scc的数量，第二问就是求对每个scc出度为0的数量和入度为0的数量 #include\u003ciostream\u003e\r#include\u003ccstring\u003e\r#include\u003cvector\u003e\rusing namespace std;\rconst int maxv = 105;\rint V; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv];\rvector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; int in[maxv],out[maxv];\rvoid add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u003cG[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u003crG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u003cV;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u003e\u003eV; for(int i=0;i\u003cV;i++){\rwhile(1){\rint tmp;\rcin\u003e\u003etmp;\rif(tmp==0) break;\rtmp--;\radd_edge(i,tmp); }\r}\rint k = kosaraju_scc();\rfor(int i=0;i\u003cV;i++){\rfor(int j=0;j\u003cG[i].size();j++){\rint to = G[i][j];\rif(cmp[i] != cmp[to]){\rin[cmp[to]]++;\rout[cmp[i]]++;\r}\r}\r}\rint ind =0;\rint outd = 0;\rfor(int i=0;i\u003ck;i++){\rif(in[i]==0) ind++;\rif(out[i]==0) outd++;\r}\rint ans;\rif(k==1) ans = 0;else ans = max(ind,outd);\rcout\u003c\u003cind\u003c\u003cendl;\rcout\u003c\u003cans\u003c\u003cendl;\rreturn 0;\r}\r =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:15:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"平面点分治 3714 ","date":"2020-01-27","objectID":"/poj/:16:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 懒得写 #include \u003ciostream\u003e\r#include \u003ciomanip\u003e\r#include \u003calgorithm\u003e\r#include \u003ccmath\u003e\rusing namespace std;\rtypedef double db ;\rstruct node{\rdb x, y;\rint flag;\r}vt[200005], tmp[200005];\rbool compy(node n1, node n2){\rreturn n1.y \u003c n2.y;\r}\rbool compx(node n1, node n2){\rreturn n1.x \u003c n2.x;\r}\rdb dist(node n1, node n2){\rdb dx = fabs(n1.x - n2.x);\rdb dy = fabs(n1.y - n2.y);\rreturn sqrt(dx * dx + dy * dy);\r}\rdb solve(int l, int r){\rif(l == r) return 1e50;\rint m = (l + r) / 2;\rdb d = min(solve(l, m), solve(m + 1, r));\rint cnt = 0;\rfor(int i = l; i \u003c= r; ++i){\rif(abs(vt[i].x - vt[m].x) \u003c d){\rtmp[++cnt] = vt[i];\r}\r}\rsort(tmp + 1, tmp + cnt + 1, compy);\rfor(int i = 1; i \u003c= cnt; ++i){\rfor(int j = i + 1; j \u003c= cnt; ++j){\rif(tmp[j].y - tmp[i].y \u003e= d) break;\rif(tmp[j].flag == tmp[i].flag) continue;\rd = min(d, dist(tmp[i], tmp[j]));\r}\r}\rreturn d;\r}\rint main() {\rint _;\rcin \u003e\u003e _;\rwhile (_--) {\rint n;\rcin \u003e\u003e n;\rfor(int i = 1; i \u003c= n; ++i){\rcin \u003e\u003e vt[i].x \u003e\u003e vt[i].y;\rvt[i].flag = 0;\r}\rfor(int i = n + 1; i \u003c= 2 * n; ++i){\rcin \u003e\u003e vt[i].x \u003e\u003e vt[i].y;\rvt[i].flag = 1;\r}\rsort(vt + 1, vt + 2 * n + 1, compx);\rcout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c solve(1, 2 * n) \u003c\u003c endl;\r}\rreturn 0;\r}\r ","date":"2020-01-27","objectID":"/poj/:16:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["note"],"content":"简易对拍","date":"2020-01-27","objectID":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/","tags":["cpp"],"title":"简易对拍","uri":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/"},{"categories":["note"],"content":"以这道题为例 准备一个对拍的文件夹，里面装这些东西 duipai_random_input_src.cpp是产生随机测试数据的代码 #include\u003ccstdlib\u003e\r#include\u003ciostream\u003e\r#include\u003cctime\u003e\rusing namespace std;\rint t=100; //数据组数\rint main()\r{\rsrand(time(0));\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"w\",stdout);\rint a,b;\rwhile(t--)\r{\ra=rand();\rb=rand();\rif(a\u003eb) swap(a,b);\rcout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003cendl;\r}\rreturn 0;\r} 将产生的随机测试数据写入duipai_random_input.txt中 ac代码或暴力搜索正确的代码 //ac\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u003c=50) return x;\rif(x\u003e50 and x\u003c=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u003e0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"r\",stdin);\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_ac_output.txt\",\"w\",stdout);\rwhile(~scanf(\"%lld%lld\",\u0026t1,\u0026t2)) {\rprintf(\"input data are %lld %lld --- \",t1,t2);\rprintf(\"%lld\\n\",fun(t2)-fun(t1-1));\r}\r//cout\u003c\u003cfun(180);\r return 0;\r}\r 从duipai_random_input.txt读入，写到duipai_ac_output.txt中 wa代码 //wa\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u003c=50) return x;\rif(x\u003e50 and x\u003c=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u003e0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"r\",stdin);\rfreopen(\"D:\\\\c++\\\\duipai\\\\duipai_wa_output.txt\",\"w\",stdout);\rwhile(~scanf(\"%lld%lld\",\u0026t1,\u0026t2)) {\rprintf(\"input data are %lld %lld --- \",t1,t2);\rprintf(\"%lld\\n\",fun(t2)-fun(t1)+1);\r}\r//cout\u003c\u003cfun(180);\r return 0;\r}\r 从duipai_random_input.txt读入，写到duipai_wa_output.txt中 比较duipai_ac_output.txt 和 duipai_wa_output.txt 在duipai文件夹下运行批处理命令（duipai.bat） @echo off\rfc duipai_ac_output.txt duipai_wa_outout.txt\rpause\r echo off是不回显，fc是文件比较 运行cpp和bat程序 得到结果 过于复杂的输入数据和输出数据，简易对拍不好实现 要产生大随机数，可以用 long long r=123456789;\rcout\u003c\u003c(long long)((double)(rand()*r)/RAND_MAX);\r 这题也可对拍 ","date":"2020-01-27","objectID":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/:0:0","tags":["cpp"],"title":"简易对拍","uri":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/"},{"categories":["abc"],"content":"abc152-D","date":"2020-01-26","objectID":"/abc152-d/","tags":["cpp"],"title":"abc152-D","uri":"/abc152-d/"},{"categories":["abc"],"content":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数 字，B的第一个数字是A的最后一个数字，个位数也算，输出满足条件的正整数对的个数 这种题感觉abc一贯的风格 当时第一感觉是纯模拟肯定巨麻烦，就想着有没有规律，发现没有规律 又想着按数位分类。 按数位分类就要考虑对子里面的数位 花了一些时间把它整理成元素都是9^n的矩阵（一个对称矩阵） 然而并没有什么用，还是得求N-10^k这个剩余部分 问题又回到起点 试图从9^n求和中找规律，无果 试图简化模拟或换个角度模拟，无果 看了别人的解答，大同小异 遍历一遍N，二维数组存N中第一个数字为 i ，最后一个数字为 j 的个数 最后遍历ans+=c[i][j]*c[j][i] #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint n;\rlong long ans;\rlong long c[10][10];\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r cin\u003e\u003en;\rfor(int i=1;i\u003c=n;i++)\r{\rstring s=to_string(i);\rc[s[0]-'0'][s[s.length()-1]-'0']++;\r}\rfor(int i=0;i\u003c10;i++)\rfor(int j=0;j\u003c10;j++)\rans+=c[i][j]*c[j][i];\rcout\u003c\u003cans;\rreturn 0; }\r 总结：我好弱啊 ","date":"2020-01-26","objectID":"/abc152-d/:0:0","tags":["cpp"],"title":"abc152-D","uri":"/abc152-d/"},{"categories":["note"],"content":"排序算法的时间复杂度","date":"2020-01-23","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","tags":["cpp","sort"],"title":"排序算法的时间复杂度","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["note"],"content":"时间复杂度与计算时间的关系","date":"2020-01-23","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","tags":["cpp"],"title":"时间复杂度与计算时间的关系","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["note"],"content":"c++交集、并集、差、对称差函数","date":"2020-01-17","objectID":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/"},{"categories":["note"],"content":" #include\u003ciostream\u003e\r#include\u003cset\u003e\r//#include\u003cmap\u003e\r//#include\u003cstring\u003e\r#include\u003calgorithm\u003e\r#include\u003citerator\u003e\rusing namespace std;\rint main()\r{\rint a[]={3,2,1};\rint b[]={3,4,5,6};\rset\u003cint\u003e s1(a,a+3);\rset\u003cint\u003e s2(b,b+4);\rset\u003cint\u003e s3;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin()));\rfor(set\u003cint\u003e::iterator it=s3.begin();it!=s3.end();it++)\rcout\u003c\u003c*it\u003c\u003c\" \";\rcout\u003c\u003cendl;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\"*\"));\rcout\u003c\u003cendl;\rset_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \"));\rcout\u003c\u003cendl;\rset_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \"));\rcout\u003c\u003cendl;\rset_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \"));\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/:0:0","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/"},{"categories":["note"],"content":"c++每种类型的值域","date":"2020-01-17","objectID":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/","tags":["cpp"],"title":"c++每种类型的值域","uri":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/"},{"categories":["note"],"content":" #include\u003ciostream\u003e\r#include\u003cstring\u003e\r#include \u003climits\u003e\rusing namespace std;\rint main()\r{\rcout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl;\rcout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)();\rcout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t);\rcout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)();\rcout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl;\rcout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl;\r// \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl;\r cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl;\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/:0:0","tags":["cpp"],"title":"c++每种类型的值域","uri":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/"},{"categories":["algorithm","note"],"content":"extended euclidean algorithm","date":"2020-01-17","objectID":"/extended-euclidean-algorithm/","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"/extended-euclidean-algorithm/"},{"categories":["algorithm","note"],"content":" #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint ex_gcd(int a,int b,int\u0026 x,int\u0026 y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main()\r{\rint a,b,x,y;\ra=60;\rb=22;\rcout\u003c\u003cex_gcd(a,b,x,y)\u003c\u003cendl;\rcout\u003c\u003cx\u003c\u003c\" \"\u003c\u003cy\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/extended-euclidean-algorithm/:0:0","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"/extended-euclidean-algorithm/"},{"categories":["algorithm","note"],"content":"ford fulkerson algorithm","date":"2020-01-17","objectID":"/ford-fulkerson-algorithm/","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"/ford-fulkerson-algorithm/"},{"categories":["algorithm","note"],"content":" //O(FE) /* input 5 7\r1 3 6\r3 5 8\r2 5 5\r3 2 3\r1 2 6\r4 1 10\r4 2 2\r4 5\routput\r11\r*/\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\r#define maxv 100\r#define inf 0x3f3f3f3f\rint v,e;\rint s,t;\rstruct edge{int to,cap,rev;\r};\rvector\u003cedge\u003e G[maxv];\rbool used[maxv];\rvoid add_edge(int from ,int to,int cap)\r{\rG[from].push_back((edge){to,cap,G[to].size()});\rG[to].push_back((edge){from,0,G[from].size()-1});\r}\rint dfs(int s,int t,int f)\r{\rif(s==t) return f;\rused[s]=true;\rfor(int i=0;i\u003cG[s].size();i++)\r{\redge \u0026e =G[s][i];\rif(!used[e.to] \u0026\u0026 e.cap\u003e0)\r{\rint d=dfs(e.to,t,min(f,e.cap));\rif(d\u003e0)\r{\re.cap-=d;\rG[e.to][e.rev].cap+=d;\rreturn d;\r}\r}\r}\rreturn 0;\r}\rint max_flow(int s,int t)\r{\rint flow=0;\rfor(;;)\r{\rmemset(used,0,sizeof(used));\rint f=dfs(s,t,inf);\rif(f==0) return flow;\rflow+=f;\r}\r}\rint main()\r{\rfreopen(\"input.txt\",\"r\",stdin);\rcin\u003e\u003ev\u003e\u003ee;\rfor(int i=0;i\u003ce;i++)\r{\rint from,to,cap;\rscanf(\"%d%d%d\",\u0026from,\u0026to,\u0026cap);\radd_edge(from,to,cap);\r}\rcin\u003e\u003es\u003e\u003et;\rcout\u003c\u003cmax_flow(s,t);\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/ford-fulkerson-algorithm/:0:0","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"/ford-fulkerson-algorithm/"},{"categories":["algorithm","note"],"content":"字符串匹配算法(未完成)","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"从学习方法和代码实现debug花了挺长时间。。。 这个算法是从字符串s中找子串p出现的第一个位置 以下是两个常见的字符串匹配算法（还有其他更高效的比如Turbo-bm算法，sunday算法） kmp算法和bm算法 时间复杂度是O(s+p) bm算法总体比kmp算法要快3倍 当然也可以直接用函数，比如 s.find( p ); //懒得写更多，懒得修饰代码 plus:字符串的读入常常会出现读空格、读回车等奇妙现象 ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:0","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"kmp算法 //kmp without optimization\r//strncpy() memmove()\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint kmp(char s[],char p[])\r{\r//preprocess\r int sl=strlen(s);\rint pl=strlen(p);\rchar subp[pl+1][pl+1];\rint next[pl+1];\rfor(int k=0;k\u003cpl;k++)\r{\rstrncpy(subp[k],p,k+1);\r}\r//can optimized\r for(int k=0;k\u003cpl;k++)\r{\rstring tl;\rstring tr;\rint len_sub=k+1;\rint len=0;\rfor(int m=len_sub-1;m\u003e0;m--)\r{\rtl=string(subp[k],subp[k]+m);\rtr=string(subp[k]+len_sub-m,subp[k]+len_sub);\rif(tl==tr)\r{\rlen=m;\rbreak;\r}\r}\rnext[k]=len;\r}\rfor(int k=pl-1;k\u003e0;k--)\r{\rnext[k]=next[k-1];\r}\rnext[0]=-1;\r//match\r int i=0;int j=0;\rwhile(1)\r{\rif(s[i]==p[j])\r{\ri++;\rj++;\r}\relse\r{\rint t=next[j];\rif(t==-1)\r{\ri++;\rj=0;\r}\relse\r{\rj=t;\r}\r}\rif(j\u003e=pl)\r{\rreturn i-pl;\r}\rif(i\u003e=sl)\r{\rreturn -1;\r}\r}\r}\rint main()\r{\rfreopen(\"input.txt\",\"r\",stdin);\rchar a[100];\rchar b[100];\rcin\u003e\u003ea\u003e\u003eb;\rcout\u003c\u003ckmp(a,b);\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:1","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"bm算法 //bm algorithm three to five times faster than kmp in genneral\r#include\u003ciostream\u003e\r#include\u003calgorithm\u003e\r#include\u003ccstring\u003e\r#include\u003cstring\u003e\r#include\u003cvector\u003e\rusing namespace std;\rint get_badc(char t,char a[])\r{\rint k=strlen(a)-1;\rwhile(1)\r{\rif(k\u003e=0) //assert\r {\rif(a[k--]==t)\r{\rreturn k+1;\r}\r}\relse return -1;\r}\r}\rint get_goods(vector\u003cchar\u003e t,char a[]) //most difficult\r{\rint k=strlen(a)-1;\rvector\u003cchar\u003e temp;\rint max_len=0;\rint m=0;\rint loc=-1;\rwhile(1)\r{ if(k\u003e=0) //assert\r {\rif(t[m]==a[k])\r{\rtemp.push_back(a[k]);\rm++;\rk--;\r}\relse\r{\rm=0;\rk--;\rif(temp.size()\u003emax_len)\r{\rmax_len=temp.size();\rloc=k+1;\rtemp.clear();\r}\r}\r}\relse return loc;\r}\r}\rint bm(char s[],char p[])\r{\rint sl=strlen(s);\rint pl=strlen(p);\rint i=pl-1;\rint j=pl-1;\rwhile(1)\r{\rif(i\u003csl and j\u003e=0) //asseert // i\u003csl !!!!!!!!!! not i\u003e0\r {\rif(s[i]==p[j])\r{\rvector\u003cchar\u003e goods;\rgoods.push_back(s[i]);\rwhile(1)\r{\ri--;\rj--;\rif(i\u003e=0 and j\u003e=0) //assert\r {\rif(s[i]!=p[j])\r{\rchar badc1=s[i];\rstring str(p,p+pl-goods.size());\rint loc1=get_badc(badc1,\u0026str[0]);\rint loc2=get_goods(goods,\u0026str[0]);\rif(loc1==-1 and loc2!=-1)\r{\ri+=pl-1-loc2;\rj=pl-1;\r}\relse if(loc2==-1 and loc1!=-1)\r{\ri+=pl-1-loc1;\rj=pl-1;\r}\relse\r{\ri+=pl-1-min(loc1,loc2);\rj=pl-1;\r}\r}\relse\r{\rgoods.push_back(s[i]); //still add in good-suffix\r }\r}\relse break;\r}\r}\relse //only have bad-character\r {\rchar badc2=s[i];\rint loc=get_badc(badc2,p);\ri+=pl-1-loc;\rj=pl-1;\r}\r}\relse if(i\u003e=sl) return -1; //!!!!!!!!!!!!!\r else return i+1; //!!!!!!!!!!!!\r }\r}\rint main()\r{\rfreopen(\"input.txt\",\"r\",stdin);\rchar a[100];\rchar b[100];\rcin\u003e\u003ea\u003e\u003eb;\rcout\u003c\u003cb\u003c\u003cendl\u003c\u003ca;\rcout\u003c\u003cbm(b,a)\u003c\u003cendl;\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:2","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"筛法求区间内质数个数？","date":"2020-01-17","objectID":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/"},{"categories":["algorithm","note"],"content":"很早以前写的懒得去审查。。。 不知道对不对。。。 Eprime #include\u003cbits/stdc++.h\u003e\rusing namespace std;\r#define MAX 10000\rlong long prime1[MAX],num1;\rlong long prime2[MAX],num2;\rbool isprime1[MAX],isprime2[MAX];\rint qprime1(int n)\r{\rnum1=0;\rmemset(isprime1,1,sizeof(isprime1));\risprime1[0]=isprime1[1]=0;\rfor(int i=2;i\u003c=n;i++)\r{\rif(isprime1[i])\r{\rprime1[num1++]=i;\rfor(int j=2;j*i\u003c=n;j++)\risprime1[j*i]=0;\r}\r}\rreturn num1;\r}\rint qprime2(int m,int n)\r{\rnum2=0;\rqprime1((int)sqrt(n));\rmemset(isprime2,1,sizeof(isprime2));\rfor(int i=0;i\u003cnum1;i++)\r{\rfor(int j=m/prime1[i];j*prime1[i]\u003c=n;j++)\r{\risprime2[j*prime1[i]]=0;\r}\r}\rfor(int i=m;i\u003c=n;i++)\rif(isprime2[i]) num2++;\rreturn num2;\r} int main()\r{\rcout\u003c\u003cqprime2(10,100);\rreturn 0;\r}\r ","date":"2020-01-17","objectID":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/:0:0","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/"},{"categories":["note"],"content":"输入输出优化(提高读入输出速度)","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291 ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:0:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"1.用scanf,printf代替cin,cout ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:1:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"2.取消同步和绑定 ios::sync_with_stdio(false);\rcin.tie(0);\r//cout.tie(0);\r 此时只能用cin,cout ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:2:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"3.对整型输入输出，将每个数字变成字符 inline int read()\r{\rint x=0;int f=1;char s=getchar();\rwhile(s\u003c'0' or s\u003e'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u003e='0' and s\u003c='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rvoid write(int x)\r{\rif(x/10\u003e0) write(x/10);\rputchar(char(x%10+'0'));\r}\rint main()\r{\r//freopen(\"input.txt\",\"r\",stdin);\r int n=read();\rcout\u003c\u003cn\u003c\u003cendl;\rwrite(200);\rreturn 0;\r} ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:3:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"}]
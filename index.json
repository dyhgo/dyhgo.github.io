[{"categories":["algorithm","note"],"content":"快速排序","date":"2024-02-22","objectID":"/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","tags":["cpp","sort"],"title":"快速排序","uri":"/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"categories":["algorithm","note"],"content":" #include \u003cbits/stdc++.h\u003e using namespace std; void quickSort(vector\u003cint\u003e\u0026 a, int l, int r) { if (l \u003c r) { int ptrl = l, ptrr = r; int x = a[ptrl]; while (ptrl \u003c ptrr) { while (a[ptrl] \u003c= x and ptrl \u003c r) { // 注意这里是 \u003c r 不是 \u003c ptrr ptrl++; } while (a[ptrr] \u003e= x and ptrr \u003e l) { ptrr--; } if (ptrl \u003c ptrr) { swap(a[ptrl], a[ptrr]); } } swap(a[l], a[ptrr]); quickSort(a, l, ptrr - 1); quickSort(a, ptrr + 1, r); } } int main() { vector\u003cint\u003e a = {3, 5, 1, 8, 9, 4, 2, 6, 0, 1}; quickSort(a, 1, (int) a.size() - 1); for (int i : a) { cout \u003c\u003c i \u003c\u003c ' '; } return 0; } ","date":"2024-02-22","objectID":"/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","tags":["cpp","sort"],"title":"快速排序","uri":"/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"categories":["database"],"content":"redis","date":"2024-02-20","objectID":"/redis/","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"基础篇 ","date":"2024-02-20","objectID":"/redis/:1:0","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"redis命令 通用命令 String类型 key的层级结构 e.g. douyin:user:1 douyin:user:2 douyin:product:1 Hash类型 List类型 List的操作类似于deque的操作 Set类型 SortedSet类型 ","date":"2024-02-20","objectID":"/redis/:1:1","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"实战篇 ","date":"2024-02-20","objectID":"/redis/:2:0","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"高级篇 ","date":"2024-02-20","objectID":"/redis/:3:0","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"分布式缓存 Redis持久化 RDB持久化 redis database backup redis会对当前所存的数据（内存上）进行备份，备份到磁盘的rdb文件 AOF持久化 append only file aof文件记录“写命令”，当数据丢失时，只要重新执行aof文件的记录的“写命令”就行 由于AOF记录的是命令，RDB记录的是数据，所以AOF文件比RDB文件大很多，有时候对一个key重复操作，可能是没有意义的，为了解决这个问题，可以用命令bgrewriteaof优化命令，使多条命令合并成一条命令 Redis主从 redis的场景经常是多读写少，所以可以把写操作给主节点，把读操作给从节点（当然要保证主从数据的一致性） 主从同步 全量同步 增量同步 Redis哨兵 Redis分片集群 ","date":"2024-02-20","objectID":"/redis/:3:1","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"多级缓存 ","date":"2024-02-20","objectID":"/redis/:3:2","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"最佳实践 键值设计 key要有层级结构 不要有大key（单个key的value小于10KB，对于集合类型，元素个数小于1000） 如何发现bigkey 如何删除bigkey 使用合理的数据结构 批处理 ","date":"2024-02-20","objectID":"/redis/:3:3","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"原理篇 ","date":"2024-02-20","objectID":"/redis/:4:0","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"数据结构 简单动态字符串sds IntSet Dict ZipList QuickList SkipList RedisObject 五种数据类型 String List Set ZSet Hash ","date":"2024-02-20","objectID":"/redis/:4:1","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"网络模型 用户空间和内核空间 阻塞IO blocking io 非阻塞IO nonblocking io IO多路复用 io multiplexing select poll epoll 信号驱动IO signal driven io 异步IO asynchronous io 缺点：用户不管内核忙不忙得过来，一直向内核发请求会让内核崩溃 Redis网络模型 ","date":"2024-02-20","objectID":"/redis/:4:2","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"通信协议 RESP协议 模拟Redis客户端 ","date":"2024-02-20","objectID":"/redis/:4:3","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"内存策略 过期策略 过期策略是惰性删除和周期删除相结合 淘汰策略 ","date":"2024-02-20","objectID":"/redis/:4:4","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["database"],"content":"参考 黑马程序员 ","date":"2024-02-20","objectID":"/redis/:5:0","tags":["redis"],"title":"redis","uri":"/redis/"},{"categories":["linux"],"content":"test_password","date":"2024-02-01","objectID":"/test_password/","tags":["shell","linux"],"title":"test_password","uri":"/test_password/"},{"categories":["linux"],"content":"hahahah ","date":"2024-02-01","objectID":"/test_password/:0:0","tags":["shell","linux"],"title":"test_password","uri":"/test_password/"},{"categories":["note"],"content":"docker2","date":"2024-01-11","objectID":"/docker2/","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"参考链接 ","date":"2024-01-11","objectID":"/docker2/:0:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"Containerize an application 构建应用的镜像 编写Dockerfile，构建镜像（假设镜像名叫getting-started） docker build -t getting-started . 根据镜像创建容器 docker run -dp 127.0.0.1:3000:3000 getting-started 查看正在运行的容器 docker ps ","date":"2024-01-11","objectID":"/docker2/:1:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"Update the application 修改源码 重新构建镜像 docker build -t getting-started . 重新开启新的容器 docker run -dp 127.0.0.1:3000:3000 getting-started 由于旧的容器已经占用端口，所以新容器无法运行 停止旧的容器 docker stop \u003cthe-container-id\u003e 删除旧的容器 docker rm \u003cthe-container-id\u003e 或者用以下命令停止并删除 docker rm -f \u003cthe-container-id\u003e 运行新的容器 docker run -dp 127.0.0.1:3000:3000 getting-started ","date":"2024-01-11","objectID":"/docker2/:2:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"Share the application 在网页端登录docker hub，创建仓库，名为getting-started 在命令行登录docker hub docker login -u YOUR-USER-NAME 给镜像打标签 docker tag getting-started YOUR-USER-NAME/getting-started 推到仓库 docker push YOUR-USER-NAME/getting-started 使用play with docker 在一个全新的环境里运行镜像 由于play with docker用的是amd64的平台，如果电脑是arm架构，就需要构建一个能在amd64平台上运行的镜像 docker build --platform linux/amd64 -f ./Dockerfile -t da1yh/getting_started . 重新push 在play with docker中，创建新的实例 在终端中输入 docker run -dp 0.0.0.0:3000:3000 YOUR-USER-NAME/getting-started 由于本地找不到这个镜像，所以去docker hub拉取 ","date":"2024-01-11","objectID":"/docker2/:3:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"Persist the DB 运行一个ubuntu容器，让它产生一个data.txt文件，并写入一个随机数 docker run -d ubuntu bash -c \"shuf -i 1-10000 -n 1 -o /data.txt \u0026\u0026 tail -f /dev/null\" 查看这个数字，注意docker exec和docker run的区别是他们虽然都是在容器中执行命令，但是docker exec是在已启动的容器中执行 docker exec \u003ccontainer-id\u003e cat /data.txt volume用于将容器中的文件与主机的文件关联，把一个卷挂载到容器中的一个文件路径，就可以在修改容器内这个路径下的所有数据同步到主机 创建volume docker volume create todo-db 运行容器，并挂载到特定目录 docker run -dp 127.0.0.1:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started 对应用进行增删改，停止并删除容器，重新运行容器，发现数据都在 查看volume信息 docker volume inspect todo-db [ { \"CreatedAt\": \"2019-09-26T02:18:36Z\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/todo-db/_data\", \"Name\": \"todo-db\", \"Options\": {}, \"Scope\": \"local\" } ] Mountpoint指示了容器中某个路径映射到主机的哪个路径 ","date":"2024-01-11","objectID":"/docker2/:4:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"Use bind mounts bind mount可以指定主机哪个路径和容器内的路径关联 两者不同之处 Named volumes Bind mounts Host location Docker chooses You decide Mount example (using –mount) type=volume,src=my-volume,target=/usr/local/data type=bind,src=/path/to/data,target=/usr/local/ Populates new volume with container contents yes no Supports Volume Drivers yes no 运行如下命令 docker run -it --mount type=bind,src=\"$(pwd)\",target=/src ubuntu bash cd到src目录，ls发现与主机的目录内容一样 在容器中创建文件，会同步到主机 退出容器，文件在主机上不会消失 进入容器，在主机上删掉文件，在容器中也会相应删除 ctrl-d 退出容器，注意容器只是状态是exited，但并没有消失 bind mount的好处是不需要自己搭建开发环境，只需要docker run相应的容器就有了开发环境 以下说明一下怎么用docker搭建开发环境 首先确保没有容器在运行 运行以下代码 docker run -dp 127.0.0.1:3000:3000 \\ -w /app --mount type=bind,src=\"$(pwd)\",target=/app \\ node:18-alpine \\ sh -c \"yarn install \u0026\u0026 yarn run dev\" 查看日志 docker logs -f \u003ccontainer-id\u003e 具有开发环境的容器，你在本地修改文件，只要启动了容器，运行应用可以发现修改立即生效，因为bind mount 然后你就可以构建新的镜像 docker build -t getting-started . ","date":"2024-01-11","objectID":"/docker2/:5:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"Multi container apps 创建network docker network create todo-app 运行一个mysql容器，绑定某个网络，然后指定一些参数来初始化数据库 docker run -d \\ --network todo-app --network-alias mysql \\ -v todo-mysql-data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=todos \\ mysql:8.0 在容器中启动mysql docker exec -it \u003cmysql-container-id\u003e mysql -u root -p 同一个网络下的容器要怎么找到别的容器？用容器的ip地址 接下来将使用一个镜像，它用来排除网络故障和调试 nicolaka/netshoot 运行 docker run -it --network todo-app nicolaka/netshoot 找ip，这个mysql就是–network-alias指定的 dig mysql 得到输出 ; \u003c\u003c\u003e\u003e DiG 9.18.13 \u003c\u003c\u003e\u003e mysql ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 39687 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;mysql. IN A ;; ANSWER SECTION: mysql. 600 IN A 172.18.0.2 ;; Query time: 3 msec ;; SERVER: 127.0.0.11#53(127.0.0.11) (UDP) ;; WHEN: Wed Jan 10 12:35:55 UTC 2024 ;; MSG SIZE rcvd: 44 运行getting-started-app docker run -dp 127.0.0.1:3000:3000 \\ -w /app -v \"$(pwd):/app\" \\ --network todo-app \\ -e MYSQL_HOST=mysql \\ -e MYSQL_USER=root \\ -e MYSQL_PASSWORD=secret \\ -e MYSQL_DB=todos \\ node:18-alpine \\ sh -c \"yarn install \u0026\u0026 yarn run dev\" 使用docker logs -f 查看发现用了mysql 打开浏览器，增加数据，在mysql容器中查看数据是否同步 docker exec -it \u003cmysql-container-id\u003e mysql -p todos mysql\u003e select * from todo_items; +--------------------------------------+--------------------+-----------+ | id | name | completed | +--------------------------------------+--------------------+-----------+ | c906ff08-60e6-44e6-8f49-ed56a0853e85 | Do amazing things! | 0 | | 2912a79e-8486-4bc3-a4c5-460793a575ab | Be awesome! | 0 | +--------------------------------------+--------------------+-----------+ ","date":"2024-01-11","objectID":"/docker2/:6:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"Use Docker Compose docker compose可以很好的处理多容器应用 需要在Dockerfile同级的目录下创建compose.yaml 本来是这样启动应用的 docker run -dp 127.0.0.1:3000:3000 \\ -w /app -v \"$(pwd):/app\" \\ --network todo-app \\ -e MYSQL_HOST=mysql \\ -e MYSQL_USER=root \\ -e MYSQL_PASSWORD=secret \\ -e MYSQL_DB=todos \\ node:18-alpine \\ sh -c \"yarn install \u0026\u0026 yarn run dev\" 现在在compose.yaml中这样写 services: app: image: node:18-alpine command: sh -c \"yarn install \u0026\u0026 yarn run dev\" ports: - 127.0.0.1:3000:3000 working_dir: /app volumes: - ./:/app environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: secret MYSQL_DB: todos 本来是这样启动mysql docker run -d \\ --network todo-app --network-alias mysql \\ -v todo-mysql-data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=todos \\ mysql:8.0 现在在compose.yaml中是这样 services: app: # The app service definition mysql: image: mysql:8.0 volumes: - todo-mysql-data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: todos volumes: todo-mysql-data: 最终的compose.yaml长这样 services: app: image: node:18-alpine command: sh -c \"yarn install \u0026\u0026 yarn run dev\" ports: - 127.0.0.1:3000:3000 working_dir: /app volumes: - ./:/app environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: secret MYSQL_DB: todos mysql: image: mysql:8.0 volumes: - todo-mysql-data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: todos volumes: todo-mysql-data: 启动应用 首先确保没有该应用的容器在运行 docker compose up -d 看到输出，docker自动创建了volume和network [+] Running 4/4 ✔ Network getting-started-app_default Created 0.0s ✔ Volume \"getting-started-app_todo-mysql-data\" Created 0.0s ✔ Container getting-started-app-mysql-1 Started 0.3s ✔ Container getting-started-app-app-1 Started 0.3s 查看实时日志 docker compose logs -f 停止并删除容器，注意这个命令也会删除network，但不会删除volume，如果要删除volume，要加--volumes docker compose down 输出 [+] Running 3/3 ✔ Container getting-started-app-mysql-1 Removed 3.4s ✔ Container getting-started-app-app-1 Removed 0.1s ✔ Network getting-started-app_default Removed ","date":"2024-01-11","objectID":"/docker2/:7:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"Image-building best practices docker中的layer 参考链接 查看某个镜像的每一\"layer\" docker image history getting-started 有些layer无法显示，用下面的命令显示所有的layer docker image history --no-trunc getting-started 原来Dockerfile # syntax=docker/dockerfile:1 FROM node:18-alpine WORKDIR /app COPY . . RUN yarn install --production CMD [\"node\", \"src/index.js\"] EXPOSE 3000 修改为 # syntax=docker/dockerfile:1 FROM node:18-alpine WORKDIR /app COPY package.json yarn.lock ./ RUN yarn install --production COPY . . CMD [\"node\", \"src/index.js\"] 与Dockerfile同级目录创建.dockerignore，写入node_modules 构建镜像 docker build -t getting-started . 修改源码，再次构建，会发现快很多 Multi-stage builds … ","date":"2024-01-11","objectID":"/docker2/:8:0","tags":["docker"],"title":"docker2","uri":"/docker2/"},{"categories":["note"],"content":"docker","date":"2023-12-26","objectID":"/docker/","tags":["docker"],"title":"docker","uri":"/docker/"},{"categories":["note"],"content":"参考资料 参考教程 docker的三个重要概念 image：镜像，就是各种环境的集合 container：由镜像生成一个一个的容器，是镜像的实例化 dockerfile：管理镜像和容器的文件 ","date":"2023-12-26","objectID":"/docker/:0:0","tags":["docker"],"title":"docker","uri":"/docker/"},{"categories":["note"],"content":"docker下载镜像 以安装redis为例 到docker hub上找redis，然后可以找到官方提供的一条命令 docker run --name some-redis -d redis 可以在docker桌面版中看到有redis的镜像和容器 ","date":"2023-12-26","objectID":"/docker/:1:0","tags":["docker"],"title":"docker","uri":"/docker/"},{"categories":["note"],"content":"docker运行ubuntu docker pull ubuntu docker run -itd --name myubuntu ubuntu 用如下命令进入容器 docker exec -it \u003ccontainer_id\u003e /bin/bash 可以用vscode的docker插件来编辑容器内的文本 docker的ubuntu没有gcc、vim等东西，要自己安装，但是无法使用apt install 要修改/etc/source.list 参考(https://blog.csdn.net/moutain9426/article/details/120292272) ","date":"2023-12-26","objectID":"/docker/:2:0","tags":["docker"],"title":"docker","uri":"/docker/"},{"categories":["note"],"content":"C++互斥锁","date":"2023-12-25","objectID":"/c-%E4%BA%92%E6%96%A5%E9%94%81/","tags":["cpp"],"title":"C++互斥锁","uri":"/c-%E4%BA%92%E6%96%A5%E9%94%81/"},{"categories":["note"],"content":"std::mutex 最简单的互斥锁 // mutex example #include \u003ciostream\u003e // std::cout #include \u003cthread\u003e // std::thread #include \u003cmutex\u003e // std::mutex std::mutex mtx; // mutex for critical section void print_block (int n, char c) { // critical section (exclusive access to std::cout signaled by locking mtx): // mtx.lock(); for (int i=0; i\u003cn; ++i) { std::cout \u003c\u003c c; } std::cout \u003c\u003c '\\n'; // mtx.unlock(); } int main () { std::thread th1 (print_block,50,'*'); std::thread th2 (print_block,50,'$'); th1.join(); th2.join(); return 0; } 输出 ****************************************$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$********** $$$$$$$$$$$$$$ // mutex example #include \u003ciostream\u003e // std::cout #include \u003cthread\u003e // std::thread #include \u003cmutex\u003e // std::mutex std::mutex mtx; // mutex for critical section void print_block (int n, char c) { // critical section (exclusive access to std::cout signaled by locking mtx): mtx.lock(); for (int i=0; i\u003cn; ++i) { std::cout \u003c\u003c c; } std::cout \u003c\u003c '\\n'; mtx.unlock(); } int main () { std::thread th1 (print_block,50,'*'); std::thread th2 (print_block,50,'$'); th1.join(); th2.join(); return 0; } 输出 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ ************************************************** ","date":"2023-12-25","objectID":"/c-%E4%BA%92%E6%96%A5%E9%94%81/:1:0","tags":["cpp"],"title":"C++互斥锁","uri":"/c-%E4%BA%92%E6%96%A5%E9%94%81/"},{"categories":["note"],"content":"std::lock_guard 能够在线程抛出异常和结束时自动解锁 // lock_guard example #include \u003ciostream\u003e // std::cout #include \u003cthread\u003e // std::thread #include \u003cmutex\u003e // std::mutex, std::lock_guard #include \u003cstdexcept\u003e // std::logic_error std::mutex mtx; void print_even (int x) { if (x%2==0) std::cout \u003c\u003c x \u003c\u003c \" is even\\n\"; else throw (std::logic_error(\"not even\")); } void print_thread_id (int id) { try { // using a local lock_guard to lock mtx guarantees unlocking on destruction / exception: std::lock_guard\u003cstd::mutex\u003e lck (mtx); print_even(id); } catch (std::logic_error\u0026) { std::cout \u003c\u003c \"[exception caught]\\n\"; } } int main () { std::thread threads[10]; // spawn 10 threads: for (int i=0; i\u003c10; ++i) threads[i] = std::thread(print_thread_id,i+1); for (auto\u0026 th : threads) th.join(); return 0; } 一种可能的输出 2 is even [exception caught] [exception caught] 6 is even 4 is even [exception caught] [exception caught] 8 is even [exception caught] 10 is even ","date":"2023-12-25","objectID":"/c-%E4%BA%92%E6%96%A5%E9%94%81/:2:0","tags":["cpp"],"title":"C++互斥锁","uri":"/c-%E4%BA%92%E6%96%A5%E9%94%81/"},{"categories":["note"],"content":"std::shared_mutex 读写锁，支持多读单写 配合std::unique_lock和std::shared_lock，前者是写锁，后者是读锁 #include \u003ciostream\u003e #include \u003cmutex\u003e // 对于 std::unique_lock #include \u003cshared_mutex\u003e #include \u003cthread\u003e class ThreadSafeCounter { public: ThreadSafeCounter() = default; // 多个线程/读者能同时读计数器的值。 unsigned int get() const { std::shared_lock\u003cstd::shared_mutex\u003e lock(mutex_); return value_; } // 只有一个线程/写者能增加/写线程的值。 void increment() { std::unique_lock\u003cstd::shared_mutex\u003e lock(mutex_); value_++; } // 只有一个线程/写者能重置/写线程的值。 void reset() { std::unique_lock\u003cstd::shared_mutex\u003e lock(mutex_); value_ = 0; } private: mutable std::shared_mutex mutex_; unsigned int value_ = 0; }; int main() { ThreadSafeCounter counter; auto increment_and_print = [\u0026counter]() { for (int i = 0; i \u003c 3; i++) { counter.increment(); std::cout \u003c\u003c std::this_thread::get_id() \u003c\u003c ' ' \u003c\u003c counter.get() \u003c\u003c '\\n'; // 注意：写入 std::cout 实际上也要由另一互斥同步。省略它以保持示例简洁。 } }; std::thread thread1(increment_and_print); std::thread thread2(increment_and_print); thread1.join(); thread2.join(); } // 解释：下列输出在单核机器上生成。 thread1 开始时，它首次进入循环并调用 increment() ， // 随后调用 get() 。然而，在它能打印返回值到 std::cout 前，调度器将 thread1 置于休眠 // 并唤醒 thread2 ，它显然有足够时间一次运行全部三个循环迭代。再回到 thread1 ，它仍在首个 // 循环迭代中，它最终打印其局部的计数器副本的值，即 1 到 std::cout ，再运行剩下二个循环。 // 多核机器上，没有线程被置于休眠，且输出更可能为递增顺序。 在单核上运行，可能的输出 123084176803584 2 123084176803584 3 123084176803584 4 123084185655040 1 123084185655040 5 123084185655040 6 ","date":"2023-12-25","objectID":"/c-%E4%BA%92%E6%96%A5%E9%94%81/:3:0","tags":["cpp"],"title":"C++互斥锁","uri":"/c-%E4%BA%92%E6%96%A5%E9%94%81/"},{"categories":["note"],"content":"std::unique_lock和std::lock_guard的区别 std::unique_lock是std::lock_guard的扩展，它可以在生命周期内手动加锁和解锁 ","date":"2023-12-25","objectID":"/c-%E4%BA%92%E6%96%A5%E9%94%81/:4:0","tags":["cpp"],"title":"C++互斥锁","uri":"/c-%E4%BA%92%E6%96%A5%E9%94%81/"},{"categories":["note"],"content":"信号量 #include \u003csemaphore.h\u003e #include \u003csignal.h\u003e sem_init 初始化一个信号量，并给定初值 sem_wait 信号量-1，如果信号量本来为0就会阻塞直到信号量\u003e0 sem_post 信号量+1 signal(某个信号，收到这个信号的处理函数) ","date":"2023-12-25","objectID":"/c-%E4%BA%92%E6%96%A5%E9%94%81/:5:0","tags":["cpp"],"title":"C++互斥锁","uri":"/c-%E4%BA%92%E6%96%A5%E9%94%81/"},{"categories":["note"],"content":"参考 https://cplusplus.com/reference/mutex/mutex/ https://cplusplus.com/reference/mutex/lock_guard/ https://zh.cppreference.com/w/cpp/thread/shared_mutex ","date":"2023-12-25","objectID":"/c-%E4%BA%92%E6%96%A5%E9%94%81/:6:0","tags":["cpp"],"title":"C++互斥锁","uri":"/c-%E4%BA%92%E6%96%A5%E9%94%81/"},{"categories":["note"],"content":"C++类继承和可见性","date":"2023-12-25","objectID":"/c-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/","tags":["cpp"],"title":"C++类继承和可见性","uri":"/c-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/"},{"categories":["note"],"content":"三种继承方式，是否真正继承了，子类可访问吗，外部可访问吗 三种可见性，类自己可访问吗，外部可访问吗 继承默认是private继承 ","date":"2023-12-25","objectID":"/c-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/:0:0","tags":["cpp"],"title":"C++类继承和可见性","uri":"/c-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/"},{"categories":["note"],"content":"继承和可见性问题 private、protected、public public大家都可以访问、private只有类成员可以访问（友元也行）、protected只有基类和派生类可以访问 友元，把类或函数声明成一个类的友元，那么它可以访问这个类的private变量 访问范围/是否继承（这一列）、父类成员可见性（这一行） public protected Private 类内 ✅ ✅ ✅ 外部 ✅ ❌ ❌ 子类public继承 ✅public ✅protected ❌ 子类protected继承 ✅protected ✅protected ❌ 子类private继承 ✅private ✅private ❌ ","date":"2023-12-25","objectID":"/c-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/:1:0","tags":["cpp"],"title":"C++类继承和可见性","uri":"/c-%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/"},{"categories":["linux"],"content":"shell三剑客","date":"2023-12-13","objectID":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/","tags":["shell","linux"],"title":"shell三剑客","uri":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/"},{"categories":["linux"],"content":"grep Global Regular Expression Print 用正则表达式查找文本 grep [-option] {pattern} {file} -A\u003c行数\u003e 除了显示匹配 pattern 的那一行外，显示该行之后的内容 -B\u003c行数\u003e 除了显示匹配 pattern 的那一行外，显示该行之前的内容 -C\u003c行数\u003e 除了显示匹配 pattern 的那一行外，显示该行前、后的内容 -c 统计匹配的行数 -e 同时匹配多个pattern -i 忽略字符的大小写 -n 显示匹配的行号 -o 只显示匹配的字符串 -v 显示没有匹配pattern的那一行，相当于反向匹配 -w 匹配整个单词 ","date":"2023-12-13","objectID":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/:1:0","tags":["shell","linux"],"title":"shell三剑客","uri":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/"},{"categories":["linux"],"content":"sed stream editor 对某个文本进行批量操作 sed [-option] '{region} {command}' file -n 只打印匹配到的行 -e 多次匹配，相当于对每行处理时，顺序执行多个sed命令 -i 直接将处理结果写入文件 不给地址 默认对全文进行处理 单地址 /pattern/，被pattern匹配到的每一行 地址范围 #, # x |d|删除模式空间匹配到的行| |p|打印模式空间中的内容| |s/old/new/g|将old替换为new，g表示行内全局替换| ","date":"2023-12-13","objectID":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/:2:0","tags":["shell","linux"],"title":"shell三剑客","uri":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/"},{"categories":["linux"],"content":"awk Aho-Corasick With Additional Features ","date":"2023-12-13","objectID":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/:3:0","tags":["shell","linux"],"title":"shell三剑客","uri":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/"},{"categories":["linux"],"content":"参考 https://zhuanlan.zhihu.com/p/181724885 https://zhuanlan.zhihu.com/p/181734158 https://zhuanlan.zhihu.com/p/186289624 ","date":"2023-12-13","objectID":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/:4:0","tags":["shell","linux"],"title":"shell三剑客","uri":"/shell%E4%B8%89%E5%89%91%E5%AE%A2/"},{"categories":["linux"],"content":"Linux输入输出","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["linux"],"content":"万物皆文件 – Linus Torvalds ","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["linux"],"content":"重定向 标准输入流stdin的文件描述符是0，标准输出流stdout的文件描述符是1，标准错误流的文件描述符是2 标准输入流一般是键盘在终端的输入，标准输出流和错误输出流一般显示在终端屏幕上 我们可以将输入输出流重定向到其他文件 输出有\u003e表示覆盖和\u003e\u003e表示追加，输入有\u003c 注意像2\u003e这种符号之间不能有空格 ","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:0","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["linux"],"content":"2\u003e\u00261 2\u003e\u00261表示把错误输出2，重定向\u003e\u0026到标准输出1所在的文件描述符(默认是终端屏幕） command \u003e file 2\u003e\u00261表示command的标准输出先重定向到file，然后错误输出重定向到标准输出（现在是file），所以最后标准输出和错误输出都被重定向到file command 2\u003e\u00261 \u003e file表示command的错误输出重定向到标准输出（现在是终端）（相当于啥事没发生），然后标准输出重定向到file，最后只有标准输出重定向到file，错误输出还是在终端输出 同理可以有1\u003e\u00262等组合 ","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:1","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["linux"],"content":"各种命令 命令 作用 command \u003e file 将command的标准输出重定向到file command » file 将command的标准输出重定向到file command 2\u003e file 只将command的标准错误输出重定向到file command 2» file 只将command的标准错误输出重定向到file command 2\u003e\u00261 将command的错误输出重定向到标准输出 command \u003e file 2\u003e\u00261 将command的标准输出和错误输出重定向到file,此时2\u003e\u00261只能写在最后 command » file 2\u003e\u00261 将command的标准输出和错误输出重定向到file,此时2\u003e\u00261只能写在最后 command \u0026\u003e file command \u003e file 2\u003e\u00261的简写，注意简写\u0026\u003e只能放在file前，不能放在后面 command \u003e\u0026 file 同command \u0026\u003e file command \u0026» file command » file 2\u003e\u00261的简写，注意\u0026»不能写成»\u0026 command 2\u003e\u00261 \u003e file 将command的标准输出重定向到file command 2\u003e\u00261 » file 将command的标准输出重定向到file command \u003c input 将command的标准输入重定向到input command « input 一直从键盘输入，直到遇到字符input，here-document方式 command «\u003c input input为单行字符串，here- string方式，其中input用单引号和双引号效果不一样，详见参考 command \u003c file1 \u003e file2 将command的标准输入重定向到file1，标准输出重定向到file2 ","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:2","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["linux"],"content":"例子 command \u003e file dyh@0v0:~$ cat a 123 dyh@0v0:~$ echo 'hello' \u003e a dyh@0v0:~$ cat a hello command \u003e\u003e file dyh@0v0:~$ cat a hello dyh@0v0:~$ echo 'world' \u003e\u003e a dyh@0v0:~$ cat a hello world command 2\u003e file dyh@0v0:~$ cd 123 -bash: cd: 123: No such file or directory dyh@0v0:~$ cat a hehe dyh@0v0:~$ cd 123 2\u003e a dyh@0v0:~$ cat a -bash: cd: 123: No such file or directory dyh@0v0:~$ cd 123 \u003e a -bash: cd: 123: No such file or directory dyh@0v0:~$ cat a dyh@0v0:~$ command 2\u003e\u003e file dyh@0v0:~$ cat a -bash: cd: 123: No such file or directory dyh@0v0:~$ cd 124 2\u003e\u003e a dyh@0v0:~$ cat a -bash: cd: 123: No such file or directory -bash: cd: 124: No such file or directory command \u003e file 2\u003e\u00261 dyh@0v0:~$ cat a qqq dyh@0v0:~$ ls a b \u003e a 2\u003e\u00261 dyh@0v0:~$ cat a ls: cannot access 'b': No such file or directory a command \u003e\u003e file 2\u003e\u00261 dyh@0v0:~$ cat a ls: cannot access 'b': No such file or directory a dyh@0v0:~$ ls a b \u003e\u003e a 2\u003e\u00261 dyh@0v0:~$ cat a ls: cannot access 'b': No such file or directory a ls: cannot access 'b': No such file or directory a command \u0026\u003e file dyh@0v0:~$ cat a ls: cannot access 'b': No such file or directory a ls: cannot access 'b': No such file or directory a dyh@0v0:~$ ls a b \u0026\u003e a dyh@0v0:~$ cat a ls: cannot access 'b': No such file or directory a command \u003e\u0026 file dyh@0v0:~$ cat a 111 dyh@0v0:~$ ls a b \u003e\u0026 a dyh@0v0:~$ cat a ls: cannot access 'b': No such file or directory a command \u0026\u003e\u003e file dyh@0v0:~$ cat a ls: cannot access 'b': No such file or directory a dyh@0v0:~$ ls a b \u0026\u003e\u003e a dyh@0v0:~$ cat a ls: cannot access 'b': No such file or directory a ls: cannot access 'b': No such file or directory a command 2\u003e\u00261 \u003e file dyh@0v0:~$ cat a qqq dyh@0v0:~$ ls a b 2\u003e\u00261 \u003e a ls: cannot access 'b': No such file or directory dyh@0v0:~$ cat a a command 2\u003e\u00261 \u003e\u003e file dyh@0v0:~$ cat a a dyh@0v0:~$ ls a b 2\u003e\u00261 \u003e\u003e a ls: cannot access 'b': No such file or directory dyh@0v0:~$ cat a a a command \u003c input dyh@0v0:~$ cat a hello world hah dyh@0v0:~$ wc -l a 3 a dyh@0v0:~$ wc -l \u003c a 3 command \u003c\u003c input dyh@0v0:~$ wc -l \u003c\u003c a \u003e 123 \u003e 456 \u003e hello world \u003e yes \u003e no \u003e a 5 command \u003c\u003c\u003c input dyh@0v0:~$ tr a-z A-Z \u003c\u003c\u003c aa AA dyh@0v0:~$ tr a-z A-Z \u003c\u003c\u003c 'hello world' HELLO WORLD dyh@0v0:~$ tr a-z A-Z \u003c\u003c\u003c \"hello world\" HELLO WORLD dyh@0v0:~$ tr a-z A-Z \u003c\u003c\u003c aa bb tr: extra operand ‘bb’ Try 'tr --help' for more information. command \u003c file1 \u003e file2 dyh@0v0:~$ cat a hello world hah dyh@0v0:~$ tr a-z A-Z \u003c a \u003e r dyh@0v0:~$ cat r HELLO WORLD HAH dyh@0v0:~$ cat a hello world hah dyh@0v0:~$ cat \u003e a \u003c\u003c qq \u003e erfafsa \u003e fafssvadrfgh \u003e fvdsf \u003e qq dyh@0v0:~$ cat a erfafsa fafssvadrfgh fvdsf ","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:3","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["linux"],"content":"/dev/null 将输出流重定向到/dev/null就会消失，像掉进黑洞一样 ","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:4","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["linux"],"content":"管道 管道将标准输出流转化成标准输入流 dyh@0v0:~$ ps -ef | grep \"ba\" root 31 2 0 Nov22 ? 00:00:00 [writeback] root 610 1 0 Nov22 ? 00:00:03 /usr/sbin/irqbalance --foreground root 1086 1 0 Nov22 ttyS0 00:00:00 /sbin/agetty -o -p -- \\u --keep-baud 115200,57600,38400,9600 ttyS0 vt220 root 10451 10361 0 20:18 pts/0 00:00:00 -bash dyh 10468 10467 0 20:18 pts/0 00:00:00 -bash dyh 10560 10468 0 21:02 pts/0 00:00:00 grep ba 有时候只使用管道是不行的，要通过xargs把标准输入转化成一个或多个下一个命令的参数，一般使用空格分开，但是如果标准输入中就有空格，需要额外处理 dyh@0v0:~$ ls -l total 12 -rw-r--r-- 1 dyh dyh 29 Nov 24 20:39 a -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 aa drwxr-xr-x 2 dyh dyh 4096 Nov 24 21:22 dir_a dyh@0v0:~$ find ~ -name '*a*' /home/dyh/aa /home/dyh/a /home/dyh/dir_a dyh@0v0:~$ ls -l /home/dyh/aa /home/dyh/a /home/dyh/dir_a -rw-r--r-- 1 dyh dyh 29 Nov 24 20:39 /home/dyh/a -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 /home/dyh/aa /home/dyh/dir_a: total 0 dyh@0v0:~$ find ~ -name '*a*' | ls -l total 12 -rw-r--r-- 1 dyh dyh 29 Nov 24 20:39 a -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 aa drwxr-xr-x 2 dyh dyh 4096 Nov 24 21:22 dir_a dyh@0v0:~$ find ~ -name '*a*' | xargs ls -l -rw-r--r-- 1 dyh dyh 29 Nov 24 20:39 /home/dyh/a -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 /home/dyh/aa /home/dyh/dir_a: total 0 对于find命令，可以使用-exec选项 dyh@0v0:~$ find ~ -name '*a*' -exec ls -l {} \\; -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 /home/dyh/aa -rw-r--r-- 1 dyh dyh 29 Nov 24 20:39 /home/dyh/a total 0 不过如果要查找文件，最好用whereis或locate，这两个都比find快，不过find是最强大的查找工具 find \u003cpath\u003e -name \u003cname\u003e -exec \u003ccommand\u003e {} \\;和find \u003cpath\u003e -name \u003cname\u003e | xargs \u003ccommand\u003e有什么区别 Q: find \u003cpath\u003e -name \u003cname\u003e -exec \u003ccommand\u003e {} \\;和find \u003cpath\u003e -name \u003cname\u003e | xargs \u003ccommand\u003e都是Linux中的find命令，用于查找文件并对其执行指定的命令。两者的区别在于： A: find \u003cpath\u003e -name \u003cname\u003e -exec \u003ccommand\u003e {} \\;会对每个查找到的文件都执行一次指定的命令，而find \u003cpath\u003e -name \u003cname\u003e | xargs \u003ccommand\u003e则会将所有查找到的文件名作为参数传递给xargs命令，然后再一次性地执行指定的命令。 find \u003cpath\u003e -name \u003cname\u003e -exec \u003ccommand\u003e {} \\;可以保证命令的执行顺序，而find \u003cpath\u003e -name \u003cname\u003e | xargs \u003ccommand\u003e则不能保证命令的执行顺序。 例如，下面的命令将在当前目录下查找所有.txt文件，并对每个文件执行ls -l命令： find . -name \"*.txt\" -type f -exec ls -l {} \\; 而下面的命令则使用了xargs命令来执行相同的操作： find . -name \"*.txt\" -type f | xargs ls -l 这两个命令的效果是相同的，但是第二个命令可能会更快，因为它可以将多个文件名作为参数传递给ls命令，从而减少了命令的执行次数. 总的来说，如果需要对每个查找到的文件执行指定的命令，并且命令的执行顺序很重要，那么应该使用-exec选项。如果只是需要对所有查找到的文件执行指定的命令，并且命令的执行顺序不重要，那么可以考虑使用xargs命令. 以上答案来自于gpt-4 xargs 处理空格输入 dyh@0v0:~$ ls -l total 12 -rw-r--r-- 1 dyh dyh 29 Nov 24 21:59 a -rw-r--r-- 1 root root 0 Nov 24 22:00 'a a' -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 aa drwxr-xr-x 2 dyh dyh 4096 Nov 24 21:22 dir_a dyh@0v0:~$ ls a 'a a' aa dir_a dyh@0v0:~$ find ./ -name '*a*' ./aa ./a a ./a ./dir_a dyh@0v0:~$ ls -l ./aa ./a\\ a ./a ./dir_a -rw-r--r-- 1 dyh dyh 29 Nov 24 21:59 ./a -rw-r--r-- 1 root root 0 Nov 24 22:00 './a a' -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 ./aa ./dir_a: total 0 dyh@0v0:~$ find ./ -name '*a*' | ls -l total 12 -rw-r--r-- 1 dyh dyh 29 Nov 24 21:59 a -rw-r--r-- 1 root root 0 Nov 24 22:00 'a a' -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 aa drwxr-xr-x 2 dyh dyh 4096 Nov 24 21:22 dir_a dyh@0v0:~$ find ./ -name '*a*' | xargs ls -l -rw-r--r-- 1 dyh dyh 29 Nov 24 21:59 ./a -rw-r--r-- 1 dyh dyh 29 Nov 24 21:59 ./a -rw-r--r-- 1 dyh dyh 29 Nov 24 21:59 a -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 ./aa ./dir_a: total 0 dyh@0v0:~$ find ./ -name '*a*' -print0 | xargs -0 ls -l -rw-r--r-- 1 dyh dyh 29 Nov 24 21:59 ./a -rw-r--r-- 1 root root 0 Nov 24 22:00 './a a' -rw-r--r-- 1 dyh dyh 15 Nov 24 21:13 ./aa ./dir_a: total 0 -print0和-0意思是不用空格分割了，用null分割 ","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:2:0","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["linux"],"content":"参考 https://www.runoob.com/linux/linux-shell-io-redirections.html https://www.redhat.com/sysadmin/linux-shell-redirection-pipelining https://blog.csdn.net/succing/article/details/127355545 https://blog.csdn.net/weixin_43025343/article/details/132537234 https://luzejia.blog.csdn.net/article/details/112059493?spm=1001.2014.3001.5502 https://blog.csdn.net/oqqHuTu12345678/article/details/129282059 https://www.runoob.com/linux/linux-comm-xargs.html ","date":"2023-11-24","objectID":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:3:0","tags":["shell","linux"],"title":"Linux输入输出","uri":"/linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["database"],"content":"mysql","date":"2023-11-20","objectID":"/mysql/","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"基础 ","date":"2023-11-20","objectID":"/mysql/:1:0","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"SQL SQL语言分类 DDL 数据类型 数值型 字符串类型 日期和时间型 数据库 查数据库show databases; 查当前数据库select database(); 增加数据库create database [if not exists] xxx [default charset xxx] [collate xxx]; 删除数据drop database [if exists] xxx; 使用数据库use xxx; 表 查询当前数据库的所有表show tables; 查询某个表的结构desc xxx; 查询建表的语句show create table xxx; 创建表 create table xxx( id int comment 'student id', name varchar(20) comment 'name' ) comment 'student table'; 对已存在的表添加新的字段alter table {table name} add {field name} {type} [comment] [restraint]; 对已存在的表修改某个字段的数据类型alter table {table name} modify {field name} {new type}; 对已存在的表修改某个字段alter table {table name} change {old field name} {new field name} {type} [comment] [restraint]; 删除字段alter table {table name} drop {filed name}; 修改表名alter table {table name} rename to {new table name}; DML 添加数据 insert into {table name} ( {field name1}, {field name2}, ...) values ( {value1}, {value2}, ...); 给全部字段添加数据 insert into {table name} values ( {value1}, {value2}, ...); 一次性插入多条数据 修改某条数据 update {table name} set {field name1} = {value1}, {field name2} = {value2}, ... [where...]; 删除某条数据 delete from {table name} [where...]; DQL select {fields} from {tables} where {conditions} group by {group fields} having {conditions} order by {sorting fields} limit {args}; 基础查询 查询几个字段的记录 以下用fd代替field name，tb代替table name，fds代替{fd1}, {fd2}, ... select {fd1}, {fd2}, ... from {tb}; select * from {tb}; 设置别名，设置别名 select {fd1} [as alias1], {fd2} [as alias2] ... from {tb}; 去除重复记录 select distinct {fds} from {tb} 条件查询 聚合函数 count min max avg sum 分组查询 group by {fd} having {condition} 排序查询 order by {fd1} asc|desc, {fd2} asc|desc;先按fd1排，然后再排fd2 asc可以省略 分页查询 语句的执行顺序 select {fields} 4 from {tables} 1 where {conditions} 2 group by {group fields} 3 having {conditions} order by {sorting fields} 5 limit {args} 6; DCL ","date":"2023-11-20","objectID":"/mysql/:1:1","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"函数 字符串函数 数值函数 日期函数 流程函数 ","date":"2023-11-20","objectID":"/mysql/:1:2","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"约束 外键相关的删除更新行为 ","date":"2023-11-20","objectID":"/mysql/:1:3","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"多表查询 内连接 查询两张表交集的部分 隐式内连接 select {fds} from {tbs} where {condition}; 显示内连接 select {fds} from {tb1} [inner] join {tb2} on {condition}; 外连接 查询某个表所有的信息加上另个相关联的表的部分信息就是外连接 左外连接 select {fds} from {tb1} left [outer] join {tb2} on {condition}; 右外连接 select {fds} from {tb1} right [outer] join {tb2} on {condition}; 自连接 必须起别名 select {fds} from {tb1} {alias1} join {tb1} {alias2} on {condition}; 自连接可以包含内连接和外连接，只要语法和内连接和外连接一样就行 联合查询 把两个查询结果联合成一张表 select {fds} from {tbs} ... union [all] select {fds} from {tbs} ...; 加all表示不对两次查询的结果去重 与or的区别，如果条件很多则选择union性能更好，查询条件较少，选择or 子查询 子查询就是where语句的条件是DQL 标量子查询 子查询的结果是一行一列 行子查询 子查询的结果是一行多列 列子查询 子查询的结果是一列多行 表子查询 子查询结果是多行多列 ","date":"2023-11-20","objectID":"/mysql/:1:4","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"事务 查看事务是自动提交还是手动提交 select @@autocommit; 如果是1，是自动提交，如果是0，是手动提交 设置提交方式 set @@autocommit=0; 提交事务 commit;` 回滚事务，撤销所有未提交的修改 rollback; 开启事务 start transaction; begin; ACID 并发事务带来的问题 （没懂） 事务隔离级别（重要） 查看事务隔离级别 select @@transaction_isolation; 设置事务隔离级别 set [session|global] transaction isolation level {read uncommitted | read committed | repeatable read | serializable}; ","date":"2023-11-20","objectID":"/mysql/:1:5","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"进阶 mysql体系结构 ","date":"2023-11-20","objectID":"/mysql/:2:0","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"存储引擎 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也叫做表类型 查当前数据库支持的存储引擎 show engines; InnoDB 特点 DML操作遵循ACID模型，支持事务 行级锁，提高并发访问性能 支持外键约束 InnoDB把每张数据库存在xxx.ibd文件中，xxx是表名 InnoDB的逻辑存储结构 MyISAM mysql早期存储引擎 特点 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件 xxx.sdi 存储表结构信息 xxx.MYD 存储数据 xxx.MYI 存储引擎 Memory memory引擎的表数据存储在内存中，容易收到断电影响，所以作临时表或缓存表用 特点 内存存放，速度快 hash索引 文件 xxx.sdi 存储表结构信息 存储引擎对比（重要） 存储引擎选择 现在一般使用innodb，myisam被mongodb取代，memory被redis取代 ","date":"2023-11-20","objectID":"/mysql/:2:1","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"索引 （重要） 结构 b树 b+树 hash表 分类 有了聚集索引和二级索引后，查数据用的是回表查询 语法 创建索引 create [unique | fulltext] index {index_name} on {table name} ({col_name1}, {col_name2}, ...); 查看索引 show index from {table_name}; 删除索引 drop index {index_name} on {table_name}; SQL性能分析 查看数据库增删改查的频次 show global status like 'Com_______'; 慢查询日志 查看每条语句耗时 show profiles; 查询执行语句详情 explain {language}; 使用规则 索引可以大幅提升查询时间 最左前缀法则 如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳过某一列，索引将部分失效（后面的字段索引失效） 联合索引中，出现范围查询（指大于和小于），范围查询右侧的列索引失效 所以尽量用大于等于和小于等于 索引失效情况 在索引列上进行运算操作，索引失效 字符串没加引号，失效 模糊查询中，尾部模糊不会失效，头部模糊会失效 or连接的所有条件必须都有索引，否则整个or语句不会用到索引 mysql评估使用索引比全表扫描慢，则不使用索引 SQL提示 建议mysql使用特定索引 ... from ... use index ({index name}) where ...; 不使用特定索引 ... ignore index ...; 强制使用特定索引 ... force index ...; 覆盖索引和回表查询 注意这里关注的是查询的字段就是select后面的内容而不是查询的条件（where后面的内容） 覆盖索引指的是查询的字段最好是联合索引的子集（可以加上id，如果id是聚集索引的索引项），否则会回表查询 回表查询就是先从二级索引中查，然后再到聚集索引中查 explain语句的extra字段中，using where; using index不需要回表查询，using index condition就是要回表查询 前缀索引 对于varchar，text的字符串类型，把它们用做索引时，很耗费开销，所以取字符串的前缀作索引 create index {index_name} on {table_name}(column(x));表示取前x个字符 前缀索引如果多个字符串前缀相同在b+树中怎么查询？先查到一个，然后回表查询比对，不是的话沿链表查询下一个，具体不知道 单列索引和联合索引 一般选择联合索引，单列索引容易造成回表查询 设计原则 ","date":"2023-11-20","objectID":"/mysql/:2:2","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"SQL优化 大部分都涉及到索引 插入数据 插入少量数据 当需要插入多条数据时，使用批量插入 手动提交事务 主键顺序插入 插入大量数据 load 主键优化 插入数据最好按主键顺序插入，否则会产生“页分裂” 当删除数据时会出现“页合并” order by优化 using filesort和using index在explain语句的extra字段查看 using filesort慢，using index快 尽量把using filesort优化成using index 按照order by后面的字段的顺序和升降序创建对应的索引 前提是要用到覆盖索引（就是查询的字段是索引的子集（可以带主键）），覆盖索引不需要回表查询 group by优化 根据group by的条件建立联合索引，注意索引也是满足最左前缀法则，如果有where语句，where后面的条件也纳入最左前缀法则的范畴 limit优化 通过覆盖索引和子查询进行优化 count优化 性能 count(字段) \u003c count(主键) \u003c count(1) \u003c count(*) update优化 update的where跟着的字段要是索引，不然两个事务共同执行时行锁变成表锁，并发性能降低 innodb的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁变成表锁 ","date":"2023-11-20","objectID":"/mysql/:2:3","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"视图 创建视图 create [or replace] view {view_name} as select ...; 查看创建视图的语句 show create view {view_name}; 查看视图数据，和表的操作一致 select * from {view_name}; 修改视图 create [or replace] view {view_name} as select ...; 或者 alter view {view_name} as select ...; 删除视图 drop view [if exists] {view_name}; 对视图的其他增删改查操作和表操作的语法一样 注意：对视图的增删改操作将会影响基表，对基表的修改会影响视图 注意：如果一个视图基于基于表的视图，那么对视图的修改仍然会影响基表 注意：视图可以基于视图创建 检查选项 由于对视图的修改会影响到基表或基视图 如果不加检查选项，那么对视图的修改不会检查视图创建语句的where条件 如果对视图增加或修改一条不满足条件的数据，基表或基视图会正常增加或修改，但是视图不显示（因为不满足条件） 要想做到无法增加或修改不满足条件的数据就要使用检查选项 cascaded 在创建视图的语句后面加上with cascaded check option;则对视图进行增加修改时会检查这条数据是否满足创建视图的语句的where条件，并且还会级联地检查这条数据是否满足基视图的where条件 对视图增加或修改数据的判断逻辑是，如果这个视图没有加检查选项，则不做检查，然后检查这个视图基于的视图或表，如果它有加检查选项就检查是否满足条件，如果是级联的，就继续往下检查；如果没加检查选项，就继续查看它基于的表 只要有一个视图加了级联，则它一定会判断这个视图基于的所有视图和表的条件 local local就是只检查当前视图条件，不级联检查它基于的视图条件 注意：要不要检查条件是一定会顺着链路一直进行下去的，但是local只负责当前视图，cascaded则会检查它所有的基视图或基表的条件，默认是cascaded 视图的更新限制 只有当视图中的每一条数据和基表是 一一对应关系时才可以更新 视图的作用 把那些经常查询的数据列出来，这样比较直观，也不需要重复写这些查询条件，有点像求质数的预处理操作 安全性，给特定的用户提供特定的视图 ","date":"2023-11-20","objectID":"/mysql/:2:4","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"存储过程 就是把多条mysql语句集合在一起 基本语法 创建过程 create procedure {procedure_name}([{aug1}, {aug2}, {aug3}]) begin {sql_statement} end; 调用过程 call {procedure_name}({aug1}, {aug2}, ...); 查看该数据库具有的过程 select * from information_schema.ROUTINES where ROUTINE_SCHEMA='{database_name}'; 查看创建过程的语句 show create procedure {procedure_name}; 删除过程 drop procedure [if exists] {procedure_name}; 注意在命令行中执行创建过程语句时，会出现遇到分号提前结束mysql语句的错误 需要写输入以下命令 delimiter xx 表示mysql语句由xx结尾，然后把创建过程的语句最后的分号改成xx 变量 变量分为系统变量、用户变量、局部变量 系统变量 系统变量是系统定义的变量 系统变量分为全局变量（global）和会话变量（session） 注意：全局变量会在mysql服务器重启后变成默认值，如果想要永久修改全局变量，则要到/etc/my.conf这个文件中修改 查看系统变量（没加session或者global默认是session） show [session | global] variables; show [session | global] variables like 'xxx'; select @@[session | global][.]{var_name}; 设置系统变量 set [session | global] {var_name} = {var_value}; set @@[session | global][.]{var_name} = {var_value}; 用户变量 定义和赋值，可以用:=，也可以用=，推荐使用:=，因为mysql的相等和赋值都是=，用:=不会混淆 set @{var_name} = xxx [, @{var_name2} = xxx]; set @{var_name} := xxx [, @{var_name2} := xxx]; select @{var_name} := xxx [, @{var_name2} := xxx]; 把从表中查询到的某些字段（结果）赋值给用户变量 select {field_name} into @{var_name} from {table_name}; 查看 select @{var_name}; 注意：用户变量不需要声明和初始化，但是如果没有初始化，则默认值是null 局部变量 局部变量需要声明，常用在过程中的局部变量和输入参数，局部变量的作用范围是begin end之间 声明 declare {var_name} {var_type} [default ...]; 变量类型就是数据库字段类型 赋值 set {var_name} = {var_value}; set {var_name} := {var_value}; select {field_name} into {var_name} from {table_name} ... ; 条件语句 if if判断写在过程的begin和end内 语法 if {condition1} then ... elseif {condition2} then ... else ... end if; case 语法 case {var} when {value1} then ... [when {value2} then ... [else ...] end case; case when {condition1} then ... [when {condition2} then ... [else ...] end case; 参数和返回值 参数有三种，in表示传入的参数，out表示返回值，inout既可以作为形参，也可以作为返回值 语法 create procedure {procedure_name}([in|out|inout {para_name} {para_type}]) begin ... end; inout变量有点像传引用 循环 while while {condition} do ... end while; repeat repeat ... until {condition} end repeat; loop [{loop_name1}:] loop ... iterate {loop_name1}; leave {loop_name1}; ... end loop [{loop_name1}]; 指针 用来对查询结果集进行操作 声明指针 declare {cursor_name} cursor for {select_statement}; 打开指针 open {cursor_name}; 获取指针记录 fetch {cursor_name} into {var1} [, {var2}, {var3}, ...]; 关闭指针 close {cursor_name}; 注意：在过程中，局部变量的声明要在指针的声明之前 注意：指针指代查询结果集的一行，每次fetch之后，指针自动跳到下一行 处理程序 可以定义在一个流程中，如果遇到了某种情况的相应处理措施 handler_action是处理措施，有两种 continue继续执行当前程序，exit退出当前程序 condition_value是触发条件 sqlstate {value} ，这个value是状态码，比如02000 sqlwarning，所有以01开头的状态码 not found，所有以02开头的状态码 sqlexception，除了sqlwarning和not found以外的状态码 声明handler declare {handler_action} handler for {condition_value1} [, {condition_value2}, ...] {actions_before_handler_action}; 注意：这里的handler_action的作用范围是所在的begin end块 函数 一种特殊的过程，它一定有返回值，且参数只能是in类型 create function {function_name}([in] {para_name1} {para_type1}, [[in] {para_name2} {para_type2}]) returns {return_type} deterministic|no sql|reads sql data begin ... return {return_value}; end; characteristic说明 deterministic 相同的输入总是产生相同的输出 no sql 不包含sql语句 reads sql data 有读数据的语句没有写数据的语句 ","date":"2023-11-20","objectID":"/mysql/:2:5","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"触发器 有三种类型的触发器，并且用old和new来表示旧的数据和新的数据 类型 old new insert类型触发器 new表示新增的数据 update类型的触发器 old表示旧的数据 new表示更新后的数据 delete类型触发器 old表示要删除的数据 mysql只支持行级触发器（update语句更新了多行就触发多次）不支持语句级触发器（update语句不管更新几行，只要是一条语句就触发一次） 创建触发器 create trigger {trigger_name} before|after insert|update|delete --触发触发器的操作 on {table_name} /*被监控的表*/ for each row begin ... end; 查看触发器 show triggers; 删除触发器，如果不指定数据库名，则默认是当前数据库 drop trigger [{db_name}.]{trigger_name}; ","date":"2023-11-20","objectID":"/mysql/:2:6","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"锁 （重要） 全局锁 锁整个数据库 典型的使用场景是数据库要做备份，要先加全局锁 对当前数据库加全局锁 flush tables with read lock; 数据库数据备份（注意：这不是mysql语句，而是bash命令） -h是连接远程数据库 mysqldump [-h {ip_addr}] -uxxx -pxxx {db_name} \u003e xxx.sql 释放全局锁 unlock tables; innodb引擎中使用如下语句可以通过不加锁实现数据一致性的备份（快照读方式） mysqldump --single-transaction -uxxx -pxxx {db_name} \u003e xxx.sql 表级锁 表级锁分为表锁、元数据锁、意向锁 表锁 表锁分为表读锁和表写锁（又叫表共享锁和表排他锁） 表读锁允许自己读，不允许自己写，允许别人读，不允许别人写 表写锁允许自己读，允许自己写，不允许别人读，不允许别人写 加锁 lock tables {tb_name} read|write; 释放锁 unlock tables; 或者客户端断开连接 元数据锁 meta data lock MDL 元数据就是表结构，元数据锁是在访问一张表时系统自动加的，为了避免dml和ddl冲突，保证读写操作的正确性 具体客户端在对数据表做操作时加哪些锁，看下表 元数据锁会自动释放，当这条语句执行完后自动释放，当使用事务时，在commit之后才算语句执行完，才释放锁 查看元数据锁 select object_type, object_schema, object_name, lock_type, lock_duration from performance_schema.metadata_locks; 意向锁 intension lock 意向锁是为了解决表锁和行锁的冲突。当对一行数据进行修改时会加行锁，这个时候如果别人就不能加表锁，要加表锁时要一行一行判断是否有行锁，很耗时，所以在加入行锁的时候再加入意向锁，当别人要加表锁时，只需要判断是否有意向锁就行 意向锁分为意向共享锁 is，与表读锁兼容，与表写锁互斥 意向排他锁ix，与表读锁和表写锁都互斥 意向锁之间不会互斥 查看意向锁 select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks; 在select语句后面加上lock in share mode就可以加上行共享锁和意向共享锁，当这条语句执行完后（如果时事务，则要提交）会自动释放锁 update语句会自动加行排他锁和意向排他锁 行级锁 应用在innodb存储引擎中 行级锁分为行锁（record lock）、间隙锁（gap lock）、临键锁（next-key lock） rc时read commmi，rr时repeatable read 行锁 间隙锁 临键锁（行锁加间隙锁，锁的是一个记录和记录前的间隙） 此图描述有误 行锁 分为共享锁和排他锁，其实就是读锁和写锁 执行增删改查时加行锁的情况 注意：加行级锁一定会加意向锁，一般同一时间加的一批行级锁对应一个意向锁 注意：innodb的行级锁都是基于索引来加的，所以如果select语句的where条件不走索引，那么innodb对表中的所有数据都加锁，即锁变成了表锁。表锁是无论如何也不允许别人写的 间隙锁/临键锁 作用时避免幻读 当对唯一索引进行等值操作时（看where后面的语句知是否走唯一索引），进行删改时，如果该记录不存在，则行级锁没法成为行锁，它会变成间隙锁，比如有数据id是3和7，改或删5，不存在，就锁住3和7之间的间隙，间隙锁的唯一作用就是防止别人在其中插入数据，也不能把已有的数据更新为间隙内的值，但是删掉间隙左右的记录是可以的 注意：上面这种情况也会同步加上意向排他锁 注意：可以对同一个间隙加多个间隙锁 当对普通索引（非唯一索引）进行等值操作时，它会增加行锁、临键锁、间隙锁。比如有数据为2 2 2 3 3 3 3 7 7 9 9 9，对3进行等值操作，那么会在最后一个3和第一个7之间加间隙锁，在所有的3上加行锁，在第一个3和之前的间隙（最后一个2和第一个3之间）上加临键锁。最后还有一个意向锁 对唯一索引进行范围查询时，它会增加行锁、临键锁，比如数据 2 3 5 7 9，查询\u003e= 7的，它对7加行锁，(7,9]加临键锁，[9,∞)加临键锁，再加一个意向锁 [此处还有待认真学习 ！！！] ","date":"2023-11-20","objectID":"/mysql/:2:7","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"InnoDB引擎 逻辑存储结构 一个表空间表示一个数据库中的一张表，是idb文件 架构 内存架构 磁盘架构 后台线程 事务的原理 事务有acid性 其中acd是有redo log和undo log实现的 i是由锁和mvcc实现的 redo log 保证了事务的持久性 记录了数据的变更内容 原理参考此处和这个，还有这个 Q：如果redo log buffer刷新redo log file失败了怎么办？ A：则事务提交不成功，不需要维护提交不成功事务的持久性 undo log 保证了事务的原子性 MVCC（重要） 当前读 快照读 MVCC 隐藏字段 查看idb文件 idb2sdi xxx.idb undolog 参考此处 undolog 版本链 readview MVCC原理（RC级别） 参考此处 MVCC原理（RR级别） 参考此处 事务的隔离性由mvcc（隐藏字段、undolog版本链、readview）和锁保证 而事务的一致性是由redo log和undo log一起保证的 事务的持久性有redo log保证 事务的原子性由redo log保证 ","date":"2023-11-20","objectID":"/mysql/:2:8","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"MySQL管理 系统级数据库 mysql常用工具 在命令行使用的 mysql mysqladmin是一个执行管理操作的客户端程序，可以用来检查服务器的配置和当前的状态、创建并删除数据库等 mysqlbinlog由于服务器生成的日志文件是以二进制保存的，所以想要查看这些文件的文本格式，就要用这个工具 mysqlshow用来查找存在哪些数据库、数据库中的表、表中的列和索引 mysqldump用来备份数据库和在不同数据库间进行数据迁移。备份内容包括创建表和插入表的sql语句 mysqlimport导入数据，用来导入mysqldump -T参数后的文本文件 source xxx.sql导入sql文件 ","date":"2023-11-20","objectID":"/mysql/:2:9","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"运维 ","date":"2023-11-20","objectID":"/mysql/:3:0","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"日志 错误日志 二进制日志 查询日志 记录客户端所有操作语句，默认是关闭 慢查询日志 ","date":"2023-11-20","objectID":"/mysql/:3:1","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"主从复制 原理 ","date":"2023-11-20","objectID":"/mysql/:3:2","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"分库分表 mycat是分库分表中间件 ","date":"2023-11-20","objectID":"/mysql/:3:3","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"读写分离 基于主从复制，一般通过mycat实现 ","date":"2023-11-20","objectID":"/mysql/:3:4","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"参考 黑马程序员 ","date":"2023-11-20","objectID":"/mysql/:4:0","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["database"],"content":"练习 牛客mysql练习 ","date":"2023-11-20","objectID":"/mysql/:5:0","tags":["mysql"],"title":"mysql","uri":"/mysql/"},{"categories":["cooking"],"content":"蛋炒饭","date":"2023-10-12","objectID":"/%E8%9B%8B%E7%82%92%E9%A5%AD/","tags":["cooking"],"title":"蛋炒饭","uri":"/%E8%9B%8B%E7%82%92%E9%A5%AD/"},{"categories":["cooking"],"content":"蛋炒饭需要使用隔夜饭，所以提前一天把饭拿到冰箱中 拿出隔夜饭，打两个蛋 切两根火腿 鸡蛋液倒四分之一到米饭中 抓一抓米饭，使其松散（颗粒分开） 点火，倒油 倒入鸡蛋液 翻炒 倒入米饭 倒入火腿，翻炒 倒一些酱油，提色 继续翻炒，翻炒的大体原则就是把锅底的东西放到锅边，把锅边的东西放到锅底 加入一些葱 翻炒一会儿，出锅 migration test —– ","date":"2023-10-12","objectID":"/%E8%9B%8B%E7%82%92%E9%A5%AD/:0:0","tags":["cooking"],"title":"蛋炒饭","uri":"/%E8%9B%8B%E7%82%92%E9%A5%AD/"},{"categories":["cooking"],"content":"套肠炒羊肚菌","date":"2023-10-11","objectID":"/%E5%A5%97%E8%82%A0%E7%82%92%E7%BE%8A%E8%82%9A%E8%8F%8C/","tags":["cooking"],"title":"套肠炒羊肚菌","uri":"/%E5%A5%97%E8%82%A0%E7%82%92%E7%BE%8A%E8%82%9A%E8%8F%8C/"},{"categories":["cooking"],"content":"此篇文章做简单记录，以防忘记 在市场上买好套肠 羊肚菌浸泡半个小时 点火，向锅中倒油 加入一些蒜 将套肠和羊肚菌倒入锅中翻炒 加入一些酱油和水（像这种比较干的东西需要加水） 加入一些葱 翻炒一会儿就能出锅 ","date":"2023-10-11","objectID":"/%E5%A5%97%E8%82%A0%E7%82%92%E7%BE%8A%E8%82%9A%E8%8F%8C/:0:0","tags":["cooking"],"title":"套肠炒羊肚菌","uri":"/%E5%A5%97%E8%82%A0%E7%82%92%E7%BE%8A%E8%82%9A%E8%8F%8C/"},{"categories":["note"],"content":"protobuf","date":"2023-08-23","objectID":"/protobuf/","tags":["note"],"title":"protobuf","uri":"/protobuf/"},{"categories":["note"],"content":"protobuf是一个类似于用来定义网络传输过程中数据包格式的东西，有点像json 它可以被序列化和反序列化，从而用于传输 参考链接 它的格式类似于这样 message Person { optional string name = 1; optional int32 id = 2; optional string email = 3; } 本文基于macos系统 ","date":"2023-08-23","objectID":"/protobuf/:0:0","tags":["note"],"title":"protobuf","uri":"/protobuf/"},{"categories":["note"],"content":"安装pb编译器 brew install protobuf ","date":"2023-08-23","objectID":"/protobuf/:1:0","tags":["note"],"title":"protobuf","uri":"/protobuf/"},{"categories":["note"],"content":"举例 以一个通讯簿应用例子来说明protobuf的使用 ","date":"2023-08-23","objectID":"/protobuf/:2:0","tags":["note"],"title":"protobuf","uri":"/protobuf/"},{"categories":["note"],"content":"定义proto格式 在proto文件中这样定义，文件名为addressbook.proto syntax = \"proto2\"; package tutorial; message Person { optional string name = 1; optional int32 id = 2; optional string email = 3; enum PhoneType { PHONE_TYPE_UNSPECIFIED = 0; PHONE_TYPE_MOBILE = 1; PHONE_TYPE_HOME = 2; PHONE_TYPE_WORK = 3; } message PhoneNumber { optional string number = 1; optional PhoneType type = 2 [default = PHONE_TYPE_HOME]; } repeated PhoneNumber phones = 4; } message AddressBook { repeated Person people = 1; } optional表示不一定需要自己给值，如果你不给值，这个字段就会是默认值，string就是空字符串，bool就是false，int就是0，除非你使用[default=]来指定默认值 repeated 表示可变数组 proto3没有required这个修饰符 =1，=2可以看作是这个message里的字段的id ","date":"2023-08-23","objectID":"/protobuf/:2:1","tags":["note"],"title":"protobuf","uri":"/protobuf/"},{"categories":["note"],"content":"编译proto buffers 输入命令，-I表示proto文件的路径，空格后跟着proto文件名，–cpp_out表示生成的头文件和源文件的路径 protoc -I=\".\" addressbook.proto --cpp_out=\".\" 可以发现生成了addressbook.pb.h和addressbook.pb.cc，里面有很多api，api相关部分看官方文档 ","date":"2023-08-23","objectID":"/protobuf/:2:2","tags":["note"],"title":"protobuf","uri":"/protobuf/"},{"categories":["note"],"content":"写message 背景：Here is a program which reads an AddressBook from a file, adds one new Person to it based on user input, and writes the new AddressBook back out to the file again. #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003cstring\u003e #include \"addressbook.pb.h\" using namespace std; // This function fills in a Person message based on user input. void PromptForAddress(tutorial::Person* person) { cout \u003c\u003c \"Enter person ID number: \"; int id; cin \u003e\u003e id; person-\u003eset_id(id); cin.ignore(256, '\\n'); cout \u003c\u003c \"Enter name: \"; getline(cin, *person-\u003emutable_name()); cout \u003c\u003c \"Enter email address (blank for none): \"; string email; getline(cin, email); if (!email.empty()) { person-\u003eset_email(email); } while (true) { cout \u003c\u003c \"Enter a phone number (or leave blank to finish): \"; string number; getline(cin, number); if (number.empty()) { break; } tutorial::Person::PhoneNumber* phone_number = person-\u003eadd_phones(); phone_number-\u003eset_number(number); cout \u003c\u003c \"Is this a mobile, home, or work phone? \"; string type; getline(cin, type); if (type == \"mobile\") { phone_number-\u003eset_type(tutorial::Person::MOBILE); } else if (type == \"home\") { phone_number-\u003eset_type(tutorial::Person::HOME); } else if (type == \"work\") { phone_number-\u003eset_type(tutorial::Person::WORK); } else { cout \u003c\u003c \"Unknown phone type. Using default.\" \u003c\u003c endl; } } } // Main function: Reads the entire address book from a file, // adds one person based on user input, then writes it back out to the same // file. int main(int argc, char* argv[]) { // Verify that the version of the library that we linked against is // compatible with the version of the headers we compiled against. GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) { cerr \u003c\u003c \"Usage: \" \u003c\u003c argv[0] \u003c\u003c \" ADDRESS_BOOK_FILE\" \u003c\u003c endl; return -1; } tutorial::AddressBook address_book; { // Read the existing address book. fstream input(argv[1], ios::in | ios::binary); if (!input) { cout \u003c\u003c argv[1] \u003c\u003c \": File not found. Creating a new file.\" \u003c\u003c endl; } else if (!address_book.ParseFromIstream(\u0026input)) { cerr \u003c\u003c \"Failed to parse address book.\" \u003c\u003c endl; return -1; } } // Add an address. PromptForAddress(address_book.add_people()); { // Write the new address book back to disk. fstream output(argv[1], ios::out | ios::trunc | ios::binary); if (!address_book.SerializeToOstream(\u0026output)) { cerr \u003c\u003c \"Failed to write address book.\" \u003c\u003c endl; return -1; } } // Optional: Delete all global objects allocated by libprotobuf. google::protobuf::ShutdownProtobufLibrary(); return 0; } ","date":"2023-08-23","objectID":"/protobuf/:2:3","tags":["note"],"title":"protobuf","uri":"/protobuf/"},{"categories":["note"],"content":"读message #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003cstring\u003e #include \"addressbook.pb.h\" using namespace std; // Iterates though all people in the AddressBook and prints info about them. void ListPeople(const tutorial::AddressBook\u0026 address_book) { for (int i = 0; i \u003c address_book.people_size(); i++) { const tutorial::Person\u0026 person = address_book.people(i); cout \u003c\u003c \"Person ID: \" \u003c\u003c person.id() \u003c\u003c endl; cout \u003c\u003c \" Name: \" \u003c\u003c person.name() \u003c\u003c endl; if (person.has_email()) { cout \u003c\u003c \" E-mail address: \" \u003c\u003c person.email() \u003c\u003c endl; } for (int j = 0; j \u003c person.phones_size(); j++) { const tutorial::Person::PhoneNumber\u0026 phone_number = person.phones(j); switch (phone_number.type()) { case tutorial::Person::MOBILE: cout \u003c\u003c \" Mobile phone #: \"; break; case tutorial::Person::HOME: cout \u003c\u003c \" Home phone #: \"; break; case tutorial::Person::WORK: cout \u003c\u003c \" Work phone #: \"; break; } cout \u003c\u003c phone_number.number() \u003c\u003c endl; } } } // Main function: Reads the entire address book from a file and prints all // the information inside. int main(int argc, char* argv[]) { // Verify that the version of the library that we linked against is // compatible with the version of the headers we compiled against. GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) { cerr \u003c\u003c \"Usage: \" \u003c\u003c argv[0] \u003c\u003c \" ADDRESS_BOOK_FILE\" \u003c\u003c endl; return -1; } tutorial::AddressBook address_book; { // Read the existing address book. fstream input(argv[1], ios::in | ios::binary); if (!address_book.ParseFromIstream(\u0026input)) { cerr \u003c\u003c \"Failed to parse address book.\" \u003c\u003c endl; return -1; } } ListPeople(address_book); // Optional: Delete all global objects allocated by libprotobuf. google::protobuf::ShutdownProtobufLibrary(); return 0; } ","date":"2023-08-23","objectID":"/protobuf/:2:4","tags":["note"],"title":"protobuf","uri":"/protobuf/"},{"categories":["note"],"content":"gflags","date":"2023-08-22","objectID":"/gflags/","tags":["note"],"title":"gflags","uri":"/gflags/"},{"categories":["note"],"content":"文档链接 gflags相当于代码中的常量 gflags读取命令行的flags，然后修改代码中相应名字的“常量” 主要有三个函数 DEFINE_xxx()，定义flag名，默认值，描述信息，flag名为FLAGS_xxx 描述信息可以使用--help显示 #include \u003cgflags/gflags.h\u003e DEFINE_bool(big_menu, true, \"Include 'advanced' options in the menu listing\"); DEFINE_string(languages, \"english,french,german\", \"comma-separated list of languages to offer in the 'lang' menu\"); DECLARE_xxx()，在不同的文件中声明，相当于extern FLAGS_xxx DECLARE_bool(big_menu); 在main函数第一行，表示我要解析传入的参数，并对代码中设定的flag修改 gflags::ParseCommandLineFlags(\u0026argc, \u0026argv, true); 可以在命令行中输入 app_containing_foo --nobig_menu -languages=\"chinese,japanese,korean\" ... 其中bool型flag可以在前面加no来表示值为false，此处-和–都可以，=可以省略 ","date":"2023-08-22","objectID":"/gflags/:0:0","tags":["note"],"title":"gflags","uri":"/gflags/"},{"categories":["note"],"content":"git","date":"2023-08-22","objectID":"/git%E8%A1%A5%E5%85%85/","tags":["git"],"title":"git补充","uri":"/git%E8%A1%A5%E5%85%85/"},{"categories":["note"],"content":"参考资料 ","date":"2023-08-22","objectID":"/git%E8%A1%A5%E5%85%85/:0:0","tags":["git"],"title":"git补充","uri":"/git%E8%A1%A5%E5%85%85/"},{"categories":["note"],"content":"问题 如果已经推到远程仓库，该怎么撤销 ","date":"2023-08-22","objectID":"/git%E8%A1%A5%E5%85%85/:1:0","tags":["git"],"title":"git补充","uri":"/git%E8%A1%A5%E5%85%85/"},{"categories":["note"],"content":"其他 从工作目录git add提交到暂存区后，想撤销 注意如果在工作目录创建文件，撤销操作只是不跟踪该文件，并不会把文件删掉 git reset HEAD xxx 或者 git reset HEAD * 从暂存区commit到本地仓库，想撤销到暂存区 git reset --soft HEAD~1 从暂存区commit到本地仓库，想撤销到工作目录 git reset HEAD~1 从暂存区commit到本地仓库，想撤销所有操作，就是在工作目录也没有修改记录 git reset --hard HEAD~1 如果从工作目录add到暂存区（或者add完commit到本地仓库），然后把工作目录某些文件删掉，想要找回（暂存区还有） git restore xxx 如果从工作目录add到暂存区（或者add完commit到本地仓库），然后修改工作目录的某些文件，想要撤销操作（变得和暂存区一样） git restore xxx 如果已经push到远程仓库，想要回退到某个版本，必须要使用--hard否则不会工作目录不会完全回退成功，还会留有待add的修改记录，这时候再使用--hard不会成功回退，解决办法是先使用如下命令到达最新版本，然后再做一次回退 git reset --hard \u003ccommitId\u003e 此时只是工作目录，暂存区，本地仓库回退到那个版本，但是远程仓库不变，此时不能push因为本地仓库落后于远程仓库，此时要想让远程仓库变成和本地一样 使用一下命令，可以让远程仓库的不要的提交消失 git push --force origin master 如果想要创建一个提交使得它和之前的提交相同 不知道 删除本地仓库某个分支，不能删除活动分支和未合并的分支，可以使用-D强制删除 git branch -d \u003cbranch_name\u003e 删除远程仓库某个分支 git push origin --delete \u003cbranch_name\u003e 创建远程分支，先创建本地分支，然后 git push origin \u003cbranch_name\u003e 假设在master分支基础上创建了br_merge分支，在两个分支上做修改，然后要合并 先切换到master分支 git merge br_merge 解决冲突后 git push origin master git stash 在工作目录修改，（modified和untracked）还未添加到暂存区，使用 git stash会让modified的部分消失，untracked的文件不变（不会删除） 如果把修改的和创建的添加到暂存区后，使用git stash，modified的部分消失，创建的新文件消失（因为已经 tracked）了 如果已经commit到本地仓库，使用git stash，无效，提示no local changes to save，可见git stash只能适用于未提交的修改，可以让这些修改暂时消失 以上操作都可以使用git stash pop恢复变更 git revert \u003ccommitId\u003e 形成一个新的commit，撤销commitId的变更，其他commit不变 git pull –rebase/–no-rebase/–ff-only git merge –ff/–no-ff/–ff-only FETCH_HEAD ","date":"2023-08-22","objectID":"/git%E8%A1%A5%E5%85%85/:2:0","tags":["git"],"title":"git补充","uri":"/git%E8%A1%A5%E5%85%85/"},{"categories":["go"],"content":"GO利用ftp服务器进行文件上传和下载","date":"2023-04-11","objectID":"/go%E5%88%A9%E7%94%A8ftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/","tags":["go"],"title":"GO利用ftp服务器进行文件上传和下载","uri":"/go%E5%88%A9%E7%94%A8ftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/"},{"categories":["go"],"content":"购买云服务器，这个云服务器将作为ftp服务器 假设云服务器是centos系统 先安装vsftpd 输入以下命令 sudo yum install vsftpd 启动vsftpd服务 sudo systemctl start vsftpd 确认 vsftpd 服务已启动及其状态是否为“active” sudo systemctl status vsftpd 将 vsftpd 设置为开机启动 sudo systemctl enable vsftpd.service 配置 vsftpd.conf，修改如下几项 # Example config file /etc/vsftpd/vsftpd.conf # # The default compiled in settings are fairly paranoid. This sample file # loosens things up a bit, to make the ftp daemon more usable. # Please see vsftpd.conf.5 for all compiled in defaults. # # READ THIS: This example file is NOT an exhaustive list of vsftpd options. # Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's # capabilities. # # Allow anonymous FTP? (Beware - allowed by default if you comment this out). anonymous_enable=NO # # Uncomment this to allow local users to log in. # When SELinux is enforcing check for SE bool ftp_home_dir local_enable=YES # # Uncomment this to enable any form of FTP write command. write_enable=YES # # Default umask for local users is 077. You may wish to change this to 022, # if your users expect that (022 is used by most other ftpd's) local_umask=022 # # Uncomment this to allow the anonymous FTP user to upload files. This only # has an effect if the above global write enable is activated. Also, you will # obviously need to create a directory writable by the FTP user. # When SELinux is enforcing check for SE bool allow_ftpd_anon_write, allow_ftpd_full_access #anon_upload_enable=YES # # Uncomment this if you want the anonymous FTP user to be able to create # new directories. #anon_mkdir_write_enable=YES # # Activate directory messages - messages given to remote users when they # go into a certain directory. dirmessage_enable=YES # # Activate logging of uploads/downloads. xferlog_enable=YES # # Make sure PORT transfer connections originate from port 20 (ftp-data). connect_from_port_20=YES # # If you want, you can arrange for uploaded anonymous files to be owned by # a different user. Note! Using \"root\" for uploaded files is not # recommended! #chown_uploads=YES #chown_username=whoever # # You may override where the log file goes if you like. The default is shown # below. #xferlog_file=/var/log/xferlog # # If you want, you can have your log file in standard ftpd xferlog format. # Note that the default log file location is /var/log/xferlog in this case. xferlog_std_format=YES # # You may change the default value for timing out an idle session. #idle_session_timeout=600 # # You may change the default value for timing out a data connection. #data_connection_timeout=120 # # It is recommended that you define on your system a unique user which the # ftp server can use as a totally isolated and unprivileged user. #nopriv_user=ftpsecure # # Enable this and the server will recognise asynchronous ABOR requests. Not # recommended for security (the code is non-trivial). Not enabling it, # however, may confuse older FTP clients. #async_abor_enable=YES # # By default the server will pretend to allow ASCII mode but in fact ignore # the request. Turn on the below options to have the server actually do ASCII # mangling on files when in ASCII mode. The vsftpd.conf(5) man page explains # the behaviour when these options are disabled. # Beware that on some FTP servers, ASCII support allows a denial of service # attack (DoS) via the command \"SIZE /big/file\" in ASCII mode. vsftpd # predicted this attack and has always been safe, reporting the size of the # raw file. # ASCII mangling is a horrible feature of the protocol. #ascii_upload_enable=YES #ascii_download_enable=YES # # You may fully customise the login banner string: #ftpd_banner=Welcome to blah FTP service. # # You may specify a file of disallowed anonymous e-mail addresses. Apparently # useful for combatting certain DoS attacks. #deny_email_enable=YES # (default follows) #banned_email_file=/etc/vsftpd/banned_emails # # You may specify an explicit list of local users to chroot() to their home # directory. If chroot_local_user is YES, th","date":"2023-04-11","objectID":"/go%E5%88%A9%E7%94%A8ftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/:0:0","tags":["go"],"title":"GO利用ftp服务器进行文件上传和下载","uri":"/go%E5%88%A9%E7%94%A8ftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/"},{"categories":["go"],"content":"GO与测试","date":"2023-02-18","objectID":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/","tags":["go"],"title":"GO与测试","uri":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["go"],"content":"参考 ","date":"2023-02-18","objectID":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/:0:0","tags":["go"],"title":"GO与测试","uri":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["go"],"content":"单元测试 ","date":"2023-02-18","objectID":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/:1:0","tags":["go"],"title":"GO与测试","uri":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["go"],"content":"规则 所有测试文件以_test.go结尾 func TestXxx(*testing.T) 初始化逻辑放到TestMain中 例子 文件名为nihao_test.go package hello import \"testing\" func HelloTom() string { return \"Jerry\" } func TestHelloTom(t *testing.T) { output := HelloTom() expectOutput := \"Tom\" if output != expectOutput { t.Errorf(\"Expect %s do not match actual %s\", expectOutput, output) } } 在命令行输入`go test nihao_test.go`` 更好的比较输出与预期的方法是用assert 代码如下 package hello import ( \"github.com/stretchr/testify/assert\" \"testing\" ) func HelloTom() string { return \"Jerry\" } func TestHelloTom(t *testing.T) { output := HelloTom() expectOutput := \"Tom\" assert.Equal(t, expectOutput, output) } 输入命令之后，结果如下 需要在go.mod中添加依赖（可以IDE自动添加） require github.com/stretchr/testify v1.7.0 require ( github.com/davecgh/go-spew v1.1.1 // indirect github.com/kr/pretty v0.3.0 // indirect github.com/pmezard/go-difflib v1.0.0 // indirect github.com/rogpeppe/go-internal v1.8.0 // indirect gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b // indirect ) ","date":"2023-02-18","objectID":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/:1:1","tags":["go"],"title":"GO与测试","uri":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["go"],"content":"覆盖率 写两个文件nihao.go和nihao_test.go，分别写如下代码 nihao.go package hello func JudgeScore(score int) bool { if score \u003e= 60 { return true } return false } nihao_test.go package hello import ( \"github.com/stretchr/testify/assert\" \"testing\" ) func TestJS(t *testing.T) { output := JudgeScore(70) assert.Equal(t, true, output) } 输入命令 go test nihao_test.go nihao.go --cover 输出结果 如果将两个函数放在同一个文件中，执行以上命令无法测试覆盖率，会有如下结果 如果把nihao_test.go代码改为 package hello import ( \"github.com/stretchr/testify/assert\" \"testing\" ) func TestJS(t *testing.T) { output := JudgeScore(70) assert.Equal(t, true, output) } func TestJS2(t *testing.T) { output := JudgeScore(20) assert.Equal(t, false, output) } 覆盖率将达到100% ","date":"2023-02-18","objectID":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/:1:2","tags":["go"],"title":"GO与测试","uri":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["go"],"content":"Mock测试 一种测试工具是monkey https://github.com/bouk/monkey ","date":"2023-02-18","objectID":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/:2:0","tags":["go"],"title":"GO与测试","uri":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["go"],"content":"基准测试 基准测试就是测代码的运行性能 例子 在nihao.go文件中写如下代码 package hello import ( \"github.com/bytedance/gopkg/lang/fastrand\" \"math/rand\" ) var ServerIndex [10]int func InitServerIndex() { for i := 0; i \u003c 10; i++ { ServerIndex[i] = i + 100 } } func Select() int { return ServerIndex[rand.Intn(10)] } func FastSelect() int { return ServerIndex[fastrand.Intn(10)] } 在nihao_test.go中写如下代码 package hello import ( \"testing\" ) func BenchmarkSelect(b *testing.B) { InitServerIndex() b.ResetTimer() for i := 0; i \u003c b.N; i++ { Select() } } func BenchmarkSelectParallel(b *testing.B) { InitServerIndex() b.ResetTimer() b.RunParallel(func(pb *testing.PB) { for pb.Next() { Select() } }) } func BenchmarkFastSelectParallel(b *testing.B) { InitServerIndex() b.ResetTimer() b.RunParallel(func(pb *testing.PB) { for pb.Next() { FastSelect() } }) } 输入如下命令go test nihao_test.go nihao.go -bench=.，有如下结果 可以看到BenchmarkSelectParallel在使用多协程并发时性能还不如单协程，这是因为rand为了保证全局的随机性和全局安全，持有了一把随机锁，可以用fastrand来优化 ","date":"2023-02-18","objectID":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/:3:0","tags":["go"],"title":"GO与测试","uri":"/go%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["go"],"content":"GO与socks5代理服务器","date":"2023-02-09","objectID":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/","tags":["go"],"title":"GO与socks5代理服务器","uri":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["go"],"content":"参考 ","date":"2023-02-09","objectID":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["go"],"title":"GO与socks5代理服务器","uri":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["go"],"content":"Socks5原理 如果不设置代理服务器，网站先和服务器建立tcp连接，然后三次握手，之后网站发送http请求，服务器返回http响应。 当加入了代理服务器之后，浏览器客户端先和代理建立tcp连接，代理再和真正的服务器建立tcp连接，这里可以分为四个阶段，握手阶段、认证阶段、请求阶段和relay阶段。 在握手阶段，浏览器会向代理发送请求，请求的内容包含协议的版本号和可选的认证方式，代理会选择一种认证，返回给浏览器。如果返回的是00，则不需要认证，否则开启认证阶段。 认证完之后，浏览器发送请求，表明代理要和某个地址或者某个端口建立连接，代理会和真正的后端服务器建立tcp连接，然后返回一个响应。 在relay阶段，浏览器发送请求，可以是http请求也可以是tcp请求，而代理只作为过渡进行转发。 ","date":"2023-02-09","objectID":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["go"],"title":"GO与socks5代理服务器","uri":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["go"],"content":"实现 ","date":"2023-02-09","objectID":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["go"],"title":"GO与socks5代理服务器","uri":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["go"],"content":"tcp echo server 先实现一个tcp echo server package main import ( \"bufio\" \"log\" \"net\" ) func main() { server, err := net.Listen(\"tcp\", \"127.0.0.1:1080\") if err != nil { panic(err) } for { client, err := server.Accept() //接受一个请求，返回连接net.Conn if err != nil { log.Printf(\"Accept failed %v\", err) continue } go process(client) //启动一个go routine } } func process(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) //创建一个带缓冲的只读流 for { b, err := reader.ReadByte() //读一个字节 if err != nil { break } _, err = conn.Write([]byte{b}) if err != nil { break } } } 运行代码，在命令行输入nc 127.0.0.1 1080，输入hello，就会返回hello ","date":"2023-02-09","objectID":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:1","tags":["go"],"title":"GO与socks5代理服务器","uri":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["go"],"content":"认证阶段 package main import ( \"bufio\" \"fmt\" \"io\" \"log\" \"net\" ) const socks5Ver = 0x05 const cmdBind = 0x01 const atypIPV4 = 0x01 const atypeHOST = 0x03 const atypeIPV6 = 0x04 func main() { server, err := net.Listen(\"tcp\", \"127.0.0.1:1080\") if err != nil { panic(err) } for { client, err := server.Accept() if err != nil { log.Printf(\"Accept failed %v\", err) continue } go process(client) } } func process(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) err := auth(reader, conn) if err != nil { log.Printf(\"client %v auth failed:%v\", conn.RemoteAddr(), err) return } log.Println(\"auth success\") } func auth(reader *bufio.Reader, conn net.Conn) (err error) { // +----+----------+----------+ // |VER | NMETHODS | METHODS | // +----+----------+----------+ // | 1 | 1 | 1 to 255 | // +----+----------+----------+ // VER: 协议版本，socks5为0x05 // NMETHODS: 支持认证的方法数量 // METHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下: // X’00’ NO AUTHENTICATION REQUIRED // X’02’ USERNAME/PASSWORD ver, err := reader.ReadByte() if err != nil { return fmt.Errorf(\"read ver failed:%w\", err) } if ver != socks5Ver { return fmt.Errorf(\"not supported ver:%v\", ver) } methodSize, err := reader.ReadByte() if err != nil { return fmt.Errorf(\"read methodSize failed:%w\", err) } method := make([]byte, methodSize) _, err = io.ReadFull(reader, method) if err != nil { return fmt.Errorf(\"read method failed:%w\", err) } log.Println(\"ver\", ver, \"method\", method) // +----+--------+ // |VER | METHOD | // +----+--------+ // | 1 | 1 | // +----+--------+ _, err = conn.Write([]byte{socks5Ver, 0x00}) if err != nil { return fmt.Errorf(\"write failed:%w\", err) } return nil } 在命令行中输入curl --socks5 127.0.0.1:1080 -v www.baidu.com 在程序中会输出 说明客户端使用的是socks5协议，支持的认证方式为00和01 ","date":"2023-02-09","objectID":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:2","tags":["go"],"title":"GO与socks5代理服务器","uri":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["go"],"content":"请求阶段 请求阶段由connect函数实现 package main import ( \"bufio\" \"encoding/binary\" \"errors\" \"fmt\" \"io\" \"log\" \"net\" ) const socks5Ver = 0x05 const cmdBind = 0x01 const atypIPV4 = 0x01 const atypeHOST = 0x03 const atypeIPV6 = 0x04 func main() { server, err := net.Listen(\"tcp\", \"127.0.0.1:1080\") if err != nil { panic(err) } for { client, err := server.Accept() if err != nil { log.Printf(\"Accept failed %v\", err) continue } go process(client) } } func process(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) err := auth(reader, conn) if err != nil { log.Printf(\"client %v auth failed:%v\", conn.RemoteAddr(), err) return } err = connect(reader, conn) if err != nil { log.Printf(\"client %v auth failed:%v\", conn.RemoteAddr(), err) return } } func auth(reader *bufio.Reader, conn net.Conn) (err error) { // +----+----------+----------+ // |VER | NMETHODS | METHODS | // +----+----------+----------+ // | 1 | 1 | 1 to 255 | // +----+----------+----------+ // VER: 协议版本，socks5为0x05 // NMETHODS: 支持认证的方法数量 // METHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下: // X’00’ NO AUTHENTICATION REQUIRED // X’02’ USERNAME/PASSWORD ver, err := reader.ReadByte() if err != nil { return fmt.Errorf(\"read ver failed:%w\", err) } if ver != socks5Ver { return fmt.Errorf(\"not supported ver:%v\", ver) } methodSize, err := reader.ReadByte() if err != nil { return fmt.Errorf(\"read methodSize failed:%w\", err) } method := make([]byte, methodSize) _, err = io.ReadFull(reader, method) if err != nil { return fmt.Errorf(\"read method failed:%w\", err) } // +----+--------+ // |VER | METHOD | // +----+--------+ // | 1 | 1 | // +----+--------+ _, err = conn.Write([]byte{socks5Ver, 0x00}) if err != nil { return fmt.Errorf(\"write failed:%w\", err) } return nil } func connect(reader *bufio.Reader, conn net.Conn) (err error) { // +----+-----+-------+------+----------+----------+ // |VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT | // +----+-----+-------+------+----------+----------+ // | 1 | 1 | X'00' | 1 | Variable | 2 | // +----+-----+-------+------+----------+----------+ // VER 版本号，socks5的值为0x05 // CMD 0x01表示CONNECT请求 // RSV 保留字段，值为0x00 // ATYP 目标地址类型，DST.ADDR的数据对应这个字段的类型。 // 0x01表示IPv4地址，DST.ADDR为4个字节 // 0x03表示域名，DST.ADDR是一个可变长度的域名 // DST.ADDR 一个可变长度的值 // DST.PORT 目标端口，固定2个字节 buf := make([]byte, 4) _, err = io.ReadFull(reader, buf) if err != nil { return fmt.Errorf(\"read header failed:%w\", err) } ver, cmd, atyp := buf[0], buf[1], buf[3] if ver != socks5Ver { return fmt.Errorf(\"not supported ver:%v\", ver) } if cmd != cmdBind { return fmt.Errorf(\"not supported cmd:%v\", ver) } addr := \"\" switch atyp { case atypIPV4: _, err = io.ReadFull(reader, buf) //刚好是4个字节 if err != nil { return fmt.Errorf(\"read atyp failed:%w\", err) } addr = fmt.Sprintf(\"%d.%d.%d.%d\", buf[0], buf[1], buf[2], buf[3]) case atypeHOST: hostSize, err := reader.ReadByte() if err != nil { return fmt.Errorf(\"read hostSize failed:%w\", err) } host := make([]byte, hostSize) _, err = io.ReadFull(reader, host) if err != nil { return fmt.Errorf(\"read host failed:%w\", err) } addr = string(host) case atypeIPV6: return errors.New(\"IPv6: no supported yet\") default: return errors.New(\"invalid atyp\") } _, err = io.ReadFull(reader, buf[:2]) //读端口号 if err != nil { return fmt.Errorf(\"read port failed:%w\", err) } port := binary.BigEndian.Uint16(buf[:2]) //返回uint16 log.Println(\"dial\", addr, port) //写response // +----+-----+-------+------+----------+----------+ // |VER | REP | RSV | ATYP | BND.ADDR | BND.PORT | // +----+-----+-------+------+----------+----------+ // | 1 | 1 | X'00' | 1 | Variable | 2 | // +----+-----+-------+------+----------+----------+ // VER socks版本，这里为0x05 // REP Relay field,内容取值如下 X’00’ succeeded // RSV 保留字段 // ATYPE 地址类型 // BND.ADDR 服务绑定的地址 // BND.PORT 服务绑定的端口DST.PORT _, err = conn.Write([]byte{0x05, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 0}) if err != nil { return fmt.Errorf(\"write failed: %w\", err) } return nil } 运行这个程序，在命令行中输入curl --socks5 127.0.0.1:1080 -v www.baidu.com 程序会输出 表明它之后要对这个ip和端口建立连接 ","date":"2023-02-09","objectID":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:3","tags":["go"],"title":"GO与socks5代理服务器","uri":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["go"],"content":"relay阶段 使用Dail函数建立代理和web服务器的连接，使用Copy函数实现数据的转发 package main import ( \"bufio\" \"context\" \"encoding/binary\" \"errors\" \"fmt\" \"io\" \"log\" \"net\" ) const socks5Ver = 0x05 const cmdBind = 0x01 const atypIPV4 = 0x01 const atypeHOST = 0x03 const atypeIPV6 = 0x04 func main() { server, err := net.Listen(\"tcp\", \"127.0.0.1:1080\") if err != nil { panic(err) } for { client, err := server.Accept() if err != nil { log.Printf(\"Accept failed %v\", err) continue } go process(client) } } func process(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) err := auth(reader, conn) if err != nil { log.Printf(\"client %v auth failed:%v\", conn.RemoteAddr(), err) return } err = connect(reader, conn) if err != nil { log.Printf(\"client %v auth failed:%v\", conn.RemoteAddr(), err) return } } func auth(reader *bufio.Reader, conn net.Conn) (err error) { // +----+----------+----------+ // |VER | NMETHODS | METHODS | // +----+----------+----------+ // | 1 | 1 | 1 to 255 | // +----+----------+----------+ // VER: 协议版本，socks5为0x05 // NMETHODS: 支持认证的方法数量 // METHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下: // X’00’ NO AUTHENTICATION REQUIRED // X’02’ USERNAME/PASSWORD ver, err := reader.ReadByte() if err != nil { return fmt.Errorf(\"read ver failed:%w\", err) } if ver != socks5Ver { return fmt.Errorf(\"not supported ver:%v\", ver) } methodSize, err := reader.ReadByte() if err != nil { return fmt.Errorf(\"read methodSize failed:%w\", err) } method := make([]byte, methodSize) _, err = io.ReadFull(reader, method) if err != nil { return fmt.Errorf(\"read method failed:%w\", err) } // +----+--------+ // |VER | METHOD | // +----+--------+ // | 1 | 1 | // +----+--------+ _, err = conn.Write([]byte{socks5Ver, 0x00}) if err != nil { return fmt.Errorf(\"write failed:%w\", err) } return nil } func connect(reader *bufio.Reader, conn net.Conn) (err error) { // +----+-----+-------+------+----------+----------+ // |VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT | // +----+-----+-------+------+----------+----------+ // | 1 | 1 | X'00' | 1 | Variable | 2 | // +----+-----+-------+------+----------+----------+ // VER 版本号，socks5的值为0x05 // CMD 0x01表示CONNECT请求 // RSV 保留字段，值为0x00 // ATYP 目标地址类型，DST.ADDR的数据对应这个字段的类型。 // 0x01表示IPv4地址，DST.ADDR为4个字节 // 0x03表示域名，DST.ADDR是一个可变长度的域名 // DST.ADDR 一个可变长度的值 // DST.PORT 目标端口，固定2个字节 buf := make([]byte, 4) _, err = io.ReadFull(reader, buf) if err != nil { return fmt.Errorf(\"read header failed:%w\", err) } ver, cmd, atyp := buf[0], buf[1], buf[3] if ver != socks5Ver { return fmt.Errorf(\"not supported ver:%v\", ver) } if cmd != cmdBind { return fmt.Errorf(\"not supported cmd:%v\", ver) } addr := \"\" switch atyp { case atypIPV4: _, err = io.ReadFull(reader, buf) if err != nil { return fmt.Errorf(\"read atyp failed:%w\", err) } addr = fmt.Sprintf(\"%d.%d.%d.%d\", buf[0], buf[1], buf[2], buf[3]) case atypeHOST: hostSize, err := reader.ReadByte() if err != nil { return fmt.Errorf(\"read hostSize failed:%w\", err) } host := make([]byte, hostSize) _, err = io.ReadFull(reader, host) if err != nil { return fmt.Errorf(\"read host failed:%w\", err) } addr = string(host) case atypeIPV6: return errors.New(\"IPv6: no supported yet\") default: return errors.New(\"invalid atyp\") } _, err = io.ReadFull(reader, buf[:2]) if err != nil { return fmt.Errorf(\"read port failed:%w\", err) } port := binary.BigEndian.Uint16(buf[:2]) dest, err := net.Dial(\"tcp\", fmt.Sprintf(\"%v:%v\", addr, port)) //与目标ip建立连接，返回一个连接 if err != nil { return fmt.Errorf(\"dial dst failed:%w\", err) } defer dest.Close() log.Println(\"dial\", addr, port) // +----+-----+-------+------+----------+----------+ // |VER | REP | RSV | ATYP | BND.ADDR | BND.PORT | // +----+-----+-------+------+----------+----------+ // | 1 | 1 | X'00' | 1 | Variable | 2 | // +----+-----+-------+------+----------+----------+ // VER socks版本，这里为0x05 // REP Relay field,内容取值如下 X’00’ succeeded // RSV 保留字段 // ATYPE 地址类型 // BND.ADDR 服务绑定的地址 // BND.PORT 服务绑定的端口DST.PORT _, err = conn.Write([]byte{0x05, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 0}) if e","date":"2023-02-09","objectID":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:4","tags":["go"],"title":"GO与socks5代理服务器","uri":"/go%E4%B8%8Esocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["go"],"content":"GO与并发","date":"2023-02-09","objectID":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/","tags":["go"],"title":"GO与并发","uri":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["go"],"content":"并发与并行 concurrncy和parallellism 并发指多个任务在同一时间段进行，并行指多个任务在同一时刻进行 单核cpu只能并发不能并行，现在的多核cpu既能并发又能并行 ","date":"2023-02-09","objectID":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/:1:0","tags":["go"],"title":"GO与并发","uri":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["go"],"content":"协程 coroutine，协程运行在线程上，一个线程可以拥有多个协程，协程只在用户态运行，由用户调度，它不像线程一样，由操作系统调度，切换涉及用户态和内核态，所以协程的开销很小。线程是栈MB级别，协程师栈KB级别 go使用协程 例子：启用5个协程，总共打印数字0～5 package main import ( \"fmt\" \"time\" ) func hello(i int) { println(\"hello\", fmt.Sprint(i)) } func main() { for i := 0; i \u003c 5; i++ { go func(j int) { hello(j) }(i) } time.Sleep(time.Second) //为了避免子协程还没运行完，主协程先执行完了 } ","date":"2023-02-09","objectID":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/:2:0","tags":["go"],"title":"GO与并发","uri":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["go"],"content":"协程间通信 协程间通信有两种：通道，共享内存（临界区） 一般通过通道更好，用临界区容易产生数据竞争 ","date":"2023-02-09","objectID":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/:3:0","tags":["go"],"title":"GO与并发","uri":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["go"],"content":"channel 通道有两种 无缓冲通道，a = make(chan int) 有缓冲通道，b = make(chan int, 2) 任务：A协程发送0～9数字，B协程得到数字计算数字的平方，主协程输出数字 package main func main() { channel1 := make(chan int) channel2 := make(chan int, 3) go func() { defer close(channel1) for i := 0; i \u003c 10; i++ { channel1 \u003c- i } }() go func() { defer close(channel2) for i := range channel1 { channel2 \u003c- i * i } }() for i := range channel2 { println(i, \" \") } } 输出，可以发现输出是有序的，因为第2个通道是缓冲通道 ","date":"2023-02-09","objectID":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/:3:1","tags":["go"],"title":"GO与并发","uri":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["go"],"content":"共享内存，互斥锁 任务：开启5个协程，每个协程对某个变量执行2000次递增操作，分为加锁和不加锁情况 package main import ( \"sync\" \"time\" ) var ( x int64 lock sync.Mutex ) func addWithoutLock() { for i := 0; i \u003c 2000; i++ { x++ } } func addWithLock() { for i := 0; i \u003c 2000; i++ { lock.Lock() x++ lock.Unlock() } } func main() { x = 0 for i := 0; i \u003c 5; i++ { go addWithoutLock() } time.Sleep(time.Second) println(\"add without lock \", x) x = 0 for i := 0; i \u003c 5; i++ { go addWithLock() } time.Sleep(time.Second) println(\"add with lock \", x) } 输出结果 ","date":"2023-02-09","objectID":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/:3:2","tags":["go"],"title":"GO与并发","uri":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["go"],"content":"WaitGroup 在上面的程序中使用time.Sleep的形式十分的不优雅，此处使用WaitGroup来让主协程等待子协程 WaitGroup使用计数器来达到要求，开启一个子协程时，计数器+1，结束一个子协程时，计数器-1，主协程会阻塞直到计数器为0。WaitGroup有三个重要的方法 Add方法计数器增加某个值，Done方法计数器-1，Wait方法阻塞当前协程，直到计数器为0 现在用WaitGroup来改写5个协程打印0～5的程序 package main import ( \"fmt\" \"sync\" ) func hello(i int) { println(\"hello\", fmt.Sprint(i)) } func main() { var wg sync.WaitGroup wg.Add(5) for i := 0; i \u003c 5; i++ { go func(j int) { defer wg.Done() hello(j) }(i) } wg.Wait() } ","date":"2023-02-09","objectID":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/:3:3","tags":["go"],"title":"GO与并发","uri":"/go%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"categories":["go"],"content":"GO与http请求","date":"2023-02-07","objectID":"/go%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82/","tags":["go"],"title":"GO与http请求","uri":"/go%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82/"},{"categories":["go"],"content":"参考 ","date":"2023-02-07","objectID":"/go%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82/:0:0","tags":["go"],"title":"GO与http请求","uri":"/go%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82/"},{"categories":["go"],"content":"任务 用go写一个http请求，输入一个单词，通过对彩云小译发起网络请求，返回单词的翻译结果 ","date":"2023-02-07","objectID":"/go%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82/:1:0","tags":["go"],"title":"GO与http请求","uri":"/go%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82/"},{"categories":["go"],"content":"过程 打开网站 输入单词good，点击翻译 打开开发者工具，找到对应的请求 现在用go来模拟这个请求，我们使用自动化工具生成代码 打开这个网站，右键对应的请求，选择copy as curl 复制到那个网站中，就会自动生成代码 代码如下 package main import ( \"fmt\" \"io\" \"log\" \"net/http\" \"strings\" ) func main() { client := \u0026http.Client{} var data = strings.NewReader(`{\"trans_type\":\"en2zh\",\"source\":\"good\"}`) req, err := http.NewRequest(\"POST\", \"https://api.interpreter.caiyunai.com/v1/dict\", data) if err != nil { log.Fatal(err) } req.Header.Set(\"authority\", \"api.interpreter.caiyunai.com\") req.Header.Set(\"accept\", \"application/json, text/plain, */*\") req.Header.Set(\"accept-language\", \"zh-CN,zh;q=0.9,en;q=0.8\") req.Header.Set(\"app-name\", \"xy\") req.Header.Set(\"content-type\", \"application/json;charset=UTF-8\") req.Header.Set(\"device-id\", \"\") req.Header.Set(\"origin\", \"https://fanyi.caiyunapp.com\") req.Header.Set(\"os-type\", \"web\") req.Header.Set(\"os-version\", \"\") req.Header.Set(\"referer\", \"https://fanyi.caiyunapp.com/\") req.Header.Set(\"sec-ch-ua\", `\"Not_A Brand\";v=\"99\", \"Google Chrome\";v=\"109\", \"Chromium\";v=\"109\"`) req.Header.Set(\"sec-ch-ua-mobile\", \"?0\") req.Header.Set(\"sec-ch-ua-platform\", `\"macOS\"`) req.Header.Set(\"sec-fetch-dest\", \"empty\") req.Header.Set(\"sec-fetch-mode\", \"cors\") req.Header.Set(\"sec-fetch-site\", \"cross-site\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36\") req.Header.Set(\"x-authorization\", \"token:qgemv4jr1y38jyq6vhvi\") resp, err := client.Do(req) if err != nil { log.Fatal(err) } defer resp.Body.Close() bodyText, err := io.ReadAll(resp.Body) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\\n\", bodyText) } 运行之后可以输出结果 将json数据写成结构体的形式，然后用序列化，代码改成 package main import ( \"bytes\" \"encoding/json\" \"fmt\" \"io\" \"log\" \"net/http\" ) type DictRequest struct { TransType string `json:\"trans_type\"` Source string `json:\"source\"` UserID string `json:\"user_id\"` } func main() { client := \u0026http.Client{} request := DictRequest{TransType: \"en2zh\", Source: \"good\"} buf, err := json.Marshal(request) //返回byte[]，所以后面调用bytes.NewReader if err != nil { log.Fatal(err) } var data = bytes.NewReader(buf) req, err := http.NewRequest(\"POST\", \"https://api.interpreter.caiyunai.com/v1/dict\", data) if err != nil { log.Fatal(err) } req.Header.Set(\"Connection\", \"keep-alive\") req.Header.Set(\"DNT\", \"1\") req.Header.Set(\"os-version\", \"\") req.Header.Set(\"sec-ch-ua-mobile\", \"?0\") req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36\") req.Header.Set(\"app-name\", \"xy\") req.Header.Set(\"Content-Type\", \"application/json;charset=UTF-8\") req.Header.Set(\"Accept\", \"application/json, text/plain, */*\") req.Header.Set(\"device-id\", \"\") req.Header.Set(\"os-type\", \"web\") req.Header.Set(\"X-Authorization\", \"token:qgemv4jr1y38jyq6vhvi\") req.Header.Set(\"Origin\", \"https://fanyi.caiyunapp.com\") req.Header.Set(\"Sec-Fetch-Site\", \"cross-site\") req.Header.Set(\"Sec-Fetch-Mode\", \"cors\") req.Header.Set(\"Sec-Fetch-Dest\", \"empty\") req.Header.Set(\"Referer\", \"https://fanyi.caiyunapp.com/\") req.Header.Set(\"Accept-Language\", \"zh-CN,zh;q=0.9\") req.Header.Set(\"Cookie\", \"_ym_uid=16456948721020430059; _ym_d=1645694872\") resp, err := client.Do(req) if err != nil { log.Fatal(err) } defer resp.Body.Close() bodyText, err := io.ReadAll(resp.Body) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\\n\", bodyText) } 接下来从response中获得翻译结果 从response中可以看出它的结构还是挺复杂的 我们使用自动化工具将json生成结构体，将response的内容复制到工具里，点击转换嵌套 在代码里使用unmarshal来反序列化，代码为 package main import ( \"bytes\" \"encoding/json\" \"fmt\" \"io/ioutil\" \"log\" \"net/http\" ) type DictRequest struct { TransType string `json:\"trans_type\"` Source string `json:\"source\"` UserID string `json:\"user_id\"` } type DictResponse struct { Rc int `json:\"rc\"` Wiki struct { KnownInLaguages int `json:\"known_in_laguages\"` Description struct { Source string `json:\"source\"` Target interface{} `json:\"target\"` } `json:\"description\"` ID string `json:\"id\"` Item struct { Source string `json:\"source\"` Target string `json:\"target\"` ","date":"2023-02-07","objectID":"/go%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82/:2:0","tags":["go"],"title":"GO与http请求","uri":"/go%E4%B8%8Ehttp%E8%AF%B7%E6%B1%82/"},{"categories":["note","slam"],"content":"vins_estimator","date":"2022-11-27","objectID":"/vins_estimator/","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"vins_estimator ","date":"2022-11-27","objectID":"/vins_estimator/:0:0","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"rosNodeTest.cpp ","date":"2022-11-27","objectID":"/vins_estimator/:1:0","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"读取配置文件的参数 readParameters(config_file); readParameters()将配置文件的参数读取到parameters.h中 ","date":"2022-11-27","objectID":"/vins_estimator/:1:1","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"estimator.setParameter() 设置estimator的外参、td、g 设置FeatureManager的旋转外参 设置ProjectionFactor的协方差（此处是协方差的开方） 设置FeatureTracker的内参 如果是多线程，processMeasurements()会一直工作 ","date":"2022-11-27","objectID":"/vins_estimator/:1:2","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"让发布者注册话题 registerPub(ros::NodeHandle \u0026n) ","date":"2022-11-27","objectID":"/vins_estimator/:1:3","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"订阅者订阅话题 imu_callback 从消息中获取时间戳、线加速度和角加速度 将imu信息输入到estimator中estimator.inputIMU(t, acc, gyr) 将值加到accBuf和gyrBuf中 根据上一帧的pvq和imu的输入来更新此时的pvq fastPredictIMU(t, linearAcceleration, angularVelocity) - 发布最新的pvq信息 pubLatestOdometry(latest_P, latest_Q, latest_V, t) feature_callback 获得点云的id、cameraid、3d坐标、像素坐标、像素速度、时间戳信息 将特征点信息输入到estimator中 estimator.inputFeature(t, featureFrame) 将值加入到featureBuf中 processMeasurements() img0_callback 获得左目的图片消息，存到rosNodeTest的img0_buf中 img1_callback 获得右目的图片消息，存到rosNodeTest的img1_buf中 restart_callback 重启estimator，重新设置参数 estimator.clearState() 把buf清空，参数设置成初始值 estimator.setParameter() imu_switch_callback 更改estimator中是否使用imu选项 estimator.changeSensorType() 如果现在使用了imu，要重启estimator cam_switch_callback 更改estimator中是否使用imu选项 estimator.changeSensorType() ","date":"2022-11-27","objectID":"/vins_estimator/:1:4","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"将图像送给estimator std::thread sync_thread{sync_process} 不断执行 双目 从img0_buf和img1_buf中判断两帧的时间差不超过0.003s 通过getImageFromMsg()获得左右目的cv::Mat图像 estimator.inputImage(time, image0, image1) 单目 从img0_buf中取第一帧，getImageFromMsg()获得图像 estimator.inputImage(time, image) featureFrame = featureTracker.trackImage(t, _img) cv::calcOpticalFlowPyrLK() 反向追踪 reduceVector()把没追踪到的点除去 使特征点分布均匀 setMask() 设置mask图 将当前追踪的点按追踪次数降序排 清空cur_pts、ids、track_cnt 通过画圈的方式使特征点均匀，重新填充cur_pts、ids、track_cnt cv::goodFeaturesToTrack()提取角点 把新角点增加进cur_pts等 undistortedPts(cur_pts, m_camera[0])将像素坐标恢复成归一化坐标放到cur_un_pts中 ptsVelocity(ids, cur_un_pts, cur_un_pts_map, prev_un_pts_map)求像素速度（实际上是在归一化平面求）把结果放入pts_velocity 把id和当前帧像素坐标对应 通过前后两帧像素差除以时间求速度 左右目光流追踪 反向左右目光流追踪 和单目相似，更新右目信息 drawTrack() prev=cur hasPrediction = false 将归一化坐标、真正的像素坐标、归一化平面xy的速度封装成featureFrame，如果有右目，再来一次，返回featureFrame 获得左目图像，pubTrackImage(imgTrack, t)发布消息用于可视化 featureBuf.push(make_pair(t, featureFrame)) processMeasurements() feature为当前帧的特征点，加上时间戳 curTime是当前时间 循环等待当前时刻的imu数据到来 把前一帧和当前帧之间的buf数据取出放Vector中 getIMUInterval(prevTime, curTime, accVector, gyrVector) initFirstIMUPose(accVector) 取这段时间的平均加速度作为重力 让加速度和重力对齐，修正Rs[0] 根据上一图像帧的位姿和之间的imu数据进行粗略的预积分得到现在图像帧的pvq processIMU(accVector[i].first, dt, accVector[i].second, gyrVector[i].second) 把dt，加速度、角速度加到当前帧的pre_integrations中，再加入到当前帧的对应的buf中 - processImage(feature.second, feature.first) - addFeatureCheckParallax(frame_count, image, td)判断边缘化最老帧还是次新帧 - 更新feature数组 - compensatedParallax2(it_per_id, frame_count)算视差 - 在归一化平面计算点的距离 - 通过视差判断是否为关键帧 - 将当前帧封装成ImageFrame，装进all_image_frame - 获得特征点在两帧下的归一化坐标 getCorresponding(frame_count - 1, frame_count) - CalibrationExRotation(corres, pre_integrations[frame_count]-\u003edelta_q, calib_ric) - 根据对极约束求位姿，8点法 solveRelativeR(corres) - 通过两帧的像素坐标(归一化坐标XY)求本质矩阵 - 将E（-E）分解成R和t decomposeE() - - 检验四组解 testTriangulation(ll, rr, R1, t1)获得真正的R - 通过cv::triangulatePoints()检验深度为正的点的比例 - 求qbc，详细看《手写VIO》第七讲第10页 - 如果成功把结果给calib_ric_result - 初始化 - 单目+imu - initialStructure() - imu激励是否足够 - 计算所有帧的加速度的标准差 - 创建Q、T、sfm_f、sfm_tracked_points - 把feature信息填充到sfm_f中 - 确定参考帧l，求最新帧到它的位姿 relativePose(relative_R, relative_T, l) - 遍历滑窗，获得第i帧和最新帧的共视点 - 计算共视点的平均视差并判断 - 对极约束，五点法求位姿 solveRelativeRT(corres, relative_R, relative_T) - RANSAC求解本质矩阵E - 对极约束恢复位姿 cv::recoverPose(E, ll, rr, cameraMatrix, rot, trans, mask) - SFM sfm.construct(frame_count + 1, Q, T, l, relative_R, relative_T,sfm_f, sfm_tracked_points) - 创建c_XXX数组表示第l帧相机在别的帧相机系下的表示 - 三角化l和最新帧 triangulateTwoFrames() - 遍历特征点，如果是这两个帧的共视点 triangulatePoint()，求出在l相机系的空间坐标，更新sfm_f 《手写VIO》 - pnp求l+1帧的位姿 solveFrameByPnP() - 获得特征点的3d坐标和2d坐标 - 将cv::Eigen转化为cv::Mat - cv::solvePnP()求旋转向量和平移向量 - 三角化l+1帧和最新帧 triangulateTwoFrames() - 三角化l帧和l+1帧 - pnp求l-1帧 - 三角化l-1帧和l帧 - triangulatePoint()三角化剩余点，更新sfm_f - 全局ba - 用ceres求解，添加参数块，将先验设为恒定 - ReprojectionError3D定义残差 - 重投影-光流 - 添加残差块，ceres求解 - 更新滑窗每一帧的q和T，填充sfm_tracked_points - pnp求所有帧 - 如果当前帧在滑窗内，更新ImageFrame的R和T - 如果当前帧不在滑窗内，找这个帧被三角化的特征点，获得3d、2d坐标 - cv::solvePnP()求解该帧的位姿 - 更新该帧ImageFrame的R和T - 视觉imu对齐 visualInitialAlign() - VisualIMUAlignment(all_image_frame, Bgs, g, x) - solveGyroscopeBias(all_image_frame, Bgs) - - ldlt求解 更新滑窗内的Bgs数组 - 所有帧重新预积分 repropagate(Vector3d::Zero(), Bgs[0]) - LinearAlignment(all_image_frame, g, x) - - RefineGravity(all_image_frame, g, x) - - 用尺度、优化后的速度更新滑窗内的Ps、Rs、Vs，并把坐标系从第l帧相机系转到世界系 - 对滑窗内的帧重新预积分 repropagate(Vector3d::Zero(), Bgs[i]) - 求将第l帧g变换到世界系的g的旋转，把参考系从第l帧变到第0帧body系（世界系），现在的Rs、Ps、Vs是第i帧imu在第0帧body系 - clearDepth() 清楚feature数组FeaturePerId的深度 - 重新求深度（相对于世界系） triangulate(frame_count, Ps, Rs, tic, ric) - 获得首次观测到这个特征点的帧 获得左目右目的像素坐标 triangulatePoint()三角化求世界系的空间坐标 - feature数组的FeaturePerId的深度是在首次观测到该特征点的帧的相机系的z - 三角化的两帧是首次观测到该特征点的帧和它的下一帧 - 详细看手写VIO第6讲25页 - SVD求解 - optimization() - updateLatestStates() - slideWindow() - slideWindow() - 双目+imu - initFramePoseByPnP(frame_count, Ps, Rs, tic, ric) - 遍历滑窗特征点，获得世界系3d坐标和最新帧的像素坐标 - solvePoseByPnP()求位姿 - 主要是格式转换 旋转向量和旋转矩阵转换 cv::solvePnP() - 更新最新帧的Ps、Rs - triangulate(frame_count, Ps, Rs, tic, ric) - 更新all_image_frame的RT（all_image_fram","date":"2022-11-27","objectID":"/vins_estimator/:1:5","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"IntegrationBase ","date":"2022-11-27","objectID":"/vins_estimator/:2:0","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"repropagate() 把预积分相关的变量设为初始值 遍历所有imu帧，预积分 propagate(dt_buf[i], acc_buf[i], gyr_buf[i]) midPointIntegration(_dt, acc_0, gyr_0, _acc_1, _gyr_1, delta_p, delta_q, delta_v, linearized_ba, linearized_bg, result_delta_p, result_delta_q, result_delta_v, result_linearized_ba, result_linearized_bg, 1) - 新值赋给旧值 ","date":"2022-11-27","objectID":"/vins_estimator/:2:1","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"evaluate() ","date":"2022-11-27","objectID":"/vins_estimator/:2:2","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"IMUFactor ","date":"2022-11-27","objectID":"/vins_estimator/:3:0","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"evaluate() 计算残差 pre_integration-\u003eevaluate(Pi, Qi, Vi, Bai, Bgi, Pj, Qj, Vj, Baj, Bgj) ","date":"2022-11-27","objectID":"/vins_estimator/:3:1","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"ProjectionFactor ","date":"2022-11-27","objectID":"/vins_estimator/:4:0","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"MarginalizationFactor ","date":"2022-11-27","objectID":"/vins_estimator/:5:0","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"ResidualBlockInfo Evaluate() 调用对应残差的Evalua()函数求残差和雅克比 cost_function-\u003eEvaluate(parameter_blocks.data(), residuals.data(), raw_jacobians) 如果有核函数，残差和雅克比需要缩放 ","date":"2022-11-27","objectID":"/vins_estimator/:5:1","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"MarginalizationInfo addResidualBlockInfo() 填充parameter_block_size和parameter_block_idx，先记为0 getParameterBlocks() 将边缘化保留的变量存入到keep_block_xxx中 preMarginalize() 调用对应的Evaluate()求残差和雅克比 填充parameter_block_data marginalize() 把边缘化掉的变量排在前面，在parameter_block_idx中体现 构造H和b，舒尔补求新的H和b - 将H和b分解出J和e - ","date":"2022-11-27","objectID":"/vins_estimator/:5:2","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"MarginalizationFactor Evaluate() 计算残差 雅克比就是marginalization_info的雅克比 ","date":"2022-11-27","objectID":"/vins_estimator/:5:3","tags":["slam"],"title":"vins_estimator","uri":"/vins_estimator/"},{"categories":["note","slam"],"content":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"简要记录一下论文的内容，防止遗忘，有些地方自己也没弄明白，记录不涉及公式的推导（公式推导参考崔华坤vins公式推导） ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:0:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Abstract VINS-Mono是一个由港科大秦通、栗培梁、沈劭劼完成的单目VI状态估计器，输入相机的图片和IMU参数，经过非线性优化，实时输出位姿和地图。 代码在此链接 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:1:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Introduction 由于单目相机对尺度不可测，所以使用IMU辅助。单目VIO系统存在一些问题，比如为了成功初始化需要有足够的加速度激励。由于系统高度非线性，初始化也比较麻烦。外参标定和误差漂移也是问题。所以作者提出了VINS-Mono。 作者提出本文的主要贡献为 鲁棒的初始化 紧耦合和基于优化的VIO可以进行外参标定和IMU偏置估计 在线回环检测和紧耦合的重定位 四自由度全局位姿图优化 实际应用良好 开源 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:2:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Related Work 有关视觉里程计的算法有很多，PTAM、SVO、LSD-SLAM、DSO、ORB-SLAM。最简单的VIO是IMU和视觉松耦合的EKF，紧耦合的VIO既可以使用滤波（常用MSCKF），也可以使用优化（批图优化和BA配合滑窗）。 对于视觉测量的处理，一般有直接法和特征点法。直接法依赖于光度误差，计算量小，对初始位姿估计要求严格。特征点法依赖于平面的几何位移，计算量大，主要体现在提取和匹配特征点上。实际中，由于特征点法更成熟和鲁棒，也更常用，在稠密建图上直接法更好用。 IMU通常有很高的频率，对于优化方法，通常使用IMU预积分。 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:3:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Overview VINS的结构图如下 在一开始时，图像会进行特征点追踪和提取，IMU数据进行预积分。在V部分会进行纯视觉SfM和视觉惯性对齐，这部分叫初始化，初始化之后就可以得到必要的信息（每一帧的位姿，速度，重力，陀螺仪偏置，3D点坐标）为后续非线性优化使用。在VI和VII部分，非线性优化将使用紧耦合的视觉和IMU数据，并且使用回环检测进行重定位。最后在VIII部分，使用重定位的结果进行全局位姿图优化，重定位和位姿图优化并行进行。 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:4:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Measurement Preprocessing 测量预处理包括图像的特征点追踪和提取，IMU的预积分。 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:5:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Vision Processing Front-end 图像首先进行特征点追踪，然后提取新的角点，使用RANSAC进行外点剔除。 关键帧的判断有两个条件：如果当前帧和上一个关键帧的特征点平均视差过大，当前帧就是关键帧。如果跟踪到的点很少，当前帧就是关键帧。 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:5:1","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"IMU Pre-integration 一些前置定义 区分两个概念，测量值和真实值，测量值可以直接通过传感器得到，真实值是测量值尽可能消去误差（bias和noise）得到的 下标k是图像帧，下标i是IMU帧 原始的陀螺仪和加速度计的测量值 $$ \\begin{aligned} \\hat{\\mathbf{a}}_{t} \u0026 =\\mathbf{a}_{t}+\\mathbf{b}_{a_{t}}+\\mathbf{R}_{w}^{t} \\mathbf{g}^{w}+\\mathbf{n}_{a} \\end{aligned} $$ $$ \\begin{aligned} \\hat{\\boldsymbol{\\omega}}_{t} \u0026 =\\boldsymbol{\\omega}_{t}+\\mathbf{b}_{w_{t}}+\\mathbf{n}_{w} \\end{aligned} $$ 假设噪声满足正态分布，偏置的导数满足正态分布 第k+1图像帧的位移、速度和旋转（在世界坐标系下）可以通过上一帧得到 $$ \\begin{array}{l} \\mathbf{p}_{b_{k+1}}^{w}=\\mathbf{p}_{b_{k}}^{w}+\\mathbf{v}_{b_{k}}^{w} \\Delta t_{k} +\\iint_{t \\in\\left[t_{k}, t_{k+1}\\right]}\\left(\\mathbf{R}_{t}^{w}\\left(\\hat{\\mathbf{a}}_{t}-\\mathbf{b}_{a_{t}}-\\mathbf{n}_{a}\\right)-\\mathbf{g}^{w}\\right) d t^{2} \\end{array} $$ $$ \\begin{array}{l} \\mathbf{v}_{b_{k+1}}^{w}=\\mathbf{v}_{b_{k}}^{w}+\\int_{t \\in\\left[t_{k}, t_{k+1}\\right]}\\left(\\mathbf{R}_{t}^{w}\\left(\\hat{\\mathbf{a}}_{t}-\\mathbf{b}_{a_{t}}-\\mathbf{n}_{a}\\right)-\\mathbf{g}^{w}\\right) d t \\end{array} $$ $$ \\begin{array}{l} \\mathbf{q}_{b_{k+1}}^{w}=\\mathbf{q}_{b_{k}}^{w} \\otimes \\int_{t \\in\\left[t_{k}, t_{k+1}\\right]} \\frac{1}{2} \\boldsymbol{\\Omega}\\left(\\hat{\\boldsymbol{\\omega}}_{t}-\\mathbf{b}_{w_{t}}-\\mathbf{n}_{w}\\right) \\mathbf{q}_{t}^{b_{k}} d t \\end{array} $$ This is a tip\r一个 技巧 横幅\r行内公式: 公式块: 原始的带有 Markdown 语法的内容: 由上面的公式可以看出，Rwt是待优化变量，每次优化调整时，就需要重新传递才能使其他量更准确，很浪费时间，所以采用预积分的策略 不在世界坐标系下求pvq，而是在bk系下求，这样公式转变成 $$ \\begin{aligned} \\mathbf{R}{w}^{b{k}} \\mathbf{p}{b{k+1}}^{w} \u0026 =\\mathbf{R}{w}^{b{k}}\\left(\\mathbf{p}{b{k}}^{w}+\\mathbf{v}{b{k}}^{w} \\Delta t_{k}-\\frac{1}{2} \\mathbf{g}^{w} \\Delta t_{k}^{2}\\right)+\\boldsymbol{\\alpha}{b{k+1}}^{b_{k}} \\ \\mathbf{R}{w}^{b{k}} \\mathbf{v}{b{k+1}}^{w} \u0026 =\\mathbf{R}{w}^{b{k}}\\left(\\mathbf{v}{b{k}}^{w}-\\mathbf{g}^{w} \\Delta t_{k}\\right)+\\boldsymbol{\\beta}{b{k+1}}^{b_{k}} \\ \\mathbf{q}{w}^{b{k}} \\otimes \\mathbf{q}{b{k+1}}^{w} \u0026 =\\gamma_{b_{k+1}}^{b_{k}} \\end{aligned} $$ $$ \\begin{aligned} \\boldsymbol{\\alpha}{b{k+1}}^{b_{k}} \u0026 =\\iint_{t \\in\\left[t_{k}, t_{k+1}\\right]} \\mathbf{R}{t}^{b{k}}\\left(\\hat{\\mathbf{a}}{t}-\\mathbf{b}{a_{t}}-\\mathbf{n}{a}\\right) d t^{2} \\ \\boldsymbol{\\beta}{b_{k+1}}^{b_{k}} \u0026 =\\int_{t \\in\\left[t_{k}, t_{k+1}\\right]} \\mathbf{R}{t}^{b{k}}\\left(\\hat{\\mathbf{a}}{t}-\\mathbf{b}{a_{t}}-\\mathbf{n}{a}\\right) d t \\ \\boldsymbol{\\gamma}{b_{k+1}}^{b_{k}} \u0026 =\\int_{t \\in\\left[t_{k}, t_{k+1}\\right]} \\frac{1}{2} \\boldsymbol{\\Omega}\\left(\\hat{\\boldsymbol{\\omega}}{t}-\\mathbf{b}{w_{t}}-\\mathbf{n}{w}\\right) \\boldsymbol{\\gamma}{t}^{b_{k}} d t \\end{aligned} $$ 三个预积分项可以近似看成是相邻图像帧之间的pvq的变化量，可以看出三个预积分项没有待优化变量。三个预积分项和bias有关，当bias变化时，变化不大，则用预积分项的一阶近似代替，变化很大则重传递 上面的预积分项是连续的，实际是用离散形式代替，离散形式有欧拉法、中点法等，论文写的是欧拉法，代码中用的是中点法。欧拉法的预积分项传递公式如下（不考虑噪声） $$ \\begin{array}{l} \\hat{\\boldsymbol{\\alpha}}{i+1}^{b{k}}=\\hat{\\boldsymbol{\\alpha}}{i}^{b{k}}+\\hat{\\boldsymbol{\\beta}}{i}^{b{k}} \\delta t+\\frac{1}{2} \\mathbf{R}\\left(\\hat{\\gamma}{i}^{b{k}}\\right)\\left(\\hat{\\mathbf{a}}{i}-\\mathbf{b}{a_{i}}\\right) \\delta t^{2} \\ \\hat{\\boldsymbol{\\beta}}{i+1}^{b{k}}=\\hat{\\boldsymbol{\\beta}}{i}^{b{k}}+\\mathbf{R}\\left(\\hat{\\gamma}{i}^{b{k}}\\right)\\left(\\hat{\\mathbf{a}}{i}-\\mathbf{b}{a_{i}}\\right) \\delta t \\ \\hat{\\boldsymbol{\\gamma}}{i+1}^{b{k}}=\\hat{\\boldsymbol{\\gamma}}{i}^{b{k}} \\otimes\\left[\\begin{array}{c} 1 \\ \\frac{1}{2}\\left(\\hat{\\boldsymbol{\\omega}}{i}-\\mathbf{b}{w_{i}}\\right) \\delta t \\end{array}\\right] \\end{array} $$ 预积分和bias的误差传递公式如下 $$ \\begin{array}{l} {\\left[\\begin{array}{c} \\delta \\dot{\\boldsymbol{\\alpha}}{t}^{b{k}} \\ \\delta \\dot{\\boldsymbol{\\beta}}{t}^{b{k}} \\ \\delta \\dot{\\boldsymbol{\\theta}}{t}^{b{k}} \\ \\delta \\dot{\\mathbf{b}}{a{t}} \\ \\delta \\dot{\\mathbf{b}}{w{t}} \\end{array}\\right]=\\left[\\begin{array}{ccccc} 0 \u0026 \\mathbf{I} \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 -\\mathbf{R}{t}^{b{k}}\\left\\lfloor\\hat{\\mathbf{a}}{t}-\\mathbf{b}{a_{t}}\\right\\rfloor_{\\times} \u0026 -\\mathbf{R}{t}^{b{k}} \u0026 0 \\ 0 \u0026 0 \u0026 -\\left\\lfloor\\hat{\\boldsymbol{\\omega}}{t}-\\mathbf{b}{w_{t}}\\right\\rfloor_{\\times} \u0026 0 \u0026 -\\mathbf{I} \\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\end{array}\\right]\\left[\\begin{array}{c} \\delta \\boldsymbol{\\alph","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:5:2","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Estimator Initialization 先纯视觉SfM，然后视觉和IMU对齐恢复尺度、重力、速度、bias。在初始化时，忽略加速度计的bias ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:6:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Sliding Window Vision-Only SfM 当滑窗满了开始初始化，求最新帧和前面帧的共视点，如果前面存在一个帧有足够的共视点和视差，则那一帧当做参考帧，通过五点法求出不含尺度的相对旋转和位移。如果找不到参考帧，则移出最老帧，等待新帧。 如果五点法成功，则三角化参考帧和最新帧的共视点。有了3D点，通过PnP求滑窗中其他帧的位姿。最后全局BA ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:6:1","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Visual-Inertial Alignment Gyroscope Bias Calibration 陀螺仪偏置的标定通过最小化如下函数来求，其中q由SfM得到，γ由IMU得到 $$ \\begin{array}{r} \\min {\\delta b{w}} \\sum_{k \\in \\mathcal{B}}\\left|\\mathbf{q}{b{k+1}}^{c_{0}}{ }^{-1} \\otimes \\mathbf{q}{b{k}}^{c_{0}} \\otimes \\boldsymbol{\\gamma}{b{k+1}}^{b_{k}}\\right|^{2} \\ \\gamma_{b_{k+1}}^{b_{k}} \\approx \\hat{\\gamma}{b{k+1}}^{b_{k}} \\otimes\\left[\\begin{array}{c} 1 \\ \\frac{1}{2} \\mathbf{J}{b{w}}^{\\gamma} \\delta \\mathbf{b}_{w} \\end{array}\\right] \\end{array} $$ B表示滑窗所有帧 求出陀螺仪偏置后重传递更新所有的IMU预积分 Velocity, Gravity Vector and Metric Scale Initialization 待求的变量为 $$ \\mathcal{X}{I}=\\left[\\mathbf{v}{b_{0}}^{b_{0}}, \\mathbf{v}{b{1}}^{b_{1}}, \\cdots \\mathbf{v}{b{n}}^{b_{n}}, \\mathbf{g}^{c_{0}}, s\\right] $$ 论文中给出了结论，求这个向量就是最小化以下函数 $$ \\min {\\mathcal{X}{I}} \\sum_{k \\in \\mathcal{B}}\\left|\\hat{\\mathbf{z}}{b{k+1}}^{b_{k}}-\\mathbf{H}{b{k+1}}^{b_{k}} \\mathcal{X}_{I}\\right|^{2} $$ $$ \\hat{\\mathbf{z}}{b{k+1}}^{b_{k}}=\\left[\\begin{array}{c} \\hat{\\boldsymbol{\\alpha}}{b{k+1}}^{b_{k}}-\\mathbf{p}{c}^{b}+\\mathbf{R}{c_{0}}^{b_{k}} \\mathbf{R}{b{k+1}}^{c_{0}} \\mathbf{p}{c}^{b} \\ \\hat{\\boldsymbol{\\beta}}{b_{k+1}}^{b_{k}} \\end{array}\\right] $$ $$ \\mathbf{H}{b{k+1}}^{b_{k}}=\\left[\\begin{array}{cccc} -\\mathbf{I} \\Delta t_{k} \u0026 \\mathbf{0} \u0026 \\frac{1}{2} \\mathbf{R}{c{0}}^{b_{k}} \\Delta t_{k}^{2} \u0026 \\mathbf{R}{c{0}}^{b_{k}}\\left(\\overline{\\mathbf{p}}{c{k+1}}^{c_{0}}-\\overline{\\mathbf{p}}{c{k}}^{c_{0}}\\right) \\ -\\mathbf{I} \u0026 \\mathbf{R}{c{0}}^{b_{k}} \\mathbf{R}{b{k+1}}^{c_{0}} \u0026 \\mathbf{R}{c{0}}^{b_{0}} \\Delta t_{k} \\end{array}\\right] $$ Gravity Refinement 由于重力的值通常是已知的，所以只有2自由度，但是我们求出的g有3自由度，所以进行优化 将g写成这种形式$g \\cdot \\overline{\\hat{\\mathbf{g}}}+w_{1} \\mathbf{b}{1}+w{2} \\mathbf{b}_{2}$，其中g是已知的重力值，g\\hat\\bar是原本重力的单位向量，b1b2是原本重力切平面的正交基，w1w2是权重 b是这样求的 w是通过改写上面公式的H和z求的 Completing Initialization 最后将重力转到z轴，求出一个旋转矩阵，通过旋转矩阵将所有的量从c0系转到世界系 然后这些量将输入进紧耦合VIO中 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:6:2","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Tightly-Coupled Monocular VIO ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:7:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Formulation 待优化变量为滑窗内每个图像pvqb，外参，特征点的逆深度 $$ \\begin{aligned} \\mathcal{X} \u0026 =\\left[\\mathbf{x}{0}, \\mathbf{x}{1}, \\cdots \\mathbf{x}{n}, \\mathbf{x}{c}^{b}, \\lambda_{0}, \\lambda_{1}, \\cdots \\lambda_{m}\\right] \\ \\mathbf{x}{k} \u0026 =\\left[\\mathbf{p}{b_{k}}^{w}, \\mathbf{v}{b{k}}^{w}, \\mathbf{q}{b{k}}^{w}, \\mathbf{b}{a}, \\mathbf{b}{g}\\right], k \\in[0, n] \\ \\mathbf{x}{c}^{b} \u0026 =\\left[\\mathbf{p}{c}^{b}, \\mathbf{q}_{c}^{b}\\right] \\end{aligned} $$ 非线性优化的公式如下，这也是VINS最重要的公式，之后会说下公式的含义 $$ \\begin{aligned} \\min {\\mathcal{X}}\\left{\\left|\\mathbf{r}{p}-\\mathbf{H}{p} \\mathcal{X}\\right|^{2}+\\right. \u0026 \\sum{k \\in \\mathcal{B}}\\left|\\mathbf{r}{\\mathcal{B}}\\left(\\hat{\\mathbf{z}}{b_{k+1}}^{b_{k}}, \\mathcal{X}\\right)\\right|{\\mathbf{P}{b_{k+1}}^{b_{k}}}^{2}+ \\sum_{(l, j) \\in \\mathcal{C}} \\rho\\left(\\left|\\mathbf{r}{\\mathcal{C}}\\left(\\hat{\\mathbf{z}}{l}^{c_{j}}, \\mathcal{X}\\right)\\right|{\\left.\\mathbf{P}{l}^{c_{j}}\\right)}^{2}\\right} \\end{aligned} $$ 这个公式有三项分别是边缘化的先验约束、IMU约束、视觉约束，约束就是残差，其中后两项带有协方差矩阵，最后一项加上Huber核，B是IMU在滑窗内所有的测量值，C是滑窗内被跟踪至少两次的特征点。用ceres solver求解 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:7:1","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"IMU Measurement Residual IMU约束是相邻两个图像之间的预积分项的残差 $$ \\begin{array}{l} \\mathbf{r}{\\mathcal{B}}\\left(\\hat{\\mathbf{z}}{b_{k+1}}^{b_{k}}, \\mathcal{X}\\right)=\\left[\\begin{array}{c} \\delta \\boldsymbol{\\alpha}{b{k+1}}^{b_{k}} \\ \\delta \\boldsymbol{\\beta}{b{k+1}}^{b_{k}} \\ \\delta \\boldsymbol{\\theta}{b{k+1}}^{b_{k}} \\ \\delta \\mathbf{b}{a} \\ \\delta \\mathbf{b}{g} \\end{array}\\right] \\ =\\left[\\begin{array}{c} \\mathbf{R}{w}^{b{k}}\\left(\\mathbf{p}{b{k+1}}^{w}-\\mathbf{p}{b{k}}^{w}+\\frac{1}{2} \\mathbf{g}^{w} \\Delta t_{k}^{2}-\\mathbf{v}{b{k}}^{w} \\Delta t_{k}\\right)-\\hat{\\boldsymbol{\\alpha}}{b{k+1}}^{b_{k}} \\ \\mathbf{R}{w}^{b{k}}\\left(\\mathbf{v}{b{k+1}}^{w}+\\mathbf{g}^{w} \\Delta t_{k}-\\mathbf{v}{b{k}}^{w}\\right)-\\hat{\\boldsymbol{\\beta}}{b{k+1}}^{b_{k}} \\ 2\\left[\\mathbf{q}{b{k}}^{w^{-1}} \\otimes \\mathbf{q}{b{k+1}}^{w} \\otimes\\left(\\hat{\\gamma}{b{k+1}}^{b_{k}}\\right)^{-1}\\right]{x y z} \\ \\mathbf{b}{a b_{k+1}}-\\mathbf{b}{a b{k}} \\ \\mathbf{b}{w b{k+1}}-\\mathbf{b}{w b{k}} \\end{array}\\right] \\end{array} $$ ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:7:2","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Visual Measurement Residual 视觉的约束就是重投影误差 误差的距离不是在成像平面上计算，是将特征点像素坐标通过内参投影到单位球上，然后在单位球上求向量的差，因为误差是2维（像素坐标是2维）的，所以误差实际上在单位球的正切平面上算 $$ \\begin{array}{l} \\mathbf{r}{\\mathcal{C}}\\left(\\hat{\\mathbf{z}}{l}^{c_{j}}, \\mathcal{X}\\right)=\\left[\\begin{array}{ll} \\mathbf{b}{1} \u0026 \\mathbf{b}{2} \\end{array}\\right]^{T} \\cdot\\left(\\hat{\\overline{\\mathcal{P}}}{l}^{c{j}}-\\frac{\\mathcal{P}{l}^{c{j}}}{\\left|\\mathcal{P}{l}^{c{j}}\\right|}\\right) \\ \\begin{array}{l} \\hat{\\mathcal{P}}{l}^{c{j}}=\\pi_{c}{ }^{-1}\\left(\\left[\\begin{array}{c} \\hat{u}{l}^{c{j}} \\ \\hat{v}{l}^{c{j}} \\end{array}\\right]\\right) \\ \\mathcal{P}{l}^{c{j}}=\\mathbf{R}{b}^{c}\\left(\\mathbf { R } _ { w } ^ { b _ { j } } \\left(\\mathbf { R } _ { b _ { i } } ^ { w } \\left(\\mathbf{R}{c}^{b} \\frac{1}{\\lambda_{l}} \\pi_{c}{ }^{-1}\\left(\\left[\\begin{array}{c} u_{l}^{c_{i}} \\ v_{l}^{c_{i}} \\end{array}\\right]\\right)\\right.\\right.\\right. \\left.\\left.\\left.+\\mathbf{p}{c}^{b}\\right)+\\mathbf{p}{b_{i}}^{w}-\\mathbf{p}{b{j}}^{w}\\right)-\\mathbf{p}_{c}^{b}\\right) \\end{array} \\end{array} $$ ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:7:3","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Marginalization 由于要滑窗容量有限，当新帧来时，就需要把滑窗内的某一帧移出去，而移出去的过程就叫边缘化，移出去的帧和相关的数据不能直接丢弃，会作为先验信息加入到非线性优化中 边缘化的策略是，如果次新帧是关键帧，则边缘化最老帧，把相关的VI数据作为先验，如果次新帧不是关键帧，则抛弃它，视觉数据直接抛弃，IMU数据和后面的连在一起 边缘化采用舒尔补，具体形式论文没有详细叙述，详细公式在A General Optimization-based Framework for Local Odometry Estimation with Multiple Sensors论文中叙述 边缘化对导致线性化点的过早固定，这样可能会得到次优解，不过作者认为小误差漂移是可以接受的（可能后续可以通过回环检测来消除） ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:7:4","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Motion-only Visual-Inertial Bundle Adjustment for Camera-Rate State Estimation 对于算力不是很足的设备，在优化时只优化后面几帧的数据，而不是整个滑窗的数据 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:7:5","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"IMU Forward Propagation for IMU-Rate State Estimation ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:7:6","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Failure Detection and Recovery 故障检测的标准是：最新帧跟踪的特征点小于某个阈值，估计器输出的最后两帧的位移和旋转差很大，估计器估计的bias和外参在两个时刻差很大 当检测到故障时，回到初始化阶段 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:7:7","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Relocalization 由于滑窗和边缘化计算的是局部的信息，会带来误差并累积，所以使用回环检测和重定位来消除 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:8:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Loop Detection 使用DBoW2词袋模型进行回环检测，除了用于VIO的角点，会额外提取500个角点并计算BRIEF描述子，描述子作为单词进行查找，查找后会返回回环候选帧。我们只保留描述子用于信息检索，原始图像将会被抛弃来减少内存消耗 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:8:1","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Feature Retrieval 对于回环候选帧，如果直接比较描述子鲁棒性不是很高 所以先用RANSAC做一次2D-2D的测试，再用RANSAC做一次PnP测试，如果内点大于阈值则为回环帧，然后进行重定位 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:8:2","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Tightly-Coupled Relocalization 重定位就是改变非线性优化的代价函数，再加一项视觉的回环约束，因为我们将VIO中这些特征点和回环中看到的这些特征点认为是相同的。但是把从位姿图中拿出的回环帧的位姿保持恒定 如果滑窗有多个回环帧时，一起优化以提高精度和平滑度 $$ \\begin{array}{l} \\min {\\mathcal{X}}\\left{\\left|\\mathbf{r}{p}-\\mathbf{H}{p} \\mathcal{X}\\right|^{2}+\\sum{k \\in \\mathcal{B}}\\left|\\mathbf{r}{\\mathcal{B}}\\left(\\hat{\\mathbf{z}}{b_{k+1}}^{b_{k}}, \\mathcal{X}\\right)\\right|{\\mathbf{P}{b_{k+1}}^{b_{k}}}^{2}\\right. +\\sum_{(l, j) \\in \\mathcal{C}} \\rho\\left(\\left|\\mathbf{r}{\\mathcal{C}}\\left(\\hat{\\mathbf{z}}{l}^{c_{j}}, \\mathcal{X}\\right)\\right|{\\mathbf{P}{l}^{c_{j}}}^{2}\\right) +\\sum_{(l, v) \\in \\mathcal{L}} \\rho\\left(\\left|\\mathbf{r}{\\mathcal{C}}\\left(\\hat{\\mathbf{z}}{l}^{v}, \\mathcal{X}, \\hat{\\mathbf{q}}{v}^{w}, \\hat{\\mathbf{p}}{v}^{w}\\right)\\right|{\\mathbf{P}{l}^{c_{v}}}^{2}\\right} \\end{array} $$ 其中v表示回环帧 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:8:3","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Global Pose Graph Optimization 为了使全局保持同步，所以将重定位的结果加进全局位姿图优化中。因为重力方向已经确定，所以三个方向的平移和对重力方向的旋转是不可观的，只进行4自由度的位姿图优化 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:9:0","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Adding Keyframes into the Pose Graph 当关键帧从滑窗中边缘化掉后，它将作为顶点加进位姿图中 这个顶点与别的顶点有两种边 序列边：这个关键帧与前面的关键帧相连，边表示的是相对平移，假设刚被边缘化的关键帧i和之前某一个关键帧j，考虑4自由度，平移和yaw角 $$ \\begin{aligned} \\hat{\\mathbf{p}}{i j}^{i} \u0026 =\\hat{\\mathbf{R}}{i}^{w-1}\\left(\\hat{\\mathbf{p}}{j}^{w}-\\hat{\\mathbf{p}}{i}^{w}\\right) \\ \\hat{\\psi}{i j} \u0026 =\\hat{\\psi}{j}-\\hat{\\psi}_{i} \\end{aligned} $$ 回环边：如果刚被边缘化的关键帧有回环帧，则加一条4自由度的边，边的值从重定位中获取，形式和上面的公式一样 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:9:1","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"4-DOF Pose Graph Optimization 定义两帧i和j的残差 $$ \\mathbf{r}{i, j}\\left(\\mathbf{p}{i}^{w}, \\psi_{i}, \\mathbf{p}{j}^{w}, \\psi{j}\\right)=\\left[\\begin{array}{c} \\mathbf{R}\\left(\\hat{\\phi}{i}, \\hat{\\theta}{i}, \\psi_{i}\\right)^{-1}\\left(\\mathbf{p}{j}^{w}-\\mathbf{p}{i}^{w}\\right)-\\hat{\\mathbf{p}}{i j}^{i} \\ \\psi{j}-\\psi_{i}-\\hat{\\psi}_{i j} \\end{array}\\right] $$ 全局图的代价函数为 $$ \\min {\\mathbf{p}, \\psi}\\left{\\sum{(i, j) \\in \\mathcal{S}}\\left|\\mathbf{r}{i, j}\\right|^{2}+\\sum{(i, j) \\in \\mathcal{L}} \\rho\\left(\\left|\\mathbf{r}_{i, j}\\right|^{2}\\right)\\right} $$ 其中S是序列边，L是回环边，序列边不加鲁棒核是因为它的数据从VIO中获得，已经进行了外点剔除，具有鲁棒性了 重定位和全局位姿图优化在不同的线程中进行，这样可以保证它们互相使用最新的结果 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:9:2","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note","slam"],"content":"Pose Graph Management 由于全局位姿图会不断膨胀，在计算上会越来越耗时，所以之后有回环的关键帧会被保留，那些很相似的关键帧将被丢弃 ","date":"2022-11-03","objectID":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/:9:3","tags":["slam"],"title":"VINS-Mono: A Robust and Versatile Monocular Visual-Inertial State Estimator","uri":"/vins-mono-a-robust-and-versatile-monocular-visual-inertial-state-estimator/"},{"categories":["note"],"content":"Matrix Decomposition","date":"2022-10-14","objectID":"/matrix-decomposition/","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"本文试图用最简洁清晰的语言解释各种矩阵分解，只记录矩阵分解的基础知识和过程，对性质和应用的讨论先挖个坑，下次再填 有关矩阵分解的知识可以参考这个 为什么要矩阵分解？为了更好的计算，降低计算复杂度 ","date":"2022-10-14","objectID":"/matrix-decomposition/:0:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Definitions ","date":"2022-10-14","objectID":"/matrix-decomposition/:1:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Unitary matrix Conjugate transpose 共轭转置 aka Hermitian transpose，计$A^H$为A的共轭转置（有时也写成$A^*$） 对实矩阵，${\\displaystyle {\\boldsymbol {A}}^{\\mathrm {H} }={\\boldsymbol {A}}^{\\mathsf {T}}}$ 对矩阵A，共轭转置后，每个元素的定义为 $${\\displaystyle \\left({\\boldsymbol {A}}^{\\mathrm {H} }\\right)_{ij}={\\overline {{\\boldsymbol {A}}_{ji}}}}$$ 比如矩阵A $$ {\\displaystyle {\\boldsymbol {A}}={\\begin{bmatrix}1\u0026-2-i\u00265\\\\1+i\u0026i\u00264-2i\\end{bmatrix}}} $$ $$ {\\displaystyle {\\boldsymbol {A}}^{\\mathsf {T}}={\\begin{bmatrix}1\u00261+i\\\\-2-i\u0026i\\\\5\u00264-2i\\end{bmatrix}}} $$ $$ {\\displaystyle {\\boldsymbol {A}}^{\\mathrm {H} }={\\begin{bmatrix}1\u00261-i\\\\-2+i\u0026-i\\\\5\u00264+2i\\end{bmatrix}}} $$ 酉矩阵的定义为，对于方阵U，满足如下性质，U*是共轭转置，I是单位阵 $$ {\\displaystyle U^{*}U=UU^{*}=UU^{-1}=I} $$ 酉矩阵的行列式绝对值为1，在特征空间中正交，当矩阵为实数阵时，就是正交矩阵（orthogonal matrix） 正交矩阵就是各列向量线性无关，是实数下的酉矩阵 ","date":"2022-10-14","objectID":"/matrix-decomposition/:1:1","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Definite matrix Definitions for real matrices 假设M是n阶实对称矩阵 $$ {\\displaystyle M{\\text{ positive-definite}}\\quad \\iff \\quad \\mathbf {x} ^{\\textsf {T}}M\\mathbf {x} \u003e0{\\text{ for all }}\\mathbf {x} \\in \\mathbb {R} ^{n}\\setminus \\{\\mathbf {0} \\}} $$ $$ {\\displaystyle M{\\text{ positive semi-definite}}\\quad \\iff \\quad \\mathbf {x} ^{\\textsf {T}}M\\mathbf {x} \\geq 0{\\text{ for all }}\\mathbf {x} \\in \\mathbb {R} ^{n}} $$ $$ {\\displaystyle M{\\text{ negative-definite}}\\quad \\iff \\quad \\mathbf {x} ^{\\textsf {T}}M\\mathbf {x} \u003c0{\\text{ for all }}\\mathbf {x} \\in \\mathbb {R} ^{n}\\setminus \\{\\mathbf {0} \\}} $$ $$ {\\displaystyle M{\\text{ negative semi-definite}}\\quad \\iff \\quad \\mathbf {x} ^{\\textsf {T}}M\\mathbf {x} \\leq 0{\\text{ for all }}\\mathbf {x} \\in \\mathbb {R} ^{n}} $$ Definitions for complex matrices 设M是n阶Hermite复矩阵 $$ {\\displaystyle M{\\text{ positive-definite}}\\quad \\iff \\quad \\mathbf {x} ^{*}M\\mathbf {x} \u003e0{\\text{ for all }}\\mathbf {x} \\in \\mathbb {C} ^{n}\\setminus \\{\\mathbf {0} \\}} $$ $$ {\\displaystyle M{\\text{ positive semi-definite}}\\quad \\iff \\quad \\mathbf {x} ^{*}M\\mathbf {x} \\geq 0{\\text{ for all }}\\mathbf {x} \\in \\mathbb {C} ^{n}} $$ $$ {\\displaystyle M{\\text{ negative-definite}}\\quad \\iff \\quad \\mathbf {x} ^{*}M\\mathbf {x} \u003c0{\\text{ for all }}\\mathbf {x} \\in \\mathbb {C} ^{n}\\setminus \\{\\mathbf {0} \\}} $$ $$ {\\displaystyle M{\\text{ negative semi-definite}}\\quad \\iff \\quad \\mathbf {x} ^{*}M\\mathbf {x} \\leq 0{\\text{ for all }}\\mathbf {x} \\in \\mathbb {C} ^{n}} $$ 正定矩阵的几何意义参考此处 实际上$x^TAx$的形式表示二次型（有一个概念叫合同与之相关），而根据定义，正定矩阵表示对所有的非零解，它的值都是大于0的，这在空间上是一个开口向上的抛物面（三维），正定矩阵如果看做一种空间变换，就相当于把一块布的四个角往上提了 假设$y=x^TAx$，那么y\u003e0，且y有最小值 Illustration\r当我们求一个二次型的极值时，假设它是正定矩阵，那么一定有最小值（如上图），而根据泰勒公式，Hessian矩阵就是二次型的矩阵A，所以判断Hessian矩阵是不是正定矩阵就行 Example 单位阵是正定矩阵也是正半定矩阵 $$ {\\displaystyle\\mathbf{z}^{\\textsf{T}}I\\mathbf{z}={\\begin{bmatrix}a\u0026b\\end{bmatrix}}{\\begin{bmatrix}1\u00260\\\\0\u00261\\end{bmatrix}}{\\begin{bmatrix}a\\\\b\\end{bmatrix}}=a^{2}+b^{2}.} $$ 这个矩阵M也是正定矩阵 $$ {\\displaystyle M={\\begin{bmatrix}2\u0026-1\u00260\\\\-1\u00262\u0026-1\\\\0\u0026-1\u00262\\end{bmatrix}}} $$ $$ {\\displaystyle {\\begin{aligned}\\mathbf {z} ^{\\textsf {T}}M\\mathbf {z} =\\left(\\mathbf {z} ^{\\textsf {T}}M\\right)\\mathbf {z} \u0026={\\begin{bmatrix}(2a-b)\u0026(-a+2b-c)\u0026(-b+2c)\\end{bmatrix}}{\\begin{bmatrix}a\\\\b\\\\c\\end{bmatrix}}\\\\\u0026=(2a-b)a+(-a+2b-c)b+(-b+2c)c\\\\\u0026=2a^{2}-ba-ab+2b^{2}-cb-bc+2c^{2}\\\\\u0026=2a^{2}-2ab+2b^{2}-2bc+2c^{2}\\\\\u0026=a^{2}+a^{2}-2ab+b^{2}+b^{2}-2bc+c^{2}+c^{2}\\\\\u0026=a^{2}+(a-b)^{2}+(b-c)^{2}+c^{2}\\end{aligned}}} $$ 这个矩阵N不是正定矩阵 $$ {\\displaystyle N={\\begin{bmatrix}1\u00262\\\\2\u00261\\end{bmatrix}}} $$ $$ {\\displaystyle {\\begin{bmatrix}-1\u00261\\end{bmatrix}}N{\\begin{bmatrix}-1\u00261\\end{bmatrix}}^{\\textsf {T}}=-2\u003c0} $$ Eigenvalues Type Condition(iff all eigenvalues are) positive definite positive positive semi-definite non-negative negative definite negative negative semi-definite non-positive indefinite both positive and negative ","date":"2022-10-14","objectID":"/matrix-decomposition/:1:2","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Hermitian matrix 共轭转置为自身的方阵叫Hermite矩阵 $$ {\\displaystyle A{\\text{ Hermitian}}\\quad \\iff \\quad a_{ij}={\\overline {{a}_{ji}}}} $$ 或者 $$ {\\displaystyle A{\\text{ Hermitian}}\\quad \\iff \\quad A=A^{\\mathsf {H}}} $$ Hermite矩阵的对角线必须为实数，如下就是一个Hermite矩阵，由此可见对称矩阵一定是Hermite矩阵 $$ {\\displaystyle {\\begin{bmatrix}0\u0026a-ib\u0026c-id\\\\a+ib\u00261\u0026m-in\\\\c+id\u0026m+in\u00262\\end{bmatrix}}} $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:1:3","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Eigenvalues and eigenvectors 此处可以去看3b1b的视频，讲解非常清晰 只有方阵才有特征值和特征向量 方阵的秩不小于它的非零特征值的个数 一个特征值可以有多个特征向量 在实数范围内，可能没有特征值和特征向量，但是在复数范围内，一定有，且有无穷多个特征向量 几何意义是： 方阵可以看作是对空间的一种线性变换，特征向量就是变化后方向保持不变的向量，特征值就是特征向量在变换后放缩的倍率。 行列式是平行四边形包围的面积，如果为负，就类似于平面翻转 ","date":"2022-10-14","objectID":"/matrix-decomposition/:2:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Gram–Schmidt process 施密特正交法用于在欧氏空间中，给定线性无关向量组求标准正交基的过程 给定v，求e $$ {\\displaystyle \\operatorname {proj} _{\\mathbf {u} }(\\mathbf {v} )={\\frac {\\langle \\mathbf {u} ,\\mathbf {v} \\rangle }{\\langle \\mathbf {u} ,\\mathbf {u} \\rangle }}{\\mathbf {u} }} $$ $$ {\\displaystyle {\\begin{aligned}\\mathbf{u} _{1}\u0026=\\mathbf {v} _{1},\u0026\\mathbf {e} _{1}\u0026={\\frac {\\mathbf {u} _{1}}{|\\mathbf {u} _{1}|}}\\\\\\mathbf {u} _{2}\u0026=\\mathbf {v} _{2}-\\operatorname {proj} _{\\mathbf {u} _{1}}(\\mathbf {v} _{2}),\u0026\\mathbf {e} _{2}\u0026={\\frac {\\mathbf {u} _{2}}{|\\mathbf {u} _{2}|}}\\\\\\mathbf {u} _{3}\u0026=\\mathbf {v} _{3}-\\operatorname {proj} _{\\mathbf {u} _{1}}(\\mathbf {v} _{3})-\\operatorname {proj} _{\\mathbf {u} _{2}}(\\mathbf {v} _{3}),\u0026\\mathbf {e} _{3}\u0026={\\frac {\\mathbf {u} _{3}}{|\\mathbf {u} _{3}|}}\\\\\\mathbf {u} _{4}\u0026=\\mathbf {v} _{4}-\\operatorname {proj} _{\\mathbf {u} _{1}}(\\mathbf {v} _{4})-\\operatorname {proj} _{\\mathbf {u} _{2}}(\\mathbf {v} _{4})-\\operatorname {proj} _{\\mathbf {u} _{3}}(\\mathbf {v} _{4}),\u0026\\mathbf {e} _{4}\u0026={\\mathbf {u} _{4} \\over |\\mathbf {u} _{4}|}\\\\\u0026{}\\ \\ \\vdots \u0026\u0026{}\\ \\ \\vdots \\\\\\mathbf {u} _{k}\u0026=\\mathbf {v} _{k}-\\sum _{j=1}^{k-1}\\operatorname {proj} _{\\mathbf {u} _{j}}(\\mathbf {v} _{k}),\u0026\\mathbf {e} _{k}\u0026={\\frac {\\mathbf {u} _{k}}{|\\mathbf {u} _{k}|}}\\end{aligned}}} $$ The modified Gram-Schmidt process being executed on three linearly independent, non-orthogonal vectors of a basis for R3\r","date":"2022-10-14","objectID":"/matrix-decomposition/:3:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Gaussian elimination ","date":"2022-10-14","objectID":"/matrix-decomposition/:4:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Introduction 高斯消元可以用来求线性方程组的解，矩阵的秩，方阵的行列式，可逆矩阵的逆等等。 高斯消元使用初等行变换（elementary row operations），使矩阵有更多的0元素 初等行变换有3种 交换两行 对某一行乘上任意非零数 将某一行的倍数加到另一行（减同理） 高斯消元首先将矩阵变成行阶梯形式（row echelon form），此时可以判断方程无解、有唯一解、无穷多解，然后再变成最简行阶梯形式（reduced row echelon form），此时可以求出具体的解，转化到最简行阶梯矩阵的过程又叫Gauss–Jordan elimination 首项系数（leading coefficients）是每一行的第一个非0数，比如下面红色的数 $$ \\left[\\begin{array}{cccc} 0 \u0026 \\color{red}{2} \u0026 1 \u0026 -1\\\\0 \u0026 0 \u0026 \\color{red}3 \u0026 1\\\\0 \u0026 0 \u0026 0 \u0026 0 \\end{array}\\right] $$ 最简行阶梯形式就是首项系数为1，首项系数所在的每一列，除了它以外全是0 高斯消元的过程如下 $$ \\left[\\begin{array}{cccc} 1 \u0026 3 \u0026 1 \u0026 9 \\\\1 \u0026 1 \u0026 -1 \u0026 1 \\\\3 \u0026 11 \u0026 5 \u0026 35 \\end{array}\\right] \\rightarrow\\left[\\begin{array}{cccc} 1 \u0026 3 \u0026 1 \u0026 9 \\\\0 \u0026 -2 \u0026 -2 \u0026 -8 \\\\0 \u0026 2 \u0026 2 \u0026 8 \\end{array}\\right] \\rightarrow\\left[\\begin{array}{cccc} 1 \u0026 3 \u0026 1 \u0026 9 \\\\0 \u0026 -2 \u0026 -2 \u0026 -8 \\\\0 \u0026 0 \u0026 0 \u0026 0 \\end{array}\\right] \\rightarrow\\left[\\begin{array}{cccc} 1 \u0026 0 \u0026 -2 \u0026 -3 \\\\0 \u0026 1 \u0026 1 \u0026 4 \\\\0 \u0026 0 \u0026 0 \u0026 0 \\end{array}\\right] $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:4:1","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Example 假设要求解的方程组为 $$ {\\displaystyle {\\begin{alignedat}{4}2x\u0026{}+{}\u0026y\u0026{}-{}\u0026z\u0026{}={}\u00268\u0026\\qquad (L_{1})\\\\-3x\u0026{}-{}\u0026y\u0026{}+{}\u00262z\u0026{}={}\u0026-11\u0026\\qquad (L_{2})\\\\-2x\u0026{}+{}\u0026y\u0026{}+{}\u00262z\u0026{}={}\u0026-3\u0026\\qquad (L_{3})\\end{alignedat}}} $$ 高斯消元的过程如下 System of equations Row operations Augmented matrix $${\\displaystyle {\\begin{alignedat}{4}2x\u0026{}+{}\u0026y\u0026{}-{}\u0026z\u0026{}={}\u00268\u0026\\\\-3x\u0026{}-{}\u0026y\u0026{}+{}\u00262z\u0026{}={}\u0026-11\u0026\\\\-2x\u0026{}+{}\u0026y\u0026{}+{}\u00262z\u0026{}={}\u0026-3\u0026\\end{alignedat}}}$$ $${\\displaystyle \\left[{\\begin{array}{rrr|r}2\u00261\u0026-1\u00268\\\\-3\u0026-1\u00262\u0026-11\\\\-2\u00261\u00262\u0026-3\\end{array}}\\right]}$$ $${\\displaystyle {\\begin{alignedat}{4}2x\u0026{}+{}\u0026y\u0026{}-{}\u0026z\u0026{}={}\u00268\u0026\\\\\u0026\u0026{\\tfrac {1}{2}}y\u0026{}+{}\u0026{\\tfrac {1}{2}}z\u0026{}={}\u00261\u0026\\\\\u0026\u00262y\u0026{}+{}\u0026z\u0026{}={}\u00265\u0026\\end{alignedat}}}$$ $${\\displaystyle {\\begin{aligned}L_{2}+{\\tfrac {3}{2}}L_{1}\u0026\\to L_{2}\\\\L_{3}+L_{1}\u0026\\to L_{3}\\end{aligned}}}$$ $${\\displaystyle \\left[{\\begin{array}{rrr|r}2\u00261\u0026-1\u00268\\\\0\u0026{\\frac {1}{2}}\u0026{\\frac {1}{2}}\u00261\\\\0\u00262\u00261\u00265\\end{array}}\\right]}$$ $${\\displaystyle {\\begin{alignedat}{4}2x\u0026{}+{}\u0026y\u0026{}-{}\u0026z\u0026{}={}\u00268\u0026\\\\\u0026\u0026{\\tfrac {1}{2}}y\u0026{}+{}\u0026{\\tfrac {1}{2}}z\u0026{}={}\u00261\u0026\\\\\u0026\u0026\u0026\u0026-z\u0026{}={}\u00261\u0026\\end{alignedat}}}$$ $${\\displaystyle L_{3}+-4L_{2}\\to L_{3}}$$ $${\\displaystyle \\left[{\\begin{array}{rrr|r}2\u00261\u0026-1\u00268\\\\0\u0026{\\frac {1}{2}}\u0026{\\frac {1}{2}}\u00261\\\\0\u00260\u0026-1\u00261\\end{array}}\\right]}$$ $${\\displaystyle {\\begin{alignedat}{4}2x\u0026{}+{}\u0026y\u0026\u0026\u0026{}={}7\u0026\\\\\u0026\u0026{\\tfrac {1}{2}}y\u0026\u0026\u0026{}={}{\\tfrac {3}{2}}\u0026\\\\\u0026\u0026\u0026{}-{}\u0026z\u0026{}={}1\u0026\\end{alignedat}}}$$ $${\\displaystyle {\\begin{aligned}L_{2}+{\\tfrac {1}{2}}L_{3}\u0026\\to L_{2}\\\\L_{1}-L_{3}\u0026\\to L_{1}\\end{aligned}}}$$ $${\\displaystyle \\left[{\\begin{array}{rrr|r}2\u00261\u00260\u00267\\\\0\u0026{\\frac {1}{2}}\u00260\u0026{\\frac {3}{2}}\\\\0\u00260\u0026-1\u00261\\end{array}}\\right]}$$ $${\\displaystyle {\\begin{alignedat}{4}2x\u0026{}+{}\u0026y\u0026\\quad \u0026\u0026{}={}\u00267\u0026\\\\\u0026\u0026y\u0026\\quad \u0026\u0026{}={}\u00263\u0026\\\\\u0026\u0026\u0026\\quad \u0026z\u0026{}={}\u0026-1\u0026\\end{alignedat}}}$$ $${\\displaystyle {\\begin{aligned}2L_{2}\u0026\\to L_{2}\\\\-L_{3}\u0026\\to L_{3}\\end{aligned}}}$$ $${\\displaystyle \\left[{\\begin{array}{rrr|r}2\u00261\u00260\u00267\\\\0\u00261\u00260\u00263\\\\0\u00260\u00261\u0026-1\\end{array}}\\right]}$$ $${\\displaystyle {\\begin{alignedat}{4}x\u0026\\quad \u0026\u0026\\quad \u0026\u0026{}={}\u00262\u0026\\\\\u0026\\quad \u0026y\u0026\\quad \u0026\u0026{}={}\u00263\u0026\\\\\u0026\\quad \u0026\u0026\\quad \u0026z\u0026{}={}\u0026-1\u0026\\end{alignedat}}}$$ $${\\displaystyle {\\begin{aligned}L_{1}-L_{2}\u0026\\to L_{1}\\\\{\\tfrac {1}{2}}L_{1}\u0026\\to L_{1}\\end{aligned}}}$$ $${\\displaystyle \\left[{\\begin{array}{rrr|r}1\u00260\u00260\u00262\\\\0\u00261\u00260\u00263\\\\0\u00260\u00261\u0026-1\\end{array}}\\right]}$$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:4:2","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Applications Computing determinants Finding the inverse of a matrix Computing ranks and bases ","date":"2022-10-14","objectID":"/matrix-decomposition/:4:3","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"LU decomposition ","date":"2022-10-14","objectID":"/matrix-decomposition/:5:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Introduction LU分解是把方阵A分成L乘上U，L是下三角矩阵（lower triangular matrix），U是上三角矩阵（upper triangular matrix） $$ {\\displaystyle A=LU} $$ $$ {\\displaystyle {\\begin{bmatrix}a_{11}\u0026a_{12}\u0026a_{13}\\\\a_{21}\u0026a_{22}\u0026a_{23}\\\\a_{31}\u0026a_{32}\u0026a_{33}\\end{bmatrix}}={\\begin{bmatrix}\\ell {11}\u00260\u00260\\\\\\ell {21}\u0026\\ell {22}\u00260\\\\\\ell {31}\u0026\\ell {32}\u0026\\ell {33}\\end{bmatrix}}{\\begin{bmatrix}u{11}\u0026u{12}\u0026u{13}\\\\0\u0026u{22}\u0026u{23}\\\\0\u00260\u0026u{33}\\end{bmatrix}}} $$ 只有对A进行适当的排列才能分解成功，比如a11=l11*u11，如果a11=0，那么l11和u11必然有一个为0，这样L或者U就是奇异矩阵，那么A不可能非奇异。 有时候我们需要对A进行一定的重排列才可以LU分解 假设P是对A的行重排列，那么就可以这样分解，称为LUP分解 $$ {\\displaystyle PA=LU} $$ 假设Q是对A的列重排列，那么就可以这样分解 $$ {\\displaystyle PAQ=LU} $$ 还可以这样分解，D是对角矩阵，称为LDU分解 $$ {\\displaystyle A=LDU} $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:5:1","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Example 假设要分解这样的矩阵 $$ {\\displaystyle {\\begin{bmatrix}4\u00263\\\\6\u00263\\end{bmatrix}}={\\begin{bmatrix}\\ell _{11}\u00260\\\\\\ell _{21}\u0026\\ell _{22}\\end{bmatrix}}{\\begin{bmatrix}u_{11}\u0026u_{12}\\\\0\u0026u_{22}\\end{bmatrix}}} $$ 一种方法是写成线性方程组 $$ {\\displaystyle {\\begin{aligned}\\ell _{11}\\cdot u_{11}+0\\cdot 0\u0026=4\\\\\\ell _{11}\\cdot u_{12}+0\\cdot u_{22}\u0026=3\\\\\\ell _{21}\\cdot u_{11}+\\ell _{22}\\cdot 0\u0026=6\\\\\\ell _{21}\\cdot u_{12}+\\ell _{22}\\cdot u_{22}\u0026=3\\end{aligned}}} $$ 可以发现这个方程组有无穷多个解，有时候我们可以规定下三角矩阵的对角元为1，这样可以求出 $$ {\\displaystyle {\\begin{aligned}\\ell _{11}=\\ell _{22}\u0026=1\\\\\\ell _{21}\u0026=1.5\\\\u_{11}\u0026=4\\\\u_{12}\u0026=3\\\\u_{22}\u0026=-1.5\\end{aligned}}} $$ $$ {\\displaystyle {\\begin{bmatrix}4\u00263\\\\6\u00263\\end{bmatrix}}={\\begin{bmatrix}1\u00260\\\\1.5\u00261\\end{bmatrix}}{\\begin{bmatrix}4\u00263\\\\0\u0026-1.5\\end{bmatrix}}} $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:5:2","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Existence and uniqueness Square matrices Symmetric positive-definite matrices General matrices ","date":"2022-10-14","objectID":"/matrix-decomposition/:5:3","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Rank factorization 将秩为r的m*n矩阵A，分解成CF，C是m*r的列满秩矩阵，F是r*n的行满秩矩阵 满秩分解可以求Moore-Penrose 伪逆（Moore-Penrose pseudoinverse），就是在方程组无解时，求最接近的解，在方程组无穷多解时求2范数最小的解 任何有限维矩阵都有满秩分解 如果${\\textstyle A=C_{1}F_{1}}$是一个满秩分解，${\\textstyle C_{2}=C_{1}R}$，${\\textstyle F_{2}=R^{-1}F_{1}}$是另一个满秩分解，R是任意兼容维度下的可逆矩阵 ","date":"2022-10-14","objectID":"/matrix-decomposition/:6:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Example 首先求A的最简行阶梯矩阵B，然后将B中每行非0首元（leading coefficient）所在的列在A中消去，产生矩阵C。将B中所有的全0行在B中消去产生矩阵F 考虑如下矩阵 $$ {\\displaystyle A={\\begin{bmatrix}1\u00263\u00261\u00264\\\\2\u00267\u00263\u00269\\\\1\u00265\u00263\u00261\\\\1\u00262\u00260\u00268\\end{bmatrix}}\\sim {\\begin{bmatrix}1\u00260\u0026-2\u00260\\\\0\u00261\u00261\u00260\\\\0\u00260\u00260\u00261\\\\0\u00260\u00260\u00260\\end{bmatrix}}=B{\\text{}}} $$ 将A的第三列取出产生C，将B的最后一行去除产生F $$ {\\displaystyle C={\\begin{bmatrix}1\u00263\u00264\\\\2\u00267\u00269\\\\1\u00265\u00261\\\\1\u00262\u00268\\end{bmatrix}}{\\text{,}}\\qquad F={\\begin{bmatrix}1\u00260\u0026-2\u00260\\\\0\u00261\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}}{\\text{}}} $$ $$ {\\displaystyle A={\\begin{bmatrix}1\u00263\u00261\u00264\\\\2\u00267\u00263\u00269\\\\1\u00265\u00263\u00261\\\\1\u00262\u00260\u00268\\end{bmatrix}}={\\begin{bmatrix}1\u00263\u00264\\\\2\u00267\u00269\\\\1\u00265\u00261\\\\1\u00262\u00268\\end{bmatrix}}{\\begin{bmatrix}1\u00260\u0026-2\u00260\\\\0\u00261\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}}=CF{\\text{}}} $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:6:1","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Cholesky decomposition 一种常见的矩阵分解 适用于方阵，对称矩阵，正定矩阵，Hermite矩阵 Cholesky分解的效率大约是LU分解的两倍 对于Hermite正定矩阵A，它可以被分解成如下形式，其中L是下三角矩阵，且对角元为正实数，L*为L的共轭转置，所有的Hermite正定矩阵（当然包括实对称正定矩阵）都有唯一的Cholesky分解 $$ {\\displaystyle \\mathbf {A} =\\mathbf {LL} ^{*}} $$ 逆命题也成立，即如果一个矩阵能被分解成如上形式，它就是Hermite正定矩阵 特殊地，当A是实对称正定矩阵时，L是下三角矩阵，且对角元为正实数 $$ {\\displaystyle \\mathbf {A} =\\mathbf {LL} ^{\\mathsf {T}}} $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:7:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"LDL decomposition 由于Cholesky分解又叫平方根法，所以LDL分解又叫改进平方根法 分解形式如下，L是单位下三角矩阵（主对角线全为1），D是对角阵 这样分解的好处是避免提取平方根 $$ {\\displaystyle \\mathbf {A} =\\mathbf {LDL} ^{*}} $$ 如何从Cholesky分解转LDL分解？ 假设正定矩阵A被分解成${\\displaystyle \\mathbf {A} =\\mathbf {C} \\mathbf {C} ^{*}}$，如果S是一个对角阵，包含了C的主对角元，那么${\\displaystyle \\mathbf {L} =\\mathbf {C} \\mathbf {S} ^{-1}}$，这样缩放了每一列元素，使对角线为1，${\\displaystyle \\mathbf {D} =\\mathbf {S} ^{2}}$ 如果A是正定矩阵，那么D的对角元都是正的 ","date":"2022-10-14","objectID":"/matrix-decomposition/:7:1","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Example 对一个实对称矩阵做Cholesky分解 $$ \\left(\\begin{array}{rrr} 4 \u0026 12 \u0026 -16 \\\\12 \u0026 37 \u0026 -43 \\\\-16 \u0026 -43 \u0026 98 \\end{array}\\right)=\\left(\\begin{array}{rrr} 2 \u0026 0 \u0026 0 \\\\6 \u0026 1 \u0026 0 \\\\-8 \u0026 5 \u0026 3 \\end{array}\\right)\\left(\\begin{array}{rrr} 2 \u0026 6 \u0026 -8 \\\\0 \u0026 1 \u0026 5 \\\\0 \u0026 0 \u0026 3 \\end{array}\\right) $$ LDL分解 $$ \\left(\\begin{array}{rrr} 4 \u0026 12 \u0026 -16 \\\\12 \u0026 37 \u0026 -43 \\\\-16 \u0026 -43 \u0026 98 \\end{array}\\right)=\\left(\\begin{array}{rrr} 1 \u0026 0 \u0026 0 \\\\3 \u0026 1 \u0026 0 \\\\-4 \u0026 5 \u0026 1 \\end{array}\\right)\\left(\\begin{array}{lll} 4 \u0026 0 \u0026 0 \\\\0 \u0026 1 \u0026 0 \\\\0 \u0026 0 \u0026 9 \\end{array}\\right)\\left(\\begin{array}{rrr} 1 \u0026 3 \u0026 -4 \\\\0 \u0026 1 \u0026 5 \\\\0 \u0026 0 \u0026 1 \\end{array}\\right) $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:7:2","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Computation n维时间复杂度是O(n^3)，Cholesky分解是一个迭代的过程，很适合计算机运算，此处只叙述LDL分解的迭代过程 当A是对称时 $$ {\\displaystyle {\\begin{aligned}\\mathbf {A} =\\mathbf {LDL} ^{\\mathrm {T} }\u0026={\\begin{pmatrix}1\u00260\u00260\\\\L_{21}\u00261\u00260\\\\L_{31}\u0026L_{32}\u00261\\\\\\end{pmatrix}}{\\begin{pmatrix}D_{1}\u00260\u00260\\\\0\u0026D_{2}\u00260\\\\0\u00260\u0026D_{3}\\\\\\end{pmatrix}}{\\begin{pmatrix}1\u0026L_{21}\u0026L_{31}\\\\0\u00261\u0026L_{32}\\\\0\u00260\u00261\\\\\\end{pmatrix}}\\\\[8pt]\u0026={\\begin{pmatrix}D_{1}\u0026\u0026(\\mathrm {symmetric} )\\\\L_{21}D_{1}\u0026L_{21}^{2}D_{1}+D_{2}\u0026\\\\L_{31}D_{1}\u0026L_{31}L_{21}D_{1}+L_{32}D_{2}\u0026L_{31}^{2}D_{1}+L_{32}^{2}D_{2}+D_{3}.\\end{pmatrix}}\\end{aligned}}} $$ 递归以下步骤 $$ {\\displaystyle D_{j}=A_{jj}-\\sum {k=1}^{j-1}L{jk}^{2}D_{k}} $$ $$ {\\displaystyle L_{ij}={\\frac {1}{D_{j}}}\\left(A_{ij}-\\sum {k=1}^{j-1}L{ik}L_{jk}D_{k}\\right)\\quad {\\text{for }}i\u003ej} $$ 只要D的对角元能够一直保持非0，就能产生一个唯一的分解。如果A是实的，D和L也是实的 ","date":"2022-10-14","objectID":"/matrix-decomposition/:7:3","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Applications Linear least squares Non-linear optimization Monte Carlo simulation Kalman filters Matrix inversion ","date":"2022-10-14","objectID":"/matrix-decomposition/:7:4","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"QR decomposition 适用于列线性无关的m*n的矩阵 分解形式，Q是m*m的酉矩阵，R是m*n的上三角矩阵 $$ {\\displaystyle A=QR} $$ 在很多时候，QR分解不唯一。但是如果A是满秩的，R是唯一的，且对角元都为正数，如果A是方阵，Q也是唯一的 QR分解可以很快地计算线性方程组${\\displaystyle A\\mathbf {x} =\\mathbf {b} }$，因为Q是正交的，所以方程组可以化为${\\displaystyle R\\mathbf {x} =Q^{\\mathsf {T}}\\mathbf {b} }$，因为R是上三角矩阵，所以很好计算 接下来在实数空间上讨论 假设A是方阵 $$ {\\displaystyle A=QR} $$ 那么Q是正交矩阵，R是上三角矩阵，如果A是可逆的，且要求R对角元都为正数，则分解是唯一的 如果A是m*n的矩阵，m\u003e=n，分解后Q是酉矩阵（实数下就是正交矩阵），R是上三角矩阵 Q是m*m，R是m*n，R1是n*n，0是(m-n)*n，Q1是m*n，Q2是m*(m-n)，Q1和Q2都有正交列 $$ {\\displaystyle A=QR=Q{\\begin{bmatrix}R_{1}\\\\0\\end{bmatrix}}={\\begin{bmatrix}Q_{1}\u0026Q_{2}\\end{bmatrix}}{\\begin{bmatrix}R_{1}\\\\0\\end{bmatrix}}=Q_{1}R_{1}} $$ 如果A是满秩（秩为n），且要求R1的对角元全为正数，则Q1和R1都是唯一的，但是一般Q2不是，R1是A*A（A是实的话就是A^TA）的Cholesky分解的上三角部分 ","date":"2022-10-14","objectID":"/matrix-decomposition/:8:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Computing the QR decomposition 有很多种方法计算QR分解 Gram–Schmidt process 对于列满秩矩阵${\\displaystyle A={\\begin{bmatrix}\\mathbf {a} _{1}\u0026\\cdots \u0026\\mathbf {a} _{n}\\end{bmatrix}}}$，定义向量v和w的内积${\\displaystyle \\langle \\mathbf {v} ,\\mathbf {w} \\rangle =\\mathbf {v} ^{\\textsf {T}}\\mathbf {w} }$，定义投影${\\displaystyle \\operatorname {proj} _{\\mathbf {u} }\\mathbf {a} ={\\frac {\\left\\langle \\mathbf {u} ,\\mathbf {a} \\right\\rangle }{\\left\\langle \\mathbf {u} ,\\mathbf {u} \\right\\rangle }}{\\mathbf {u} }}$ 施密特正交化过程为 $$ {\\displaystyle {\\begin{aligned}\\mathbf {u} _{1}\u0026=\\mathbf {a} _{1},\u0026\\mathbf {e} _{1}\u0026={\\frac {\\mathbf {u} _{1}}{\\|\\mathbf {u} _{1}\\|}}\\\\\\mathbf {u} _{2}\u0026=\\mathbf {a} _{2}-\\operatorname {proj} _{\\mathbf {u} _{1}}\\mathbf {a} _{2},\u0026\\mathbf {e} _{2}\u0026={\\frac {\\mathbf {u} _{2}}{\\|\\mathbf {u} _{2}\\|}}\\\\\\mathbf {u} _{3}\u0026=\\mathbf {a} _{3}-\\operatorname {proj} _{\\mathbf {u} _{1}}\\mathbf {a} _{3}-\\operatorname {proj} _{\\mathbf {u} _{2}}\\mathbf {a} _{3},\u0026\\mathbf {e} _{3}\u0026={\\frac {\\mathbf {u} _{3}}{\\|\\mathbf {u} _{3}\\|}}\\\\\u0026\\;\\;\\vdots \u0026\u0026\\;\\;\\vdots \\\\\\mathbf {u} _{k}\u0026=\\mathbf {a} _{k}-\\sum _{j=1}^{k-1}\\operatorname {proj} _{\\mathbf {u} _{j}}\\mathbf {a} _{k},\u0026\\mathbf {e} _{k}\u0026={\\frac {\\mathbf {u} _{k}}{\\|\\mathbf {u} _{k}\\|}}\\end{aligned}}} $$ 在此基础上，求A的各列向量 $$ {\\displaystyle {\\begin{aligned}\\mathbf {a} _{1}\u0026=\\left\\langle \\mathbf {e} _{1},\\mathbf {a} _{1}\\right\\rangle \\mathbf {e} _{1}\\\\\\mathbf {a} _{2}\u0026=\\left\\langle \\mathbf {e} _{1},\\mathbf {a} _{2}\\right\\rangle \\mathbf {e} _{1}+\\left\\langle \\mathbf {e} _{2},\\mathbf {a} _{2}\\right\\rangle \\mathbf {e} _{2}\\\\\\mathbf {a} _{3}\u0026=\\left\\langle \\mathbf {e} _{1},\\mathbf {a} _{3}\\right\\rangle \\mathbf {e} _{1}+\\left\\langle \\mathbf {e} _{2},\\mathbf {a} _{3}\\right\\rangle \\mathbf {e} _{2}+\\left\\langle \\mathbf {e} _{3},\\mathbf {a} _{3}\\right\\rangle \\mathbf {e} _{3}\\\\\u0026\\;\\;\\vdots \\\\\\mathbf {a} _{k}\u0026=\\sum _{j=1}^{k}\\left\\langle \\mathbf {e} _{j},\\mathbf {a} _{k}\\right\\rangle \\mathbf {e} _{j}\\end{aligned}}} $$ 其中${\\displaystyle \\left\\langle \\mathbf {e} _{i},\\mathbf {a} _{i}\\right\\rangle =\\left\\|\\mathbf {u} _{i}\\right\\|}$ 那么Q和R可以写成如下形式 $$ {\\displaystyle Q={\\begin{bmatrix}\\mathbf {e} _{1}\u0026\\cdots \u0026\\mathbf {e} _{n}\\end{bmatrix}}} $$ $$ {\\displaystyle R={\\begin{bmatrix}\\langle \\mathbf {e} _{1},\\mathbf {a} _{1}\\rangle \u0026\\langle \\mathbf {e} _{1},\\mathbf {a} _{2}\\rangle \u0026\\langle \\mathbf {e} _{1},\\mathbf {a} _{3}\\rangle \u0026\\cdots \u0026\\langle \\mathbf {e} _{1},\\mathbf {a} _{n}\\rangle \\\\0\u0026\\langle \\mathbf {e} _{2},\\mathbf {a} _{2}\\rangle \u0026\\langle \\mathbf {e} _{2},\\mathbf {a} _{3}\\rangle \u0026\\cdots \u0026\\langle \\mathbf {e} _{2},\\mathbf {a} _{n}\\rangle \\\\0\u00260\u0026\\langle \\mathbf {e} _{3},\\mathbf {a} _{3}\\rangle \u0026\\cdots \u0026\\langle \\mathbf {e} _{3},\\mathbf {a} _{n}\\rangle \\\\\\vdots \u0026\\vdots \u0026\\vdots \u0026\\ddots \u0026\\vdots \\\\0\u00260\u00260\u0026\\cdots \u0026\\langle \\mathbf {e} _{n},\\mathbf {a} _{n}\\rangle \\\\\\end{bmatrix}}} $$ Example 考虑如下矩阵 $$ {\\displaystyle A={\\begin{bmatrix}12\u0026-51\u00264\\\\6\u0026167\u0026-68\\\\-4\u002624\u0026-41\\end{bmatrix}}} $$ 用施密特正交法可以计算出 $$ {\\displaystyle {\\begin{aligned}U={\\begin{bmatrix}\\mathbf {u} _{1}\u0026\\mathbf {u} _{2}\u0026\\mathbf {u} _{3}\\end{bmatrix}}\u0026={\\begin{bmatrix}12\u0026-69\u0026-58/5\\\\6\u0026158\u00266/5\\\\-4\u002630\u0026-33\\end{bmatrix}}\\\\Q={\\begin{bmatrix}{\\frac {\\mathbf {u} _{1}}{\\|\\mathbf {u} _{1}\\|}}\u0026{\\frac {\\mathbf {u} _{2}}{\\|\\mathbf {u} _{2}\\|}}\u0026{\\frac {\\mathbf {u} _{3}}{\\|\\mathbf {u} _{3}\\|}}\\end{bmatrix}}\u0026={\\begin{bmatrix}6/7\u0026-69/175\u0026-58/175\\\\3/7\u0026158/175\u00266/175\\\\-2/7\u00266/35\u0026-33/35\\end{bmatrix}}\\end{aligned}}} $$ $$ {\\displaystyle {\\begin{aligned}Q^{\\textsf {T}}A\u0026=Q^{\\textsf {T}}Q\\,R=R\\\\R\u0026=Q^{\\textsf {T}}A={\\begin{bmatrix}14\u002621\u0026-14\\\\0\u0026175\u0026-70\\\\0\u00260\u002635\\end{bmatrix}}\\end{aligned}}} $$ RQ分解就是把列看成行 Householder reflections ","date":"2022-10-14","objectID":"/matrix-decomposition/:8:1","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Connection to a determinant or a product of eigenvalues $$ {\\displaystyle \\det A=\\det Q\\det R} $$ 当Q的行列式为1时，rii是主对角元，也是特征值 $$ {\\displaystyle \\det A=\\det R=\\prod _{i}r_{ii}} $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:8:2","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Singular value decomposition 适用于m*n的矩阵，分解形式 $$ {\\displaystyle A=UDV^{*}} $$ D是非负的对角阵，U和V是酉矩阵（实数上就是正交矩阵） D的对角元称为A的奇异值 A的奇异值是唯一的，U和V不一定唯一 在有些地方把奇异值分解的形式写成 $$ {\\displaystyle \\ \\mathbf {M} =\\mathbf {U\\Sigma V^{*}} \\ } $$ 其中，矩阵的大小为 Visualization of the matrix multiplications in singular value decomposition\r奇异值分解的几何意义是 对于M在空间上所做的变换，U将空间进行旋转，Σ将空间进行缩放，V*再将空间进行旋转，Σ的对角元就是缩放的比例 如果M的行列式是正的，那么U，V*可以都带反射（reflection）（就是将一张纸翻过来），或者都不带反射，如果M的行列式是负的，那么U或V*带反射 如果M不是方阵，假设是m*n的，几何意义可以看作是n维空间到m维空间的变换，U和V*分别作用于m维和n维空间，Σ除了对min(m,n)维空间进行缩放后，在其他维度要补0，以便后续的计算 Illustration\rAnimated illustration of the SVD of a 2D, real shearing matrix M. First, we see the unit disc in blue together with the two canonical unit vectors. We then see the actions of M, which distorts the disk to an ellipse. The SVD decomposes M into three simple transformations: an initial rotation V⁎, a scaling {\\displaystyle \\mathbf {\\Sigma } }\\mathbf{\\Sigma} along the coordinate axes, and a final rotation U. The lengths σ1 and σ2 of the semi-axes of the ellipse are the singular values of M, namely Σ1,1 and Σ2,2.\r","date":"2022-10-14","objectID":"/matrix-decomposition/:9:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Example $$ \\mathbf {M} ={\\begin{bmatrix}1\u00260\u00260\u00260\u00262\\\\0\u00260\u00263\u00260\u00260\\\\0\u00260\u00260\u00260\u00260\\\\0\u00262\u00260\u00260\u00260\\end{bmatrix}} $$ $$ {\\displaystyle {\\begin{aligned}\\mathbf {U} \u0026={\\begin{bmatrix}\\color {Green}0\u0026\\color {Blue}-1\u0026\\color {Cyan}0\u0026\\color {Emerald}0\\\\\\color {Green}-1\u0026\\color {Blue}0\u0026\\color {Cyan}0\u0026\\color {Emerald}0\\\\\\color {Green}0\u0026\\color {Blue}0\u0026\\color {Cyan}0\u0026\\color {Emerald}-1\\\\\\color {Green}0\u0026\\color {Blue}0\u0026\\color {Cyan}-1\u0026\\color {Emerald}0\\end{bmatrix}}\\\\[6pt]{\\boldsymbol {\\Sigma }}\u0026={\\begin{bmatrix}3\u00260\u00260\u00260\u0026\\color {Gray}{\\mathit {0}}\\\\0\u0026{\\sqrt {5}}\u00260\u00260\u0026\\color {Gray}{\\mathit {0}}\\\\0\u00260\u00262\u00260\u0026\\color {Gray}{\\mathit {0}}\\\\0\u00260\u00260\u0026\\color {Red}\\mathbf {0} \u0026\\color {Gray}{\\mathit {0}}\\end{bmatrix}}\\\\[6pt]\\mathbf {V} ^{*}\u0026={\\begin{bmatrix}\\color {Violet}0\u0026\\color {Violet}0\u0026\\color {Violet}-1\u0026\\color {Violet}0\u0026\\color {Violet}0\\\\\\color {Plum}-{\\sqrt {0.2}}\u0026\\color {Plum}0\u0026\\color {Plum}0\u0026\\color {Plum}0\u0026\\color {Plum}-{\\sqrt {0.8}}\\\\\\color {Magenta}0\u0026\\color {Magenta}-1\u0026\\color {Magenta}0\u0026\\color {Magenta}0\u0026\\color {Magenta}0\\\\\\color {Orchid}0\u0026\\color {Orchid}0\u0026\\color {Orchid}0\u0026\\color {Orchid}1\u0026\\color {Orchid}0\\\\\\color {Purple}-{\\sqrt {0.8}}\u0026\\color {Purple}0\u0026\\color {Purple}0\u0026\\color {Purple}0\u0026\\color {Purple}{\\sqrt {0.2}}\\end{bmatrix}}\\end{aligned}}} $$ 另一个V* $$ {\\displaystyle \\mathbf {V} ^{*}={\\begin{bmatrix}\\color {Violet}0\u0026\\color {Violet}1\u0026\\color {Violet}0\u0026\\color {Violet}0\u0026\\color {Violet}0\\\\\\color {Plum}0\u0026\\color {Plum}0\u0026\\color {Plum}1\u0026\\color {Plum}0\u0026\\color {Plum}0\\\\\\color {Magenta}{\\sqrt {0.2}}\u0026\\color {Magenta}0\u0026\\color {Magenta}0\u0026\\color {Magenta}0\u0026\\color {Magenta}{\\sqrt {0.8}}\\\\\\color {Orchid}{\\sqrt {0.4}}\u0026\\color {Orchid}0\u0026\\color {Orchid}0\u0026\\color {Orchid}{\\sqrt {0.5}}\u0026\\color {Orchid}-{\\sqrt {0.1}}\\\\\\color {Purple}-{\\sqrt {0.4}}\u0026\\color {Purple}0\u0026\\color {Purple}0\u0026\\color {Purple}{\\sqrt {0.5}}\u0026\\color {Purple}{\\sqrt {0.1}}\\end{bmatrix}}} $$ SVD分解的过程参考此处 ","date":"2022-10-14","objectID":"/matrix-decomposition/:9:1","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Schur complement 舒尔补的作用是将p+q维矩阵的求逆变成p维和q维矩阵的求逆，降低运算时间 SLAM和舒尔补 假设A、B、C、D矩阵为 p × p, p × q, q × p, q × q $$ {\\displaystyle M=\\left[{\\begin{matrix}A\u0026B\\\\C\u0026D\\end{matrix}}\\right]} $$ 假设D是可逆的（即非奇异），则D在M中的舒尔补为 $$ {\\displaystyle M/D:=A-BD^{-1}C} $$ 假设A是可逆的，则A在M中的舒尔补为 $$ {\\displaystyle M/A:=D-CA^{-1}B} $$ 舒尔补在高斯消元中有用到，为了使M变成上三角矩阵，可以右乘一个下三角矩阵 $$ {\\displaystyle {\\begin{aligned}\u0026M={\\begin{bmatrix}A\u0026B\\\\C\u0026D\\end{bmatrix}}\\quad \\to \\quad {\\begin{bmatrix}A\u0026B\\\\C\u0026D\\end{bmatrix}}{\\begin{bmatrix}I_{p}\u00260\\\\-D^{-1}C\u0026I_{q}\\end{bmatrix}}={\\begin{bmatrix}A-BD^{-1}C\u0026B\\\\0\u0026D\\end{bmatrix}}\\end{aligned}}} $$ Ip是p阶单位阵，可以发现最后矩阵的左上角出现了D在M中的舒尔补 将这个结果左乘一个矩阵后转化为对角阵 $$ {\\displaystyle {\\begin{aligned}\u0026{\\begin{bmatrix}A-BD^{-1}C\u0026B\\\\0\u0026D\\end{bmatrix}}\\quad \\to \\quad {\\begin{bmatrix}I_{p}\u0026-BD^{-1}\\\\0\u0026I_{q}\\end{bmatrix}}{\\begin{bmatrix}A-BD^{-1}C\u0026B\\\\0\u0026D\\end{bmatrix}}={\\begin{bmatrix}A-BD^{-1}C\u00260\\\\0\u0026D\\end{bmatrix}}\\end{aligned}}} $$ 由此可以引导出M的LDU分解 $$ {\\displaystyle {\\begin{aligned}M\u0026={\\begin{bmatrix}A\u0026B\\\\C\u0026D\\end{bmatrix}}={\\begin{bmatrix}I_{p}\u0026BD^{-1}\\\\0\u0026I_{q}\\end{bmatrix}}{\\begin{bmatrix}A-BD^{-1}C\u00260\\\\0\u0026D\\end{bmatrix}}{\\begin{bmatrix}I_{p}\u00260\\\\D^{-1}C\u0026I_{q}\\end{bmatrix}}\\end{aligned}}} $$ 所以M的逆可以由D的逆和舒尔补的逆组成 $$ {\\displaystyle {\\begin{aligned}M^{-1}={\\begin{bmatrix}A\u0026B\\\\C\u0026D\\end{bmatrix}}^{-1}={}\u0026\\left({\\begin{bmatrix}I_{p}\u0026BD^{-1}\\\\0\u0026I_{q}\\end{bmatrix}}{\\begin{bmatrix}A-BD^{-1}C\u00260\\\\0\u0026D\\end{bmatrix}}{\\begin{bmatrix}I_{p}\u00260\\\\D^{-1}C\u0026I_{q}\\end{bmatrix}}\\right)^{-1}\\\\={}\u0026{\\begin{bmatrix}I_{p}\u00260\\\\-D^{-1}C\u0026I_{q}\\end{bmatrix}}{\\begin{bmatrix}\\left(A-BD^{-1}C\\right)^{-1}\u00260\\\\0\u0026D^{-1}\\end{bmatrix}}{\\begin{bmatrix}I_{p}\u0026-BD^{-1}\\\\0\u0026I_{q}\\end{bmatrix}}\\\\[4pt]={}\u0026{\\begin{bmatrix}\\left(A-BD^{-1}C\\right)^{-1}\u0026-\\left(A-BD^{-1}C\\right)^{-1}BD^{-1}\\\\-D^{-1}C\\left(A-BD^{-1}C\\right)^{-1}\u0026D^{-1}+D^{-1}C\\left(A-BD^{-1}C\\right)^{-1}BD^{-1}\\end{bmatrix}}\\\\[4pt]={}\u0026{\\begin{bmatrix}\\left(M/D\\right)^{-1}\u0026-\\left(M/D\\right)^{-1}BD^{-1}\\\\-D^{-1}C\\left(M/D\\right)^{-1}\u0026D^{-1}+D^{-1}C\\left(M/D\\right)^{-1}BD^{-1}\\end{bmatrix}}\\end{aligned}}} $$ 这是一种形式，可以交换A和D来推导出另一种形式 ","date":"2022-10-14","objectID":"/matrix-decomposition/:10:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Properties 假设p和q都是1，AD-BC不为0 $$ M^{{-1}}={\\frac {1}{AD-BC}}\\left[{\\begin{matrix}D\u0026-B\\\\-C\u0026A\\end{matrix}}\\right] $$ 当A是可逆的，那么 $$ {\\displaystyle {\\begin{aligned}M\u0026={\\begin{bmatrix}A\u0026B\\\\C\u0026D\\end{bmatrix}}={\\begin{bmatrix}I_{p}\u00260\\\\CA^{-1}\u0026I_{q}\\end{bmatrix}}{\\begin{bmatrix}A\u00260\\\\0\u0026D-CA^{-1}B\\end{bmatrix}}{\\begin{bmatrix}I_{p}\u0026A^{-1}B\\\\0\u0026I_{q}\\end{bmatrix}},\\\\[4pt]M^{-1}\u0026={\\begin{bmatrix}A^{-1}+A^{-1}B(M/A)^{-1}CA^{-1}\u0026-A^{-1}B(M/A)^{-1}\\\\-(M/A)^{-1}CA^{-1}\u0026(M/A)^{-1}\\end{bmatrix}}\\end{aligned}}} $$ 当A（D）是可逆的，则 $$ {\\displaystyle \\det(M)=\\det(A)\\det \\left(D-CA^{-1}B\\right)}\\\\{\\displaystyle \\det(M)=\\det(D)\\det \\left(A-BD^{-1}C\\right)} $$ 当D是可逆的，则 $$ {\\displaystyle \\operatorname {rank} (M)=\\operatorname {rank} (D)+\\operatorname {rank} \\left(A-BD^{-1}C\\right)} $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:10:1","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Application to solving linear equations 假设要解这样的线性方程 $$ {\\displaystyle {\\begin{bmatrix}A\u0026B\\\\C\u0026D\\end{bmatrix}}{\\begin{bmatrix}x\\\\y\\end{bmatrix}}={\\begin{bmatrix}u\\\\v\\end{bmatrix}}} $$ 假设A是可逆的，可以得到 $$ {\\displaystyle x=A^{-1}(u-By)} $$ 将上式代入可以得到 $$ {\\displaystyle \\left(D-CA^{-1}B\\right)y=v-CA^{-1}u} $$ 定义A的舒尔补 $$ {\\displaystyle S\\ {\\overset {\\underset {\\mathrm {def} }{}}{=}}\\ D-CA^{-1}B} $$ x和y可以变成 $$ {\\displaystyle y=S^{-1}\\left(v-CA^{-1}u\\right)} $$ $$ {\\displaystyle x=\\left(A^{-1}+A^{-1}BS^{-1}CA^{-1}\\right)u-A^{-1}BS^{-1}v} $$ 可以写成如下形式 $$ {\\displaystyle {\\begin{bmatrix}x\\\\y\\end{bmatrix}}={\\begin{bmatrix}A^{-1}+A^{-1}BS^{-1}CA^{-1}\u0026-A^{-1}BS^{-1}\\\\-S^{-1}CA^{-1}\u0026S^{-1}\\end{bmatrix}}{\\begin{bmatrix}u\\\\v\\end{bmatrix}}} $$ 大矩阵的逆可以分解成小矩阵的逆 $$ {\\displaystyle {\\begin{bmatrix}A\u0026B\\\\C\u0026D\\end{bmatrix}}^{-1}={\\begin{bmatrix}A^{-1}+A^{-1}BS^{-1}CA^{-1}\u0026-A^{-1}BS^{-1}\\\\-S^{-1}CA^{-1}\u0026S^{-1}\\end{bmatrix}}={\\begin{bmatrix}I_{p}\u0026-A^{-1}B\\\\\u0026I_{q}\\end{bmatrix}}{\\begin{bmatrix}A^{-1}\u0026\\\\\u0026S^{-1}\\end{bmatrix}}{\\begin{bmatrix}I_{p}\u0026\\\\-CA^{-1}\u0026I_{q}\\end{bmatrix}}} $$ ","date":"2022-10-14","objectID":"/matrix-decomposition/:10:2","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Something confusing 矩阵左乘一个行向量的几何意义 ","date":"2022-10-14","objectID":"/matrix-decomposition/:11:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Reference 无水印的图来自wikipedia ","date":"2022-10-14","objectID":"/matrix-decomposition/:12:0","tags":["math"],"title":"Matrix Decomposition","uri":"/matrix-decomposition/"},{"categories":["note"],"content":"Pandas","date":"2022-10-09","objectID":"/pandas/","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":" pandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language. 参考 import numpy as np import pandas as pd ","date":"2022-10-09","objectID":"/pandas/:0:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Object creation Series是一维数据 s = pd.Series([1, 3, 5, np.nan, 6, 8]) s 0 1.0\r1 3.0\r2 5.0\r3 NaN\r4 6.0\r5 8.0\rdtype: float64\rDataFrame是一张表格 dates = pd.date_range(\"20130101\", periods=6) dates DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\r'2013-01-05', '2013-01-06'],\rdtype='datetime64[ns]', freq='D')\rdf = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list(\"ABCD\")) df A\rB\rC\rD\r2013-01-01\r1.672611\r1.010890\r1.873754\r1.026126\r2013-01-02\r1.099263\r0.330668\r-1.858497\r-1.445272\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r-0.661282\r2013-01-04\r-0.667948\r0.947373\r0.011333\r-0.303310\r2013-01-05\r1.412637\r-1.539891\r-0.789662\r1.382914\r2013-01-06\r-1.925618\r-0.395157\r0.215027\r0.800317\r通过传递字典来构造DataFrame df2 = pd.DataFrame( { \"A\": 1.0, \"B\": pd.Timestamp(\"20130102\"), \"C\": pd.Series(1, index=list(range(4)), dtype=\"float32\"), \"D\": np.array([3] * 4, dtype=\"int32\"), \"E\": pd.Categorical([\"test\", \"train\", \"test\", \"train\"]), \"F\": \"foo\", } ) df2 A\rB\rC\rD\rE\rF\r0\r1.0\r2013-01-02\r1.0\r3\rtest\rfoo\r1\r1.0\r2013-01-02\r1.0\r3\rtrain\rfoo\r2\r1.0\r2013-01-02\r1.0\r3\rtest\rfoo\r3\r1.0\r2013-01-02\r1.0\r3\rtrain\rfoo\rDataFrames每一列可以有不同的值 df2.dtypes A float64\rB datetime64[ns]\rC float32\rD int32\rE category\rF object\rdtype: object\r","date":"2022-10-09","objectID":"/pandas/:1:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Viewing data 使用DataFrame.head()和DataFrame.tail()来查看前几行和后几行，如果不指定参数则除了第一行（或者最后一行）都显示 df.head() A\rB\rC\rD\r2013-01-01\r1.672611\r1.010890\r1.873754\r1.026126\r2013-01-02\r1.099263\r0.330668\r-1.858497\r-1.445272\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r-0.661282\r2013-01-04\r-0.667948\r0.947373\r0.011333\r-0.303310\r2013-01-05\r1.412637\r-1.539891\r-0.789662\r1.382914\rdf.tail(3) A\rB\rC\rD\r2013-01-04\r-0.667948\r0.947373\r0.011333\r-0.303310\r2013-01-05\r1.412637\r-1.539891\r-0.789662\r1.382914\r2013-01-06\r-1.925618\r-0.395157\r0.215027\r0.800317\r使用DataFrame.index 和 DataFrame.columns来获取行表头和列表头 df.index DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\r'2013-01-05', '2013-01-06'],\rdtype='datetime64[ns]', freq='D')\rdf.columns Index(['A', 'B', 'C', 'D'], dtype='object')\r使用DataFrame.to_numpy()可以将DataFrame转换成numpy，这将有很大的开销，因为DataFrame允许每一列的类型不一样，numpy不行 df.to_numpy() array([[ 1.67261051, 1.01088994, 1.8737536 , 1.02612614],\r[ 1.09926258, 0.33066777, -1.85849732, -1.44527193],\r[-0.83363676, 1.41695768, -0.52526275, -0.66128225],\r[-0.66794837, 0.94737275, 0.01133288, -0.30331012],\r[ 1.41263728, -1.53989118, -0.78966244, 1.38291399],\r[-1.92561833, -0.39515657, 0.21502717, 0.80031675]])\rdf2.to_numpy() array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],\r[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],\r[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],\r[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']],\rdtype=object)\r注意，转化成numpy后将不再包含行列表头信息 describe()可以显示一些基本的统计信息 df.describe() A\rB\rC\rD\rcount\r6.000000\r6.000000\r6.000000\r6.000000\rmean\r0.126218\r0.295140\r-0.178885\r0.133249\rstd\r1.466634\r1.099208\r1.242481\r1.106116\rmin\r-1.925618\r-1.539891\r-1.858497\r-1.445272\r25%\r-0.792215\r-0.213700\r-0.723563\r-0.571789\r50%\r0.215657\r0.639020\r-0.256965\r0.248503\r75%\r1.334294\r0.995011\r0.164104\r0.969674\rmax\r1.672611\r1.416958\r1.873754\r1.382914\r转置 df.T 2013-01-01\r2013-01-02\r2013-01-03\r2013-01-04\r2013-01-05\r2013-01-06\rA\r1.672611\r1.099263\r-0.833637\r-0.667948\r1.412637\r-1.925618\rB\r1.010890\r0.330668\r1.416958\r0.947373\r-1.539891\r-0.395157\rC\r1.873754\r-1.858497\r-0.525263\r0.011333\r-0.789662\r0.215027\rD\r1.026126\r-1.445272\r-0.661282\r-0.303310\r1.382914\r0.800317\rDataFrame.sort_index()按某个轴的表头排序 df.sort_index(axis=1, ascending=False) D\rC\rB\rA\r2013-01-01\r1.026126\r1.873754\r1.010890\r1.672611\r2013-01-02\r-1.445272\r-1.858497\r0.330668\r1.099263\r2013-01-03\r-0.661282\r-0.525263\r1.416958\r-0.833637\r2013-01-04\r-0.303310\r0.011333\r0.947373\r-0.667948\r2013-01-05\r1.382914\r-0.789662\r-1.539891\r1.412637\r2013-01-06\r0.800317\r0.215027\r-0.395157\r-1.925618\rDataFrame.sort_values()按某一行（列）排序 df.sort_values(by=\"B\") A\rB\rC\rD\r2013-01-05\r1.412637\r-1.539891\r-0.789662\r1.382914\r2013-01-06\r-1.925618\r-0.395157\r0.215027\r0.800317\r2013-01-02\r1.099263\r0.330668\r-1.858497\r-1.445272\r2013-01-04\r-0.667948\r0.947373\r0.011333\r-0.303310\r2013-01-01\r1.672611\r1.010890\r1.873754\r1.026126\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r-0.661282\r","date":"2022-10-09","objectID":"/pandas/:2:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Selection ","date":"2022-10-09","objectID":"/pandas/:3:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Getting 选择一个列 df[\"A\"] 2013-01-01 1.672611\r2013-01-02 1.099263\r2013-01-03 -0.833637\r2013-01-04 -0.667948\r2013-01-05 1.412637\r2013-01-06 -1.925618\rFreq: D, Name: A, dtype: float64\r使用切片的方式选择行 df[0:3] A\rB\rC\rD\r2013-01-01\r1.672611\r1.010890\r1.873754\r1.026126\r2013-01-02\r1.099263\r0.330668\r-1.858497\r-1.445272\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r-0.661282\rdf[\"20130102\":\"20130104\"] A\rB\rC\rD\r2013-01-02\r1.099263\r0.330668\r-1.858497\r-1.445272\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r-0.661282\r2013-01-04\r-0.667948\r0.947373\r0.011333\r-0.303310\r","date":"2022-10-09","objectID":"/pandas/:3:1","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Selection by label 获取某一行 df.loc[dates[0]] A 1.672611\rB 1.010890\rC 1.873754\rD 1.026126\rName: 2013-01-01 00:00:00, dtype: float64\r通过标签选择一片区域 df.loc[:, [\"A\", \"B\"]] A\rB\r2013-01-01\r1.672611\r1.010890\r2013-01-02\r1.099263\r0.330668\r2013-01-03\r-0.833637\r1.416958\r2013-01-04\r-0.667948\r0.947373\r2013-01-05\r1.412637\r-1.539891\r2013-01-06\r-1.925618\r-0.395157\rdf.loc[\"20130102\":\"20130104\", [\"A\", \"B\"]] A\rB\r2013-01-02\r1.099263\r0.330668\r2013-01-03\r-0.833637\r1.416958\r2013-01-04\r-0.667948\r0.947373\rdf.loc[\"20130102\", [\"A\", \"B\"]] A 1.099263\rB 0.330668\rName: 2013-01-02 00:00:00, dtype: float64\rdf.loc[dates[0], \"A\"] 1.6726105100658228\rdf.at[dates[0], \"A\"] 1.6726105100658228\r","date":"2022-10-09","objectID":"/pandas/:3:2","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Selection by position 通过传入的参数选择某一行 df.iloc[3] A -0.667948\rB 0.947373\rC 0.011333\rD -0.303310\rName: 2013-01-04 00:00:00, dtype: float64\r通过传入的参数切片 df.iloc[3:5, 0:2] A\rB\r2013-01-04\r-0.667948\r0.947373\r2013-01-05\r1.412637\r-1.539891\r通过列表选择行和列 df.iloc[[1, 2, 4], [0, 2]] A\rC\r2013-01-02\r1.099263\r-1.858497\r2013-01-03\r-0.833637\r-0.525263\r2013-01-05\r1.412637\r-0.789662\r对行直接切片 df.iloc[1:3, :] A\rB\rC\rD\r2013-01-02\r1.099263\r0.330668\r-1.858497\r-1.445272\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r-0.661282\r对列直接切片 df.iloc[:, 1:3] B\rC\r2013-01-01\r1.010890\r1.873754\r2013-01-02\r0.330668\r-1.858497\r2013-01-03\r1.416958\r-0.525263\r2013-01-04\r0.947373\r0.011333\r2013-01-05\r-1.539891\r-0.789662\r2013-01-06\r-0.395157\r0.215027\r直接获得某个值 df.iloc[1, 1] 0.33066776522090735\rdf.iat[1, 1] 0.33066776522090735\r","date":"2022-10-09","objectID":"/pandas/:3:3","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Boolean indexing 使用单个列的值来选择 df[df[\"A\"] \u003e 0] A\rB\rC\rD\r2013-01-01\r1.672611\r1.010890\r1.873754\r1.026126\r2013-01-02\r1.099263\r0.330668\r-1.858497\r-1.445272\r2013-01-05\r1.412637\r-1.539891\r-0.789662\r1.382914\r从DataFrame中选择 df[df \u003e 0] A\rB\rC\rD\r2013-01-01\r1.672611\r1.010890\r1.873754\r1.026126\r2013-01-02\r1.099263\r0.330668\rNaN\rNaN\r2013-01-03\rNaN\r1.416958\rNaN\rNaN\r2013-01-04\rNaN\r0.947373\r0.011333\rNaN\r2013-01-05\r1.412637\rNaN\rNaN\r1.382914\r2013-01-06\rNaN\rNaN\r0.215027\r0.800317\r使用isin()来过滤 df2 = df.copy() df2[\"E\"] = [\"one\", \"one\", \"two\", \"three\", \"four\", \"three\"] df2 A\rB\rC\rD\rE\r2013-01-01\r1.672611\r1.010890\r1.873754\r1.026126\rone\r2013-01-02\r1.099263\r0.330668\r-1.858497\r-1.445272\rone\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r-0.661282\rtwo\r2013-01-04\r-0.667948\r0.947373\r0.011333\r-0.303310\rthree\r2013-01-05\r1.412637\r-1.539891\r-0.789662\r1.382914\rfour\r2013-01-06\r-1.925618\r-0.395157\r0.215027\r0.800317\rthree\rdf2[df2[\"E\"].isin([\"two\", \"four\"])] A\rB\rC\rD\rE\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r-0.661282\rtwo\r2013-01-05\r1.412637\r-1.539891\r-0.789662\r1.382914\rfour\r","date":"2022-10-09","objectID":"/pandas/:3:4","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Setting 设置新列将自动按索引对齐数据 s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range(\"20130102\", periods=6)) s1 2013-01-02 1\r2013-01-03 2\r2013-01-04 3\r2013-01-05 4\r2013-01-06 5\r2013-01-07 6\rFreq: D, dtype: int64\r通过label来设置值 df.at[dates[0], \"A\"] = 0 通过位置来设置值 df.iat[0, 1] = 0 df A\rB\rC\rD\r2013-01-01\r0.000000\r0.000000\r1.873754\r5\r2013-01-02\r1.099263\r0.330668\r-1.858497\r5\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r5\r2013-01-04\r-0.667948\r0.947373\r0.011333\r5\r2013-01-05\r1.412637\r-1.539891\r-0.789662\r5\r2013-01-06\r-1.925618\r-0.395157\r0.215027\r5\r使用where设置值 df2 = df.copy() df2[df2 \u003e 0] = -df2 df2 A\rB\rC\rD\r2013-01-01\r0.000000\r0.000000\r-1.873754\r-5\r2013-01-02\r-1.099263\r-0.330668\r-1.858497\r-5\r2013-01-03\r-0.833637\r-1.416958\r-0.525263\r-5\r2013-01-04\r-0.667948\r-0.947373\r-0.011333\r-5\r2013-01-05\r-1.412637\r-1.539891\r-0.789662\r-5\r2013-01-06\r-1.925618\r-0.395157\r-0.215027\r-5\r","date":"2022-10-09","objectID":"/pandas/:3:5","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Missing data np.nan表示缺失的数据 reindex可以更改、增加、删除某个轴上的索引，返回一份拷贝 df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + [\"E\"]) df1.loc[dates[0] : dates[1], \"E\"] = 1 df1 A\rB\rC\rD\rE\r2013-01-01\r0.000000\r0.000000\r1.873754\r5\r1.0\r2013-01-02\r1.099263\r0.330668\r-1.858497\r5\r1.0\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r5\rNaN\r2013-01-04\r-0.667948\r0.947373\r0.011333\r5\rNaN\rDataFrame.dropna()将有缺失值的行抛弃 df1.dropna(how=\"any\") A\rB\rC\rD\rE\r2013-01-01\r0.000000\r0.000000\r1.873754\r5\r1.0\r2013-01-02\r1.099263\r0.330668\r-1.858497\r5\r1.0\rDataFrame.fillna()填充缺失的数据 df1.fillna(value=5) A\rB\rC\rD\rE\r2013-01-01\r0.000000\r0.000000\r1.873754\r5\r1.0\r2013-01-02\r1.099263\r0.330668\r-1.858497\r5\r1.0\r2013-01-03\r-0.833637\r1.416958\r-0.525263\r5\r5.0\r2013-01-04\r-0.667948\r0.947373\r0.011333\r5\r5.0\risna()把nan的块变成true，其他位false pd.isna(df1) A\rB\rC\rD\rE\r2013-01-01\rFalse\rFalse\rFalse\rFalse\rFalse\r2013-01-02\rFalse\rFalse\rFalse\rFalse\rFalse\r2013-01-03\rFalse\rFalse\rFalse\rFalse\rTrue\r2013-01-04\rFalse\rFalse\rFalse\rFalse\rTrue\r","date":"2022-10-09","objectID":"/pandas/:4:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Operations ","date":"2022-10-09","objectID":"/pandas/:5:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Stats 平均值 df.mean() A -0.152551\rB 0.126658\rC -0.178885\rD 5.000000\rdtype: float64\r另一个轴的平均值 df.mean(1) 2013-01-01 1.718438\r2013-01-02 1.142858\r2013-01-03 1.264515\r2013-01-04 1.322689\r2013-01-05 1.020771\r2013-01-06 0.723563\rFreq: D, dtype: float64\r不同维度时需要对齐和广播 s = pd.Series([1, 3, 5, np.nan, 6, 8], index=dates).shift(2) s 2013-01-01 NaN\r2013-01-02 NaN\r2013-01-03 1.0\r2013-01-04 3.0\r2013-01-05 5.0\r2013-01-06 NaN\rFreq: D, dtype: float64\rdf.sub(s, axis=\"index\") A\rB\rC\rD\r2013-01-01\rNaN\rNaN\rNaN\rNaN\r2013-01-02\rNaN\rNaN\rNaN\rNaN\r2013-01-03\r-1.833637\r0.416958\r-1.525263\r4.0\r2013-01-04\r-3.667948\r-2.052627\r-2.988667\r2.0\r2013-01-05\r-3.587363\r-6.539891\r-5.789662\r0.0\r2013-01-06\rNaN\rNaN\rNaN\rNaN\r","date":"2022-10-09","objectID":"/pandas/:5:1","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Apply DataFrame.apply()应用某个用户自定义的函数 df.apply(np.cumsum) A\rB\rC\rD\r2013-01-01\r0.000000\r0.000000\r1.873754\r5\r2013-01-02\r1.099263\r0.330668\r0.015256\r10\r2013-01-03\r0.265626\r1.747625\r-0.510006\r15\r2013-01-04\r-0.402323\r2.694998\r-0.498674\r20\r2013-01-05\r1.010315\r1.155107\r-1.288336\r25\r2013-01-06\r-0.915304\r0.759950\r-1.073309\r30\rdf.apply(lambda x: x.max() - x.min()) A 3.338256\rB 2.956849\rC 3.732251\rD 0.000000\rdtype: float64\r","date":"2022-10-09","objectID":"/pandas/:5:2","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Histogramming s = pd.Series(np.random.randint(0, 7, size=10)) s 0 3\r1 5\r2 6\r3 5\r4 5\r5 0\r6 5\r7 2\r8 3\r9 5\rdtype: int32\rs.value_counts() 5 5\r3 2\r6 1\r0 1\r2 1\rdtype: int64\r","date":"2022-10-09","objectID":"/pandas/:5:3","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"String Methods s = pd.Series([\"A\", \"B\", \"C\", \"Aaba\", \"Baca\", np.nan, \"CABA\", \"dog\", \"cat\"]) s.str.lower() 0 a\r1 b\r2 c\r3 aaba\r4 baca\r5 NaN\r6 caba\r7 dog\r8 cat\rdtype: object\r","date":"2022-10-09","objectID":"/pandas/:5:4","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Merge ","date":"2022-10-09","objectID":"/pandas/:6:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Concat concat() df = pd.DataFrame(np.random.randn(10, 4)) df 0\r1\r2\r3\r0\r-0.197911\r-0.211569\r0.648594\r-1.123691\r1\r-1.486624\r-0.347519\r0.168468\r-1.687462\r2\r-2.242102\r0.853538\r-1.275269\r2.274398\r3\r-1.695120\r0.262447\r-0.312296\r-0.977294\r4\r0.606254\r-0.358807\r0.517332\r-0.495694\r5\r0.400137\r-0.557555\r0.032655\r0.057777\r6\r0.842657\r1.707752\r0.159613\r-0.077072\r7\r-1.918256\r0.666318\r-0.842085\r-0.655119\r8\r0.955265\r-1.577956\r-0.073302\r0.049012\r9\r0.518293\r-1.392874\r-1.549751\r0.232338\r# break it into pieces pieces = [df[:3], df[3:7], df[7:]] pd.concat(pieces) 0\r1\r2\r3\r0\r-0.197911\r-0.211569\r0.648594\r-1.123691\r1\r-1.486624\r-0.347519\r0.168468\r-1.687462\r2\r-2.242102\r0.853538\r-1.275269\r2.274398\r3\r-1.695120\r0.262447\r-0.312296\r-0.977294\r4\r0.606254\r-0.358807\r0.517332\r-0.495694\r5\r0.400137\r-0.557555\r0.032655\r0.057777\r6\r0.842657\r1.707752\r0.159613\r-0.077072\r7\r-1.918256\r0.666318\r-0.842085\r-0.655119\r8\r0.955265\r-1.577956\r-0.073302\r0.049012\r9\r0.518293\r-1.392874\r-1.549751\r0.232338\rAdding a column to a DataFrame is relatively fast. However, adding a row requires a copy, and may be expensive. We recommend passing a pre-built list of records to the DataFrame constructor instead of building a DataFrame by iteratively appending records to it. ","date":"2022-10-09","objectID":"/pandas/:6:1","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Join merge() left = pd.DataFrame({\"key\": [\"foo\", \"foo\"], \"lval\": [1, 2]}) right = pd.DataFrame({\"key\": [\"foo\", \"foo\"], \"rval\": [4, 5]}) left key\rlval\r0\rfoo\r1\r1\rfoo\r2\rright key\rrval\r0\rfoo\r4\r1\rfoo\r5\rpd.merge(left, right, on=\"key\") key\rlval\rrval\r0\rfoo\r1\r4\r1\rfoo\r1\r5\r2\rfoo\r2\r4\r3\rfoo\r2\r5\r另一个例子 left = pd.DataFrame({\"key\": [\"foo\", \"bar\"], \"lval\": [1, 2]}) right = pd.DataFrame({\"key\": [\"foo\", \"bar\"], \"rval\": [4, 5]}) left key\rlval\r0\rfoo\r1\r1\rbar\r2\rright key\rrval\r0\rfoo\r4\r1\rbar\r5\rpd.merge(left, right, on=\"key\") key\rlval\rrval\r0\rfoo\r1\r4\r1\rbar\r2\r5\r","date":"2022-10-09","objectID":"/pandas/:6:2","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Grouping group一般执行以下步骤 Splitting the data into groups based on some criteria Applying a function to each group independently Combining the results into a data structure df = pd.DataFrame( { \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"], \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"], \"C\": np.random.randn(8), \"D\": np.random.randn(8), } ) df A\rB\rC\rD\r0\rfoo\rone\r0.441899\r0.453832\r1\rbar\rone\r1.074023\r-0.715191\r2\rfoo\rtwo\r1.716625\r-1.196256\r3\rbar\rthree\r0.037677\r-1.320146\r4\rfoo\rtwo\r-0.545053\r-0.372236\r5\rbar\rtwo\r-0.763277\r-1.350397\r6\rfoo\rone\r-0.962743\r1.600875\r7\rfoo\rthree\r0.684661\r-0.004039\rdf.groupby(\"A\")[[\"C\", \"D\"]].sum() C\rD\rA\rbar\r0.348422\r-3.385734\rfoo\r1.335389\r0.482176\rdf.groupby([\"A\", \"B\"]).sum() C\rD\rA\rB\rbar\rone\r1.074023\r-0.715191\rthree\r0.037677\r-1.320146\rtwo\r-0.763277\r-1.350397\rfoo\rone\r-0.520844\r2.054707\rthree\r0.684661\r-0.004039\rtwo\r1.171571\r-1.568492\r","date":"2022-10-09","objectID":"/pandas/:7:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Reshaping ","date":"2022-10-09","objectID":"/pandas/:8:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Stack tuples = list( zip( [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"], [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"], ) ) index = pd.MultiIndex.from_tuples(tuples, names=[\"first\", \"second\"]) df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=[\"A\", \"B\"]) df2 = df[:4] df2 A\rB\rfirst\rsecond\rbar\rone\r0.124214\r0.765203\rtwo\r-0.519057\r2.075762\rbaz\rone\r-0.830936\r-0.544587\rtwo\r1.660069\r1.475826\rstacked = df2.stack() stacked first second bar one A 0.124214\rB 0.765203\rtwo A -0.519057\rB 2.075762\rbaz one A -0.830936\rB -0.544587\rtwo A 1.660069\rB 1.475826\rdtype: float64\rstacked.unstack() A\rB\rfirst\rsecond\rbar\rone\r0.124214\r0.765203\rtwo\r-0.519057\r2.075762\rbaz\rone\r-0.830936\r-0.544587\rtwo\r1.660069\r1.475826\rstacked.unstack(1) second\rone\rtwo\rfirst\rbar\rA\r0.124214\r-0.519057\rB\r0.765203\r2.075762\rbaz\rA\r-0.830936\r1.660069\rB\r-0.544587\r1.475826\rstacked.unstack(0) first\rbar\rbaz\rsecond\rone\rA\r0.124214\r-0.830936\rB\r0.765203\r-0.544587\rtwo\rA\r-0.519057\r1.660069\rB\r2.075762\r1.475826\r","date":"2022-10-09","objectID":"/pandas/:8:1","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Pivot tables df = pd.DataFrame( { \"A\": [\"one\", \"one\", \"two\", \"three\"] * 3, \"B\": [\"A\", \"B\", \"C\"] * 4, \"C\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\", \"bar\"] * 2, \"D\": np.random.randn(12), \"E\": np.random.randn(12), } ) df A\rB\rC\rD\rE\r0\rone\rA\rfoo\r-0.341421\r-0.546007\r1\rone\rB\rfoo\r1.618503\r0.611306\r2\rtwo\rC\rfoo\r-0.941145\r1.940351\r3\rthree\rA\rbar\r0.799316\r0.184894\r4\rone\rB\rbar\r1.621951\r-0.394846\r5\rone\rC\rbar\r-1.334491\r0.177758\r6\rtwo\rA\rfoo\r-2.192872\r-0.217708\r7\rthree\rB\rfoo\r-1.127164\r-0.266335\r8\rone\rC\rfoo\r-0.305296\r0.404488\r9\rone\rA\rbar\r-0.479922\r0.379061\r10\rtwo\rB\rbar\r-2.166614\r-2.103981\r11\rthree\rC\rbar\r1.932436\r0.609512\rpd.pivot_table(df, values=\"D\", index=[\"A\", \"B\"], columns=[\"C\"]) C\rbar\rfoo\rA\rB\rone\rA\r-0.479922\r-0.341421\rB\r1.621951\r1.618503\rC\r-1.334491\r-0.305296\rthree\rA\r0.799316\rNaN\rB\rNaN\r-1.127164\rC\r1.932436\rNaN\rtwo\rA\rNaN\r-2.192872\rB\r-2.166614\rNaN\rC\rNaN\r-0.941145\r","date":"2022-10-09","objectID":"/pandas/:8:2","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Time series ","date":"2022-10-09","objectID":"/pandas/:9:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Categoricals df = pd.DataFrame( {\"id\": [1, 2, 3, 4, 5, 6], \"raw_grade\": [\"a\", \"b\", \"b\", \"a\", \"a\", \"e\"]} ) 转化成类别类型 df[\"grade\"] = df[\"raw_grade\"].astype(\"category\") df[\"grade\"] 0 a\r1 b\r2 b\r3 a\r4 a\r5 e\rName: grade, dtype: category\rCategories (3, object): ['a', 'b', 'e']\r重命名 new_categories = [\"very good\", \"good\", \"very bad\"] df[\"grade\"] = df[\"grade\"].cat.rename_categories(new_categories) ","date":"2022-10-09","objectID":"/pandas/:10:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note"],"content":"Plotting import matplotlib.pyplot as plt plt.close(\"all\") ts = pd.Series(np.random.randn(1000), index=pd.date_range(\"1/1/2000\", periods=1000)) ts = ts.cumsum() ts.plot() \u003cAxesSubplot:\u003e\rplt.show() df = pd.DataFrame( np.random.randn(1000, 4), index=ts.index, columns=[\"A\", \"B\", \"C\", \"D\"] ) df = df.cumsum() plt.figure(); \u003cFigure size 432x288 with 0 Axes\u003e\rdf.plot(); plt.legend(loc='best'); No handles with labels found to put in legend.\r","date":"2022-10-09","objectID":"/pandas/:11:0","tags":["python"],"title":"Pandas","uri":"/pandas/"},{"categories":["note","slam"],"content":"Kalman Filter in One Dimension","date":"2022-09-21","objectID":"/kalman-filter-in-one-dimension/","tags":["slam"],"title":"Kalman Filter in One Dimension","uri":"/kalman-filter-in-one-dimension/"},{"categories":["note","slam"],"content":"参考资料 卡尔曼滤波就是用测量值（measured value）、测量不确定度（measurement uncertainty）、估计值（estimated value）、估计不确定度（estimate uncertainty），通过一轮轮的迭代来使估计值接近真实值（true value）。需要初始化测量值和估计不确定度。 迭代的过程可以分成状态更新（state update）和预测（prediction） ","date":"2022-09-21","objectID":"/kalman-filter-in-one-dimension/:0:0","tags":["slam"],"title":"Kalman Filter in One Dimension","uri":"/kalman-filter-in-one-dimension/"},{"categories":["note","slam"],"content":"算法流程和方程 以下方程是针对某个特定场景，比如汽车行驶 Equation Equation Name $$\\hat{x}_{n, n}=\\hat{x}_{n, n-1}+K_{n}\\left(z_{n}-\\hat{x}_{n, n-1}\\right)$$ State Update $$\\begin{array}{l}\\hat{x}_{n+1, n}=\\hat{x}_{n, n}+\\Delta t \\hat{v}_{n, n} \\\\ \\hat{v}_{n+1, n}=\\hat{v}_{n, n}\\end{array}$$ (For constant velocity dynamics) State Extrapolation $$K_{n}=\\frac{p_{n, n-1}}{p_{n, n-1}+r_{n}}$$ Kalman Gain $$p_{n, n}=\\left(1-K_{n}\\right) p_{n, n-1}$$ Covariance Update $$p_{n+1, n}=p_{n, n}+q_n$$(For constant dynamics) Covariance Extrapolation 参数说明 下标为n,n-1意思是第n-1到第n轮，一般为第n-1轮的输出即第n轮的输入 下标为n,n为第n轮的过渡变量，即状态更新了，还没预测 Parameter Meaning $$\\hat{x}$$ System State Estimate (Position) $$K$$ Kalman Gain $$z$$ Measured Value $$\\hat{v}$$ System State Estimate (Velocity) $$p$$ Estimate Uncertainty $$r$$ Measurement Uncertainty $$q$$ Noise ","date":"2022-09-21","objectID":"/kalman-filter-in-one-dimension/:1:0","tags":["slam"],"title":"Kalman Filter in One Dimension","uri":"/kalman-filter-in-one-dimension/"},{"categories":["note","slam"],"content":"卡尔曼增益的数学含义 A low measurement uncertainty relative to the estimate uncertainty would result in a high Kalman Gain (close to 1). Therefore the new estimate would be close to the measurement. A high measurement uncertainty relative to the estimate uncertainty would result in a low Kalman Gain (close to 0). Therefore the new estimate would be close to the previous estimate. 例子参见原文 有时当测量的物体在变化时，卡尔曼滤波不准，可以通过改进模型使它更贴近真实情况或增大噪音 We can eliminate the lag error by setting a high process uncertainty. However, since our model is not well-defined, we get noisy estimates that are almost equal to the measurements, and we miss the goal of the Kalman Filter. The best Kalman Filter implementation would involve a model that is very close to reality, leaving little room for process noise. However, a precise model is not always available - for example, an airplane pilot may decide to perform a sudden maneuver that changes the predicted airplane trajectory. In this case, the process noise would be increased. ","date":"2022-09-21","objectID":"/kalman-filter-in-one-dimension/:2:0","tags":["slam"],"title":"Kalman Filter in One Dimension","uri":"/kalman-filter-in-one-dimension/"},{"categories":["problemlist"],"content":"剑指offer","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":" 在leetcode平台上做一下剑指offer的题，不定时更新 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:0:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"03 数组中重复的数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:1:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:1:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 找出数组中任一重复的数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:1:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func findRepeatNumber(nums []int) int { mp := make(map[int]int) for i := range nums { if _, ok := mp[nums[i]]; ok { return nums[i] } mp[nums[i]] = 1 } return 0 } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:1:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"04 二维数组中的查找 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:2:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 线性查找 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:2:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 在二维数组中查找目标数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:2:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 暴力时间复杂度O(n*m) 从右上角开始，如果这个值小于目标数，则往下一行查找，如果大于目标数，则往前一列查找 func findNumberIn2DArray(matrix [][]int, target int) bool { if matrix == nil || len(matrix) == 0 { return false } r, c := len(matrix), len(matrix[0]) i, j := 0, c - 1 for i \u003c r \u0026\u0026 j \u003e= 0 { tmp := matrix[i][j] if tmp == target { return true } if tmp \u003c target { i++ } else { j-- } } return false } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:2:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"05 替换空格 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:3:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:3:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 把字符串中的空格替换成%20 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:3:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func replaceSpace(s string) string { ans := \"\" for _, v := range s { if v == ' ' { ans += \"%20\" } else { ans += string(v) } } return ans } func replaceSpace(s string) string { return strings.Replace(s, \" \", \"%20\", -1) } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:3:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"06 从尾到头打印链表 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:4:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:4:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 如题名 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:4:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) []int { var ans []int for head != nil { ans = append(ans, head.Val) head = head.Next } for i, j := 0, len(ans) - 1; i \u003c j; i, j = i + 1, j - 1 { ans[i], ans[j] = ans[j], ans[i] } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:4:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"07 重建二叉树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:5:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dfs、迭代 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:5:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 给二叉树的先序遍历和中序遍历，还原树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:5:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 dfs，只要锁定根在中序中的位置，然后类似于分治的做法，递归重建左子树和右子树 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var mp = make(map[int]int) func sol(pre []int, in []int, prel int, prer int, inl int, inr int) *TreeNode { if prel \u003e prer { return nil } rt := pre[prel] node := \u0026TreeNode{rt, nil, nil} leftsize := mp[rt] - inl node.Left = sol(pre, in, prel + 1, prel + leftsize, inl, leftsize - 1) node.Right = sol(pre, in, prel + leftsize + 1, prer, mp[rt] + 1, inr) return node } func buildTree(preorder []int, inorder []int) *TreeNode { n := len(preorder) for i, v := range inorder { mp[v] = i } return sol(preorder, inorder, 0, n - 1, 0, n - 1) } 用栈代替dfs可以节省时间和空间 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var mp = make(map[int]int) type foo struct { node *TreeNode prel, prer, inl, inr int } func buildTree(preorder []int, inorder []int) *TreeNode { n := len(preorder) for i, v := range inorder { mp[v] = i } var stack []foo if n == 0 { return nil } node := \u0026TreeNode{preorder[0], nil, nil} stack = append(stack, foo{node, 0, n - 1, 0, n - 1}) for len(stack) != 0 { tmp := stack[len(stack)-1] stack = stack[:len(stack)-1] rt := tmp.node.Val leftsize := mp[rt] - tmp.inl curprel := tmp.prel + 1 curprer := tmp.prel + leftsize curinl := tmp.inl curinr := leftsize - 1 if curprel \u003e curprer { tmp.node.Left = nil } else { lnode := \u0026TreeNode{preorder[curprel], nil, nil} tmp.node.Left = lnode stack = append(stack, foo{lnode, curprel, curprer, curinl, curinr}) } curprel = tmp.prel + leftsize + 1 curprer = tmp.prer curinl = mp[rt] + 1 curinr = tmp.inr if curprel \u003e curprer { tmp.node.Right = nil } else { rnode := \u0026TreeNode{preorder[curprel], nil, nil} tmp.node.Right = rnode stack = append(stack, foo{rnode, curprel, curprer, curinl, curinr}) } } return node } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:5:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"09 用两个栈实现队列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:6:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 栈、队列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:6:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 两个栈，入队操作就是直接push到栈顶，出队操作要获得栈底元素，就把它们倒到另一个栈中，这样队首就是另一个栈的栈顶 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:6:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 type CQueue struct { st1, st2 []int } func Constructor() CQueue { return CQueue{} } func (this *CQueue) AppendTail(value int) { this.st1 = append(this.st1, value) } func (this *CQueue) DeleteHead() int { if len(this.st1) == 0 \u0026\u0026 len(this.st2) == 0 { return -1 } if len(this.st2) == 0 { for len(this.st1) != 0 { this.st2 = append(this.st2, this.st1[len(this.st1) - 1]) this.st1 = this.st1[:len(this.st1) - 1] } } v := this.st2[len(this.st2) - 1] this.st2 = this.st2[:len(this.st2) - 1] return v } /** * Your CQueue object will be instantiated and called as such: * obj := Constructor(); * obj.AppendTail(value); * param_2 := obj.DeleteHead(); */ ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:6:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"10-1 斐波那契数列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:7:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:7:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:7:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func fib(n int) int { const mod int = 1e9 + 7 if n \u003c 2 { return n } p, q, r := 0, 0, 1 for i := 2; i \u003c= n; i++ { p = q q = r r = (p + q) % mod } return r } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:7:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"10-2 青蛙跳台阶问题 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:8:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy dp ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:8:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:8:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func numWays(n int) int { const mod = 1e9 + 7 dp := make([]int, n + 3) dp[0] = 1 dp[1] = 1 for i := 2; i \u003c= n; i++ { dp[i] = dp[i - 1] + dp[i - 2] dp[i] %= mod } return dp[n] } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:8:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"11 旋转数组的最小数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:9:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 二分 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:9:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:9:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 二分，注意细节 func minArray(numbers []int) int { low := 0 hi := len(numbers) - 1 for low \u003c hi { mid := low + (hi-low)/2 if numbers[mid] \u003c numbers[hi] { hi = mid } else if numbers[mid] \u003e numbers[hi] { low = mid + 1 } else { hi-- } } return numbers[low] } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:9:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"12 矩阵中的路径 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:10:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dfs、回溯、剪枝 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:10:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:10:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 注意要加剪枝、有几处需要回溯 题解在调用dfs时传递字符串，这样很浪费时间，不是一个快速的方法 func exist(board [][]byte, word string) bool { dir := [][]int{{0, 1}, {0, -1}, {-1, 0}, {1, 0}} n := len(board) m := len(board[0]) if len(word) \u003e n*m { return false } vis := make([][]bool, n) for i := range vis { vis[i] = make([]bool, m) } le := len(word) var dfs func(x, y int, str string) bool dfs = func(x, y int, str string) bool { vis[x][y] = true defer func() { vis[x][y] = false }() for i := 0; i \u003c len(str); i++ { if str[i] != word[i] { return false } } if len(str) == le { return true } for i := 0; i \u003c 4; i++ { nx := x + dir[i][0] ny := y + dir[i][1] if nx \u003e= 0 \u0026\u0026 nx \u003c n \u0026\u0026 ny \u003e= 0 \u0026\u0026 ny \u003c m \u0026\u0026 !vis[nx][ny] { if dfs(nx, ny, str+string(board[nx][ny])) { return true } } } return false } for i, row := range board { for j, v := range row { if dfs(i, j, string(v)) { return true } } } return false } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:10:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"13 机器人的运动范围 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:11:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 搜索 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:11:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:11:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 把数位和\u003ek的格子当做障碍 func movingCount(m int, n int, k int) int { var queue [][2]int check := func(x int) int { res := 0 for x != 0 { res += x % 10 x /= 10 } return res } obstacle := make([][]bool, m) for i := range obstacle { obstacle[i] = make([]bool, n) } vis := make([][]bool, m) for i := range vis { vis[i] = make([]bool, n) } dir := [][]int{{0, 1}, {0, -1}, {-1, 0}, {1, 0}} sx, sy := 0, 0 for i := 0; i \u003c m; i++ { for j := 0; j \u003c n; j++ { if check(i) + check(j) \u003e k { obstacle[i][j] = true } } } queue = append(queue, [2]int{sx, sy}) vis[sx][sy] = true ans := 1 for len(queue) != 0 { tmp := queue[0] queue = queue[1:] sx, sy = tmp[0], tmp[1] for i := 0; i \u003c 4; i++ { nx, ny := sx + dir[i][0], sy + dir[i][1] if nx \u003e= 0 \u0026\u0026 nx \u003c m \u0026\u0026 ny \u003e= 0 \u0026\u0026 ny \u003c n \u0026\u0026 !vis[nx][ny] \u0026\u0026 !obstacle[nx][ny] { queue = append(queue, [2]int{nx, ny}) ans++ vis[nx][ny] = true } } } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:11:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"14-1 剪绳子 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:12:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 数学规律 dp ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:12:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 给一个段长度为n的绳子，把绳子分成若干段，求每段绳子的长度积的最大值 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:12:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 dp很容易想到，对于数学规律 首先平均分能够获得最大积，但是不知道是分成222222还是333333还是444444 因为有时候不能正好平均分，所以一般是222221,33333332,44444443这种形式 可以概括为分成1和2的、分成2和3的、分成3和4的。。。 对于分成3和4的，由于4可以分成2和2，没有损失，所以3和4实际上就是2和3 对于分成4和5的，由于4可以分成2和2，没有损失，5可以分成2和3，积增加了，所以4和5实际还是2和3 对于分成5和6的，由于5可以分成2和3，6可以分成3和3，积增加了，所以5和6实际上还是2和3 可以推测其他的都可以变成2和3 比较1和2的与2和3的，假设把2和3分解成1和2，积减少了，所以还是2和3划算，且应该尽可能多得保留3（可以进行严谨的数学证明，懒得写） 结论，当n%3=0时，是3333333，当n%3=1时，是33333322，当n%3==2时，是3333333332 func cuttingRope(n int) int { switch n { case 1: return 1 case 2: return 1 case 3: return 2 default: if n%3 == 0 { return int(math.Pow(3, float64(n/3))) } else if n%3 == 1 { return int(math.Pow(3, float64(n/3-1)) * 4) } else { return int(math.Pow(3, float64(n/3)) * 2) } } } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:12:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"14-2 剪绳子 II ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:13:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 数学规律 dp 快速幂 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:13:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 给一个段长度为n的绳子，把绳子分成若干段，求每段绳子的长度积的最大值 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:13:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 同上题，加个快速幂 func cuttingRope(n int) int { const mod = 1e9 + 7 qpow := func(x, n int) int { res := 1 for n \u003e 0 { if n \u0026 1 == 1 { res = res * x % mod } x = x * x % mod n \u003e\u003e= 1 } return res } switch n { case 1: return 1 case 2: return 1 case 3: return 2 default: if n%3 == 0 { return qpow(3, n / 3) } else if n%3 == 1 { return qpow(3, n / 3 - 1) * 4 % mod } else { return qpow(3, n / 3) * 2 % mod } } } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:13:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"15 二进制中1的个数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:14:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 位运算 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:14:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 求正数二进制1的个数 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:14:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func hammingWeight(num uint32) int { ans := 0 for num != 0 { ans += (int)(num \u0026 1) num \u003e\u003e= 1 } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:14:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"16 数值的整数次方 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:15:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 快速幂 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:15:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 求x的n次方 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:15:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func myPow(x float64, n int) float64 { if n == 0 { return 1 } pos := n \u003e 0 if !pos { n = -n } var ans = 1.0 for n \u003e 0 { if n%2 == 1 { ans *= x } x *= x n \u003e\u003e= 1 } if pos { return ans } else { return 1 / ans } } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:15:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"17 打印从1到最大的n位数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:16:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 小模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:16:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 如题名 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:16:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func printNumbers(n int) []int { var ans []int for i := 1; i \u003c (int)(math.Pow10(n)); i++ { ans = append(ans, i) } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:16:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"18 删除链表的节点 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:17:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 小模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:17:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 如题名 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:17:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(head *ListNode, val int) *ListNode { cnt := head if head.Val == val { return head.Next } for cnt != nil { if cnt.Next.Val == val { cnt.Next = cnt.Next.Next return head } cnt = cnt.Next } return head } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:17:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"19 正则表达式匹配 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:18:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 hard dp 分类讨论 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:18:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:18:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 正则表达式匹配最高效的做法应该是用状态机？ 很好的dp题，细节比较多（官方题解似乎很简洁🤔） dp[i][j]表示s串前i个和p串的前j个是否匹配 如果s[i] = p[j] 那一定可以匹配， dp[i][j] = dp[i-1][j-1] 否则如果p[j] 是个字母，由于两个字母不同，一定不匹配 dp[i][j] = false 否则如果p[j]是’.’，它可以匹配任意一个字母，可以匹配dp[i][j] = dp[i-1][j-1] 否则如果p[j] = ‘*’， 这个比较麻烦 如果p[j-1] = s[i] 则这个*可以把前面的字母和自己吞掉，可以把自己吞掉，可以复制前面的字母，所以 dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j] （注意这里是dp[i-1][j]不是dp[i-1][j-1]，这样可以过加强的用例） 否则如果p[j-1]是个字母，那*只能把前面的字母吞掉，dp[i][j] = dp[i][j-2] 否则如果p[j-1]是’.’， 那它可以当做任何一个字母，dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j-1] 不可能出现两个连续的’*’ 初始化 dp = false, dp[0][0] = true 这么做有几个漏洞 “aab”, “cab” 无法通过，因为一开始就不匹配，后面都匹配不了（这肯能和代码有关），所以需要在s串和p串加个’a’来启动匹配 “aaa”, “.*” 无法通过，最后漏考虑了一种情况，因为 “.*” 的 ‘.’ 可以是任意字母，所以dp[i][j] |= dp[i-1][j]，即当前s串的最后一个字母一定能匹配 有罚时的比赛应该考虑怎么通过想这些样例来降低dirt！！ func isMatch(s string, p string) bool { s, p = \"a\" + s, \"a\" + p // insert 'a' in front to make aligned, pass \"aab\", \"c*a*b\" sn, pn := len(s), len(p) s, p = \"a\" + s, \"a\" + p dp := make([][]bool, sn+2) for i := range dp { dp[i] = make([]bool, pn+2) } dp[0][0] = true // fmt.Println(s) // fmt.Println(p) for i := 1; i \u003c= sn; i++ { for j := 1; j \u003c= pn; j++ { if s[i] == p[j] { dp[i][j] = dp[i - 1][j - 1] } else if 'a' \u003c= p[j] \u0026\u0026 p[j] \u003c= 'z' { dp[i][j] = false } else if p[j] == '.' { dp[i][j] = dp[i - 1][j - 1] } else if p[j] == '*' { if p[j - 1] == s[i] { dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j] } else if p[j - 1] \u003e= 'a' \u0026\u0026 p[j - 1] \u003c= 'z' { dp[i][j] = dp[i][j - 2] } else if p[j - 1] == '.' { dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j - 1] || dp[i - 1][j] } } } } // for i := 1; i \u003c= sn; i++ { // for j := 1; j \u003c= pn; j++ { // fmt.Printf(\"%d %d \", i, j) // fmt.Println(dp[i][j]) // } // } return dp[sn][pn] } //数据加强了 // \"aaa\" // \"a*\" // wa false // ac true ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:18:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"20 表示数值的字符串 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:19:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dfa，大模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:19:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:19:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 dfa，大模拟题，此处放一个官方题解 class Solution { public: enum State { STATE_INITIAL, STATE_INT_SIGN, STATE_INTEGER, STATE_POINT, STATE_POINT_WITHOUT_INT, STATE_FRACTION, STATE_EXP, STATE_EXP_SIGN, STATE_EXP_NUMBER, STATE_END }; enum CharType { CHAR_NUMBER, CHAR_EXP, CHAR_POINT, CHAR_SIGN, CHAR_SPACE, CHAR_ILLEGAL }; CharType toCharType(char ch) { if (ch \u003e= '0' \u0026\u0026 ch \u003c= '9') { return CHAR_NUMBER; } else if (ch == 'e' || ch == 'E') { return CHAR_EXP; } else if (ch == '.') { return CHAR_POINT; } else if (ch == '+' || ch == '-') { return CHAR_SIGN; } else if (ch == ' ') { return CHAR_SPACE; } else { return CHAR_ILLEGAL; } } bool isNumber(string s) { unordered_map\u003cState, unordered_map\u003cCharType, State\u003e\u003e transfer{ { STATE_INITIAL, { {CHAR_SPACE, STATE_INITIAL}, {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT}, {CHAR_SIGN, STATE_INT_SIGN} } }, { STATE_INT_SIGN, { {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT} } }, { STATE_INTEGER, { {CHAR_NUMBER, STATE_INTEGER}, {CHAR_EXP, STATE_EXP}, {CHAR_POINT, STATE_POINT}, {CHAR_SPACE, STATE_END} } }, { STATE_POINT, { {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP}, {CHAR_SPACE, STATE_END} } }, { STATE_POINT_WITHOUT_INT, { {CHAR_NUMBER, STATE_FRACTION} } }, { STATE_FRACTION, { {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP}, {CHAR_SPACE, STATE_END} } }, { STATE_EXP, { {CHAR_NUMBER, STATE_EXP_NUMBER}, {CHAR_SIGN, STATE_EXP_SIGN} } }, { STATE_EXP_SIGN, { {CHAR_NUMBER, STATE_EXP_NUMBER} } }, { STATE_EXP_NUMBER, { {CHAR_NUMBER, STATE_EXP_NUMBER}, {CHAR_SPACE, STATE_END} } }, { STATE_END, { {CHAR_SPACE, STATE_END} } } }; int len = s.length(); State st = STATE_INITIAL; for (int i = 0; i \u003c len; i++) { CharType typ = toCharType(s[i]); if (transfer[st].find(typ) == transfer[st].end()) { return false; } else { st = transfer[st][typ]; } } return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END; } }; type State int type CharType int const ( STATE_INITIAL State = iota STATE_INT_SIGN STATE_INTEGER STATE_POINT STATE_POINT_WITHOUT_INT STATE_FRACTION STATE_EXP STATE_EXP_SIGN STATE_EXP_NUMBER STATE_END ) const ( CHAR_NUMBER CharType = iota CHAR_EXP CHAR_POINT CHAR_SIGN CHAR_SPACE CHAR_ILLEGAL ) func toCharType(ch byte) CharType { switch ch { case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9': return CHAR_NUMBER case 'e', 'E': return CHAR_EXP case '.': return CHAR_POINT case '+', '-': return CHAR_SIGN case ' ': return CHAR_SPACE default: return CHAR_ILLEGAL } } func isNumber(s string) bool { transfer := map[State]map[CharType]State{ STATE_INITIAL: map[CharType]State{ CHAR_SPACE: STATE_INITIAL, CHAR_NUMBER: STATE_INTEGER, CHAR_POINT: STATE_POINT_WITHOUT_INT, CHAR_SIGN: STATE_INT_SIGN, }, STATE_INT_SIGN: map[CharType]State{ CHAR_NUMBER: STATE_INTEGER, CHAR_POINT: STATE_POINT_WITHOUT_INT, }, STATE_INTEGER: map[CharType]State{ CHAR_NUMBER: STATE_INTEGER, CHAR_EXP: STATE_EXP, CHAR_POINT: STATE_POINT, CHAR_SPACE: STATE_END, }, STATE_POINT: map[CharType]State{ CHAR_NUMBER: STATE_FRACTION, CHAR_EXP: STATE_EXP, CHAR_SPACE: STATE_END, }, STATE_POINT_WITHOUT_INT: map[CharType]State{ CHAR_NUMBER: STATE_FRACTION, }, STATE_FRACTION: map[CharType]State{ CHAR_NUMBER: STATE_FRACTION, CHAR_EXP: STATE_EXP, CHAR_SPACE: STATE_END, }, STATE_EXP: map[CharType]State{ CHAR_NUMBER: STATE_EXP_NUMBER, CHAR_SIGN: STATE_EXP_SIGN, }, STATE_EXP_SIGN: map[CharType]State{ CHAR_NUMBER: STATE_EXP_NUMBER, }, STATE_EXP_NUMBER: map[CharType]State{ CHAR_NUMBER: STATE_EXP_NUMBER, CHAR_SPACE: STATE_END, }, STATE_END: map[CharType]State{ CHAR_SPACE: STATE_END, }, } state := STATE_INITIAL for i := 0; i \u003c len(s); i++ { typ := toCharType(s[i]) if _, ok := transfer[state][typ]; !ok { return false } else { state = transfer[state][typ] } } return state == STATE_INTEGER || state == STATE_POINT || state == STATE_FRACTION || state == STATE_EXP_NUMBER || state == STATE_END } 图片和代码 作者：LeetCode-Solution 链接：https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:19:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"21 调整数组顺序使奇数位于偶数前面 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:20:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 双指针 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:20:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:20:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func exchange(nums []int) []int { n := len(nums) l, r := 0, n-1 for l \u003c r { if nums[l]%2 == 0 \u0026\u0026 nums[r]%2 == 1 { nums[l], nums[r] = nums[r], nums[l] l++ r-- } else if nums[l] % 2 == 1 \u0026\u0026 nums[r] % 2 == 0 { l++ r-- } else if nums[l] % 2 == 0 \u0026\u0026 nums[r] % 2 == 0 { r-- } else { l++ } } return nums } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:20:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"22 链表中倒数第k个节点 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:21:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:21:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:21:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 注意函数体可以调用返回值变量 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getKthFromEnd(head *ListNode, k int) (kth *ListNode) { n := 0 for node := head; node != nil; node = node.Next { n++ } for kth = head; n \u003e k; n-- { kth = kth.Next } return } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:21:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"24 反转链表 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:22:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 三指针 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:22:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:22:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { if head == nil { return nil } if head.Next == nil { return head } l, m, r := head, head.Next, head.Next.Next for r != nil { m.Next = l l, m = m, r r = m.Next } m.Next = l head.Next = nil return m } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:22:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"25 合并两个排序的链表 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:23:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 双指针比较值 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:23:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:23:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 注意切换主链和副链，主链是真正头节点的链 空间复杂度O(1) /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { var ma1n, sub *ListNode if l1 == nil { return l2 } else if l2 == nil { return l1 } if l1.Val \u003c l2.Val { ma1n, sub = l1, l2 } else { ma1n, sub = l2, l1 } head := ma1n for ma1n != nil \u0026\u0026 sub != nil { if ma1n.Val \u003c= sub.Val { if ma1n.Next != nil \u0026\u0026 ma1n.Next.Val \u003c= sub.Val { ma1n = ma1n.Next } else { tmp := ma1n.Next ma1n.Next = sub ma1n = tmp ma1n, sub = sub, ma1n // 互换主链和副链 } } else { if sub.Next != nil \u0026\u0026 sub.Next.Val \u003c= ma1n.Val { sub = sub.Next } else { tmp := sub.Next sub.Next = ma1n sub = tmp ma1n, sub = sub, ma1n // 互换主链和副链 } } } return head } // [5] // [1,2,4] // wa [1,5] // ac [1,2,4,5] // [-9,-7,-3,-3,-1,2,3] // [-7,-7,-6,-6,-5,-3,2,4] // wa [-9,-7,-7,-7,-6,-6,-5,-3,-1,2,2,3,4] // ac [-9,-7,-7,-7,-6,-6,-5,-3,-3,-3,-1,2,2,3,4] ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:23:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"26 树的子结构 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:24:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 递归 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:24:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:24:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSubStructure(A *TreeNode, B *TreeNode) bool { if A == nil || B == nil { return false } if A.Val == B.Val \u0026\u0026 B.Left == nil \u0026\u0026 B.Right == nil { return true } ok := true if A.Val == B.Val { //ok = isSubStructure(A.Left, B.Left) \u0026\u0026 isSubStructure(A.Right, B.Right) if B.Left != nil { if A.Left != nil \u0026\u0026 A.Left.Val == B.Left.Val \u0026\u0026 isSubStructure(A.Left, B.Left) { //注意需要条件A.Left.Val == B.Left.Val } else { ok = false } } if ok \u0026\u0026 B.Right != nil { if A.Right != nil \u0026\u0026 A.Right.Val == B.Right.Val \u0026\u0026 isSubStructure(A.Right, B.Right) { } else { ok = false } } } else { ok = false //加这一句 } return ok || isSubStructure(A.Left, B) || isSubStructure(A.Right, B) } // [3,4] // [3,4] // wa false // ac true // [0,-4,-3] // [1,-4] // wa true // ac false ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:24:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"27 二叉树的镜像 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:25:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 递归 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:25:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:25:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } tmpL := root.Left tmpR := root.Right if tmpR != nil { root.Left = mirrorTree(tmpR) } else { root.Left = nil } if tmpL != nil { root.Right = mirrorTree(tmpL) } else { root.Right = nil } return root } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:25:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"28 对称的二叉树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:26:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 递归 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:26:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:26:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 先求镜像，然后比较是否相同，注意深拷贝 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } tmpL := root.Left tmpR := root.Right if tmpR != nil { root.Left = mirrorTree(tmpR) } else { root.Left = nil } if tmpL != nil { root.Right = mirrorTree(tmpL) } else { root.Right = nil } return root } func same(node1, node2 *TreeNode) bool { if node1 == nil \u0026\u0026 node2 == nil { return true } else if node1 == nil || node2 == nil { return false } return node1.Val == node2.Val \u0026\u0026 same(node1.Left, node2.Left) \u0026\u0026 same(node2.Right, node1.Right) } func deepCopy(node *TreeNode) *TreeNode { if node == nil { return nil } newNode := \u0026TreeNode{node.Val, nil, nil} if node.Left != nil { newNode.Left = deepCopy(node.Left) } if node.Right != nil { newNode.Right = deepCopy(node.Right) } return newNode } func isSymmetric(root *TreeNode) bool { copied := deepCopy(root) mirrorTree(root) return same(root, copied) } 官方较为简洁的代码 func isSymmetric(root *TreeNode) bool { return check(root, root) } func check(p, q *TreeNode) bool { if p == nil \u0026\u0026 q == nil { return true } if p == nil || q == nil { return false } return p.Val == q.Val \u0026\u0026 check(p.Left, q.Right) \u0026\u0026 check(p.Right, q.Left) } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:26:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"29 顺时针打印矩阵 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:27:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:27:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:27:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 注意特判 func spiralOrder(matrix [][]int) []int { // 特判 if len(matrix) == 0 || len(matrix[0]) == 0 { return []int{} } dir := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}} n, m := len(matrix), len(matrix[0]) var ans []int vis := make([][]bool, n) for i := range vis { vis[i] = make([]bool, m) } idx := 0 ans = append(ans, matrix[0][0]) vis[0][0] = true x, y := 0, 0 for len(ans) != n*m { nx, ny := x+dir[idx][0], y+dir[idx][1] if nx \u003e= 0 \u0026\u0026 nx \u003c n \u0026\u0026 ny \u003e= 0 \u0026\u0026 ny \u003c m \u0026\u0026 !vis[nx][ny] { x, y = nx, ny vis[x][y] = true ans = append(ans, matrix[x][y]) } else { idx = (idx + 1) % 4 } } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:27:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"30 包含min函数的栈 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:28:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 栈、思维 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:28:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:28:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 使用两个栈，具体看动图 type MinStack struct { stack []int minStack []int } /** initialize your data structure here. */ func Constructor() MinStack { return MinStack{ stack: []int{}, minStack: []int{math.MaxInt64}, } } func (this *MinStack) Push(x int) { this.stack = append(this.stack, x) this.minStack = append(this.minStack, min(x, this.minStack[len(this.minStack)-1])) } func (this *MinStack) Pop() { this.stack = this.stack[:len(this.stack)-1] this.minStack = this.minStack[:len(this.minStack)-1] } func (this *MinStack) Top() int { return this.stack[len(this.stack)-1] } func (this *MinStack) Min() int { return this.minStack[len(this.minStack)-1] } func min(x, y int) int { if x \u003c y { return x } else { return y } } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Min(); */ ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:28:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"31 栈的压入、弹出序列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:29:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 栈 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:29:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:29:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func validateStackSequences(pushed []int, popped []int) bool { mp := make(map[int]bool) var st []int idx := 0 sz := len(pushed) for _, v := range popped { _, ok := mp[v] if ok { if st[len(st)-1] == v { st = st[:len(st)-1] } else { return false } } else { for idx \u003c sz \u0026\u0026 pushed[idx] != v { st = append(st, pushed[idx]) mp[pushed[idx]] = true idx++ } //st = append(st, pushed[idx]) mp[pushed[idx]] = true idx++ } } return true } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:29:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"32-1 从上到下打印二叉树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:30:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium bfs ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:30:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:30:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 注意特判空树 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) []int { if root == nil { return []int{} } var ( ans []int queue []*TreeNode ) queue = append(queue, root) for len(queue) != 0 { tmp := queue[0] queue = queue[1:] ans = append(ans, tmp.Val) if tmp.Left != nil { queue = append(queue, tmp.Left) } if tmp.Right != nil { queue = append(queue, tmp.Right) } } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:30:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"32-2 从上到下打印二叉树 II ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:31:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy bfs ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:31:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:31:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } var ( ans [][]int queue []*TreeNode ) queue = append(queue, root) sz := 1 var nana []int for len(queue) != 0 { tmp := queue[0] queue = queue[1:] nana = append(nana, tmp.Val) sz-- if tmp.Left != nil { queue = append(queue, tmp.Left) } if tmp.Right != nil { queue = append(queue, tmp.Right) } if sz == 0 { sz = len(queue) ans = append(ans, nana) nana = []int{} } } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:31:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"32-3 从上到下打印二叉树 III ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:32:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium bfs ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:32:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:32:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } var ( ans [][]int queue []*TreeNode ) queue = append(queue, root) sz := 1 var nana []int for len(queue) != 0 { tmp := queue[0] queue = queue[1:] nana = append(nana, tmp.Val) sz-- if tmp.Left != nil { queue = append(queue, tmp.Left) } if tmp.Right != nil { queue = append(queue, tmp.Right) } if sz == 0 { sz = len(queue) ans = append(ans, nana) nana = []int{} } } rev := false for _, v := range ans { if rev { reverse(v) } rev = !rev } return ans } func reverse(x []int) { for i, j := 0, len(x)-1; i \u003c j; i, j = i+1, j-1 { x[i], x[j] = x[j], x[i] } } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:32:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"33 二叉搜索树的后序遍历序列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:33:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 单调栈、思维 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:33:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 给定一个后序遍历序列，问是否可以还原成二叉搜索树 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:33:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 用单调栈O(n)，递归O(n*n) func verifyPostorder(postorder []int) bool { var stack []int par := math.MaxInt64 for i := len(postorder) - 1; i \u003e= 0; i-- { if postorder[i] \u003e par { return false } for len(stack) != 0 \u0026\u0026 postorder[i] \u003c stack[len(stack) - 1] { par = stack[len(stack) - 1] stack = stack[:len(stack) - 1] } stack = append(stack, postorder[i]) } return true } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:33:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"34 二叉树中和为某一值的路径 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:34:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dfs、深拷贝 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:34:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 给一二叉树，求从根到叶子节点中权值和为target的路径 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:34:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 dfs，注意深拷贝而不是回溯，时间复杂度是O(n^2) 注意go深拷贝数组的写法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, target int) [][]int { var ans [][]int if root == nil { return [][]int{} } cnt := []int{root.Val} var dfs func(*TreeNode, []int, int) dfs = func(node *TreeNode, path []int, val int) { if node.Left == nil \u0026\u0026 node.Right == nil { if val == target { ans = append(ans, path) } else { return } } if node.Left != nil { //var tmpPath []int //for _, v := range path { // tmpPath = append(tmpPath, v) //} //tmpPath = append(tmpPath, node.Left.Val) tmpPath := make([]int, 0) tmpPath = append(tmpPath, path[:]...) tmpPath = append(tmpPath, node.Left.Val) dfs(node.Left, tmpPath, val+node.Left.Val) } if node.Right != nil { //var tmpPath []int //for _, v := range path { // tmpPath = append(tmpPath, v) //} //tmpPath = append(tmpPath, node.Right.Val) tmpPath := make([]int, 0) tmpPath = append(tmpPath, path[:]...) tmpPath = append(tmpPath, node.Right.Val) dfs(node.Right, tmpPath, val+node.Right.Val) } } dfs(root, cnt, root.Val) return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:34:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"35 复杂链表的复制 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:35:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 哈希表 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:35:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:35:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { if head == nil { return nil } mp := make(map[*Node]*Node) cnt := head s1mple := \u0026Node{cnt.Val, nil, nil} for ; ; cnt, s1mple = cnt.Next, s1mple.Next { mp[cnt] = s1mple if cnt.Next != nil { s1mple.Next = \u0026Node{cnt.Next.Val, nil, nil} } else { break } } cnt = head for ; cnt != nil; cnt = cnt.Next { mp[cnt].Random = mp[cnt.Random] } return mp[head] } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:35:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"36 二叉搜索树与双向链表 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:36:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 递归 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:36:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 将一棵值不重复的二叉搜索树转化为双向链表，要求双向链表是单调递增的，要求原地转化，链表的左指针就是二叉树的左指针，右指针就是二叉树的右指针 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:36:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 二叉搜索树的中序遍历是单调的 递归，对于一个节点，每次dfs左子树和右子树都返回子树的最左边节点（值最小的节点）和最右边的节点（值最大的节点），然后直接连边 lc没有go版本，可以去nc package main import . \"nc_tools\" /* * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func Convert(root *TreeNode) *TreeNode { if root == nil { return nil } if root.Left == nil \u0026\u0026 root.Right == nil { return root } var dfs func(*TreeNode) (*TreeNode, *TreeNode) dfs = func(node *TreeNode) (*TreeNode, *TreeNode) { var Lmin, Lmax, Rmin, Rmax *TreeNode if node.Left != nil { Lmin, Lmax = dfs(node.Left) node.Left = Lmax Lmax.Right = node } if node.Right != nil { Rmin, Rmax = dfs(node.Right) node.Right = Rmin Rmin.Left = node } if Lmin == nil { Lmin = node } if Rmax == nil { Rmax = node } return Lmin, Rmax } dfs(root) Lnode := root for Lnode.Left != nil { Lnode = Lnode.Left } //Rnode := root //for Rnode.Right != nil { // Rnode = Rnode.Right //} //Lnode.Left = Rnode //Rnode.Right = Lnode return Lnode } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:36:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"37 序列化二叉树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:37:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 hard bfs ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:37:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 将二叉树序列化和反序列化，不管实现逻辑，只要能保证不同二叉树对应不同序列即可 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:37:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 只要bfs层序遍历，多记一层的空节点 lc没有go版本，可在nc package main import . \"nc_tools\" import ( \"strconv\" \"strings\" ) /* * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func Serialize(root *TreeNode) string { if root == nil { return \"#\" } queue := make([]*TreeNode, 0) queue = append(queue, root) s := \"\" for len(queue) != 0 { tmp := queue[0] queue = queue[1:] if tmp == nil { s += \",#\" } else { if tmp != root { s += \",\" } s += strconv.Itoa(tmp.Val) } if tmp != nil { queue = append(queue, tmp.Left) queue = append(queue, tmp.Right) } } return s } func Deserialize(s string) *TreeNode { if s == \"#\" { return nil } d := strings.Split(s, \",\") val, _ := strconv.Atoi(d[0]) root := \u0026TreeNode{val, nil, nil} queue := make([]*TreeNode, 0) queue = append(queue, root) cnt := 1 for len(queue) != 0 { tmp := queue[0] queue = queue[1:] left := d[cnt] right := d[cnt+1] cnt += 2 if left != \"#\" { val, _ = strconv.Atoi(left) lnode := \u0026TreeNode{val, nil, nil} tmp.Left = lnode queue = append(queue, lnode) } if right != \"#\" { val, _ = strconv.Atoi(right) rnode := \u0026TreeNode{val, nil, nil} tmp.Right = rnode queue = append(queue, rnode) } } return root } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:37:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"38 字符串的排列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:38:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 暴力枚举 回溯 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:38:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 给一个字符串，求字符串不相同的排列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:38:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func permutation(s string) []string { mp := make(map[byte]int) var ans []string for _, v := range s { mp[byte(v)]++ } sz := len(s) var dfs func(string, map[byte]int) dfs = func(s string, m map[byte]int) { if len(s) == sz { ans = append(ans, s) return } for k, v := range m { if v != 0 { m[k]-- dfs(s + string(k), m) m[k]++ } } } dfs(\"\", mp) return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:38:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"39 数组中出现次数超过一半的数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:39:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 摩尔投票 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:39:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:39:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 时间复杂度O(n)，空间复杂度O(1)的做法是摩尔投票 func majorityElement(nums []int) int { candidate := -1 count := 0 for _, v := range nums { if candidate == v { count++ } else if count == 0 { candidate = v count = 1 } else { count-- } } return candidate } 此题的进阶版是超过n/3的数字，理论上超过n/k的数字最多有k-1个 func majorityElement(nums []int) []int { candidate1, candidate2 := math.MinInt64, math.MinInt64 count1, count2 := 0, 0 for _, v := range nums { if v == candidate1 { count1++ } else if v == candidate2 { count2++ } else if count1 == 0 { candidate1 = v count1 = 1 } else if count2 == 0 { candidate2 = v count2 = 1 } else { count1-- count2-- } } ans := make([]int, 0) count1, count2 = 0, 0 for _, v := range nums { if v == candidate1 { count1++ } if v == candidate2 { count2++ } } if count1 \u003e len(nums) / 3 { ans = append(ans, candidate1) } if count2 \u003e len(nums) / 3 { ans = append(ans, candidate2) } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:39:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"40 最小的k个数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:40:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 分治 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:40:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 求数组最小的k个数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:40:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 很多种方法 时间复杂度期望为O(n)，空间复杂度为O(logn)的方法可以用快排的分治递归思想 快排题代码如下 func quicksort(a []int, l, r int) { if l \u003c r { lo, hi := l, r for lo \u003c hi { for lo \u003c hi \u0026\u0026 a[hi] \u003e= a[l] { hi-- } for lo \u003c hi \u0026\u0026 a[lo] \u003c= a[l] { //写\u003c会超时 lo++ } a[lo], a[hi] = a[hi], a[lo] } a[lo], a[l] = a[l], a[lo] quicksort(a, l, lo-1) quicksort(a, lo+1, r) } } func arrayPairSum(nums []int) int { quicksort(nums, 0, len(nums) - 1) ans := 0 for i, v := range nums { if i % 2 == 0 { ans += v } } return ans } 本题代码如下 func quicksort(a []int, l, r, k int) { if l \u003c r { lo, hi := l, r for lo \u003c hi { for lo \u003c hi \u0026\u0026 a[hi] \u003e= a[l] { hi-- } for lo \u003c hi \u0026\u0026 a[lo] \u003c= a[l] { lo++ } a[lo], a[hi] = a[hi], a[lo] } a[lo], a[l] = a[l], a[lo] if k == lo { return } else if lo \u003c k { quicksort(a, lo+1, r, k) } else { quicksort(a, l, lo-1, k) } } } func getLeastNumbers(arr []int, k int) []int { quicksort(arr, 0, len(arr)-1, k) return arr[:k] } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:40:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"41 数据流中的中位数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:41:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 hard 堆 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:41:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:41:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 对顶堆，注意go的堆写法，用到container/heap接口 type MedianFinder struct { minHeap *MinHeap maxHeap *MaxHeap } /** initialize your data structure here. */ func Constructor() MedianFinder { return MedianFinder{\u0026MinHeap{}, \u0026MaxHeap{}} } func (this *MedianFinder) AddNum(num int) { if this.maxHeap.Len() == 0 { heap.Push(this.maxHeap, num) } else { if num \u003e this.maxHeap.IntSlice[0] { heap.Push(this.minHeap, num) } else { heap.Push(this.maxHeap, num) } } if this.maxHeap.Len() \u003e this.minHeap.Len()+1 { heap.Push(this.minHeap, heap.Pop(this.maxHeap)) } if this.minHeap.Len() \u003e this.maxHeap.Len()+1 { heap.Push(this.maxHeap, heap.Pop(this.minHeap)) } } func (this *MedianFinder) FindMedian() float64 { if this.maxHeap.Len() == this.minHeap.Len()+1 { return float64(this.maxHeap.IntSlice[0]) } else if this.minHeap.Len() == this.maxHeap.Len() + 1 { return float64(this.minHeap.Heap.IntSlice[0]) } else { return float64(this.minHeap.IntSlice[0] + this.maxHeap.IntSlice[0]) / 2 } } type Heap struct { sort.IntSlice } type MinHeap struct { Heap } type MaxHeap struct { Heap } func (h *Heap) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) } func (h *Heap) Pop() interface{} { a := h.IntSlice v := h.IntSlice[len(a)-1] h.IntSlice = a[:len(a)-1] return v } func (minHeap *MinHeap) Less(i, j int) bool { return minHeap.Heap.IntSlice[i] \u003c minHeap.Heap.IntSlice[j] } func (maxHeap *MaxHeap) Less(i, j int) bool { return maxHeap.IntSlice[i] \u003e maxHeap.IntSlice[j] } /** * Your MedianFinder object will be instantiated and called as such: * obj := Constructor(); * obj.AddNum(num); * param_2 := obj.FindMedian(); */ ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:41:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"42 连续子数组的最大和 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:42:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy dp ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:42:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 给一个数组，求所有子数组中，子数组元素和的最大值。子数组是连续的 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:42:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func maxSubArray(nums []int) int { dp := nums[0] ans := dp max := func(x, y int) int {if x \u003e y {return x } else {return y}} for i, v := range nums { if i == 0 { continue } dp = max(dp+v, v) ans = max(ans, dp) } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:42:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"43 1～n 整数中 1 出现的次数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:43:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 hard 数位dp 预处理 递归 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:43:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:43:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 预处理dp[i]表示小于等于i位数的1的个数 对于数n，比如它为114514，就可以先算1-99999中1的个数，然后计算100000-114514的1的个数，接下来算最高位的1，有14515个，最后递归算1-14514的1的个数 再比如7355608，可以先算1-999999的1的个数，然后计算1000000-7355608的1的个数，接下来算最高位1，有1000000个，再算2000000-7355608，这等价于递归算1-355608中1的个数 func countDigitOne(n int) int { dp := make([]int, 11) dp[1] = 1 for i := 2; i \u003c 11; i++ { dp[i] += dp[i - 1] dp[i] += 9 * dp[i - 1] + int(math.Pow10(i - 1)) } digitNum := func(n int) int { if n == 0 {return 1} res := 0 for n != 0 { res++ n /= 10 } return res } var cal func(int) int min := func(x, y int) int {if x \u003e y {return y} else {return x}} cal = func(n int) int { num := digitNum(n) if num == 1 {if n \u003c 1 {return 0} else {return 1}} ans := dp[num - 1] tmp := n / int(math.Pow10(num - 1)) tmp-- ans += tmp * dp[num - 1] ans += min(n - int(math.Pow10(num - 1)) + 1, int(math.Pow10(num-1))) ans += cal(n % int(math.Pow10(num - 1 ))) return ans } return cal(n) } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:43:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"44 数字序列中某一位的数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:44:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 预处理 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:44:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 一个数字序列为123456789101112…，求第n位数字 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:44:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func findNthDigit(n int) int { if n \u003c= 9 { return n } f := make([]int, 14) f[1] = 9 base10 := 10 base1 := 2 for i := 2; i \u003c 11; i++ { f[i] = f[i-1] f[i] += 9 * base10 * base1 base10 *= 10 base1++ } for i := 1; i \u003c 14; i++ { if f[i] == n { return 9 } if f[i] \u003c n \u0026\u0026 f[i+1] \u003e n { n -= f[i] a := n/(i+1) + int(math.Pow10(i)) n %= i + 1 if n == 0 { a-- str := strconv.Itoa(a) str = str[len(str) - 1:] ret, _ := strconv.Atoi(str) return ret } else { str := strconv.Itoa(a) str = string(str[n-1]) ret, _ := strconv.Atoi(str) return ret } } } return 0 } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:44:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"45 把数组排成最小的数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:45:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 排序 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:45:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 把数组中的数进行排列，使得排列后的数按字符串形式组成新的数字，这个数字尽可能小 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:45:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 排序，定义排序规则，判断字符串a和b的摆放顺序，如果a+b字典序小于b+a，那么a在前b在后 注意go的写法 func minNumber(nums []int) string { sort.Slice(nums, func(i, j int) bool { return strconv.Itoa(nums[i]) + strconv.Itoa(nums[j]) \u003c strconv.Itoa(nums[j]) + strconv.Itoa(nums[i]) }) ans := \"\" for _, v := range nums { ans += strconv.Itoa(v) } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:45:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"46 把数字翻译成字符串 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:46:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dp ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:46:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 给一个数字，0可以翻译成a，1可以翻译成b，25可以翻译成z，求有多少种翻译方式 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:46:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func translateNum(num int) int { dp, dp2 := 1, 1 str := strconv.Itoa(num) for i := 1; i \u003c len(str); i++ { if str[i - 1] \u003e '2' || (str[i - 1] == '2' \u0026\u0026 str[i] \u003e '5') || str[i - 1] == '0' { dp2 = dp } else { dp, dp2 = dp + dp2, dp } } return dp } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:46:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"47 礼物的最大价值 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:47:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dp ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:47:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 有一个网格，每个格子上有数字，从左上角走到右下角，每次只能往右和下走，求走过的数字和最大值 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:47:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func maxValue(grid [][]int) int { if len(grid) == 0 || len(grid[0]) == 0 { return 0 } n, m := len(grid), len(grid[0]) dp := make([][]int, n) for i := range dp { dp[i] = make([]int, m) } max := func(x, y int) int {if x \u003e y {return x} else {return y}} dp[0][0] = grid[0][0] for i := 1; i \u003c n; i++ { dp[i][0] = dp[i - 1][0] + grid[i][0] } for i := 1; i \u003c m; i++ { dp[0][i] = dp[0][i - 1] + grid[0][i] } for i := 1; i \u003c n; i++ { for j := 1; j \u003c m; j++ { dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) + grid[i][j] } } return dp[n - 1][m - 1] } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:47:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"48 最长不含重复字符的子字符串 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:48:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 尺取 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:48:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:48:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func lengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } mp := make(map[uint8]int) for i := 'a'; i \u003c= 'z'; i++ { mp[uint8(i)] = 0 } l, r := 0, 1 mp[s[0]] = 1 ans := 1 max := func(x, y int) int {if x \u003e y {return x} else {return y}} for r \u003c len(s) { if mp[s[r]] \u003e 0 { mp[s[l]]-- l++ } else { mp[s[r]]++ r++ ans = max(ans, r - l) } } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:48:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"49 丑数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:49:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 堆 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:49:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:49:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 注意go里面堆的写法在pop里是取最后一个元素，默认是小根堆（最小的元素在最后）less是注释的写法 type Heap struct{ sort.IntSlice } func (h *Heap) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) } func (h *Heap) Pop() interface{} { a := h.IntSlice v := a[len(a)-1] h.IntSlice = a[:len(a)-1] return v } // func (h *Heap) Less(i, j int) bool { // return h.IntSlice[i] \u003c h.IntSlice[j] // } func nthUglyNumber(n int) int { mp := make(map[int]int) data := make([]int, 0) hp := \u0026Heap{} heap.Push(hp, 1) mp[1] = 1 for len(data) \u003c 1700 { tmp := heap.Pop(hp).(int) data = append(data, tmp) if _, ok := mp[tmp*2]; !ok { mp[tmp*2] = 1 heap.Push(hp, tmp*2) } if _, ok := mp[tmp*3]; !ok { mp[tmp*3] = 1 heap.Push(hp, tmp*3) } if _, ok := mp[tmp*5]; !ok { mp[tmp*5] = 1 heap.Push(hp, tmp*5) } } return data[n-1] } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:49:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"50 第一个只出现一次的字符 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:50:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 哈希 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:50:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:50:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func firstUniqChar(s string) byte { mp := make(map[byte]int) for i := 0; i \u003c len(s); i++ { mp[s[i]]++ } for i := 0; i \u003c len(s); i++ { if mp[s[i]] == 1 { return s[i] } } return ' ' } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:50:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"51 数组中的逆序对 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:51:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 hard 树状数组、归并排序、离散化 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:51:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 求数组中逆序对个数 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:51:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 经典的就是归并排序求，但是这个细节太多不好写，树状数组思路比较直接 时间复杂度都为O(nlogn)，空间复杂度都为O(n) 归并排序 func reversePairs(nums []int) int { n := len(nums) if n \u003c 2 {return 0} tmp := make([]int, n) var crossCount func(int, int, int) int crossCount = func(l int, mid int, r int) int { for i := l; i \u003c= r; i++ { tmp[i] = nums[i] } res := 0 ptrL, ptrR := l, mid + 1 for i := l; i \u003c= r; i++ { if ptrL == mid + 1 { nums[i] = tmp[ptrR] ptrR++ } else if ptrR == r + 1 { nums[i] = tmp[ptrL] ptrL++ } else if tmp[ptrL] \u003c= tmp[ptrR] { nums[i] = tmp[ptrL] ptrL++ } else { nums[i] = tmp[ptrR] ptrR++ res += mid - ptrL + 1 } } return res } var cal func(int, int) int cal = func(l int, r int) int { if l == r {return 0} mid := l + (r - l) / 2 leftCount := cal(l, mid) rightCount := cal(mid + 1, r) if nums[mid] \u003c= nums[mid + 1] { return leftCount + rightCount } return leftCount + rightCount + crossCount(l, mid, r) } return cal(0, n - 1) } 树状数组 注意go的slice深拷贝的另一种方法b = append(b, a[:]…) type FenwickTree struct { // [1,n] bit []int n int } func FenwickTreeConstructor(n int) FenwickTree { return FenwickTree{ bit: make([]int, n+1), n: n, } } func (ft *FenwickTree) sum(i int) int { s := 0 for i \u003e 0 { s += ft.bit[i] i -= i \u0026 -i } return s } func (ft *FenwickTree) add(i, x int) { for i \u003c= ft.n { ft.bit[i] += x i += i \u0026 -i } } func reversePairs(nums []int) int { n := len(nums) tmp := make([]int, n) copy(tmp, nums) sort.Ints(tmp) for i, v := range nums { nums[i] = sort.SearchInts(tmp, v) + 1 } fenwickTree := FenwickTreeConstructor(n) ans := 0 for i := 0; i \u003c n; i++ { ans += i - fenwickTree.sum(nums[i]) fenwickTree.add(nums[i], 1) } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:51:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"52 两个链表的第一个公共节点 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:52:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 双指针 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:52:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:52:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 哈希表做法的空间复杂度为O(n)。双指针，先求两链表谁更长，长的指针先移几格，然后上下指针同步移 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { lenA, lenB := 0, 0 for i := headA; i != nil; i = i.Next { lenA++ } for i := headB; i != nil; i = i.Next { lenB++ } ptrA, ptrB := headA, headB if lenA \u003e lenB { dif := lenA - lenB for dif \u003e 0 { ptrA = ptrA.Next dif-- } } else if lenB \u003e lenA { dif := lenB - lenA for dif \u003e 0 { ptrB = ptrB.Next dif-- } } for ptrA != nil \u0026\u0026 ptrB != nil { if ptrA == ptrB { return ptrA } else { ptrA, ptrB = ptrA.Next, ptrB.Next } } return nil } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:52:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"53-1 在排序数组中查找数字 I ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:53:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 二分 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:53:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 统计一个数字在排序数组中出现的次数。 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:53:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 注意细节 func search(nums []int, target int) int { if len(nums) == 0 { return 0 } i := sort.SearchInts(nums, target) if i == len(nums) || nums[i] != target { return 0 } else { j := sort.SearchInts(nums, target + 1) return j - i } } 手写二分 func binarySearch(nums []int, target int) int { l, r := 0, len(nums) - 1 for l \u003c= r { mid := l + (r-l)/2 if nums[mid] \u003e= target { r = mid - 1 } else { l = mid + 1 } } return l } func search(nums []int, target int) int { if len(nums) == 0 {return 0} i := binarySearch(nums, target) if i == len(nums) || nums[i] != target { return 0 } else { j := binarySearch(nums, target+1) return j - i } } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:53:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"53-2 0～n-1中缺失的数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:54:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 二分 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:54:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:54:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func missingNumber(nums []int) int { l, r := 0, len(nums)-1 for l \u003c= r { mid := l + (r-l)/2 if nums[mid] == mid { l = mid + 1 } else { r = mid - 1 } } return l } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:54:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"54 二叉搜索树的第k大节点 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:55:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy dfs ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:55:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:55:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 中序遍历 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func kthLargest(root *TreeNode, k int) int { nums := make([]int, 0) var dfs func(*TreeNode) dfs = func(node *TreeNode) { if node.Left != nil { dfs(node.Left) } nums = append(nums, node.Val) if node.Right != nil { dfs(node.Right) } } dfs(root) return nums[len(nums) - k] } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:55:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"55-1 二叉树的深度 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:56:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy dfs/bfs ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:56:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:56:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } ans := 0 max := func(x, y int) int { if x \u003e y { return x } else { return y } } var dfs func(*TreeNode, int) dfs = func(node *TreeNode, i int) { ans = max(ans, i) if node.Left != nil {dfs(node.Left, i + 1)} if node.Right != nil {dfs(node.Right, i + 1)} } dfs(root, 1) return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:56:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"55-2 平衡二叉树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:57:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy dfs ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:57:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:57:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { var dfs func(*TreeNode) int ans := true max := func(x, y int) int {if x \u003e y {return x} else {return y}} dfs = func(node *TreeNode) int { if !ans {return 0} if node == nil { return 0 } dl, dr := dfs(node.Left), dfs(node.Right) if dl-dr \u003e 1 || dr-dl \u003e 1 { ans = false return 0 } else { return max(dl, dr) + 1 } } dfs(root) return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:57:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"56-1 数组中数字出现的次数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:58:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 位运算、异或、思维 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:58:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 有一个数组，数组中有两个数各出现一次，其他数各出现两次，求出现一次的两个数，要求时间复杂度O(n)，空间复杂度O(1) 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:58:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 假设两个数为x和y，所有数异或得到x和y的异或值z，找到z的二进制表示的任意一位1，x和y在该位上一定是不同的，假设x在该位上是0，y在该位上是1。分类，遍历数组，把该位为0的放在一起异或，该位为1的放在一起异或，分别得到x和y func singleNumbers(nums []int) []int { a := 0 for _, v := range nums { a ^= v } i := 0 for a \u003e\u003e i \u0026 1 == 0 { i++ } x, y := 0, 0 for _, v := range nums { if v \u003e\u003e i \u0026 1 == 0 { x ^= v } else { y ^= v } } return []int{x, y} } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:58:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"56-2 数组中数字出现的次数 II ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:59:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 位运算、思维 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:59:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 有一个数组，数组中有一个数出现一次，其他数各出现三次，求出现一次的数，要求时间复杂度O(n)，空间复杂度O(1) 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:59:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 参考此处的视频题解 func singleNumber(nums []int) int { arr := make([]int, 32) for _, v := range nums { for j := 0; j \u003c 32; j++ { if v \u003e\u003e j \u0026 1 == 1 { arr[j]++ } } } ans := 0 for i := 0; i \u003c 32; i++ { if arr[i] % 3 != 0 { ans |= (1 \u003c\u003c i) } } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:59:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"57 和为s的两个数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:60:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 双指针 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:60:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 给一个递增数组，找两个数和为s，要求时间复杂度O(n)，空间复杂度O(1) 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:60:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 哈希表时间复杂度和空间复杂度都为O(n)，因为序列有序，用双指针空间复杂度为O(1) func twoSum(nums []int, target int) []int { ptrL, ptrR := 0, len(nums)-1 for ptrL \u003c ptrR { tmp := nums[ptrL] + nums[ptrR] if tmp == target { return []int{nums[ptrL], nums[ptrR]} } else if tmp \u003e target { ptrR-- } else { ptrL++ } } return nil } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:60:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"57-2 和为s的连续正数序列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:61:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 双指针 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:61:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:61:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func findContinuousSequence(target int) [][]int { ptrL, ptrR := 1, 2 sum := 1 ans := make([][]int, 0) for ptrL \u003c ptrR \u0026\u0026 ptrR \u003c target/2+3 { if sum == target { tmp := make([]int, 0) for i := ptrL; i \u003c ptrR; i++ { tmp = append(tmp, i) } ans = append(ans, tmp) sum += ptrR sum -= ptrL ptrR++ ptrL++ } else if sum \u003c target { sum += ptrR ptrR++ } else { sum -= ptrL ptrL++ } } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:61:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"58-1 翻转单词顺序 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:62:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:62:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:62:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func reverseWords(s string) string { strs := make([]string, 0) tmp := \"\" for i := 0; i \u003c len(s); i++ { if s[i] == ' ' { if tmp != \"\" { strs = append(strs, tmp) tmp = \"\" } } else { tmp += string(s[i]) } } if tmp != \"\" { strs = append(strs, tmp) } if len(strs) == 0 { return \"\" } ans := \"\" ans += strs[len(strs) - 1] for i := len(strs) - 2; i \u003e= 0; i-- { ans += \" \" ans += strs[i] } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:62:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"58-2 左旋转字符串 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:63:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:63:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:63:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func reverseLeftWords(s string, n int) string { ans := \"\" for i := n; len(ans) \u003c len(s); i++ { ans += string(s[i % len(s)]) } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:63:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"59-1 滑动窗口的最大值 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:64:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 hard 双端队列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:64:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:64:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 参考此处 func maxSlidingWindow(nums []int, k int) []int { if len(nums) == 0 { return []int{} } n := len(nums) ans := make([]int, n-k+1) deque := make([]int, 0) for i := 0; i \u003c n; i++ { if len(deque) != 0 \u0026\u0026 deque[0] \u003c= i - k { deque = deque[1:] } for len(deque) != 0 \u0026\u0026 nums[deque[len(deque) - 1]] \u003c= nums[i] { deque = deque[0:len(deque) - 1] } deque = append(deque, i) if i \u003e= k - 1 { ans[i - k + 1] = nums[deque[0]] } } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:64:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"59-2 队列的最大值 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:65:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 双端队列 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:65:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 求动态队列的最大值 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:65:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 和上一题类似，此处deque存的是值，不是下标。对于pop操作，需要判断deque的队首和pop出的元素是否相等，相等就说明最大值被pop了（此时可能后面还有最大值，所以deque存的是非严格的递减序列，保证最大值存了多个，例如：55543） type MaxQueue struct { deque []int queue []int } func Constructor() MaxQueue { return MaxQueue{ queue: make([]int, 0), deque: make([]int, 0), } } func (this *MaxQueue) Max_value() int { if len(this.deque) == 0 { return -1 } return this.deque[0] } func (this *MaxQueue) Push_back(value int) { this.queue = append(this.queue, value) for len(this.deque) != 0 \u0026\u0026 this.deque[len(this.deque)-1] \u003c value { this.deque = this.deque[0 : len(this.deque)-1] } this.deque = append(this.deque, value) } func (this *MaxQueue) Pop_front() int { if len(this.queue) == 0 { return -1 } ret := this.queue[0] this.queue = this.queue[1:] if ret == this.deque[0] { this.deque = this.deque[1:] } return ret } /** * Your MaxQueue object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Max_value(); * obj.Push_back(value); * param_3 := obj.Pop_front(); */ ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:65:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"60 n个骰子的点数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:66:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium dp ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:66:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 输入n，求n个骰子掷出所有点数的概率 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:66:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 暴力超时，dp，dp[i][j]表示仍i个骰子，和为j的概率 func dicesProbability(n int) []float64 { dp := make([][]float64, 15) for i := range dp { dp[i] = make([]float64, 70) } dp[0][0] = 1 for i := 1; i \u003c 12; i++ { for j := i; j \u003c= 6*i; j++ { for k := 1; k \u003c= 6; k++ { if j-k \u003e= 0 { dp[i][j] += dp[i-1][j-k] / 6 } } } } ans := make([]float64, 0) for i := n; i \u003c= 6 * n; i++ { ans = append(ans, dp[n][i]) } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:66:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"61 扑克牌中的顺子 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:67:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 模拟、思维 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:67:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 判断给定的5张排是不是顺子，大小王可以当作任意排 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:67:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 func isStraight(nums []int) bool { mn, mx := 100, -1 min := func(x, y int) int { if x \u003c y { return x } else { return y } } max := func(x, y int) int { if x \u003e y { return x } else { return y } } mp := make(map[int]int) for _, v := range nums { if v == 0 { continue } mn = min(mn, v) mx = max(mx, v) mp[v]++ } for _, v := range mp { if v \u003e 1 { return false } } return mx-mn \u003c= 4 } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:67:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"62 圆圈中最后剩下的数字 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:68:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 思维、数论 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:68:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 经典的约瑟夫环，有n个人，循环报数，报到m的倍数的人退出，求最后剩下的人 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:68:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 递归的做法是，假设这个答案为f(n, m) 首先第一个退出的人是第m%n个（此处如果m%n为0就是第n个），递归求f(n-1,m)，假设为x 对于n-1个数最后剩的是第x个，那么对于n个数最后剩的就是(m+x)%n个 递归退出条件是n=1时，返回0（第一个数）（此题第一个数是0，如果是1，返回1） func lastRemaining(n int, m int) int { if n == 1 {return 0} x := lastRemaining(n - 1, m) return (x + m) % n } 用迭代代替递归，将空间复杂度降到O(1)，迭代的写法从dfs最底层倒推，即f(1,m)-\u003ef(2,m)-\u003ef(3,m)-\u003ef(n,m) func lastRemaining(n int, m int) int { ans := 0 for i := 2; i \u003c= n; i++ { ans = (ans + m) % i } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:68:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"63 股票的最大利润 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:69:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 遍历、思维 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:69:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 求数组中一个数减另一个数的最大值，要求大的数在小的数右边 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:69:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 前后缀最大最小值，空间复杂度O(n) 直接遍历数组，在更新最小值时，更新最大值，保证最大值在最小值右边，空间复杂度O(1) func maxProfit(prices []int) int { if len(prices) == 0 {return 0} mn, mx := math.MaxInt64, -1 max := func(x, y int) int { if x \u003e y { return x } else { return y } } ans := -1 for _, v := range prices { if v \u003c mn { mn = v mx = mn } else { mx = max(mx, v) } ans = max(ans, mx - mn) } return ans } // [2,4,1] // wa 0 // ac 2 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:69:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"64 求1+2+…+n ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:70:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 思维 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:70:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:70:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 递归 func sumNums(n int) int { if n == 1 {return 1} return n + sumNums(n - 1) } 还可以用快速乘，把循环全部打开，最多只要14层循环 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:70:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"65 不用加减乘除做加法 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:71:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 位运算 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:71:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:71:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 模拟位运算，此处题意说可能出现负数，但实际上因为计算机中数的表示是补码形式，所以可以当作只考虑整数 如果没有进位，只要异或即可 有进位，需要在异或之后再加上进位 但是加上进位又可能产生进位，所以需要循环做这些事，直到进位为0 进位为何最后会为0？进位的求法是(a \u0026 b) « 1，只有同位都为1会产生进位，因为进位在前一位，所以左移一位。由于进位的求法是与操作，只有该位为1，结果才可能为1，而“暂时”的求和是异或操作，产生进位需要1和1,1和1异或为0，0再和原数的1与操作会变成0，相当于不断抵消1，所以进位1的数量会一直减少，直到没有 func add(a int, b int) int { var carry int for b != 0 { carry = (a \u0026 b) \u003c\u003c 1 a ^= b b = carry } return a } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:71:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"66 构建乘积数组 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:72:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 前后缀、思维 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:72:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 给一个数组A，求数组B，其中B[i]是A中除了i位置的元素积 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:72:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 前后缀积时间复杂度和空间复杂度为O(n) 可以先求前缀积再求后缀积，求的过程把当前积乘给对应的B[i]，空间复杂度为O(1) func constructArr(a []int) []int { if len(a) == 0 { return []int{} } n := len(a) ans := make([]int, n) for i := range ans { ans[i] = 1 } product := 1 for i := 1; i \u003c len(a); i++ { product *= a[i - 1] ans[i] *= product } product = 1 for i := len(a) - 2; i \u003e= 0; i-- { product *= a[i + 1] ans[i] *= product } return ans } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:72:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"67 把字符串转换成整数 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:73:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 medium 模拟 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:73:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:73:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 模拟，注意细节（溢出和前导0）。或者状态机 func strToInt(str string) int { if len(str) == 0 { return 0 } positive := true for len(str) != 0 \u0026\u0026 str[0] == ' ' { str = str[1:] } if len(str) == 0 { return 0 } if !(str[0] == '+' || str[0] == '-' || (str[0] \u003e= '0' \u0026\u0026 str[0] \u003c= '9')) { return 0 } if str[0] == '-' { positive = false str = str[1:] } else if str[0] == '+' { str = str[1:] } if len(str) == 0 || str[0] \u003c '0' || str[0] \u003e '9' { return 0 } numStr := \"\" for len(str) != 0 \u0026\u0026 str[0] \u003e= '0' \u0026\u0026 str[0] \u003c= '9' { numStr += string(str[0]) str = str[1:] } for len(numStr) != 0 \u0026\u0026 numStr[0] == '0' { // 在这里去掉前导0 numStr = numStr[1:] } if len(numStr) \u003e 12 { // 在这里就判断是否溢出 if positive { return math.MaxInt32 } else { return math.MinInt32 } } ans, base := 0, 1 for i := len(numStr) - 1; i \u003e= 0; i-- { ans += base * int(numStr[i]-'0') base *= 10 } if positive { if ans \u003e math.MaxInt32 { // 增加len(numStr) \u003e 12 防因溢出而判断失败，判断条件为len(numStr) \u003e 12 || ans \u003e math.MaxInt32，但这样无法通过注释2，因为base超了 return math.MaxInt32 } else { return ans } } else { if -ans \u003c math.MinInt32 { return math.MinInt32 } else { return -ans } } } // overflow maxint is 9223372036854775807 // \"9223372036854775808\" // wa -9223372036854775808 // ac 2147483647 // \" 0000000000012345678\" // wa 2147483647 // ac 12345678 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:73:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"68-1 二叉搜索树的最近公共祖先 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:74:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 二叉树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:74:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:74:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 二叉搜索树的lca一定是介于两个数之间 lc没有go，在nc上可以测试 package main import . \"nc_tools\" /* * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root *TreeNode, p int, q int) int { cnt := root for true { if (cnt.Val \u003e= p \u0026\u0026 cnt.Val \u003c= q) || (cnt.Val \u003e= q \u0026\u0026 cnt.Val \u003c= p) { return cnt.Val } else if cnt.Val \u003e p \u0026\u0026 cnt.Val \u003e q { cnt = cnt.Left } else { cnt = cnt.Right } } return 0 } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:74:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"68-2 二叉树的最近公共祖先 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:75:0","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"考点 easy 二叉树 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:75:1","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:75:2","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["problemlist"],"content":"题解 维护节点的父节点和深度，往上搜索时，先将深度持平，然后同步向上爬，直到相同 如果是多次求lca，可以倍增预处理 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { depth := make(map[*TreeNode]int) par := make(map[*TreeNode]*TreeNode) depth[nil] = -1 var dfs func(*TreeNode, *TreeNode) dfs = func(node, pa *TreeNode) { depth[node] = depth[pa] + 1 par[node] = pa if node.Left != nil { dfs(node.Left, node) } if node.Right != nil { dfs(node.Right, node) } } dfs(root, nil) for depth[p] \u003e depth[q] { p = par[p] } for depth[q] \u003e depth[p] { q = par[q] } for p != q { p = par[p] q = par[q] } return p } ","date":"2022-07-24","objectID":"/%E5%89%91%E6%8C%87offer/:75:3","tags":["problemlist"],"title":"剑指offer","uri":"/%E5%89%91%E6%8C%87offer/"},{"categories":["GAME"],"content":"CS:GO参数设置","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"N卡设置 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:1:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"Config文件 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:2:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"默认 命名为conf.cfg rate \"786432\" alias +cjump \"+jump; +duck\" alias -cjump \"-jump; -duck\" bind \"space\" \"+cjump\" cl_interp \"0\" cl_interp_ratio \"1\" viewmodel_recoil \"0\" bind \"Capslock\"\"+jump;-attack;-attack2;-jump\" sv_grenade_trajectory \"1\" bind \"MWHEELDOWN\" \"toggle cl_righthand 1 0\" ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:2:1","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"跑图 命名为paotu.cfg mp_freezetime 0 mp_limitteams 10 mp_autoteambalance 0 mp_buytime \"999\" bot_kick cl_showpos 1 sv_cheats 1 bot_stop 1 sv_infinite_ammo 1 mp_startmoney 16000 mp_buytime \"999\" sv_grenade_trajectory 1 sv_grenade_trajectory_thickness 1 sv_infinite_ammo 1 mp_restartgame \"1\" mp_roundtime_defuse 60 bind \"alt\" \"noclip\" bind \"f1\" \"sv_rethrow_last_grenade\" mp_buy_anywhere \"1\" ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:2:2","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"启动项 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:3:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"steam -high -freq 144 -tickrate 128 +exec conf.cfg ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:3:1","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"5e ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:3:2","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"游戏设置 edpi = 400 * 2.17 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:4:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["GAME"],"content":"显示器设置 ","date":"2022-07-13","objectID":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/:5:0","tags":[],"title":"CS:GO参数设置","uri":"/csgo%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"},{"categories":["note"],"content":"Learning CPP","date":"2022-02-09","objectID":"/learning-cpp/","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"\rIntroduction\r学习一下c++ 教程视频地址，搬运自youtube 个人认为是一个非常不错的c++教程 空着的待补 ","date":"2022-02-09","objectID":"/learning-cpp/:0:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"How C++ works pre-process compile link ","date":"2022-02-09","objectID":"/learning-cpp/:1:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Variables ","date":"2022-02-09","objectID":"/learning-cpp/:2:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Functions ","date":"2022-02-09","objectID":"/learning-cpp/:3:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Header Files 当我们需要在cpp文件中用别的cpp的函数，需要先声明（declaration） 声明函数\rmain.cpp // main.cpp #include \u003ciostream\u003e void log(const char* msg) { std::cout \u003c\u003c msg \u003c\u003c std::endl; } int main() { log(\"hello world\"); return 0; } log.cpp // log.cpp void log(const char* msg); void initLog() { log(\"hello world\"); } 使用头文件的基本例子 使用头文件\rmain.cpp // main.cpp #include \u003ciostream\u003e #include \"log.h\" int main() { initLog(); log(\"hello world\"); return 0; } log.cpp #include \"log.h\" #include \u003ciostream\u003e void initLog() { log(\"yello\"); } void log(const char* msg) { std::cout \u003c\u003c msg \u003c\u003c std::endl; } log.h #pragma once void initLog(); void log(const char* message); CMakeLists.txt cmake_minimum_required(VERSION 3.16) project(LearnCPP) set(CMAKE_CXX_STANDARD 20) add_executable(main main.cpp) add_executable(log log.cpp) add_library(liblog log.h log.cpp) target_link_libraries(main liblog) #pragma once 的意思是这个头文件只会被include一次到一个编译单元（translate unit）（即一个cpp文件）中 举一个错误的例子 不使用#pragma once的错误例子\rmain.cpp #include \u003ciostream\u003e #include \"log.h\" int main() { initLog(); log(\"hello world\"); return 0; } log.cpp #include \"log.h\" #include \"common.h\" #include \u003ciostream\u003e void initLog() { log(\"yello\"); } void log(const char* msg) { std::cout \u003c\u003c msg \u003c\u003c std::endl; } log.h // #pragma once void initLog(); void log(const char* message); struct hello {}; common.h #pragma once #include \"log.h\" 编译之后， 另一种发挥 #pragma once 的方法是，在log.h中这样写，这个意思是如果没定义_LOG_H则会定义_LOG_H为一下代码，可见当include一次后_LOG_H就会被定义，所以之后不会在执行这些代码 #ifndef _LOG_H #define _LOG_H void initLog(); void log(const char* message); struct hello {}; #endif 带 # 的都是预处理指令，在编译前执行，include\u003c\u003e和include\"“的区别是前者在系统库所在路径下搜寻，后者在当前项目的相对路径下搜寻 include某个cpp文件就相当于把那个cpp文件的代码拷贝到这个cpp文件中 为什么cpp的头文件没有.h？ 这是为了和c的头文件区分，c++的头文件不含.h，比如iostream，cstring ","date":"2022-02-09","objectID":"/learning-cpp/:4:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"How to debug ","date":"2022-02-09","objectID":"/learning-cpp/:5:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Conditions and Branches ","date":"2022-02-09","objectID":"/learning-cpp/:6:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Project Structures ","date":"2022-02-09","objectID":"/learning-cpp/:7:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Loops ","date":"2022-02-09","objectID":"/learning-cpp/:8:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Pointers 指针只是一个地址，他所存储的数据取决于你所要的字节长度 void* ptr = 0; void* 表示暂时不关心这个数据的类型，只是声明一个指针， 0就是NULL，在cpp源码中有 #define NULL 0和 #define NULL ((void*)0), 或者用nullptr表示真正意义上的空指针 指针的间接引用（derefence） #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { int a = 8; int* ptr = \u0026a; *ptr = 10; log(a); return 0; } //output // 10 new delete #include \u003ciostream\u003e #include \u003cmemory.h\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { char *buffer = new char[8]; memset(buffer, 0, 8); delete[] buffer; return 0; } 指向指针的指针 #include \u003ciostream\u003e #include \u003cmemory.h\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { char *buffer = new char[8]; memset(buffer, 0, 8); char** ptr = \u0026buffer; delete[] buffer; return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:9:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"References 引用是一种基于指针的语法糖（Syntactic sugar） 基本例子 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { int a = 5; int\u0026 ref = a; ref = 2; log(a); return 0; } //output // 2 引用在初始化时就要指定一个变量，在指定完变量后，不能更改（即不能变成其他变量的引用），如果硬要这样做的话只能用指针 ","date":"2022-02-09","objectID":"/learning-cpp/:10:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Classes 类成员和函数需要public声明才可以在外部访问和初始化，默认是private。 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Player { public: int x, y, speed; void go(int dx, int dy) { x = dx; y = dy; } }; int main() { Player player{}; player.go(1, 2); return 0; } class和struct的区别是class的成员变量和函数默认是private，struct是public。struct可以继承，但不会去使用。看起来struct似乎是没有必要的，之所以有struct是因为它要和c兼容，c只有struct，没有class。 struct和class的使用场景没有严格要求，看个人习惯 struct适合用在数据的集合，class适合当作对象，具有比较大的功能 在写class的时候注意变量和函数的可见性（public，private，protected），protected变量可以被子类的访问 ","date":"2022-02-09","objectID":"/learning-cpp/:11:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Static static有两种，在结构体和类内的，在外面的。 外部的static，the linkage of the symbol declared as static is going to be internal, i.e. only visible in the translation unit defined in 内部的static，share memory with all instances of the class/struct; i.e. among all the instances created in this class/struct: only one instance of the variable 要使用外部的变量或函数，用extern，告诉linker这个变量或函数在外面找 extern和static举例\rmain.cpp #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl extern int var; // declaration int main() { log(var); return 0; } // output // 11 static.cpp //static int var = 11; int var = 11; // definition CMakeLists.txt （关键） add_library(libstatic static.cpp) target_link_libraries(main libstatic) 函数同理 实际上static非常常用，extern似乎还有很多用法，参考网上 类或结构体内部的static，用它修饰的变量，在创建多个实例时，不会创建多个变量（不会多分配内存） #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct Entity { static int x, y; static void Print() { std::cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c std::endl; } }; int Entity::x; int Entity::y; int main() { Entity e1, e2; // e1.x = 2; e1.y = 3; // e1.Print(); // e2.x = 4; e2.y = 5; // e2.Print(); Entity::x = 2; Entity::y = 3; e2.Print(); Entity::Print(); return 0; } // output // 2 3 // 2 3 注意如果变量非static，函数就不能用static，因为static函数不能访问非static变量 local static变量，它只有一个变量，尽管所在代码块被调用多次，因为它是local的，所以不能被外界访问 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void func() { static int i = 0; i++; log(i); } int main() { func(); func(); func(); func(); return 0; } // output // 1 // 2 // 3 // 4 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Singleton { public: static Singleton\u0026 get() { static Singleton instance; return instance; } void hello() { } }; int main() { Singleton::get().hello(); return 0; } 如果去掉local static，那么Singleton就会在栈上创建，特别是返回值是引用时会产生很大的错误，如果没有引用，那就是返回一份复制，没多大问题。 ","date":"2022-02-09","objectID":"/learning-cpp/:12:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Enums 作用：增加代码可读性 enum里面的值默认是从0递增的，且是整数，当然你可以给它赋值 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct node { enum haha { A, B }; }; enum e1 { A, B, C = 4 }; enum e2 : char { a, b, c, d }; int main() { node::A; // 注意这种写法，A需要在enum里，否则需要加static int foo = B; e1 bar = B; // 这样bar只能是e1中的值 int hoge = bar; log(bar); log(hoge); return 0; } //output //1 //1 ","date":"2022-02-09","objectID":"/learning-cpp/:13:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Constructors 构造函数本身就存在，再java中变量初始化为0，c++并不是，是之前存在内存中的值，构造函数可以对其初始化，构造函数可以写多个（只要参数不同就行），这就是重载（overload） #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class node { public: int x, y; node() { x = 1; y = 2; } [[maybe_unused]] node(int q, int w) { // [[maybe_unused]] 抑制针对未使用实体的警告, c++ 17 x = q; y = w; } void Print() const { std::cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c std::endl; } }; int main() { node n1; n1.Print(); node n2(4, 5); n2.Print(); return 0; } //output // 1 2 // 4 5 一种不允许创建实例的方法是把构造函数写在private里或者写[类名]() = delete 这样默认构造函数被删除了，这样你只能使用类的static函数 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class node { private: //node() {} public: int x, y; node() = delete ; }; int main() { node n1{}; return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:14:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Destructor 析构函数默认也有，在对象被销毁时调用 c++类的四个默认函数，构造函数、析构函数、拷贝函数、赋值函数 class String { public: String(const char *str = NULL); // 普通构造函数 String(const String \u0026other); // 拷贝构造函数 ~ String(void); // 析构函数 String \u0026 operate =(const String \u0026other); // 赋值函数 private: char *m_data; // 用于保存字符串 }; String a(“hello”); String b(“world”); String c = a; // 调用了拷贝构造函数，最好写成c(a); c = b; // 调用了赋值函数 参考 注意：析构函数没有重载，如果只自己写了一个构造函数，它不算重载，因为默认构造函数会被抛弃 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class node { public: int x, y; node() { x = 1, y = 2; log(\"created\"); } ~node() { log(\"destroyed\"); } void Print() { std::cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c std::endl; } }; void func() { node n1; n1.Print(); n1.~node(); // 不推荐这样写 } int main() { func(); return 0; } //output // //created //1 2 //destroyed //destroyed ","date":"2022-02-09","objectID":"/learning-cpp/:15:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Inheritance 子类的类型可以是父类，如果一个函数的参数是父类，则输入子类也是可以的。 三种继承 公有继承(public) 公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。 私有继承(private) 私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。 保护继承(protected) 保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。 参考 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: float x, y; Entity() { x = 1.0f; y = 2.0f; } void move(float dx, float dy) { x += dx; y += dy; } }; class Player : public Entity { public: const char *name; Player() { name = \"robot\"; } void PrintName() const { log(name); } }; int main() { Player player; log(player.x); log(player.y); log(player.name); log(sizeof(Entity)); log(sizeof(Player)); return 0; } //output //1 //2 //robot //8 //16 ","date":"2022-02-09","objectID":"/learning-cpp/:16:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Virtual Functions 看一下代码 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: std::string GetName() { return \"Entity\"; } }; class Player : public Entity { private: std::string mName; public: Player(const std::string\u0026 name) : mName(name) {} std::string GetName() { return mName; } }; void PrintName(Entity* entity) { log(entity-\u003eGetName()); } int main() { Entity *e1 = new Entity(); Player* p1 = new Player(\"dyh\"); PrintName(e1); PrintName(p1); return 0; } //output //Entity //Entity 之所以会输出两个Entity是因为PrintName()的参数类型是Entity，所以会当作Entity。 虚函数通过虚表（vtable）来编译，虚表是类中所有虚函数映射的表，通过虚表可以找到正确重写的函数。 当你需要在子类中重写父类的方法时，需要把父类的方法设置为虚函数 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: virtual std::string GetName() { return \"Entity\"; } }; class Player : public Entity { private: std::string mName; public: Player(const std::string\u0026 name) : mName(name) {} std::string GetName() override { return mName; } }; void PrintName(Entity* entity) { log(entity-\u003eGetName()); } int main() { Entity *e1 = new Entity(); Player* p1 = new Player(\"dyh\"); PrintName(e1); PrintName(p1); return 0; } //output //Entity //dyh 虚函数的额外开销：虚表需要占一定的空间，基类有一个指针指向虚表，调用虚函数时，需要遍历虚表。但这些开销在大部分情况下都可以忽略不计 ","date":"2022-02-09","objectID":"/learning-cpp/:17:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Interfaces (Pure Virtual Functions) 纯虚函数就是虚函数里不写任何内容，带有纯虚函数的父类不能被实例化，就想java的接口不能实例化只能实现。如果父类有纯虚函数，子类必须重写该函数才可以被实例化。 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: virtual std::string GetName() = 0; }; class Player : public Entity { private: std::string mName; public: Player(const std::string\u0026 name) : mName(name) {} std::string GetName() override { return mName; } }; void PrintName(Entity* entity) { log(entity-\u003eGetName()); } int main() { //Entity *e1 = new Entity(); // error Entity* e1 = new Player(\"\"); Player* p1 = new Player(\"dyh\"); PrintName(e1); PrintName(p1); return 0; } //output // //dyh 下列代码中如果Player类没有重写GetClassName()函数，则输出两个Entity #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Printable { public: virtual std::string GetClassName() = 0; }; class Entity : public Printable { public: virtual std::string GetName() { return \"hello\"; } std::string GetClassName() override { return \"Entity\"; } }; class Player : public Entity { private: std::string mName; public: Player(const std::string \u0026name) : mName(name) {} std::string GetName() override { return mName; } std::string GetClassName() override { return \"Player\"; } }; void Print(Printable *obj) { log(obj-\u003eGetClassName()); } int main() { Entity *e = new Entity(); Player *p = new Player(\"dyh\"); Print(e); Print(p); return 0; } //output //Entity //Player ","date":"2022-02-09","objectID":"/learning-cpp/:18:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Visibility c++ 的三种可见性：private、protected、public。可以把一个类或函数标记成另一个类的友元（friend），这样它就可以访问这个类的private成员 public大家都可以访问、private只有类成员可以访问（友元也行）、protected只有基类和派生类可以访问 ","date":"2022-02-09","objectID":"/learning-cpp/:19:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Arrays 如果一个函数想返回一个数组，就要用new来创建，除非传入地址参数 创建数组的方式有三种 #include \u003ciostream\u003e #include \u003carray\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { int a[5]; //在栈上面创建的，这个代码块结束后，它会被销毁 a[2] = 3; log(a[2]); // 3 int *ptr = a; *(ptr + 2) = 4; log(a[2]); // 4 *(int *) ((char *) ptr + 8) = 5; log(a[2]); // 5 log(sizeof(a)); // 20 log(sizeof(*a)); // 4 log(sizeof(\u0026a)); // 8 int *b = new int[5]; //创建在堆上（内存间接寻址），直到用delete销毁或程序结束 log(sizeof(b)); // 8 // 地址长度 delete[] b; int c[] = {1, 2, 3}; std::array\u003cint, 5\u003e d{}; return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:20:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Strings 两种形式：char数组和std::string（或者wide string） #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void Print(const std::string\u0026 x) { //加const是因为我们不想让x被修改，加\u0026是因为这样就变成一个引用，不需要拷贝字符串，拷贝字符串很占时间 log(x); } int main() { char a[3] = {'d', 'y', 'h'}; log(a); // dyh?Y╗ 后面的随机字符是因为char数组没有\\0作为结束标志，所以不知道打印到哪里 std::string b = \"dyh\"; log(b); // dyh Print(b); // dyh return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:21:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"String Literals 字符串字面量就是双引号之间的字符们，它总是存储在只读内存中 #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { // char* name = \"dyh\"; // warning: ISO c++11 does not allow conversion from string literal to 'char*' // name[1] = 'a'; // char* name = (char*) \"dyh\"; //这样去修改字符是一种未定义的行为undefined behavior，所以不要这样做，如果要修改字符串数组应该按下面的方式写 // name[1] = 'a'; //这个代码会让程序崩溃 char another[5] = \"dyh\"; //按这种方式写。用数组不要用指针 another[1] = 'a'; const char *yes = \"dyh\"; // 当用char指针时，最好加上const，这样可以提醒自己用char*时不能修改内容 // const char* yes = u8\"dyh\"; const wchar_t *bar = L\"dyh\"; // 长度由编译器决定，一般wins2字节，Linux4字节，macos4字节 const char16_t *foo = u\"dyh\"; const char32_t *hoge = U\"dyh\"; using namespace std::string_literals; std::string pop = \"happy \"s + \"new year\"; // s是一个函数 std::wstring pop2 = L\"happy\"s + L\"new year\"; std::u32string pop3 = U\"happy\"s + U\"new year\"; const char *example = R\"(Line1 Line2 Line3 Line4)\"; // R可以忽略转义字符，可以多行输入而不会黏在一起 log(example); return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:22:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Const const修饰指针 #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { //const int* a = new int; // 不能改变指针存储的值，但可以改变指针的指向 //int const* a = new int; // 同上 // int* const a = new int; // 可以改变指针存储的值，不能改变指针的指向 //const int* const a = new int; //*a = 2; int b = 100; //a = \u0026b; //log(*a); return 0; } 如果是 int* a, b;那么a是指针，b是int型，如果是int* a, *b; 那么a是指针，b是指针 #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { int x, y; int* ptr; mutable int var; public: int getx() const { // 只有在类里面才这么用 意思是只读取类数据，不修改 var = 2; //用mutable修饰的变量可以修改 return x; } int getx() { return x; } const int* const getptr() const { // 返回一个不能改变指向，不能改变存储数据的指针 return ptr; } void setx(int xx) { x = xx; } }; void Print(const Entity\u0026 e) { log(e.getx()); //如果把getx的const去掉，e就不能调用getx()，因为getx可能会修改类，这样与形参的const冲突，尽管getx并没有改变类 // 只要有const版本的getx存在就行 } int main() { return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:23:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Mutable mutable的两种用法：一种是和const一起用，一种是和lambda #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { int x = 5; auto f = [=]() mutable { // 在按值传递的情况下，如果把mutable去掉，就要改成下面的代码，它们是等价的 x++; // lambda里使用mutable的情况极少见 log(x); // int y = x; // y++; // log(y); // log(x); }; f(); log(x); return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:24:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Member Initializer Lists (Constructor Initializer Lists) #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { std::string m_name; int m_score; public: Entity() : m_name(\"hello\"), m_score(123) {} // 初始化顺序最好和声明的顺序一样 Entity(const std::string\u0026 name) : m_name(name), m_score(456) {} }; int main() { return 0; } 初始化列表和赋值形式初始化还有功能上的区别，看以下两段代码的区别。如果不用列表，类将会被实例化两次，用初始化列表，类被初始化一次，节省资源 #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class A { public: A() { log(\"created\"); } A(int x) { log(x); } }; class B { private: int x; A a; public: B() { x = 3; a = A(2); } }; int main() { B b; return 0; } //output //created //2 #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class A { public: A() { log(\"created\"); } A(int x) { log(x); } }; class B { private: int x; A a; public: B() : x(3), a(A(2)) {} //B() : x(3), a(2) {} // 效果和上面相同 }; int main() { B b; return 0; } //output // 2 ","date":"2022-02-09","objectID":"/learning-cpp/:25:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Ternary Operators 为什么用三元运算符，因为它快，更整洁 ","date":"2022-02-09","objectID":"/learning-cpp/:26:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"How to Create Instantiate Object 实例化就是看在堆上创建还是在栈上 在堆上，你决定什么时侯销毁，在栈上，超出作用域就销毁 在堆上创建实例的理由有：不想在超出作用域后被销毁，对象太大了，在栈上创建很多太占空间，栈比较小，会爆栈 在堆上分配会比在栈上费时间 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { private: string m_name; public: Entity() : m_name(\"hello\") {} Entity(const string\u0026 name) : m_name(name) {} const string\u0026 getname() const { return m_name; } }; int main() { Entity *e; { //Entity entity(\"dyh\"); // 在栈上创建，过了这个代码块就会被销毁 Entity* entity = new Entity(\"dyh\"); // 在堆上创建 //e = \u0026entity; e = entity; delete entity; } //delete entity; // wrong should be 'delete e' return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:27:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"New new 返回分配的内存的指针 placement new 留坑 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { private: string m_name; public: Entity() : m_name(\"hello\") {} Entity(const string\u0026 name) : m_name(name) {} const string\u0026 getname() const { return m_name; } }; int main() { Entity* entity = new Entity; Entity* e = (Entity*) malloc(sizeof(Entity)); // 不要用这种，它没有调用构造函数，而且可读性差 return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:28:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Implicit Conversion and Explicit Keyword #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { private: string m_name; int m_age; public: Entity(const string\u0026 name) : m_name(name), m_age(-1) {} Entity(int x) : m_name(\"unknown\"), m_age(x) {} }; int main() { // 一般不会这样写代码，可读性差 Entity e = 22; // int implicit convert to Entity //Entity e2 = \"abc\"; // wrong, because \"abc\" is char array type not string Entity e2 = (string) \"abc\"; // ok return 0; } explicit 禁止隐式转化 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { private: string m_name; int m_age; public: Entity(const string\u0026 name) : m_name(name), m_age(-1) {} explicit Entity(int x) : m_name(\"unknown\"), m_age(x) {} }; int main() { Entity e = 22; // wrong return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:29:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Operators and Operator Overloading java不支持运算符重载 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Vector2d { public: float x, y; //Vector2d() {} Vector2d(float x, float y) : x(x), y(y) {} Vector2d add(const Vector2d\u0026 other) const { //return *this + other; return operator+(other); // 两种都行 } Vector2d operator+(const Vector2d \u0026other) const { return Vector2d(x + other.x, y + other.y); } bool operator==(const Vector2d\u0026 other) const { return x == other.x \u0026\u0026 y == other.y; } }; // 重载\u003c\u003c流运算符，在class外面，因为这和class无关，而且写到类里面报错。这里重载\u003c\u003c很像java里的to_string方法 // 重载==就像重写equals std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const Vector2d\u0026 v) { stream \u003c\u003c v.x \u003c\u003c \", \" \u003c\u003c v.y; return stream; } int main() { Vector2d v1(2.0f, 1.0f), v2(3.0f, 7.0f); //Vector2d v3 = v1 + v2; Vector2d v3 = v1.add(v2); log(v3.x); log(v3.y); log(v3); bool condition = v1 == v2; condition = v1 != v2; return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:30:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"This this是指向当前对象的指针且是const修饰的，比如const A* 试试在class里写delete this（X） ","date":"2022-02-09","objectID":"/learning-cpp/:31:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Object Lifetime 在栈上创建 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: Entity() { log(\"created entity\"); } ~Entity() { log(\"destroyed entity\"); } }; int main() { { Entity entity; } return 0; } //created entity //destroyed entity 在堆上创建 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: Entity() { log(\"created entity\"); } ~Entity() { log(\"destroyed entity\"); } }; int main() { { Entity* entity = new Entity; } return 0; } //created entity int* CreateArray() { // int a[20]; //这是错误的，因为它在栈上创建 // return a; int* a = new int[20]; return a; } 如果想用new在堆上分配，又想在跳出作用域时自动删除（智能指针雏形） #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: Entity() { log(\"created entity\"); } ~Entity() { log(\"destroyed entity\"); } }; class ScopedPtr { private: Entity* m_ptr; public: ScopedPtr(Entity* entity) : m_ptr(entity) {} ~ScopedPtr() { delete m_ptr; } }; int main() { { ScopedPtr ptr = new Entity(); // implicit conversion } return 0; } //created entity //destroyed entity ","date":"2022-02-09","objectID":"/learning-cpp/:32:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Smart Pointers unique_ptr unique_ptr不能复制，因为如果复制的话，当之前的指针指向的内存区域释放后，复制的指针将指向已释放的内存，这没有意义 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: Entity() { log(\"created entity\"); } ~Entity() { log(\"destroyed entity\"); } void Print() { } }; int main() { //std::unique_ptr\u003cEntity\u003e entity(new Entity); std::unique_ptr\u003cEntity\u003e entity = std::make_unique\u003cEntity\u003e(); // 更安全的写法，如果构造函数跑出异常，它不会得到一个悬空的指针而造成内存泄露 entity-\u003ePrint(); // std::unique_ptr\u003cEntity\u003e e(entity); // std::unique_ptr\u003cEntity\u003e e = entity; // unique_ptr不能复制 return 0; } shared_ptr 使用引用计数（reference counting），就是记录有多少个指针指向它，如果引用计数变成0就删掉这块内存 如果shared_ptr复制给weak_ptr ，不会增加这个内存的引用计数。weak_ptr 不会真正占有内存块 使用时优先考虑unique，如果必须要复制，再用shared，shared比unique开销大 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: Entity() { log(\"created entity\"); } ~Entity() { log(\"destroyed entity\"); } void Print() { } }; int main() { std::shared_ptr\u003cEntity\u003e entity = std::make_shared\u003cEntity\u003e(); // 一般不用new，因为share_ptr需要控制块来记录引用计数，如果用new，要做两次内存分配，一次是new Entity，一次是分配控制块，用这种方法可以把它们结合起来更高效 std::shared_ptr\u003cEntity\u003e e1 = entity; std::weak_ptr\u003cEntity\u003e e2 = e1; return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:33:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Copying and Copy Constructors #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { int a = 2; int b = a; // copy value b = 3; log(a); int *c; *c = 5; int *d = c; // copy pointer *d = 6; log(*c); return 0; } // 2 // 6 // 6 以下是模拟写一个string类 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class String { private: char* m_buffer; unsigned int m_size; public: String(const char* string) { m_size = strlen(string); m_buffer = new char[m_size + 1]; memcpy(m_buffer, string, m_size); m_buffer[m_size] = 0; //or memcpy(m_buffer, string, m_size + 1); } ~String() { delete[] m_buffer; } friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string); }; std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string) { stream \u003c\u003c string.m_buffer; return stream; } int main() { String s = \"hello\"; //String s(\"hello\"); String s1 = s; // 这样拷贝程序会崩溃，因为s1的指针和s的指针一样，指向同一块内存区域，当s1析构时，内存区域被释放了，s析构时，又会对同一片区域释放，出错 log(s); log(s1); return 0; } // hello // hello 重载[]运算符 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class String { private: char* m_buffer; unsigned int m_size; public: String(const char* string) { m_size = strlen(string); m_buffer = new char[m_size + 1]; memcpy(m_buffer, string, m_size); m_buffer[m_size] = 0; //or memcpy(m_buffer, string, m_size + 1); } ~String() { delete[] m_buffer; } char\u0026 operator[](unsigned int index) { return m_buffer[index]; } friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string); }; std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string) { stream \u003c\u003c string.m_buffer; return stream; } int main() { String s = \"hello\"; //String s(\"hello\"); String s1 = s; // （浅拷贝）这样拷贝程序会崩溃，因为s1的指针和s的指针一样，指向同一块内存区域，当s1析构时，内存区域被释放了，s析构时，又会对同一片区域释放，出错 s1[1] = 'a'; log(s); log(s1); return 0; } // hallo // hallo 只拷贝了指针却没有拷贝指针所指向的区域，这是浅拷贝（shallow copy）如何才能拷贝指针且拷贝指针指向的区域（不同的指针加上不同的内存区域），这是深拷贝（deep copy）。深拷贝可以通过改写拷贝构造函数实现 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class String { private: char* m_buffer; unsigned int m_size; public: String(const char* string) { m_size = strlen(string); m_buffer = new char[m_size + 1]; memcpy(m_buffer, string, m_size); m_buffer[m_size] = 0; //or memcpy(m_buffer, string, m_size + 1); } //String(const String\u0026 other) : m_buffer(other.m_buffer), m_size(other.m_size) {} // 这是c++提供的默认的拷贝构造函数 // String(const String\u0026 other) { // 实际上c++提供的默认拷贝构造函数是这样的 // memcpy(this, \u0026other, sizeof(String)); // } // deep copy String(const String\u0026 other) : m_size(other.m_size) { log(\"copyed\"); m_buffer = new char[m_size + 1]; memcpy(m_buffer, other.m_buffer, m_size + 1); } ~String() { delete[] m_buffer; } char\u0026 operator[](unsigned int index) { return m_buffer[index]; } friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string); }; std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 stream, const String\u0026 string) { stream \u003c\u003c string.m_buffer; return stream; } // 用引用避免不必要的拷贝，用const是因为它不会被修改，要多用const引用，好处多多 void Print(const String\u0026 s) { log(s); } int main() { String s = \"hello\"; //String s(\"hello\"); String s1 = s; // （浅拷贝）这样拷贝程序会崩溃，因为s1的指针和s的指针一样，指向同一块内存区域，当s1析构时，内存区域被释放了，s析构时，又会对同一片区域释放，出错 s1[1] = 'a'; Print(s); Print(s1); return 0; } // hello // hallo 记得多用const引用！ ","date":"2022-02-09","objectID":"/learning-cpp/:34:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Arrow -\u003e重载的使用和场景 如果不用重载，要这样写 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: int x; void Print() const { log(\"hello\"); } }; class ScopedPtr { private: Entity* entity; public: ScopedPtr(Entity* e) : entity(e) { } ~ScopedPtr() { delete entity; } Entity* getObj() { return entity; } }; int main() { ScopedPtr e = new Entity(); // Implicit conversion e.getObj()-\u003ePrint(); // 要这样写 return 0; } 重载运算符就这样写了 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { public: int x; void Print() const { log(\"hello\"); } }; class ScopedPtr { private: Entity* entity; public: ScopedPtr(Entity* e) : entity(e) { } ~ScopedPtr() { delete entity; } Entity* operator-\u003e() { return entity; } const Entity* operator-\u003e() const { return entity; } }; int main() { ScopedPtr e = new Entity(); // Implicit conversion //const ScopedPtr e = new Entity(); //如果用const就加上const版本的重载 e-\u003ePrint(); return 0; } -\u003e的一个应用，取数据的偏移地址 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct A { float x, y, z; // Q：想找y或者z在内存里对于x的偏移 }; int main() { // 为了可读性全加上括号 // 经实验c++20不能把地址转换成int int offsetx = (int) (\u0026(((A*) nullptr)-\u003ex)); // 0 int offsety = (int) (\u0026(((A*) nullptr)-\u003ex)); // 4 log(offsetx); int x = 5; int y = (int)\u0026x; // wrong return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:35:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Vector vector作为动态数组为什么叫vector，据设计者称，这是一个命名错误，详见网上资料 vector的使用优化 以下这段代码之所以会拷贝那么多次是因为 首先在main栈上创建值为123的Vertex对象，然后将值为123的Vertex对象拷贝进vector中，这是1次。在main栈上创建值为456的Vertex对象，然后因为vector的大小默认为1，空间不够，所以在内存中找一块值为2或更大的空间，然后把Vertex123拷贝进那个空间，这是第2次，再将Vertex456拷贝进那个空间，这是第3次，其他同理。但是输出的copied并不像预想的那么多，是因为机器不同、当前环境不同，实际的过程略有差异 优化的方法，1：预先分配一定大小的空间，减少对象的转移 2：直接在vector后面创建，不要在main栈里创建，再拷贝 #include \u003ciostream\u003e #include \u003cvector\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct Vertex { float x, y, z; Vertex(float x, float y, float z) : x(x), y(y), z(z) {} Vertex(const Vertex\u0026 v) : x(v.x), y(v.y), z(v.z) { log(\"copied\"); } }; int main() { std::vector\u003cVertex\u003e vertices; vertices.push_back({1, 2, 3}); vertices.push_back({4, 5, 6}); vertices.push_back({7, 8, 9}); vertices.push_back({10, 11, 12}); return 0; } //copied //copied //copied //copied //copied //copied //copied 针对优化1 #include \u003ciostream\u003e #include \u003cvector\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct Vertex { float x, y, z; Vertex(float x, float y, float z) : x(x), y(y), z(z) {} Vertex(const Vertex\u0026 v) : x(v.x), y(v.y), z(v.z) { log(\"copied\"); } }; int main() { std::vector\u003cVertex\u003e vertices; vertices.reserve(4); vertices.push_back({1, 2, 3}); vertices.push_back({4, 5, 6}); vertices.push_back({7, 8, 9}); vertices.push_back({10, 11, 12}); return 0; } //copied //copied //copied //copied 针对优化2，注意emplace_back传入的是数字参数，而不是对象 #include \u003ciostream\u003e #include \u003cvector\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct Vertex { float x, y, z; Vertex(float x, float y, float z) : x(x), y(y), z(z) {} Vertex(const Vertex\u0026 v) : x(v.x), y(v.y), z(v.z) { log(\"copied\"); } }; int main() { std::vector\u003cVertex\u003e vertices; vertices.reserve(4); vertices.emplace_back(1, 2, 3); vertices.emplace_back(4, 5, 6); vertices.emplace_back(7, 8, 9); vertices.emplace_back(10, 11, 12); return 0; } // ","date":"2022-02-09","objectID":"/learning-cpp/:36:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Multiple Return Values 用pair、tuple、struct等等 std::tie 和 std::ignore 的用法 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctuple\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { std::tuple\u003cint, float, std::string\u003e tp = std::make_tuple(3, 2.0f, \"qwe\"); int x; float y; std::string z; std::tie(x, y, z) = tp; log(x); log(y); log(z); std::tie(x, std::ignore, z) = tp; return 0; } //3 //2 //qwe ","date":"2022-02-09","objectID":"/learning-cpp/:37:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Templates #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl //template\u003cclass T\u003e //它们是连在一起的，叫模板，Print不是一个单独的函数，如果没有调用这个函数，这个函数就不存在，只有在调用时，才会根据类型创建出函数（代码） template\u003ctypename T\u003e void Print(T x) { log(x); } int main() { Print(3); Print(\"hello\"); Print(5.2); Print\u003cint\u003e(4); return 0; } #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl template\u003ctypename T, int N\u003e class Array { private: T m_array[N]; public: int getsize() const { return N; } }; int main() { Array\u003cint, 5\u003e array; log(array.getsize()); return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:38:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Stack vs Heap Memory 程序运行时，操作系统会分配一堆的ram，堆和栈是ram中的区域 栈通常是一个固定大小的区域，大概为2M，堆可以扩充 栈的空间分配是连续的，很快的，堆的分配比较慢，一个主要原因是，栈的空间分配是预先分配好的，堆的空间分配不是预先分配的，堆的每一次分配都要找空间碎片。 另一个影响效率的是cache命中率的问题 ","date":"2022-02-09","objectID":"/learning-cpp/:39:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Macros 宏很适合用来调试 #include \u003ciostream\u003e //#ifdef LOCAL //#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl //#else //#define log(x) //#endif //以下写法比上面更好 #if LOCAL == 1 #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl #else #define log(x) #endif //#if LOCAL == 1 //#define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl //#elif defined(DEBUG) //#define log(x) //#endif //#if 0 //#endif //多行的define, \\是enter的转义，\\后不要打符号 #define Main int main() {\\ int a = 3;\\ log(a);\\ return 0;\\ } Main ","date":"2022-02-09","objectID":"/learning-cpp/:40:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"auto auto的一个用法，当类型很长时用auto代替，有时候可以这样写const auto\u0026 #include \u003ciostream\u003e #include \u003cfunctional\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { //c++ 14 auto func = [\u0026](int x) -\u003e int { return x + 1; }; return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:41:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Static Arrays std::array 固定类型、固定长度 std::array的好处是具有STL特性，可以用STL函数 时间也很快 基本不占额外的空间 #include \u003ciostream\u003e #include \u003carray\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl //int fun(std::array\u003cint, 3\u003e a) { // return (int) a.size(); //} //一种不用传递数组大小也能知道数组大小的方式 //template\u003ctypename T, size_t n\u003e //int fun(const T (\u0026arr)[n]) { // return (int) n; //} template\u003ctypename T\u003e int fun(const T\u0026 a) { return (int) a.size(); } int main() { std::array\u003cint, 6\u003e data; data[0] = 1; data[1] = 2; int a[] = {1, 2, 3}; //log(fun(a)); // 3 log(fun(data)); // 6 return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:42:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Function Pointers #include \u003ciostream\u003e #include \u003carray\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void Print(int x) { log(\"hello\"); log(x); } int main() { auto func = Print; func(5); void(*foo)(int); foo = Print; foo(6); typedef void(*PrintFunction)(int); PrintFunction bar = Print; bar(7); return 0; } // hello // 5 // hello // 6 // hello // 7 #include \u003ciostream\u003e #include \u003cvector\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void Print(int x) { log(x); } void ForEach(const std::vector\u003cint\u003e\u0026 v, void(*func)(int)) { for (int i : v) { func(i); } } int main() { std::vector\u003cint\u003e v = {5, 4, 3, 2, 1}; ForEach(v, Print); return 0; } //5 //4 //3 //2 //1 ","date":"2022-02-09","objectID":"/learning-cpp/:43:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"lambdas #include \u003ciostream\u003e #include \u003cvector\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void ForEach(const std::vector\u003cint\u003e\u0026 v, void(*func)(int)) { for (int i : v) { func(i); } } int main() { std::vector\u003cint\u003e v = {5, 4, 3, 2, 1}; auto fun = [](int x){log(x);}; ForEach(v, fun); return 0; } //5 //4 //3 //2 //1 捕获（capture） [a, \u0026b] a通过复制捕获，b通过引用捕获 [this] 通过引用捕获当前对象 [\u0026] 通过引用捕获所有变量和当前对象 [=] 通过拷贝捕获所有变量，通过引用捕获当前对象 [] 不捕获 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cfunctional\u003e #include \u003calgorithm\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void ForEach(const std::vector\u003cint\u003e\u0026 v, const std::function\u003cvoid(int)\u003e\u0026 func) { // 不加const报错 for (int i : v) { func(i); } } int main() { std::vector\u003cint\u003e v = {5, 4, 3, 2, 1}; int a = 5; auto fun = [\u0026](int x){log(x);}; // 传值，也可以修改变量的值，要加mutable ForEach(v, fun); std::find_if(v.begin(), v.end(), [\u0026](int val){return val \u003e 3;}); return 0; } //5 //4 //3 //2 //1 ","date":"2022-02-09","objectID":"/learning-cpp/:44:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Namespaces 命名空间是为了避免命名冲突 命名空间可以嵌套 类本身就是一个命名空间 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cfunctional\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl namespace apple { void Print(const char* text) { log(text); } } namespace orange { void Print(const char* text) { std::string tmp = text; std::reverse(tmp.begin(), tmp.end()); log(tmp); } } int main() { apple::Print(\"apple\"); orange::Print(\"orange\"); //using namespace apple; //using apple::Print; //namespace a = apple; // 两个namespace不能同时存在 return 0; } //apple //egnaro ","date":"2022-02-09","objectID":"/learning-cpp/:45:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Threads #include \u003ciostream\u003e #include \u003cthread\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void DoWork() { while (true) { log(\"working\"); std::cin.get(); } } int main() { std::thread worker(DoWork); // 在这里立即启动线程，并行运行 worker.join(); //运行到这一步时，阻塞当前线程（主线程），等待这个线程执行完再回到主线程 std::cin.get(); // 有了上面的join，在DoWork没有执行完是不会执行这一步的 return 0; } //... 想实现按回车结束某个线程 #include \u003ciostream\u003e #include \u003cthread\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl static bool is_finished = false; void DoWork() { using namespace std::literals::chrono_literals; log(std::this_thread::get_id()); while (!is_finished) { log(\"working\"); std::this_thread::sleep_for(1s); } } int main() { std::thread worker(DoWork); std::cin.get(); is_finished = true; worker.join(); std::cin.get(); return 0; } //2 //working //working //working //working ","date":"2022-02-09","objectID":"/learning-cpp/:46:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Timing #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cchrono\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { using namespace std::literals::chrono_literals; auto start = std::chrono::high_resolution_clock::now(); std::this_thread::sleep_for(1s); auto end = std::chrono::high_resolution_clock::now(); std::chrono::duration\u003cfloat\u003e duration = end - start; log(duration.count()); return 0; } //1.0006 一种更好的计算方式 #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cchrono\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct Timer { std::chrono::time_point\u003cstd::chrono::steady_clock\u003e start, end; std::chrono::duration\u003cfloat\u003e duration; Timer() { start = std::chrono::steady_clock::now(); } ~Timer() { end = std::chrono::steady_clock::now(); duration = end - start; std::cout \u003c\u003c duration.count() * 1000 \u003c\u003c \" ms\" \u003c\u003c std::endl; } }; void Print() { Timer timer; for (int i = 0; i \u003c 100; ++i) { log(\"hello world\"); // endl比'\\n'慢 } } int main() { Print(); return 0; } //hello world //... // 37.1672 ms ","date":"2022-02-09","objectID":"/learning-cpp/:47:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Multidimensional Arrays 一维数组比多维数组好 待补 ","date":"2022-02-09","objectID":"/learning-cpp/:48:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Sorting sort中，true和false的意义 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { std::vector\u003cint\u003e a = {2, 4, 5, 1, 3}; // 让1排在最后 std::sort(a.begin(), a.end(), [](int a, int b) { if (a == 1) return false; // false表示a在后，b在前，true相反 if (b == 1) return true; return a \u003c b; }); for (int i : a) { std::cout \u003c\u003c i \u003c\u003c ' '; } return 0; } //2 3 4 5 1 ","date":"2022-02-09","objectID":"/learning-cpp/:49:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Type Punning 类型双关 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { int a = 5; double b = a; // 隐式转化，内存的内容改动 log(b); double c = *(double *) \u0026a; // 内存的值不变，变成用double读取 log(c); return 0; } //5 //2.47033e-323 ","date":"2022-02-09","objectID":"/learning-cpp/:50:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Unions 联合体中的变量内存值相同，只占一个变量的空间 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { struct Union { union { float a; int b; }; }; Union u; u.a = 2.0f; log(u.a); log(u.b); return 0; } //2 //1073741824 union的用法 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct Vector2d { float x, y; }; struct Vector4d { union { // anonymous struct { // anonymous float x, y, z, w; }; struct { Vector2d a, b; // a的值就是x，y的值， b的值就是z，w的值 }; }; }; void PrintV2(const Vector2d\u0026 v) { std::cout \u003c\u003c v.x \u003c\u003c ' ' \u003c\u003c v.y \u003c\u003c '\\n'; } int main() { Vector4d v4 = {1.0f, 2.0f, 3.0f, 4.0f}; PrintV2(v4.a); PrintV2(v4.b); v4.z = 500.f; PrintV2(v4.a); PrintV2(v4.b); return 0; } //1 2 //3 4 //1 2 //500 4 ","date":"2022-02-09","objectID":"/learning-cpp/:51:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Virtual Destructors 和虚构造函数类似 虚函数在有子类的情况下通常都要考虑 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Base { public: Base() { log(\"base constructor\"); } ~Base() { log(\"base destructor\"); } }; class Derived : public Base { public: Derived() { log(\"derived constructor\"); } ~Derived() { // 对于基类不是重写，而是增加一个析构函数 log(\"derived destructor\"); } }; int main() { Base* base = new Base(); delete base; log(\"----------\"); Derived* derived = new Derived(); delete derived; log(\"----------\"); Base* poly = new Derived(); delete poly; return 0; } //base constructor //base destructor //---------- //base constructor //derived constructor //derived destructor //base destructor //---------- //base constructor //derived constructor //base destructor 可以看到最后没有调用derived的析构函数，这可能造成内存泄露，比如在derived的构造函数中new内存，在derived的析构函数中delete，但是因为没有调用，所有没有释放（这种情况在堆上有） #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Base { public: Base() { log(\"base constructor\"); } virtual ~Base() { log(\"base destructor\"); } }; class Derived : public Base { public: Derived() { log(\"derived constructor\"); } ~Derived() { // 对于基类不是重写，而是增加一个析构函数 log(\"derived destructor\"); } }; int main() { Base* base = new Base(); delete base; log(\"----------\"); Derived* derived = new Derived(); delete derived; log(\"----------\"); Base* poly = new Derived(); // 多态 delete poly; return 0; } //base constructor //base destructor //---------- //base constructor //derived constructor //derived destructor //base destructor //---------- //base constructor //derived constructor //derived destructor //base destructor ","date":"2022-02-09","objectID":"/learning-cpp/:52:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Casting c++风格的casting比c风格的casting，好在如果你想要去掉casting，你要去搜索，在c里要搜索int，在c++里要搜索static_cast\u003cint\u003e，这比int好搜。另一个好处是编译器会做严格的检查 static_cast , dynamic_cast , reinterpret_cast, const_cast #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Base { public: Base() {} virtual ~Base() {} }; class Derived : public Base { public: Derived() {} ~Derived() {} }; class AnotherClass : public Base { public: AnotherClass(){}; ~AnotherClass(){}; }; int main() { Derived* derived = new Derived(); Base* base = derived; //AnotherClass* ac = dynamic_cast\u003cAnotherClass*\u003e(base); // ac is null Derived* ac = dynamic_cast\u003cDerived*\u003e(base); // ac is not null // dynamic会在运行时检查 return 0; } dynamic casting #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { }; class Player : public Entity { }; class Enemy : public Entity { }; int main() { Player* player = new Player(); Entity* e = player; // ok Player* p = dynamic_cast\u003cPlayer*\u003e(e); // e可以是enemy，所以错了，但是在Entity加虚函数就行，多态 return 0; } #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Entity { virtual void Print() {} }; class Player : public Entity { }; class Enemy : public Entity { }; int main() { Player* player = new Player(); Entity* actuallyEnemy = new Enemy(); Entity* actuallyPlayer = player; Player* p0 = dynamic_cast\u003cPlayer*\u003e(actuallyEnemy); //p0是null Player* p1 = dynamic_cast\u003cPlayer*\u003e(actuallyPlayer); // p1不是null // 之所以可以吧Entity类转化成功，是因为根本不用担心Entity是enemy，因为加了虚函数相当于Entity是个接口，Entity不会被实例化 // Entity只能是Player或者Enemy，根据上文actuallyPlayer已经是player了，所以转换成功 if (dynamic_cast\u003cPlayer*\u003e(actuallyEnemy)) { // 用if检查是否能转换 } return 0; } dynamic_cast可以做到检查类型是因为它存储了RTTI（runtime type information） dynamic_cast 存储RTTI增加了开销，检查类型是否匹配也增加了开销 ","date":"2022-02-09","objectID":"/learning-cpp/:53:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Conditional and Action Breakpoints 在断点处设置条件，当条件为true时，触发断点 ","date":"2022-02-09","objectID":"/learning-cpp/:54:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Precompiled Headers ","date":"2022-02-09","objectID":"/learning-cpp/:55:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Benchmarking 怎样测试一个代码块的运行时间 #include \u003ciostream\u003e #include \u003cmemory\u003e #include \u003cchrono\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Timer { public: Timer() { startTimePoint = std::chrono::steady_clock::now(); } ~Timer() { stop(); } void stop() { auto endTimePoint = std::chrono::steady_clock::now(); auto start = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(startTimePoint).time_since_epoch().count(); auto end = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(endTimePoint).time_since_epoch().count(); auto duration = end - start; std::cout \u003c\u003c duration \u003c\u003c \" us\" \u003c\u003c std::endl; } private: std::chrono::time_point\u003cstd::chrono::steady_clock\u003e startTimePoint; }; int main() { int v = 0; { Timer timer; for (int i = 0; i \u003c 1000000; ++i) { // 有时候编译器会对这段代码进行优化，直接得出结果，这样就测不出时间 v += 2; } } log(v); __debugbreak(); //手动打断点 return 0; } share_ptr new unique_ptr性能对比 最好再release模式下测试，release比debug快，会减少很多不必要的东西 #include \u003ciostream\u003e #include \u003cmemory\u003e #include \u003cchrono\u003e #include \u003carray\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class Timer { public: Timer() { startTimePoint = std::chrono::steady_clock::now(); } ~Timer() { stop(); } void stop() { auto endTimePoint = std::chrono::steady_clock::now(); auto start = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(startTimePoint).time_since_epoch().count(); auto end = std::chrono::time_point_cast\u003cstd::chrono::microseconds\u003e(endTimePoint).time_since_epoch().count(); auto duration = end - start; std::cout \u003c\u003c duration \u003c\u003c \" us\" \u003c\u003c std::endl; } private: std::chrono::time_point\u003cstd::chrono::steady_clock\u003e startTimePoint; }; int main() { struct V { float x, y; }; log(\"make share\"); { std::array\u003cstd::shared_ptr\u003cV\u003e, 1000\u003e sharePtrs; Timer timer; for (int i = 0; i \u003c sharePtrs.size(); i++) { sharePtrs[i] = std::make_shared\u003cV\u003e(); } } log(\"new shared\"); { std::array\u003cstd::shared_ptr\u003cV\u003e, 1000\u003e sharePtrs; Timer timer; for (int i = 0; i \u003c sharePtrs.size(); i++) { sharePtrs[i] = std::shared_ptr\u003cV\u003e(new V()); } } log(\"make unique\"); { std::array\u003cstd::unique_ptr\u003cV\u003e, 1000\u003e uniquePtrs; Timer timer; for (int i = 0; i \u003c uniquePtrs.size(); i++) { uniquePtrs[i] = std::make_unique\u003cV\u003e(); } } //__debugbreak(); //手动打断点 return 0; } //debug //make share //405 us //new shared //322 us //make unique //219 us // //release //make share //126 us //new shared //184 us //make unique //66 us ","date":"2022-02-09","objectID":"/learning-cpp/:56:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Structured Bindings c++17特性 处理多返回值问题 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003ctuple\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl std::tuple\u003cstd::string, int\u003e createPerson() { return {\"dyh\", 22}; } int main() { auto [name, age] = createPerson(); return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:57:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Optional Data std::optional c++17特性 optional修饰的数据可有可无 optional用法 #include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003coptional\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl std::optional\u003cstd::string\u003e ReadFileAsString(const std::string\u0026 filepath) { std::ifstream stream(filepath); if (stream) { std::string result; // read file stream.close(); return result; } return {}; } int main() { std::optional\u003cstd::string\u003e data = ReadFileAsString(\"data.txt\"); std::string value = data.value_or(\"not present\"); if (data) { // if(data.has_value) log(\"read successfully\"); } else { //std::string\u0026 string = *data; data.value(); log(\"file could not be opened\"); } return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:58:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Multiple Types of Data in A Single Variable std::variant c++17特性 它和union的区别是，union的大小是最大变量的长度，variant的长度是每个类型长度和 #include \u003ciostream\u003e #include \u003cvariant\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { std::variant\u003cstd::string, int\u003e data; // 要按这个顺序读取 data = \"dyh\"; log(std::get\u003cstd::string\u003e(data)); data = 12; log(std::get\u003cint\u003e(data)); log(data.index()); if (auto val = std::get_if\u003cstd::string\u003e(\u0026data)) { // 如果不是string，返回NULL std::string\u0026 v = *val; } return 0; } //dyh //12 //1 variant在读取文件的应用 enum class ErrorCode { None = 0, NotFound = 1, NotAccess = 2; }; std::variant\u003cstd::string, ErrorCode\u003e ReadFileAsStirng() { return {}; } ","date":"2022-02-09","objectID":"/learning-cpp/:59:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Store Any Data std::any c++17特性 any和variant的区别，any会动态分配空间，variant要先指定类型 应该要多用variant，而不是any，variant是安全版的any #include \u003ciostream\u003e #include \u003cany\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { std::any a; a = 2; a = \"hello\"; //const char* a = std::string(\"abc\"); log(std::any_cast\u003cstd::string\u003e(a)); return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:60:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Make C++ Run Faster 用多线程 #include \u003ciostream\u003e #include \u003cfuture\u003e #include \u003cvector\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl namespace Hazel { static std::mutex s_MeshMutex; std::vector\u003cHazel::Ref\u003cHazel::Mesh\u003e\u003e m_Meshes; // void是因为LoadMesh的返回值是void std::vector\u003cstd::future\u003cvoid\u003e\u003e m_Futures; // 为什么string不传引用，这是生命周期的问题。线程函数参数按值传送，传拷贝，如果传引用要用Ref包裹， static void LoadMesh(std::vector\u003cRef\u003cMesh\u003e\u003e* meshes, std::string filepath) { auto mesh = Mesh::Load(filepath); std::lock_guard\u003cstd::mutex\u003e lock(s_MeshMutex); meshed-\u003epush_back(mesh); } void func() { #define ASYNC 1 #if ASYNC // concurrent for-loop for (const auto\u0026 file : meshFilepaths) { // std::launch::async 在不同线程上工作, deferred是根据工作负载自动选线程 // async返回std::future，要保留这个返回值，因为如果不保留，每次for循环结束后，async就会被摧毁（被析构），而析构需要等待LoadMesh结束，，这样就变成顺序执行 m_Futures.push_back(std::async(std::launch::async, LoadMesh, \u0026m_Meshes, file)); } #else // original for-loop for (const auto\u0026 file : meshFilepaths) { m_Meshes.push_back(Mesh::Load(file)); } #endif } } int main() { return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:61:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Make Strings Faster 使用string_view减少内存分配，本质是个指针 #include \u003ciostream\u003e #include \u003cstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl static uint32_t s_AllocCount = 0; void* operator new(size_t size) { s_AllocCount++; std::cout \u003c\u003c \"Allocating \" \u003c\u003c size \u003c\u003c \" bytes\\n\"; return malloc(size); } void Print(const std::string\u0026 x) { log(x); } void Print(std::string_view x) { log(x); } int main() { std::string name = \"yhdai\"; // 把string换成const char*更快，这样后面不需要加c_str() Print(name); //std::string firstName = name.substr(0, 2); //std::string lastName = name.substr(2, 3); log(s_AllocCount); // 0 不同编译器有不同结果 //减少字符串分配的一种方法是用string_view，本质是一个指针 std::string_view firstName(name.c_str(), 2); std::string_view lastName(name.c_str() + 2, 3); Print(firstName); Print(lastName); return 0; } //yhdai //0 //yh //dai ","date":"2022-02-09","objectID":"/learning-cpp/:62:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Track Memory Allocation the Easy Way #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmemory\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl struct AllocationMetrics { uint32_t TotalAllocated = 0; uint32_t TotalFreed = 0; uint32_t CurrentUsage() const {return TotalAllocated - TotalFreed;} }; static AllocationMetrics allocationMetrics; void* operator new(size_t size) { allocationMetrics.TotalAllocated += size; return malloc(size); } void operator delete(void* memory, size_t size) { allocationMetrics.TotalFreed += size; free(memory); } static void PrintMemoryUsage() { std::cout \u003c\u003c \"memory usage: \" \u003c\u003c allocationMetrics.CurrentUsage() \u003c\u003c \" bytes\\n\"; } struct obj { int x, y, z; }; int main() { PrintMemoryUsage(); std::string str = \"dddyyyhhh\"; PrintMemoryUsage(); { std::unique_ptr\u003cobj\u003e ptr = std::make_unique\u003cobj\u003e(); PrintMemoryUsage(); } PrintMemoryUsage(); return 0; } //memory usage: 0 bytes //memory usage: 0 bytes //memory usage: 12 bytes //memory usage: 0 bytes ","date":"2022-02-09","objectID":"/learning-cpp/:63:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Lvalues and Rvalues 通常人们会说左值是等号左边的值，右值是等号右边的值，这不一定对。 左值一般指某个地址的值，右值一般指一个没有地址的数据，暂时的数据 #include \u003ciostream\u003e int\u0026 func() { static int v = 10; return v; } #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { int a = 5; func() = 3; // func返回int\u0026可以，它是左值，返回int不行 func() = a; return 0; } #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl int main() { int a = 5; int\u0026 b = a; //int\u0026 c = 3; // wrong 右值不能赋给左值引用 const int\u0026 c = 3; // ok 等价于int tmp = 3; int\u0026 c = tmp; return 0; } 一种检查左值还是右值的方法，不加const的类型引用，这只接收左值，不接受右值，加上const都接收 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void Print(std::string\u0026 str) { std::cout \u003c\u003c str \u003c\u003c std::endl; } void Print2(const std::string\u0026 str) { std::cout \u003c\u003c str \u003c\u003c std::endl; } int main() { // a,b,c is lvalue, \"qwe\", \"asd\", a + b is rvalue std::string a = \"qwe\"; std::string b = \"asd\"; std::string c = a + b; Print(a); //Print(a + b); // wrong Print2(a + b); return 0; } //qwe //qweasd 函数参数只接受右值，不接受左值，用\u0026\u0026 #include \u003ciostream\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl void Print(std::string\u0026\u0026 str) { std::cout \u003c\u003c str \u003c\u003c std::endl; } void Print2(const std::string\u0026 str) { std::cout \u003c\u003c str \u003c\u003c std::endl; } int main() { // a,b,c is lvalue, \"qwe\", \"asd\", a + b is rvalue std::string a = \"qwe\"; std::string b = \"asd\"; std::string c = a + b; //Print(a); // wrong Print(a + b); Print(\"qwe\"); return 0; } //qweasd //qwe ","date":"2022-02-09","objectID":"/learning-cpp/:64:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Move Semantics #include \u003ciostream\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class String { public: String() = default; String(const char *str) { printf(\"created\\n\"); m_size = strlen(str); m_data = new char[m_size]; memcpy(m_data, str, m_size); } String(const String\u0026 other) { printf(\"copied\\n\"); m_size = other.m_size; m_data = new char[m_size]; memcpy(m_data, other.m_data, m_size); } ~String() { printf(\"destroyed\"); delete m_data; } void Print() { for (uint32_t i = 0; i \u003c m_size; ++i) { printf(\"%c\", m_data[i]); } printf(\"\\n\"); } private: char *m_data; uint32_t m_size; }; class Entity { public: Entity(const String\u0026 name) : m_name(name) { } void PrintName() { m_name.Print(); } private: String m_name; }; int main() { Entity entity(\"hello\"); entity.PrintName(); return 0; } //created //copied //hello 以上代码可以发现hello被分配了两次，一次在main函数里，一次在String的构造函数的new里，hello会在Entity的String m_name里被拷贝（通过new）。那么是否有方法在main函数里分配一次，然后把这段内存“移动”（实际数据并不是真正移动了）到Entity的String m_name里？ 这样实现move #include \u003ciostream\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class String { public: String() = default; String(const char *str) { printf(\"created\\n\"); m_size = strlen(str); m_data = new char[m_size]; memcpy(m_data, str, m_size); } String(const String\u0026 other) { // 深拷贝 printf(\"copied\\n\"); m_size = other.m_size; m_data = new char[m_size]; memcpy(m_data, other.m_data, m_size); } String(String\u0026\u0026 other) noexcept { // 只能传右值，右值优先选这个函数 // implement MOVE //相当于直接占据那块内存，指针指向那块内存，原来的指针（other）让它失效(因为析构里有delete) printf(\"moved\"); m_size = other.m_size; m_data = other.m_data; other.m_size = 0; other.m_data = nullptr; } ~String() { printf(\"destroyed\\n\"); delete m_data; } void Print() { for (uint32_t i = 0; i \u003c m_size; ++i) { printf(\"%c\", m_data[i]); } printf(\"\\n\"); } private: char *m_data; uint32_t m_size; }; class Entity { public: Entity(const String\u0026 name) : m_name(name) { } Entity(String\u0026\u0026 name) : m_name(name) { //只传右值，右值优先选这个函数 } void PrintName() { m_name.Print(); } private: String m_name; }; int main() { Entity entity(\"hello\"); entity.PrintName(); return 0; } //created //copied //destroyed //hello //destroyed 但是还是有copy，这是因为还是使用了String(const String\u0026 other)，应该使用Entity(String\u0026\u0026 name) : m_name((String\u0026\u0026) name) 或者Entity(String\u0026\u0026 name) : m_name(std::move(name)) #include \u003ciostream\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class String { public: String() = default; String(const char *str) { printf(\"created\\n\"); m_size = strlen(str); m_data = new char[m_size]; memcpy(m_data, str, m_size); } String(const String\u0026 other) { // 深拷贝 printf(\"copied\\n\"); m_size = other.m_size; m_data = new char[m_size]; memcpy(m_data, other.m_data, m_size); } String(String\u0026\u0026 other) noexcept { // 只能传右值，右值优先选这个函数 // implement MOVE //相当于直接占据那块内存，指针指向那块内存，原来的指针（other）让它失效(因为析构里有delete) printf(\"moved\\n\"); m_size = other.m_size; m_data = other.m_data; other.m_size = 0; other.m_data = nullptr; } ~String() { printf(\"destroyed\\n\"); delete m_data; } void Print() { for (uint32_t i = 0; i \u003c m_size; ++i) { printf(\"%c\", m_data[i]); } printf(\"\\n\"); } private: char *m_data; uint32_t m_size; }; class Entity { public: Entity(const String\u0026 name) : m_name(name) { } Entity(String\u0026\u0026 name) : m_name((String\u0026\u0026) name) { //只传右值，右值优先选这个函数 } void PrintName() { m_name.Print(); } private: String m_name; }; int main() { Entity entity(\"hello\"); entity.PrintName(); return 0; } //created //moved //destroyed //hello //destroyed ","date":"2022-02-09","objectID":"/learning-cpp/:65:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Move move把一个对象“移到”一个地方 #include \u003ciostream\u003e #include \u003ccstring\u003e #define log(x) std::cout \u003c\u003c x \u003c\u003c std::endl class String { public: String() = default; String(const char *str) { printf(\"created\\n\"); m_size = strlen(str); m_data = new char[m_size]; memcpy(m_data, str, m_size); } String(const String\u0026 other) { // 深拷贝 printf(\"copied\\n\"); m_size = other.m_size; m_data = new char[m_size]; memcpy(m_data, other.m_data, m_size); } String(String\u0026\u0026 other) noexcept { // 只能传右值，右值优先选这个函数 // implement MOVE //相当于直接占据那块内存，指针指向那块内存，原来的指针（other）让它失效(因为析构里有delete) printf(\"moved\\n\"); m_size = other.m_size; m_data = other.m_data; other.m_size = 0; other.m_data = nullptr; } String\u0026 operator=(String\u0026\u0026 other) noexcept { printf(\"moved\\n\"); if (this != \u0026other) { // 防止 a = std::move(a); delete [] m_data; m_size = other.m_size; m_data = other.m_data; other.m_size = 0; other.m_data = nullptr; } return *this; } ~String() { printf(\"destroyed\\n\"); delete m_data; } void Print() { for (uint32_t i = 0; i \u003c m_size; ++i) { printf(\"%c\", m_data[i]); } printf(\"\\n\"); } private: char *m_data; uint32_t m_size; }; class Entity { public: Entity(const String\u0026 name) : m_name(name) { } Entity(String\u0026\u0026 name) : m_name(std::move(name)) { //只传右值，右值优先选这个函数 } void PrintName() { m_name.Print(); } private: String m_name; }; int main() { Entity entity(\"hello\"); entity.PrintName(); String s = \"world\"; String t = std::move(s); //s.Print(); // wrong s is moved //t = s; // wrong puts(\"\"); String apple = \"Apple\"; String q; //q = apple; // wrong q = std::move(apple); // ok String w = apple; // ok 没有用到等号运算符，用构造函数 String e = std::move(apple); // ok 用move版构造函数 return 0; } ","date":"2022-02-09","objectID":"/learning-cpp/:66:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"How to Learn C++ 看需要的或感兴趣的开源项目 ","date":"2022-02-09","objectID":"/learning-cpp/:67:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note"],"content":"Conclusions 不会真有人不学rust学c++吧😅 ","date":"2022-02-09","objectID":"/learning-cpp/:68:0","tags":["cpp"],"title":"Learning CPP","uri":"/learning-cpp/"},{"categories":["note","courses"],"content":"tf-idf","date":"2021-10-05","objectID":"/tf-idf/","tags":["cs"],"title":"tf-idf","uri":"/tf-idf/"},{"categories":["note","courses"],"content":"记录一下tf-idf TF-IDF（term frequency–inverse document frequency）是一种用于信息检索与数据挖掘的常用加权技术。TF为词频，定义为 $$ TF_i = \\frac{n_i}{n} $$ 其中TFi为第i种单词的TF值，ni为该文档中第i种单词出现的频数，n为文档的总单词数 IDF为逆文档频率，定义为 $$ IDF_i = \\log\\frac{F}{F_w} $$ 其中IDF为第i种单词的idf值，F是语料库文档数量，Fw是包含这个单词的文档数量， $$ (TF-IDF)_i = TF_i * IDF_i $$ 可以看出tf-idf值越小，这个词越常用 信息检索系统的作业是：试按tf-idf算法在剔除一些常用词后给出文本中术语的统计算法和程序，并按降序进行排序 # encoding=utf-8 import jieba import re import os import math punc_reg = '\\u3002|\\uff1f|\\uff01|\\uff0c|\\u3001|\\uff1b|\\uff1a|\\u201c|\\u201d|\\u2018|\\u2019|\\uff08|\\uff09|\\u300a|\\u300b|\\u3008|\\u3009|\\u3010|\\u3011|\\u300e|\\u300f|\\u300c|\\u300d|\\ufe43|\\ufe44|\\u3014|\\u3015|\\u2026|\\u2014|\\uff5e|\\ufe4f|\\uffe5' class Article: def __init__(self, content): self.content = content def cut_word(self): self.cut_result = list(jieba.cut(self.content)) tmp_result = [] for word in self.cut_result: if re.match(punc_reg, word) == None: tmp_result.append(word) self.cut_result = tmp_result def cal_tf(self): self.tf = {} sz = len(self.cut_result) for word in self.cut_result: if word not in self.tf.keys(): self.tf[word] = 1 else: self.tf[word] += 1 for word in self.tf: self.tf[word] = float(self.tf[word] / sz) def cal_tf_idf(self): self.tf_idf = {} for word in self.tf: self.tf_idf[word] = self.tf[word] * idf[word] def get_result(self): tmp_list = list(zip(self.tf_idf.keys(), self.tf_idf.values())) tmp_list = sorted(tmp_list, key=lambda x : x[1], reverse=True) print('----------------------------') for i in range(20): print(tmp_list[i][0], tmp_list[i][1]) print('----------------------------') print() def cal_idf(): for article in articles: for word in article.cut_result: idf[word] = 1 for word in idf: for article in articles: if word in article.cut_result: idf[word] += 1 for word in idf: idf[word] -= 1 sz = len(articles) for word in idf: idf[word] = math.log(sz / idf[word]) def read_content(): path = 'material/Chinese article' files = os.listdir(path) for file in files: with open(str(path + '/' + file), encoding='utf-8') as f: data = f.read() article = Article(data) articles.append(article) def work(): for article in articles: article.cut_word() article.cal_tf() cal_idf() for article in articles: article.cal_tf_idf() article.get_result() if __name__ == '__main__': idf = {} articles = [] read_content() work() 其中一篇文章的测试效果 ","date":"2021-10-05","objectID":"/tf-idf/:0:0","tags":["cs"],"title":"tf-idf","uri":"/tf-idf/"},{"categories":["problemlist"],"content":"每日一题 (CF)","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"扫描线 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:1:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给N个区间，N\u003c=2e5，区间长度最大1e9，对于每个区间，区间里面的每个数+1，求数字分别为1,2,3…N的id个数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:1:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 如果区间长度很小，可以直接做。区间长度很大时，就类似于分段处理，用扫描线。把区间端点排序，求在当前端点到下一个端点这个区间内数字为多少。 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 1); vector\u003cpair\u003cint, int\u003e\u003e v; for (int i = 0; i \u003c n; ++i) { int l, r; cin \u003e\u003e l \u003e\u003e r; r += l; v.emplace_back(l, 1); v.emplace_back(r, -1); } sort(v.begin(), v.end()); int cnt = 0; for (int i = 0; i \u003c (int) v.size() - 1; ++i) { cnt += v[i].second; a[cnt] += v[i + 1].first - v[i].first; } for (int i = 1; i \u003c= n; ++i) { cout \u003c\u003c a[i] \u003c\u003c \" \\n\"[i == n]; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:1:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"贪心 实现 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:2:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 电影院座位有n行m列，给座位编号从上到下，从左到右为1,2,3,…nm，给nm个人安排座位，每个人的视力为ai，安排座位需要满足对于任意两个座位i,j上的人的视力ai,aj满足i \u003c j 时一定ai \u003c aj，每个人按自己的id顺序坐进去。首先，ta来到自己被安排座位的那一行，然后从左开始往右走。每个人的不方便度为ta从左走向自己座位时需要经过多少个已经在座位上的人，求不方便度总和的最小值 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:2:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 按视力排序，对于同一个视力的人，将小的id尽可能地排在最上面和最右边 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int _; cin \u003e\u003e _; while (_--) { map\u003cint, vector\u003cint\u003e\u003e mp; int n, m; cin \u003e\u003e n \u003e\u003e m; vector\u003cvector\u003cint\u003e\u003e id(n + 1, vector\u003cint\u003e(m + 1)); for (int i = 1; i \u003c= n * m; ++i) { int t; cin \u003e\u003e t; mp[t].push_back(i); } for (auto\u0026 i : mp) { sort(i.second.rbegin(), i.second.rend()); } int rem = m; int row = 1; for (const auto\u0026 i : mp) { auto cnt = i.second; while (!cnt.empty()) { if (rem \u003e= (int) cnt.size()) { for (int j = m - rem + (int) cnt.size(); !cnt.empty(); --j) { id[row][j] = cnt.back(); cnt.pop_back(); rem--; } }else { for (int j = m; rem \u003e 0; --j) { id[row][j] = cnt.back(); cnt.pop_back(); rem--; } rem = m; row++; } } } int ans = 0; for (int i = 1; i \u003c= n; ++i) { vector\u003cint\u003e vt; for (int j = 1; j \u003c= m; ++j) { int num = 0; auto ite = lower_bound(vt.begin(), vt.end(), id[i][j]); num = ite - vt.begin(); vt.insert(ite, id[i][j]); ans += num; } } cout \u003c\u003c ans \u003c\u003c '\\n'; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:2:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"构造 数学 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:3:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给数n（3-1e9）和k（3-1e5），构造出k个数，和为n，lcm不超过n/2 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:3:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 刚开始想了个fake算法：构造成a,a,a,a,….b 实际上可以构造成1,1,1,1,1…a,b,c （长度大于2） 假设a+b+c=m，如果m是奇数，就是1, m/2, m/2，如果m是偶数可以2, (m-2)/2, (m-2)/2，但是这样(m-2)/2可能是奇数。可以发现当(m-2)/2是奇数时，m为4的倍数，所以这样构造m/2, m/4, m/4 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int _; cin \u003e\u003e _; while (_--) { int n, k; cin \u003e\u003e n \u003e\u003e k; if (n % k == 0) { for (int i = 0; i \u003c k; ++i) { cout \u003c\u003c n / k \u003c\u003c \" \\n\"[i == k - 1]; } }else { int a, b, c; n -= (k - 3); if (n % 2 == 1) { a = 1; b = c = n / 2; }else if (n % 4 == 0) { a = n / 2; b = n / 4; c = n / 4; }else { a = 2; b = c = (n - 2) / 2; } cout \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c ' ' \u003c\u003c c \u003c\u003c ' '; for (int i = 0; i \u003c k - 3; ++i) { cout \u003c\u003c 1 \u003c\u003c \" \\n\"[i == k - 4]; } } } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:3:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"构造 贪心 欧拉路径 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:4:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给数n（2e5）和k（26），构造长度为n的字符串，字符串只能出现前k种字母，使得它的cost最小，cost定义为num(i, j) [s[i] == s[j] \u0026\u0026 s[i+1] == s[j+1]] ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:4:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 最直接的方法是查看每个字符可以向哪些字符转移，这样就画出一个dfa，然后求欧拉路径，另一种方法是贪心。（假设k=4） 先写下a，然后查看a与哪个字母未匹配，发现a与a未匹配，所以字符串为aa，对于第2个a，只能与b匹配，字符串为aab，b与a未匹配，字符串为aaba，a与c未匹配，字符串为aabac，c与a未匹配，字符串为aabaca，a与d未匹配，字符串为aabacad，d与a未匹配，但是如果d与a匹配了，a匹配满了就只能重复之前的匹配，所以贪心选择d与b匹配，字符串为aabacadb，b与b未匹配，字符串为aabacadbb，所以cost为0的字符串为aabacadbbcbdccdd，最后再加一个a，发现最后一个a可以作为字符串的开始，作为下一个循环 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int n, k; cin \u003e\u003e n \u003e\u003e k; string s; for (int i = 0; i \u003c k; ++i) { s += char('a' + i); for (int j = i + 1; j \u003c k; ++j) { s += char('a' + i); s += char('a' + j); } } for (int i = 0; i \u003c n; ++i) { cout \u003c\u003c s[i % (k * k)]; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:4:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"构造 贪心 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:5:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给长度为n（2e5）的01串，构造两个长度为n的字符串a、b，满足a、b为括号序列，如果第i个为0，则对应位的括号不同，为1则相同，a、b都是合法的括号序列 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:5:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 一开始想了个fake的贪心，记录当前剩余左括号个数，然后分情况讨论，贪心地增加左括号，没法增加左括号就增加右括号，后来发现反例a=’(())()’， b=’((()))' 可以发现0的个数必须是偶数，这样1的个数也是偶数，将1的前半部分填’(’，后半部分填’)’，对于0，则交错填a:’)’，b:’(‘和a:’(’，b:’)’，填的时候记录还有多少个左括号未匹配，如果为负数就是不存在 #include \u003cbits/stdc++.h\u003e using namespace std; int main() { int _; cin \u003e\u003e _; while (_--) { int n; cin \u003e\u003e n; string s; cin \u003e\u003e s; int n0, n1; n0 = n1 = 0; bool ok = true; for (int i = 0; i \u003c n; ++i) { if (s[i] == '1') n1++; else n0++; } if (n0 % 2 != 0 or n1 % 2 != 0) { puts(\"no\"); continue; } int up = 0, down = 0; int cnt = 0; string ans1, ans2; bool nor = true; for (int i = 0; i \u003c n; ++i) { if (s[i] == '1') { cnt++; if (cnt * 2 \u003c= n1) { ans1 += '('; ans2 += '('; up++; down++; } else { ans1 += ')'; ans2 += ')'; up--; down--; } } else { if (nor) { ans1 += ')'; ans2 += '('; up--; down++; nor ^= 1; } else { ans1 += '('; ans2 += ')'; up++; down--; nor ^= 1; } } if (up \u003c 0 or down \u003c 0) { ok = false; break; } } if (ok and up != 0 or down != 0) { puts(\"no\"); }else if (ok) { puts(\"yes\"); cout \u003c\u003c ans1 \u003c\u003c '\\n' \u003c\u003c ans2 \u003c\u003c '\\n'; } } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:5:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"图 模拟 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:6:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给一棵树，每次操作删除当前树的所有叶子，求k次操作后剩下几个节点 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:6:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 存度数模拟 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { int _; cin \u003e\u003e _; while (_--) { int n, k; cin \u003e\u003e n \u003e\u003e k; if (n == 1) { puts(\"0\"); continue; } vector\u003cint\u003e G[n + 1]; int degree[n + 1]; memset(degree, 0, sizeof(degree)); bool used[n + 1]; memset(used, 0, sizeof(used)); for (int i = 0; i \u003c n - 1; ++i) { int u, v; cin \u003e\u003e u \u003e\u003e v; G[u].push_back(v); G[v].push_back(u); degree[u]++; degree[v]++; } queue\u003cint\u003e q; for (int i = 1; i \u003c= n; ++i) { if (degree[i] == 1) q.push(i), used[i] = true; } int cut_num = 0; while (k--) { if (cut_num == n) break; int sz = (int) q.size(); cut_num += sz; while (sz--) { auto tmp = q.front(); q.pop(); for (int i : G[tmp]) { if (used[i]) continue; if (--degree[i] \u003c= 1) { q.push(i); used[i] = true; } } } } cout \u003c\u003c n - cut_num \u003c\u003c '\\n'; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:6:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"二分 交互 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:7:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有一个数组由0和1组成，每次可以查询一个区间的和，使用不超过20次查询求出从左往右的第k个0的位置 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:7:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int n, t, k; int ask(int l, int r) { int ret ; cout \u003c\u003c \"? \" \u003c\u003c l \u003c\u003c ' ' \u003c\u003c r \u003c\u003c endl; cout.flush(); cin \u003e\u003e ret; return ret; } int query(int l, int r, int th) { if (l == r and ask(l, r) == 0) { return l; } int one = ask(l, l + (r - l) / 2); if ((r - l) / 2 + 1 - one \u003e= th) { return query(l, l + (r - l) / 2, th); } else { return query(l + (r - l) / 2 + 1, r, th - (r - l) / 2 - 1 + one); } } int main() { cin \u003e\u003e n \u003e\u003e t; cin \u003e\u003e k; int ans = query(1, n, k); cout \u003c\u003c \"! \" \u003c\u003c ans \u003c\u003c endl; cout.flush(); return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:7:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"记忆化搜索 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:8:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有n个平面从左往右放置，一个粒子会以衰竭时间k打到平面上。粒子打到平面上会产生两种效果，以相同衰竭时间穿过平面到达下一个平面，产生一个反方向，衰竭时间-1的粒子到达之前的平面。衰竭时间为1的粒子不会产生反射粒子。求一个衰竭时间为k的粒子从左往右打到第一个平面总共会产生几个粒子 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:8:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 模拟粒子的穿过和反射操作，递归搜索，记忆化搜索，用dp[i][j][k]表示一个衰竭时间为j的粒子以k方向打到第i个平面产生的粒子数，搜索时分情况讨论 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 1e9 + 7; const int maxn = 1005; ll dp[maxn][maxn][2]; //0 is -\u003e , 1 is \u003c- int n, k; ll dfs(int id, int da, int dir) { if (dp[id][da][dir] != -1) { return dp[id][da][dir]; } ll ans = 0; if (dir == 0) { if (id == 1) { if (da != 1) { ans += (1 + dfs(id + 1, da, 0)); ans %= mod; } }else if (id == n) { if (da != 1) { ans += (1 + dfs(id - 1, da - 1, 1)); ans %= mod; } }else { if (da != 1) { ans += (1 + dfs(id + 1, da, 0)); ans %= mod; ans += dfs(id - 1, da - 1, 1); ans %= mod; } } }else { // dir == 1 if (id == 1) { if (da != 1) { ans += (1 + dfs(id + 1, da - 1, 0)); ans %= mod; } }else if (id != n) { if (da != 1) { ans += (1 + dfs(id - 1, da, 1)); ans %= mod; ans += dfs(id + 1, da - 1, 0); ans %= mod; } } } dp[id][da][dir] = ans; return ans; } int main() { int _; cin \u003e\u003e _; while (_--) { memset(dp, -1, sizeof(dp)); cin \u003e\u003e n \u003e\u003e k; if (n == 1) { if (k == 1) { puts(\"1\"); }else puts(\"2\"); continue; } cout \u003c\u003c 1 + dfs(1, k, 0) \u003c\u003c '\\n'; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:8:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"dfs lca ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:9:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给一棵树，每个节点有权值，给一个数k，求是否满足删掉1~k-1条边，让连通块的异或和相等 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:9:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 这题是我近期来做得最久的一道题，基本都在debug，就各种思维漏洞🤡 由异或的性质想到如果连通块是偶数就是0，奇数假设是x 所以如果每个值异或和为0就存在，如果为x就要判断是否能划成奇数个，每个是x，容易发现只要考虑能否被划分成3个就行 在一开始我想到删掉一条边就相当于把这条边所连节点的子树划出去，所以只需要求每个子树的异或和，然后看是否有两个同值就行（首先你要假设一个根） 这是我犯的第一个错，因为如果删除的两条边在一条链上就不满足上面的条件 所以我想那就把这种情况也考虑进去，如果删除的两条边在一条链上，那么我只需要找一棵子树异或和为0，然后看这棵子树的子树有没有异或和为x的，这是正确的 然后是我犯的第二个错误，如果要分成三个连通块就要特判k\u003e2 接下来是我犯的第三个错误，之前说到看两个子树的异或和是否有同值，这是错的。如果子树是另一个子树的子树就不行，所以这种情况需要满足两个子树不相交 我想那就把这部分补上，我便考虑求一棵树上是否存在两个节点，值相同且没有祖先后代关系 我想这可以用dfs解决，首先求每个值出现几次，然后dfs过程求每个值最多出现几次（因为dfs序，所以遍历过程一定满足祖先后代关系），如果有最多出现次数小于总次数就存在 但是这个方法单独运行应该不会超时（X），反正最后超时了 然后我想其实这个更特殊要求子树异或和为x，所以把异或和为x的节点抽出来，暴力lca判断（直觉上时间应该短） 最后居然跑得比最开始交的代码还快，属于是用空间换时间了 不过真正优美的做法肯定不是这样的━┳━　━┳━ hh 保留debug痕迹，时刻提醒自己思维要严谨 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; template \u003ctypename A, typename B\u003e string to_string(pair\u003cA, B\u003e p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; } template \u003ctypename A, typename B, typename C\u003e string to_string(tuple\u003cA, B, C\u003e p) { return \"(\" + to_string(get\u003c0\u003e(p)) + \", \" + to_string(get\u003c1\u003e(p)) + \", \" + to_string(get\u003c2\u003e(p)) + \")\"; } template \u003ctypename A, typename B, typename C, typename D\u003e string to_string(tuple\u003cA, B, C, D\u003e p) { return \"(\" + to_string(get\u003c0\u003e(p)) + \", \" + to_string(get\u003c1\u003e(p)) + \", \" + to_string(get\u003c2\u003e(p)) + \", \" + to_string(get\u003c3\u003e(p)) + \")\"; } void debug_val() {cerr \u003c\u003c '\\n';} template \u003ctypename Head, typename... Tail\u003e void debug_val(Head H, Tail... T) { cerr \u003c\u003c \" \" \u003c\u003c to_string(H); debug_val(T...); } #ifdef LOCAL #define debug(...) cerr \u003c\u003c \"[\" \u003c\u003c #__VA_ARGS__ \u003c\u003c \"]:\", debug_val(__VA_ARGS__) #define split() cerr \u003c\u003c \"===============================================\" \u003c\u003c '\\n' #define timeused() cerr \u003c\u003c \"time_used: \" \u003c\u003c t_clock - s_clock \u003c\u003c '\\n' #endif const int maxn = 100005; vector\u003cint\u003e G[maxn]; int xor_sum[maxn]; int n, k; int val[maxn]; int a; int par[maxn]; unordered_map\u003cint, int\u003e mp[maxn]; void dfs(int x, int p) { par[x] = p; if ((int) G[x].size() == 1 and G[x][0] == p) { xor_sum[x] = val[x]; return; } for (int i : G[x]) { if (i == p) continue; dfs(i, x); xor_sum[x] ^= xor_sum[i]; } xor_sum[x] ^= val[x]; } bool dfs2(int x, int p) { if ((int) G[x].size() == 1 and G[x][0] == p) { return val[x] == a; } for (int i : G[x]) { if (i == p) continue; if (xor_sum[i] == a) return true; //else return dfs2(i, x); wrong else { if (dfs2(i, x)) return true; } } return false; } //unordered_map\u003cint, int\u003e col_num; //unordered_map\u003cint, int\u003e mx_col_num; //unordered_map\u003cint, int\u003e cur_col_num; //void dfs3(int x, int p) { // if (xor_sum[x] == a) { // cur_col_num[xor_sum[x]]++; // mx_col_num[xor_sum[x]] = max(mx_col_num[xor_sum[x]], cur_col_num[xor_sum[x]]); // } // for (int i : G[x]) { // if (i == p) continue; // dfs3(i, x); // } // if (xor_sum[x] == a) { // cur_col_num[xor_sum[x]]--; // } //} // //bool sol() { // for (int i = 1; i \u003c= n; ++i) { // col_num[xor_sum[i]]++; // } // dfs3(1, 0); // for (int i = 1; i \u003c= n; ++i) { // if (xor_sum[i] != a) continue; // if (mx_col_num[xor_sum[i]] \u003c col_num[xor_sum[i]]) return true; // } // return false; //} int root; int parent[20][maxn]; int depth[maxn]; void dfs(int v,int p,int d){ parent[0][v]=p; depth[v]=d; for(int i=0;i\u003cG[v].size();i++){ if(G[v][i]!=p) dfs(G[v][i],v,d+1); } } void init(int V){ dfs(root,-1,0); for(int k=0;k+1\u003c20;k++){ for(int v=0;v\u003cV;v++){ if(parent[k][v]\u003c0) parent[k+1][v]=-1; else parent[k+1][v]=parent[k][parent[k][v]]; } } } int lca(int u,int v){ if(depth[u]\u003edepth[v]) swap(u,v); for(int k=0;k\u003c20;k++){ if((depth[v]-depth[u])\u003e\u003ek\u00261) v=parent[k][v]; } if(u==v) return u; for(int k=20-1;k\u003e=0;k--){ if(parent[k][u]!=parent[k][v]){ u=parent[k][u]; v=parent[k][v]; } } return parent[0][u]; } bool sol() { root = 1; init(n + 1); vector\u003cint\u003e tmp; for (int i = 2; i \u003c= n; ++i) { if (xor_sum[i] == a) tmp.push_back(i); } for (int i = 0; i \u003c (int) tmp.size(); ++i) { for (int j = i + 1; j \u003c (int) tmp.size(); ++j) { int cp = lca(tmp[i], tmp[j]); if (cp != tmp[i] and cp != tmp[j]) return true; } } return false; } int main() { #ifdef LOCAL freopen(\"in1.txt\", \"r\", st","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:9:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"组合 推理 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:10:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有n对数，每对数有两个属性a、b，选出三对数使得a属性完全不同或b属性完全不同，求方案数（题目保证没有完全相同的数对） ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:10:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 全部方案数-不满足的方案数，由于题目保证没有完全相同的数对，所以a属性只有两个相同，不可能有三个相同。不满足的方案数为a属性有两个相同且b属性有两个相同，即(x,y) (x,z) (q,y)/(q,z)，然后就容易推导出公式。注意long long #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { ll _; cin \u003e\u003e _; while (_--) { ll n; cin \u003e\u003e n; vector\u003cll\u003e a(n + 1), b(n + 1); unordered_map\u003cll, vector\u003cll\u003e\u003e mp1; unordered_map\u003cll, vector\u003cll\u003e\u003e mp2; for (ll i = 1; i \u003c= n; ++i) { cin \u003e\u003e a[i] \u003e\u003e b[i]; mp1[a[i]].push_back(b[i]); mp2[b[i]].push_back(a[i]); } ll ans; ans = n * (n - 1) * (n - 2) / 6; ll tmp = 0; for (auto i : mp1) { ll sz = (ll) i.second.size(); for (auto j : i.second) { if (mp2.find(j) != mp2.end()) tmp += ((ll) mp2[j].size() - 1) * (sz - 1); } } //cout \u003c\u003c tmp \u003c\u003c '\\n'; ans -= tmp; cout \u003c\u003c ans \u003c\u003c '\\n'; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:10:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"dp ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:11:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有n把椅子n=5000，从左往右排，有m个人坐在椅子上，每个人只能坐一把椅子，m\u003cn/2，你需要一个接一个让每个人移动到空座位上，移动的代价是椅子距离，最后使得每个刚开始有人占据的椅子都是空的，求最小代价 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:11:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 如果n小的话可以直接用二分图匹配。因为移动后每个人的相对顺序不变，考虑O(n^2)做法，考虑用dp来调度。 dp[i][j]表示前i个人坐前j个空座位的最小代价 dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + 第i个人和第j个空座位的距离) 最后输出dp[人数][空椅子数] 注意初始化dp[0][i] = 0，其他全为inf #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { int n; cin \u003e\u003e n; vector\u003cint\u003e one(n + 1), zero(n + 1); int ct0 = 0, ct1 = 0; for (int i = 1; i \u003c= n; ++i) { int u; cin \u003e\u003e u; if (u == 0) { zero[++ct0] = i; }else { one[++ct1]= i; } } vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(n + 1, 0x3f3f3f3f)); for (int i = 0; i \u003c= n; ++i) dp[0][i] = 0; // !!! notice initialize dp[0][i] means no person need moving, dp[i][0] // means there're some persons need moving but they can't, so the cost is inf, also dp[0][0] = 0 if (ct1 == 0) { puts(\"0\"); exit(0); } for (int i = 1; i \u003c= ct1; ++i) { for (int j = 1; j \u003c= ct0; ++j) { dp[i][j] = min(dp[i][j - 1], dp[i - 1][j - 1] + abs(one[i] - zero[j])); } } cout \u003c\u003c dp[ct1][ct0] \u003c\u003c '\\n'; return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:11:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"思维 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:12:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 3e5长度的数组，每次选择一个数删除，删除的数需满足条件：假设这个数是第i个数，则num[i]不能被i+1整除，问是否能删空 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:12:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 对于1-n的每个位置i，枚举2-i+1看是否满足num[i] % j != 0，如果存在就在那个位置删除，如果不存在这个位置就不能删空 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { int _; cin \u003e\u003e _; while (_--) { int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 1); for (int i = 1; i \u003c= n; ++i) { cin \u003e\u003e a[i]; } bool output = false; for (int i = 1; i \u003c= n; ++i) { bool ok = false; for (int j = 2; j \u003c= i + 1; ++j) { if (a[i] % j != 0) { ok = true; break; } } if (!ok) { puts(\"NO\"); output = true; break; } } if (!output) puts(\"YES\"); } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:12:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"数论 规律 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:13:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给两个偶数x、y，在1-2e18中找一数n，满足n % x = y % n x、y范围为1e9 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:13:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 设 c1x+k=n, c2n+k=y, n=(y+c1x) / (1+c2) 打表找规律，找c1和c2的规律 枚举多组x，y，枚举c1和c2，发现当x\u003ey时c1=1， c2=0 当x\u003c=y时，猜测是否与y/x或y%x有关，所以一并打y/x和y%x，发现c1=y/x，c2=1 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { int _; cin \u003e\u003e _; while (_--) { ll x, y; cin \u003e\u003e x \u003e\u003e y; ll ans = (x \u003e y ? (x + y) : ((y / x) * x + y) / 2); cout \u003c\u003c ans \u003c\u003c '\\n'; } // int x = 378, y = 99364; // //int x = 118502, y = 778; // cout \u003c\u003c y / x \u003c\u003c ' ' \u003c\u003c y % x \u003c\u003c '\\n'; // for (int c1 = 0; c1 \u003c= 1000; ++c1) { // for (int c2 = 0; c2 \u003c= 100000; ++c2) { // if ((y + c1 * x) % (1 + c2) == 0) { // int n = (y + c1 * x) / (1 + c2); // if (n % x == y % n) { // cout \u003c\u003c c1 \u003c\u003c ' ' \u003c\u003c c2 \u003c\u003c ' ' \u003c\u003c n \u003c\u003c '\\n'; // } // } // } // } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:13:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"树状数组 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:14:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 经典的求逆序三元组的个数，求逆序对可以用归并排序和树状数组，求逆序三元组就是在逆序对的基础上求，遍历数组，只是需要把逆序对的+1变成+该位置与前面产生的逆序对数量。这样就可以求逆序k元组 注意读入long ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:14:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); long[] nums = new long[n]; for (int i = 0; i \u003c n; ++i) { nums[i] = in.nextLong(); } long[] tmp = new long[n]; System.arraycopy(nums, 0, tmp, 0, n); Arrays.sort(tmp); for (int i = 0; i \u003c n; ++i) { nums[i] = Arrays.binarySearch(tmp, nums[i]) + 1; } FenwickTree fenwickTree = new FenwickTree(n); for (int i = 0; i \u003c n; ++i) { tmp[i] = i - fenwickTree.sum((int) nums[i]); fenwickTree.add((int) nums[i], 1); } long ans = 0; long sum = 0; fenwickTree = new FenwickTree(n); for (int i = 0; i \u003c n; ++i) { ans += sum - fenwickTree.sum((int) nums[i]); fenwickTree.add((int) nums[i], tmp[i]); sum += tmp[i]; } System.out.println(ans); } } class FenwickTree { //[1, n] private long[] bit; private long n; public FenwickTree(int n) { this.bit = new long[n + 2]; this.n = n; } public long sum(int i) { long s = 0; while (i \u003e 0) { s += bit[i]; i -= i \u0026 -i; } return s; } public void add(int i, long x) { while (i \u003c= n) { bit[i] += x; i += i \u0026 -i; } } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:14:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"欧拉降幂 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:15:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 求M^(K^N)，每个数1e18 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:15:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 欧拉降幂，注意底数取模防long long溢出 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll qpow(ll x,ll n,ll mod) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } const ll mod = 998244353; const ll phimod = 998244352; ll gcd(ll a , ll b){ return b == 0 ? a : gcd(b , a % b); } int main() { ll n, k, m; cin \u003e\u003e n \u003e\u003e k \u003e\u003e m; if (m % mod == 0) { puts(\"0\"); exit(0); } ll ans; ans = qpow(m % mod, qpow(k % phimod, n, phimod), mod); cout \u003c\u003c ans \u003c\u003c '\\n'; return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:15:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"数论 辗转相除法 规律 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:16:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 给俩数a,b和x，范围是1e18，求是否可以如下操作使得a=x或b=x，用a、b差替换a或替换b ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:16:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 如果x \u003e 最大的数无解 一开始想的是贪心，就是什么情况替换a，什么情况替换b，然后WA爆（其实这么做本身就没有道理） 列出每种情况找规律，举个例子 发现有些路产生的数别的路也会产生，最上面那条路始终是最快产生新数字的，所以只要考虑那条路就行，即 始终替换最大的数 这样只要模拟这个过程就行，但是会T 把这条路单独拎出来，观察发现这和求最大公约数的辗转相除法很像 但是少了11，这是因为11是余数4加7的结果，实际上只要满足%7=4都可以，这样就可以依赖欧几里得算法使时间复杂度变成logn #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; #define YES cout \u003c\u003c \"YES\" \u003c\u003c '\\n' #define NO cout \u003c\u003c \"NO\" \u003c\u003c '\\n' #define Yes cout \u003c\u003c \"Yes\" \u003c\u003c '\\n' #define No cout \u003c\u003c \"No\" \u003c\u003c '\\n' #define yes cout \u003c\u003c \"yes\" \u003c\u003c '\\n' #define no cout \u003c\u003c \"no\" \u003c\u003c '\\n' bool sol(ll a, ll b, ll k) { if (b == 0 or k \u003e a) return false; if (k % b == a % b) return true; return sol(b, a % b, k); } int main() { int _; cin \u003e\u003e _; while (_--) { ll a, b, k; cin \u003e\u003e a \u003e\u003e b \u003e\u003e k; if (a \u003c b) swap(a, b); if (sol(a, b, k)) YES; else NO; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:16:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"计数dp 排列组合 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:17:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有n个人，每个人初始有生命值ai，每一轮每个人生命值同时减k-1，k为该轮存活人数，生命值为\u003c=0时死亡，问如何安排每个人的初始生命值，使得所有生命值不超过x，且最后无人生还，求方案数。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:17:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 计数，有递推关系的考虑dp dp[i][j]表示前i个，血量不超过j的方案数，如果如果i-1 \u003e= j，血量可以随便安排即dp[i][j] = j ^ i 否则考虑一轮后剩下k个（可能也可以假设一轮后消灭k个） $$ dp[i][j] = \\sum_{k=0}^{i}{C_i^kdp[k]j-i+1^{i-k}} $$ 之前以为k从1开始加，然后样例过不了，发现需要加dp[0][j]=1 所以初始化为dp=0，dp[0][j]=1 （表示前0个是可行的） #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 998244353; ll dp[505][505]; ll qpow(ll x,ll n,ll mod){ ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } ll inv[505]; ll fac[505]; inline ll C(ll m,ll n){ return fac[n]*inv[m]%mod*inv[n-m]%mod; } inline ll A(ll m,ll n){ return fac[n]*inv[n-m]%mod; } int main() { for(ll i=0;i\u003c=502;i++){ fac[i]=1; } for(ll i=2;i\u003c=502;i++){ fac[i]=(fac[i-1]*i)%mod; } inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=502;i++){ inv[i]=(mod-mod/i)*inv[mod%i]%mod; } for(ll i=2;i\u003c=502;i++){ inv[i]=(inv[i]*inv[i-1])%mod; } ll n, x; cin \u003e\u003e n \u003e\u003e x; for (int i = 1; i \u003c= x; ++i) { dp[0][i] = 1; } for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= x; ++j) { if (i - 1 \u003e= j) dp[i][j] = qpow(j, i, mod); else { for (int k = 0; k \u003c= i; ++k) { dp[i][j] += (C(k, i) * dp[k][j - i + 1] % mod * qpow(i - 1, i - k, mod) % mod); dp[i][j] %= mod; } } } } cout \u003c\u003c dp[n][x]; return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:17:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"二分 ST ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:18:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 有一个数组和一个初始数，选择最长的子区间，使得数字遍历区间时不断加上该区间的数且该数字一直不小于0，输出该区间 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:18:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 二分区间长度，暴力判断，维护前缀和，用st表求区间最小值，时间复杂度O(nlognlogn) 注意二分的初始L和R，我把L设为0，wa了，要设为1 注意long long #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; //O(nlogn) preprocess, O(1) query // llerval minimum, maxmum, bit-or, bit-xor, gcd(less efficient than segment tree) const ll maxlogn = 21; const ll maxn = 2e5 + 10; ll f[maxn][maxlogn], logn[maxn]; void pre() { logn[1] = 0; logn[2] = 1; for (ll i = 3; i \u003c maxn; ++i) { logn[i] = logn[i / 2] + 1; } } ll dat[maxn], ini; ll ansl, ansr; ll n; bool ok(ll x) { for (ll i = 1; i \u003c= n - x + 1; ++i) { ll l = i, r = i + x - 1; ll s = logn[r - l + 1]; ll tmp = min(f[l][s], f[r - (1 \u003c\u003c s) + 1][s]); if (tmp - dat[i - 1] + ini \u003e= 0) { ansl = l, ansr = r; return true; } } return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); pre(); ll _; cin \u003e\u003e _; while (_--) { cin \u003e\u003e n \u003e\u003e dat[0]; ini = dat[0]; for (ll i = 1; i \u003c= n; ++i) cin \u003e\u003e dat[i]; for (ll i = 1; i \u003c= n; ++i) dat[i] += dat[i - 1]; for (ll i = 1; i \u003c= n; ++i) f[i][0] = dat[i]; for (ll j = 1; j \u003c maxlogn; ++j) for (ll i = 1; i + (1 \u003c\u003c j) - 1 \u003c= n; ++i) f[i][j] = min(f[i][j - 1], f[i + (1 \u003c\u003c (j - 1))][j - 1]); ll l = 1, r = n; //dat[0] = 0; while (l \u003c= r) { ll mid = (l + r) \u003e\u003e 1; if (ok(mid)) l = mid + 1; else r = mid - 1; } if (l == 1) cout \u003c\u003c -1 \u003c\u003c '\\n'; else cout \u003c\u003c ansl \u003c\u003c ' ' \u003c\u003c ansr \u003c\u003c '\\n'; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:18:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"并查集 图论 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:19:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 对于一个森林，按顺序删除点和所连的边，求每次删除后剩几个连通块 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:19:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 反向加点，并查集，每次加点判断该点和所连的点是否在同一个连通块中，如果不在，则连通块-1（说明有一条边把两个连通块连在一起） #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const int maxn = 2e5 + 10; //union find int par[maxn]; int rankk[maxn]; int sz[maxn]; void init(int n) { for(int i=0;i\u003cn;i++) { par[i]=i; rankk[i]=0; } } int find(int x) { if(par[x]==x) return x; else return par[x]=find(par[x]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y; else { par[y]=x; if(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y) { return find(x)==find(y); } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; init(n + 1); vector\u003cint\u003e G[n + 1]; for (int i = 0; i \u003c m; ++i) { int u, v; cin \u003e\u003e u \u003e\u003e v; if (u \u003e v) swap(u, v); G[u].push_back(v); } vector\u003cint\u003e ans; int cnt = 0; for (int i = n; i \u003e= 1; --i) { cnt++; for (int j : G[i]) { if (!same(j, i)) { cnt--; unite(j, i); } } ans.push_back(cnt); } reverse(ans.begin(), ans.end()); for (int i = 1; i \u003c (int) ans.size(); ++i) cout \u003c\u003c ans[i] \u003c\u003c '\\n'; cout \u003c\u003c 0 \u003c\u003c '\\n'; return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:19:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"规律 dp ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:20:0","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:20:1","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"题解 像我这种不能一眼看出规律的就要多写几组数据。从前往后填数 如果找不到规律就多写几层，可以看出每次都有3个分支，但是有些有两个分支 少掉的那个分支一定当前要填的数是前面数的mex，如果当前填的数是前面数的mex，使得现在的mex+1就可以填，否则使mex+2就不能填 三个分支填的数是前面数的mex，mex-1，mex+1，其中填mex如果造成mex+2就不能填（即前面的数有mex+1） 所以设dp[i]表示以 i 结尾的个数，num[i]表示前面mex为 i 的个数，numex[i]表示前面mex为 i 且前面没有mex+1的个数 每次dp[i] = num[a[i]-1] + num[a[i]+1] + numex[a[i]] 注意判断a[i]-1\u003e=0 更新num，numex，如果选了前面mex为a[i]-1则mex不变，个数翻倍，num[a[i]-1]*=2，但是出现了mex+1，所以不更新numex 如果选了前面mex为a[i]+1，mex不变，个数翻倍，num[a[i]+1]*=2，numex[a[i]+1]*=2 如果选了前面mex为a[i]，mex变成mex+1，num[a[i]+1] += numex[a[i]]，考虑是否更新numex即前面是否有mex+2，一定不会有，所以numex[a[i]+1] += numex[a[i]] 最后特判，如果当前数是0，dp[i]++ num[1]++ numex[1]++ 当前数是1，dp[i]++ num[0]++; 初始化全为0 答案为dp求和 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 998244353; int main() { int _; cin \u003e\u003e _; while (_--) { int n; cin \u003e\u003e n; vector\u003cint\u003e a(n + 5); for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e a[i]; vector\u003cll\u003e dp(n + 5); vector\u003cll\u003e num(n + 5), numex(n + 5); for (int i = 1; i \u003c= n; ++i) { if (a[i] - 1 \u003e= 0) dp[i] = num[a[i] - 1] + num[a[i] + 1] % mod + numex[a[i]] % mod; else dp[i] = num[a[i] + 1] % mod + numex[a[i]] % mod; if (a[i] - 1 \u003e= 0) num[a[i] - 1] = (num[a[i] - 1] * 2) % mod; num[a[i] + 1] *= 2; num[a[i] + 1] %= mod; numex[a[i] + 1] *= 2; numex[a[i] + 1] %= mod; num[a[i] + 1] += numex[a[i]]; num[a[i] + 1] %= mod; numex[a[i] + 1] += numex[a[i]]; numex[a[i] + 1] %= mod; if (a[i] == 0) { dp[i]++; dp[i] %= mod; num[1]++; num[1] %= mod; numex[1]++; numex[1] %= mod; } if (a[i] == 1) { dp[i]++; dp[i] %= mod; num[0]++; num[0] %= mod; } } ll ans = 0; for (int i = 1; i \u003c= n; ++i) { ans += dp[i]; ans %= mod; } cout \u003c\u003c ans \u003c\u003c '\\n'; } return 0; } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/:20:2","tags":["problemlist"],"title":"每日一题 (CF)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-cf/"},{"categories":["problemlist"],"content":"每日一题 (LeetCode)","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":" 在这篇文章下更新LeetCode的每日一题，之所以选择LeetCode，是因为好像只有它有每日一题版块，每日一题并不是为了提高编程水平，而是保持手感，从10月2日开始更新，应该过几天批量更新一次 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:0:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"进制转化 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:1:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 把一个有符号数数转化成16进制，不能使用内置函数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:1:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意无符号数的转化 class Solution { public String toHex(int num) { if (num == 0) return \"0\"; long NUM = num \u0026 0xffffffffl; StringBuffer sb = new StringBuffer(); while (NUM != 0) { long tmp = NUM \u0026 0xf; if (tmp \u003e 9) sb.append((char)('a' + tmp - 10)); else sb.append((char)('0' + tmp)); NUM \u003e\u003e= 4; } return sb.reverse().toString(); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:1:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟，哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:2:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给定分数的分子和分母，求小数形式，如有循环节则标出 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:2:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意long类型的转化 class Solution { public String fractionToDecimal(int numerator, int denominator) { if (numerator == 0) return \"0\"; boolean neg = (numerator \u003c 0) ^ (denominator \u003c 0); long NUM = Math.abs((long)numerator); long DEN = Math.abs((long)denominator); long interger = NUM / DEN; NUM %= DEN; Map\u003cLong, Boolean\u003e mp = new HashMap\u003cLong, Boolean\u003e(); if (NUM == 0) { StringBuffer sb = new StringBuffer(); if (neg) sb.append('-'); sb.append(String.valueOf(interger)); return sb.toString(); } List\u003clong []\u003e ans = new ArrayList\u003clong []\u003e(); long loop = 0; long remaider = NUM; while (true) { if (remaider == 0) break; if (mp.containsKey(remaider)) { loop = remaider; break; } mp.put(remaider, true); long tmp = remaider * 10 / DEN; long a[] = new long[2]; a[0] = tmp; a[1] = remaider; ans.add(a); remaider = remaider * 10 % DEN; } StringBuffer sb = new StringBuffer(); if (neg) sb.append('-'); sb.append(String.valueOf(interger)); sb.append('.'); boolean circle = false; for (long [] i : ans) { if (i[1] == loop) { circle = true; sb.append('('); } sb.append((char)('0' + i[0])); } if (circle) sb.append(')'); return sb.toString(); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:2:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:3:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:3:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public String licenseKeyFormatting(String s, int k) { int sum = 0; for (int i = 0; i \u003c s.length(); ++i) { if (s.charAt(i) != '-') sum++; } if (sum == 0) { return \"\"; } int rem = sum % k; if (rem == 0) rem = k; StringBuilder sb = new StringBuilder(); int cnt = 0; while (cnt \u003c s.length()) { while (rem \u003e 0) { if (s.charAt(cnt) == '-') { cnt++; continue; } sb.append(s.charAt(cnt)); rem--; cnt++; } if (cnt \u003e= s.length()) break; sb.append('-'); int kk = k; while (kk \u003e 0) { if (s.charAt(cnt) == '-') { cnt++; if (cnt \u003e= s.length()) break; continue; } sb.append(s.charAt(cnt)); cnt++; kk--; } } for (int i = 0; i \u003c sb.length(); ++i) { if (Character.isAlphabetic(sb.charAt(i))) { sb.setCharAt(i, Character.toUpperCase(sb.charAt(i))); } } if (sb.charAt(sb.length() - 1) == '-') sb.deleteCharAt(sb.length() - 1); return sb.toString(); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:3:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:4:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:4:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { private static final int mod = 1000000007; public int numDecodings(String s) { int sz = s.length(); StringBuilder sb = new StringBuilder(s); sb.insert(0, '#'); long dp[] = new long[sz + 1]; dp[0] = 1; char cnt = sb.charAt(1); if (cnt == '*') { dp[1] = 9; }else { if (cnt == '0') dp[1] = 0; else dp[1] = 1; } for (int i = 2; i \u003c= sz; ++i) { cnt = sb.charAt(i); if (cnt == '*') { dp[i] += 9 * dp[i - 1]; dp[i] %= mod; char pre = sb.charAt(i - 1); if (pre == '*') { dp[i] += 15 * dp[i - 2]; dp[i] %= mod; }else { // num if (pre == '1') { dp[i] += 9 * dp[i - 2]; dp[i] %= mod; }else if (pre == '2') { dp[i] += 6 * dp[i - 2]; dp[i] %= mod; } } }else { // num if (cnt == '0') { char pre = sb.charAt(i - 1); if (pre == '*') { dp[i] += 2 * dp[i - 2]; dp[i] %= mod; }else { if (pre == '1' || pre == '2') { dp[i] += dp[i - 2]; dp[i] %= mod; }else return 0; } continue; } dp[i] += dp[i - 1]; dp[i] %= mod; char pre = sb.charAt(i - 1); if (pre == '*') { if (cnt \u003e '6') { dp[i] += dp[i - 2]; dp[i] %= mod; }else { dp[i] += 2 * dp[i - 2]; dp[i] %= mod; } }else { StringBuilder str = new StringBuilder(); str.append(pre); str.append(cnt); if (str.compareTo(new StringBuilder(\"10\")) \u003e= 0 \u0026\u0026 str.compareTo(new StringBuilder(\"26\")) \u003c= 0) { dp[i] += dp[i - 2]; dp[i] %= mod; } } } } return (int) dp[sz]; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:4:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"贪心 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:5:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:5:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int findMinMoves(int[] machines) { int ans = 0; int sum = 0; for (int i : machines) sum += i; int sz = machines.length; if (sum % sz != 0) return -1; int avg = sum / sz; for (int i = 0; i \u003c machines.length; ++i) { machines[i] = machines[i] - avg; } sum = 0; for (int i : machines) { sum += i; ans = Math.max(ans, Math.max(i, Math.abs(sum))); } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:5:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"迭代器的了解 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:6:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 分析样例感觉题目说的有点不清楚，具体方法的功能写在注释里 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:6:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 泛型就直接用E代替Integer // Java Iterator interface reference: // https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html class PeekingIterator implements Iterator\u003cInteger\u003e { private Iterator\u003cInteger\u003e ite; private Integer currentElement; public PeekingIterator(Iterator\u003cInteger\u003e iterator) { // initialize any member here. ite = iterator; currentElement = ite.next(); } // Returns the next element in the iteration without advancing the iterator. // Coder's note: return the current element, starting from the first one public Integer peek() { return currentElement; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. // CN: return the current element and advance the iterator @Override public Integer next() { Integer tmp = currentElement; currentElement = ite.hasNext() ? ite.next() : null; return tmp; } //CN: return if the current element exist @Override public boolean hasNext() { return currentElement != null; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:6:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:7:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求数组第三大的数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:7:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int thirdMax(int[] nums) { TreeSet\u003cInteger\u003e ts = new TreeSet\u003c\u003e(); for (int i : nums) { ts.add(i); if (ts.size() \u003e 3) { ts.remove(ts.first()); } } return (ts.size() == 3) ? ts.first() : ts.last(); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:7:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:8:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求字符串有多少个单词，单词是由没有空格的连续字符组成的字符串 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:8:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int countSegments(String s) { int ans = 0; boolean word = false; for (int i = 0; i \u003c s.length(); ++i) { if (s.charAt(i) != ' ') { word = true; }else { if (word == true) { word = false; ans++; } } } if (word) ++ans; return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:8:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:9:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 查找字符串中长度为10且不止出现过一次的子串 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:9:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public List\u003cString\u003e findRepeatedDnaSequences(String s) { HashMap\u003cString, Integer\u003e mp = new HashMap\u003c\u003e(); StringBuilder sb = new StringBuilder(); List\u003cString\u003e ans = new ArrayList\u003c\u003e(); if (s.length() \u003c 10) return ans; for (int i = 0; i \u003c 10; i++) { sb.append(s.charAt(i)); } mp.put(sb.toString(), 1); for (int i = 10; i \u003c s.length(); ++i) { sb.append(s.charAt(i)); sb.deleteCharAt(0); if (mp.containsKey(sb.toString()) \u0026\u0026 mp.get(sb.toString()) == 1) { ans.add(sb.toString()); mp.put(sb.toString(), mp.get(sb.toString()) + 1); }else if (!mp.containsKey(sb.toString())) { mp.put(sb.toString(), 1); } } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:9:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"分类讨论 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:10:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 编写一个类的三个函数，初始化、添加一个元素、查找当前所有元素由几个区间组成（输出区间） ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:10:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 考虑合并，插入一个元素后能否和左边的数合并成一个区间、 能否和右边的数合并，分成4种情况 class SummaryRanges { private TreeMap\u003cInteger, Integer\u003e mp; int[] left; boolean[] used; public SummaryRanges() { mp = new TreeMap\u003c\u003e(); used = new boolean[10005]; left = new int[10005]; } public void addNum(int val) { if (used[val]) return; used[val] = true; if (val - 1 \u003e= 0 \u0026\u0026 used[val - 1]) { // exist left number if (used[val + 1]) { // exist left number and right number int tmp_left = left[val - 1]; int tmpsz = mp.get(tmp_left); tmpsz = tmpsz + 1 + mp.get(val + 1); left[val + mp.get(val + 1)] = tmp_left; mp.remove(val + 1); mp.put(tmp_left, tmpsz); }else { // exist left number but not right number int tmp_left = left[val - 1]; left[val] = tmp_left; mp.put(tmp_left, mp.get(tmp_left) + 1); } }else { // val == 0 or not exitst left number if (used[val + 1]) { // not exist left number but exist right number left[val + mp.get(val + 1)] = val; mp.put(val, mp.get(val + 1) + 1); mp.remove(val + 1); }else { // both left and right number are not exist left[val] = val; mp.put(val, 1); } } } public int[][] getIntervals() { int[][] ans = new int[mp.size()][2]; int id = 0; for (Map.Entry\u003cInteger, Integer\u003e entry : mp.entrySet()) { ans[id][0] = entry.getKey(); ans[id][1] = entry.getValue() + ans[id][0] - 1; id++; } return ans; } } /** * Your SummaryRanges object will be instantiated and called as such: * SummaryRanges obj = new SummaryRanges(); * obj.addNum(val); * int[][] param_2 = obj.getIntervals(); */ ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:10:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:11:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 n个硬币按阶梯式排列，求最后一层被排满的阶梯 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:11:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int arrangeCoins(int n) { long l = 1, r = n; while (l \u003c= r) { long mid = (l + r) \u003e\u003e 1; if ((1 + mid) * mid / 2 \u003c= n) { l = mid + 1; }else r = mid - 1; } return (int)(l - 1); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:11:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:12:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 把数字转化成英文 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:12:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意特判0，注意20 class Solution { String[] thousand = {\"Billion\", \"Million\", \"Thousand\", \"\"}; String[] number = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}; String[] ty = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"}; String[] teen = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"}; public String numberToWords(int num) { if (num == 0) return \"Zero\"; StringBuilder sb = new StringBuilder(); for (int i = 1000000000, j = 0; num != 0; i /= 1000, j++) { if (i == 1) { // 3-digital number if (num \u003e= 100) { sb.append(number[num / 100]); sb.append(' '); sb.append(\"Hundred\"); sb.append(' '); num %= 100; } if (num \u003e= 20) { sb.append(ty[num / 10]); sb.append(' '); num %= 10; } if (num == 0) break; if (num \u003c 10) { sb.append(number[num]); sb.append(' '); }else { sb.append(teen[num - 10]); sb.append(' '); } break; } if (num \u003e= i) { sb.append(numberToWords(num / i)); sb.append(' '); sb.append(thousand[j]); sb.append(' '); num %= i; } } sb.deleteCharAt(sb.length() - 1); return sb.toString(); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:12:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分、快速乘 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:13:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求一个数除以另一个数的结果（保留整数部分），不能使用乘法、除法、模运算 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:13:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 用快速乘的加法代替乘法，注意特判溢出 class Solution { public int divide(int dividend, int divisor) { boolean neg = (dividend \u003e 0) ^ (divisor \u003e 0); long tmp_dividend = dividend; long tmp_divisor = divisor; tmp_dividend = Math.abs(tmp_dividend); tmp_divisor = Math.abs(tmp_divisor); long l = 0, r = tmp_dividend; while (l \u003c= r) { long mid = (l + r) \u003e\u003e 1; if (qmul(mid, tmp_divisor) \u003c= tmp_dividend \u0026\u0026 qmul(mid + 1, tmp_divisor) \u003e tmp_dividend) { if (neg) mid = -mid; if (mid \u003e Integer.MAX_VALUE) return Integer.MAX_VALUE; return (int) mid; } if (qmul(mid, tmp_divisor) \u003c tmp_dividend) { l = mid + 1; }else { r = mid - 1; } } return Integer.MAX_VALUE; //!! } private long qmul(long x, long y) { long ans = 0; while (y \u003e 0) { if (y % 2 == 1) ans += x; x += x; y \u003e\u003e= 1; } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:13:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:14:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:14:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public List\u003cString\u003e fizzBuzz(int n) { List\u003cString\u003e ls = new ArrayList\u003c\u003e(); for (int i = 1; i \u003c= n; ++i) { if (i % 3 == 0 \u0026\u0026 i % 5 == 0) { ls.add(\"FizzBuzz\"); }else if (i % 3 == 0) { ls.add(\"Fizz\"); }else if (i % 5 == 0) { ls.add(\"Buzz\"); }else { ls.add(String.valueOf(i)); } } return ls; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:14:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"三分 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:15:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 logn内求单峰数组的最大值 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:15:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 三分，最高效的应该是黄金分割，其实还可以模拟退火（X） class Solution { public int peakIndexInMountainArray(int[] arr) { int l = 0, r = arr.length - 1; while (l \u003c= r) { int midl = l + (r - l) / 3; int midr = r - (r - l) / 3; if (arr[midl] \u003c arr[midr]) { l = midl + 1; }else { r = midr - 1; } } return l; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:15:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:16:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 不想描述 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:16:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public String countAndSay(int n) { if (n == 1) return \"1\"; else return describe(countAndSay(n - 1)); } private String describe(String str) { char cnt = str.charAt(0); int num = 1; StringBuilder sb = new StringBuilder(); for (int i = 1; i \u003c str.length(); ++i) { if (str.charAt(i) == cnt) { num++; }else { sb.append(String.valueOf(num)); sb.append(cnt); cnt = str.charAt(i); num = 1; } } sb.append(String.valueOf(num)); sb.append(cnt); return sb.toString(); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:16:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:17:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 对一个由数字组成的字符串中加运算符（+-*），求表达式能得到target值的所有方案，sb中文翻译居然没说数字不能有前导0 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:17:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 为了图方便，直接用python的eval，但是eval不能有前导0，但是允许000的存在，这个要后处理特判，注意list不能边遍历边删除 注意在ide中用python3.5以上的类型检查时要导入typing包 class Solution: def addOperators(self, num: str, target: int) -\u003e List[str]: # 0-based index le = len(num) ans = [] def dfs(now: str, pos: int, added: int): if pos == le - 1: try: if eval(now) == target: ans.append(now) except SyntaxError: pass return tmp_now = now[: pos + added + 1] + '+' + now[pos + added + 1:] dfs(tmp_now, pos + 1, added + 1) tmp_now = now[: pos + added + 1] + '-' + now[pos + added + 1:] dfs(tmp_now, pos + 1, added + 1) tmp_now = now[: pos + added + 1] + '*' + now[pos + added + 1:] dfs(tmp_now, pos + 1, added + 1) tmp_now = now dfs(tmp_now, pos + 1, added) def all_zero(s: str) -\u003e bool: if len(s) == 1: return False for i in s: if i != '0': return False return True dfs(num, 0, 0) fans = [] # postprocess for i in ans: removed = False s = '' for j in i: if j != '+' and j != '-' and j != '*': s += j else: if all_zero(s): removed = True break else: s = '' if not removed and all_zero(s): removed = True if not removed: fans.append(i) return fans ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:17:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 中序遍历 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:18:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求bst的第k小元素，允许多次求 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:18:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 bst的中序是有序的，插入、删除、搜索均可二分 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { List\u003cInteger\u003e li = new ArrayList\u003c\u003e(); public int kthSmallest(TreeNode root, int k) { dfs(root); //Collections.sort(li); return li.get(k - 1); } private void dfs(TreeNode node) { if (node.left != null) dfs(node.left); li.add(node.val); if (node.right != null) dfs(node.right); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:18:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"次短路 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:19:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一个无向图，经过每条边的时间为t，任何时候可以到达任何点，但是只能在该点绿灯时离开且必须离开，一开始每个点都是绿灯，红绿灯以m时间交替，求从1到n的严格第二短时间 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:19:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 dijkstra求次短路是最直接的想法，求次短路需要同时存储到每个点的次短路和最短路 class Solution { public: typedef pair\u003cint,int\u003e pii; //first 是距离 ，second是点编号 static const int maxv = 1e4 + 10; struct edge { int to,cost; }; int V; vector\u003cedge\u003e G[maxv]; int d[maxv]; int dd[maxv]; int cg ; int secondMinimum(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 edges, int time, int change) { cg = change; for (auto i : edges) { G[i[0]].push_back({i[1], time}); G[i[1]].push_back({i[0], time}); } dijkstra(1); return dd[n]; } void dijkstra(int s) { priority_queue\u003cpii,vector\u003cpii\u003e,greater\u003c\u003e \u003e q; //使小的在上面 memset(d, 0x3f, sizeof(d)); memset(dd, 0x3f, sizeof(dd)); d[s]=0; q.push(pii(0,s)); while(!q.empty()) { pii p=q.top(); q.pop(); int v=p.second; if(dd[v]\u003cp.first) continue; for(int i=0;i\u003c(int)G[v].size();i++) { edge e=G[v][i]; // if(d[e.to]\u003ed[v]+e.cost) // { // d[e.to]=d[v]+e.cost; // q.push(pii(d[e.to],e.to)); // } int tmpdist; if (p.first % (cg * 2) \u003c cg) { tmpdist = p.first + e.cost; }else { tmpdist = p.first + e.cost + 2 * cg - p.first % (2 * cg); } if (tmpdist \u003c d[e.to]) { swap(d[e.to], tmpdist); q.emplace(d[e.to], e.to); } if (d[e.to] \u003c tmpdist and dd[e.to] \u003e tmpdist) { dd[e.to] = tmpdist; q.emplace(dd[e.to], e.to); } } } } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:19:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"位运算 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:20:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求一个数耳朵二进制中0变成1,1变成0后的数字 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:20:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 将它和全1异或 class Solution { public int findComplement(int num) { int bitnum = 0; int tmp = num; while (tmp != 0) { tmp \u003e\u003e= 1; bitnum++; } int now = 0; for (int i = 0; i \u003c bitnum; ++i) { now |= (1 \u003c\u003c i); } return num ^ now; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:20:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:21:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求一个100位数+1的结果 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:21:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 分享一篇Array\u003cInteger\u003e 、Integer[] 、int[]相互转换的方法，点它，不过应该尽量避免转化 class Solution { public int[] plusOne(int[] digits) { boolean carry = false; int sz = digits.length; List\u003cInteger\u003e ls = new ArrayList\u003c\u003e(); if (digits[sz - 1] + 1 \u003e 9) { carry = true; ls.add(0); }else { ls.add(digits[sz - 1] + 1); } for (int i = sz - 2; i \u003e= 0; --i) { if (carry) { if (digits[i] + 1 \u003e 9) { ls.add(0); }else { carry = false; ls.add(digits[i] + 1); } }else { ls.add(digits[i]); } } if (carry) ls.add(1); Collections.reverse(ls); return ls.stream().mapToInt(Integer::valueOf).toArray(); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:21:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"摩尔投票 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:22:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求一个数组中出现次数超过n/3的元素，要求时间复杂度O(n)，空间复杂度O(1) ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:22:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 摩尔投票法一般用来求出现次数超过n/k的元素，这样的元素至多有k-1个，本质是相互抵消，注意判断条件的顺序 相似的题 class Solution { public List\u003cInteger\u003e majorityElement(int[] nums) { int candidate1 = 0xc0c0c0c0, candidate2 = 0xc0c0c0c0; int count1 = 0, count2 = 0; for (int i : nums) { if (count1 \u003e 0 \u0026\u0026 i == candidate1) { count1++; }else if (count2 \u003e 0 \u0026\u0026 i == candidate2) { count2++; }else if (count1 == 0) { candidate1 = i; count1 = 1; }else if (count2 == 0) { candidate2 = i; count2 = 1; }else { count1--; count2--; } } int cnt1 = 0, cnt2 = 0; for (int i : nums) { if (count1 \u003e 0 \u0026\u0026 i == candidate1) cnt1++; if (count2 \u003e 0 \u0026\u0026 i == candidate2) cnt2++; } List\u003cInteger\u003e ls = new ArrayList\u003c\u003e(); int n = nums.length; if (cnt1 \u003e n / 3) ls.add(candidate1); if (cnt2 \u003e n / 3) ls.add(candidate2); return ls; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:22:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"数学 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:23:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:23:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int[] constructRectangle(int area) { int ans = 0; for (int i = 1; i * i \u003c= area; ++i) { if (area % i == 0) ans = i; } int[] ANS = new int[]{area / ans, ans}; return ANS; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:23:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:24:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:24:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 按题意模拟 （要多写模拟，不要惧怕模拟😄） class Solution: def countValidWords(self, sentence: str) -\u003e int: ls = list(sentence.split(' ')) #print(ls) num = 0 for i in ls: if i == '': continue ok = True for j in i: if j.isdigit(): ok = False break if ok: if i.count('-') == 0: if (i.count('!') + i.count(',') + i.count('.') == 1) and ( i[len(i) - 1] == '!' or i[len(i) - 1] == ',' or i[len(i) - 1] == '.'): num += 1 elif i.count('!') + i.count(',') + i.count('.') == 0: num += 1 elif i.count('-') == 1: index = i.find('-') if index != 0 and index != len(i) - 1 and i[index - 1].isalpha() and i[index + 1].isalpha(): if (i.count('!') + i.count(',') + i.count('.') == 1) and ( i[len(i) - 1] == '!' or i[len(i) - 1] == ',' or i[len(i) - 1] == '.'): num += 1 elif i.count('!') + i.count(',') + i.count('.') == 0: num += 1 return num ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:24:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:25:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 如果整数 x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。 给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:25:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 模拟 class Solution: def nextBeautifulNumber(self, n: int) -\u003e int: def ok(n: int) -\u003e bool: st = str(n) for i in st: if st.count(i) != int(i): return False return True while True: n += 1 if ok(n): return n return 0 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:25:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs 分类讨论 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:26:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一棵二叉树，每个节点的分数为把这个节点和所连的边移除的连通块大小之积，求具有最大分数的点的个数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:26:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 dfs求一下子树大小，然后分情况讨论（叶子、一个孩子、两个孩子） class Solution { public: using ll = long long; int countHighestScoreNodes(vector\u003cint\u003e\u0026 parents) { ll num = (ll) parents.size(); vector\u003cll\u003e ch[num + 1]; ll subnum[num + 1]; for (ll i = 0; i \u003c num; ++i) { if (parents[i] == -1) continue; ch[parents[i]].push_back(i); } function\u003cvoid(ll)\u003e dfs = [\u0026](ll x) { if (ch[x].empty()) { subnum[x] = 1; return; } subnum[x] = 1; for (ll i : ch[x]) { dfs(i); subnum[x] += subnum[i]; } }; dfs(0); ll mx = -1; ll cnt = 0; if (ch[0].size() == 2) { mx = subnum[ch[0][0]] * subnum[ch[0][1]]; cnt = 1; }else if (ch[0].size() == 1) { mx = subnum[ch[0][0]]; cnt = 1; } for (ll i = 1; i \u003c num; ++i) { ll tmp; if ((ll) ch[i].size() == 2) { tmp = subnum[ch[i][0]] * subnum[ch[i][1]] * (num - subnum[ch[i][0]] - subnum[ch[i][1]] - 1); }else if ((ll) ch[i].size() == 1) { tmp = subnum[ch[i][0]] * (num - subnum[ch[i][0]] - 1); }else { tmp = num - 1; } if (tmp \u003e mx) { mx = tmp; cnt = 1; }else if (tmp == mx) { cnt++; } } return (int) cnt; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:26:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"拓扑序 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:27:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一个DAG，每个点表示一门课，有一个权值表示修这门课花费的时间，课程的修读有先后顺序，从起点开始修读到最后，求完成课程的最少时间，可以同时修多门课 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:27:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 求拓扑序的过程更新每个点的最少时间，注意可能有多个DAG class Solution { public: int minimumTime(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 relations, vector\u003cint\u003e\u0026 time) { vector\u003cint\u003e indegree(n + 1); vector\u003cint\u003e G[n + 1]; for (auto i : relations) { G[i[0]].push_back(i[1]); indegree[i[1]]++; } stack\u003cint\u003e s; vector\u003cint\u003e val(n + 1); for (int i = 1; i \u003c= n; ++i) { if (indegree[i] == 0) s.push(i); } // for (int i = 1; i \u003c= n; ++i) { // cout \u003c\u003c indegree[i] \u003c\u003c ' '; // } int ans; vector\u003cint\u003e tmp; while (!s.empty()) { int now = s.top(); s.pop(); bool ok = false; for (int j : G[now]) { ok = true; val[j] = max(val[j], val[now] + time[now - 1]); if (--indegree[j] == 0) s.push(j); } if (!ok) tmp.push_back(now); } ans = 0; for (int i : tmp) { ans = max(ans, val[i] + time[i - 1]); } return ans; //return 0; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:27:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:28:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:28:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public: unordered_map\u003cstring, int\u003e mp; string kthDistinct(vector\u003cstring\u003e\u0026 arr, int k) { for (auto i : arr) { mp[i]++; } for (auto i : arr) { if (mp[i] == 1) { k--; if (k == 0) { return i; } } } return \"\"; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:28:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:29:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 对于一个只有*和 | 的字符串，每次询问一个子串，求夹在 | 的*有几个 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:29:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 存一个前缀*和，存一下 | 出现的位置，对于每个子区间，先算有多少个*，然后算区间第一个 | 和最后一个 | ，在算一下之前和之后有几个*，减一下。注意很多种情况都是0，注意细节 class Solution { public: vector\u003cint\u003e platesBetweenCandles(string s, vector\u003cvector\u003cint\u003e\u003e\u0026 queries) { int n = s.length(); s.insert(s.begin(), '#'); vector\u003cint\u003e prestar(n + 2); if (s[1] == '*') prestar[1] = 1; for (int i = 2; i \u003c= n; ++i) { prestar[i] = prestar[i - 1] + (s[i] == '*' ? 1 : 0); } vector\u003cint\u003e bar; for (int i = 1; i \u003c= n; ++i) { if (s[i] == '|') { bar.push_back(i); } } vector\u003cint\u003e ans; for (auto i : queries) { int l = i[0], r = i[1]; l++, r++; int starnum = prestar[r] - prestar[l - 1]; if (bar.empty()) { ans.push_back(0); }else { auto ite = lower_bound(bar.begin(), bar.end(), l); if (ite == bar.end()) { ans.push_back(0); }else if (*ite \u003e r) { ans.push_back(0); }else { int tmpl = *ite; ite = upper_bound(bar.begin(), bar.end(), r); if (ite == bar.begin()) { ans.push_back(0); }else { ite--; if (*ite \u003c l) { ans.push_back(0); }else { int tmpr = *ite; ans.push_back(starnum - (tmpl - l) - (r - tmpr)); } } } } } return ans; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:29:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"排序 前缀 离散化 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:30:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 有n个区间，每个区间有一个价值，求两个不重叠区间价值和的最大值 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:30:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 区间按右端点排序，离散化求到每个区间右端点的前缀最大值 遍历每个区间，对于该区间，求小于左端点的前缀最大值并和该区间价值相加，不断更新答案 注意排序用pair排，用vector排会超时！！！ class Solution { public: int maxTwoEvents(vector\u003cvector\u003cint\u003e\u003e\u0026 events) { int mx = -1; for (auto i : events) { mx = max(mx, i[2]); } int n = (int) events.size(); vector\u003cint\u003e premax(n + 1); vector\u003cint\u003e bd; vector\u003cpair\u003cint, int\u003e\u003e v; for (auto i : events) { v.emplace_back(i[1], i[2]); } sort(v.begin(), v.end(), [\u0026](pair\u003cint, int\u003e p1, pair\u003cint, int\u003e p2){ return p1.first \u003c p2.first; }); premax[0] = v[0].second; bd.push_back(v[0].first); int ptr = 1; for (int i = 1; i \u003c n; ++i) { if (v[i].first == bd.back()) { premax[ptr - 1] = max(premax[ptr - 1], v[i].second); }else { bd.push_back(v[i].first); premax[ptr] = max(premax[ptr - 1], v[i].second); ptr++; } } v.clear(); for (auto i : events) { v.emplace_back(i[0], i[2]); } sort(v.begin(), v.end(), [\u0026](pair\u003cint, int\u003e p1, pair\u003cint, int\u003e p2) { return p1.first \u003c p2.first; }); for (int i = 1; i \u003c n; ++i) { int tmp = v[i].first - 1; auto ite = lower_bound(bd.begin(), bd.end(), tmp); if (ite != bd.end()) { if (*ite == tmp) { mx = max(mx, v[i].second + premax[ite - bd.begin()]); }else { if (ite != bd.begin()) { mx = max(mx, v[i].second + premax[ite - bd.begin() - 1]); } } } } return mx; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:30:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:31:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:31:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public: int smallestEqual(vector\u003cint\u003e\u0026 nums) { for (int i = 0; i \u003c (int) nums.size(); ++i) { if (i % 10 == nums[i]) { return i; } } return -1; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:31:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:32:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:32:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: vector\u003cint\u003e nodesBetweenCriticalPoints(ListNode* head) { ListNode* now = head; ListNode* nn = head-\u003enext; vector\u003cint\u003e vals; int pos = 1; while (nn-\u003enext != NULL) { int l = now-\u003eval; int m = nn-\u003eval; int r = nn-\u003enext-\u003eval; if (m \u003e l and m \u003e r) { vals.push_back(pos); }else if (m \u003c l and m \u003c r) { vals.push_back(pos); } now = now-\u003enext; nn = nn-\u003enext; pos++; } sort(vals.begin(), vals.end()); if ((int) vals.size() \u003c 2) { return {-1, -1}; } else { int mx = vals.back() - vals.front(); int mn = 1e6; for (int i = 0; i \u003c (int) vals.size() - 1; ++i) { mn = min(mn, vals[i + 1] - vals[i]); } return {mn, mx}; } } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:32:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"异或 思维 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:33:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。在线性时间复杂度和常数空间复杂度求解 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:33:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 假设两个数为x、y，将所有数异或为m，则x^y=m，求m二进制的某一位1，这一定是1^0的结果，遍历一遍数，把该位为1的和0的分开，两堆分开异或得到答案 注意__builtin_ffs返回最后一位1的位置，下标从1开始 class Solution { public: vector\u003cint\u003e singleNumber(vector\u003cint\u003e\u0026 nums) { int a = 0; for (int i : nums) { a ^= i; } int pos = __builtin_ffs(a); pos--; vector\u003cint\u003e v1, v2; for (int i : nums) { if (i \u003e\u003e pos \u0026 1) { v1.push_back(i); } else v2.push_back(i); } int l = 0, r = 0; for (int i : v1) { l ^= i; } for (int i : v2) { r ^= i; } return {l, r}; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:33:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"预处理 哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:34:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:34:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 预处理所有的2次幂，求每个数字出现的次数，一一比较 class Solution { public: bool reorderedPowerOf2(int n) { vector\u003cint\u003e num(10); while (n != 0) { num[n % 10]++; n /= 10; } vector\u003cvector\u003cint\u003e\u003e p; for (long long i = 1; i \u003c= 1000000000; i *= 2) { vector\u003cint\u003e tmp(10); int now = i; while (now != 0) { tmp[now % 10]++; now /= 10; } p.push_back(tmp); } for (auto i : p) { bool same = true; for (int j = 0; j \u003c 10; ++j) { if (i[j] != num[j]) { same = false; break; } } if (same) return true; } return false; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:34:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp 完全背包 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:35:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 商店有n种商品，有k个礼包，礼包将商品捆绑售卖，即给出里面每一种商品的个数和礼包的价格，购物清单上写了每种商品的需求，求恰好按购物清单上买的最低花费（\u003c=6种商品, \u003c=100个大礼包） ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:35:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 非常好的dp题，看数据大小可以暴搜，但我不会（官方题解有） 看起来很像完全背包，传统的完全背包是dp[i][j]表示前i个物品，容量不超过j的最大价值，这个题也有前i种物品（大礼包），也有容量（每种物品的购买个数），价值就变成了花费，但是有6种物品，所以有6种容量，所以可以设dp[i][j1][j2][j3][j4][j5][j6]，7重循环求解，（可以把6个容量维度状态压缩成1维，具体见民间题解），降维一下7重循环，6个维度的dp，初始化为dp = inf, dp[0][0][0][0][0][0] = 0，注意当物品没有6个时补齐6个 class Solution { public: int shoppingOffers(vector\u003cint\u003e\u0026 price, vector\u003cvector\u003cint\u003e\u003e\u0026 special, vector\u003cint\u003e\u0026 needs) { int n = (int) price.size(); for (int i = 0; i \u003c n; ++i) { vector\u003cint\u003e tmp(n + 1); tmp[i] = 1; tmp[n] = price[i]; special.push_back(tmp); } vector\u003cvector\u003cint\u003e\u003e SP; for (auto i : special) { vector\u003cint\u003e tmp = i; tmp.pop_back(); while ((int) tmp.size() != 6) { tmp.push_back(0); } tmp.push_back(i.back()); SP.push_back(tmp); } int dp[12][12][12][12][12][12]; while ((int) needs.size() \u003c 6) { needs.push_back(0); } memset(dp, 0x3f, sizeof(dp)); dp[0][0][0][0][0][0] = 0; int m = (int) special.size(); for (int i = 0; i \u003c m; ++i) { vector\u003cint\u003e bd(6); for (int j = 0; j \u003c 6; ++j) { bd[j] = SP[i][j]; } int money = SP[i][6]; for (int k0 = bd[0]; k0 \u003c= needs[0]; ++k0) { for (int k1 = bd[1]; k1 \u003c= needs[1]; ++k1) { for (int k2 = bd[2]; k2 \u003c= needs[2]; ++k2) { for (int k3 = bd[3]; k3 \u003c= needs[3]; ++k3) { for (int k4 = bd[4]; k4 \u003c= needs[4]; ++k4) { for (int k5 = bd[5]; k5 \u003c= needs[5]; ++k5) { dp[k0][k1][k2][k3][k4][k5] = min(dp[k0][k1][k2][k3][k4][k5], dp[k0 - SP[i][0]][k1 - SP[i][1]][k2 - SP[i][2]][k3 - SP[i][3]][k4 - SP[i][4]][k5 - SP[i][5]] + money); } } } } } } } return dp[needs[0]][needs[1]][needs[2]][needs[3]][needs[4]][needs[5]]; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:35:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"状态压缩 剪枝 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:36:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给你一个由若干括号和字母组成的字符串 s（长度为25，括号为20） ，删除最小数量的无效括号，使得输入的字符串有效。 返回所有可能的结果。答案可以按 任意顺序 返回。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:36:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 因为合法括号序列左括号一定等于有括号，所以状压枚举左括号和右括号，数量不相等直接剪枝，去掉的括号数小于临时答案直接剪枝，最后判断是否真的合法 class Solution { public: vector\u003cstring\u003e removeInvalidParentheses(string s) { auto ok = [\u0026](string str) { stack\u003cint\u003e st; for (char i : str) { if (i == '(') st.push(1); if (i == ')') { if (st.empty()) return false; else st.pop(); } } return st.empty(); }; int n = s.length(); int lnum = 0, rnum = 0; for (char i : s) { if (i == '(') lnum ++; if (i == ')') rnum ++; } int mn = min(lnum, rnum); unordered_set\u003cstring\u003e ans; int mncut = 100000; vector\u003cint\u003e lind, rind; for (int i = 0; i \u003c n; ++i) { if (s[i] == '(') lind.push_back(i); if (s[i] == ')') rind.push_back(i); } for (int i = 0; i \u003c (1 \u003c\u003c lnum); ++i) { for (int j = 0; j \u003c (1 \u003c\u003c rnum); ++j) { int lonenum = __builtin_popcount(i); int ronenum = __builtin_popcount(j); if (lonenum != ronenum) continue; int tmpcut = lnum + rnum - lonenum - ronenum; if (tmpcut \u003e mncut) continue; vector\u003cint\u003e ex(n); for (int k = 0; k \u003c lnum; ++k) { if ((i \u003e\u003e k \u0026 1) == 0) { ex[lind[k]] = 1; } } for (int k = 0; k \u003c rnum; ++k) { if ((j \u003e\u003e k \u0026 1) == 0) { ex[rind[k]] = 1; } } string tmpstr; for (int k = 0; k \u003c n; ++k) { if (ex[k]) continue; tmpstr.push_back(s[k]); } if (ok(tmpstr)) { if (tmpcut == mncut) { ans.insert(tmpstr); }else { mncut = tmpcut; ans.clear(); ans.insert(tmpstr); } } } } vector\u003cstring\u003e fans; for (auto i : ans) { fans.push_back(i); } return fans; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:36:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:37:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:37:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public: int countVowelSubstrings(string word) { auto ok = [\u0026](string s) { auto ed = string::npos; for (char i : s) { if (i != 'a' and i != 'e' and i != 'i' and i != 'o' and i != 'u') return false; } if (s.find('a') != ed and s.find('e') != ed and s.find('i') != ed and s.find('o') != ed and s.find('u') != ed) return true; return false; }; int ans = 0; int n = word.length(); for (int i = 0; i \u003c n; ++i) { for (int j = i; j \u003c n; ++j) { string s = word.substr(i, j - i + 1); if (ok(s)) { //cout \u003c\u003c s \u003c\u003c '\\n'; ans++; } } } return ans; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:37:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:38:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 有n个商店，有m种商品，每种商品有v[i]个，你需要把商品分到各个商店中，满足每个商店只能分一种商品（可以一个都不分），求商店最大商品数能达到的最小值 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:38:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 像这种既贪心又单调的可以考虑二分！二分答案 class Solution { public: int minimizedMaximum(int n, vector\u003cint\u003e\u0026 quantities) { int sz = (int) quantities.size(); int l = 1, r = *max_element(quantities.begin(), quantities.end()); while (l \u003c= r) { int mid = (l + r) \u003e\u003e 1; int now = 0; for (int i : quantities) { now += ceil(i / (double)mid); } if (now \u003c= n) { r = mid - 1; } else { l = mid + 1; } } return l; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:38:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"找规律 归纳 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:39:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一组行动序列，从原点出发，每次走move[i]步，每走一次自身逆时针90旋转，问走过的路径是否交叉 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:39:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 考虑交叉的情况，可以发现4条及以上才会交叉 5条（最后一条和第一条交叉才算） 6条 7条 （可以发现7条可以看做最后一条和第2条重复，所以应该算作6条） 之后也画不出更多的条数，所以对于每步只需要考虑4、5、6条的情况就行 class Solution { public boolean isSelfCrossing(int[] distance) { int n = distance.length; for (int i = 0; i \u003c n; ++i) { if (i \u003e= 3 \u0026\u0026 distance[i - 1] \u003c= distance[i - 3] \u0026\u0026 distance[i] \u003e= distance[i - 2]) return true; } for (int i = 0; i \u003c n; ++i) { if (i \u003e= 4 \u0026\u0026 distance[i - 2] \u003e distance[i - 4] \u0026\u0026 distance[i - 1] == distance[i - 3] \u0026\u0026 distance[i] + distance[i - 4] \u003e= distance[i - 2]) return true; } for (int i = 0; i \u003c n; ++i) { if (i \u003e= 5 \u0026\u0026 distance[i - 3] \u003e distance[i - 5] \u0026\u0026 distance[i - 2] \u003e distance[i - 4] \u0026\u0026 distance[i - 1] + distance[i - 5] \u003e= distance[i - 3] \u0026\u0026 distance[i - 1] \u003c distance[i - 3] \u0026\u0026 distance[i] + distance[i - 4] \u003e= distance[i - 2]) return true; } return false; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:39:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"堆 类dijkstra Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:40:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:40:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 没做过这种类型的题，感谢leetcode，设water[i][j]为水位高度，那么 water[i][j]=max(heightMap[i][j],min(water[i−1][j],water[i+1][j],water[i][j−1],water[i][j+1]))，所以water[i][j]需要四周来更新自己，但四周需要自己来更新对方 对于边缘 water[i][j] = heightMap[i][j]之后不会再改变，由于木桶效应，所以每次选择已经确定水位的方块中的最低水位的方块，来更新四周没有确定水位的方块，这就需要小根堆，用类dijkstra的思想 注意入堆时是Math.max(height[tx][ty], val) class Solution { public int trapRainWater(int[][] height) { int n = height.length; int m = height[0].length; boolean[][] used = new boolean[n][m]; int[][] dir = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}}; PriorityQueue\u003cint[]\u003e pq = new PriorityQueue\u003c\u003e((a, b) -\u003e a[1] - b[1]); // 小根堆 for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if (i == 0 || i == n - 1 || j == 0 || j == m - 1) { pq.offer(new int[]{i * m + j, height[i][j]}); used[i][j] = true; } } } int ans = 0; while (!pq.isEmpty()) { int[] cnt = pq.poll(); int x = cnt[0] / m; int y = cnt[0] % m; int val = cnt[1]; for (int i = 0; i \u003c 4; ++i) { int tx = x + dir[i][0]; int ty = y + dir[i][1]; if (tx \u003e= 0 \u0026\u0026 tx \u003c n \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c m \u0026\u0026 !used[tx][ty]) { if (val \u003e height[tx][ty]) ans += val - height[tx][ty]; used[tx][ty] = true; pq.offer(new int[]{tx * m + ty, Math.max(height[tx][ty], val)}); } } } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:40:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"枚举 模拟 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:41:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 强烈建议看英文题面 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:41:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 由于数据大小，枚举所有局面判断是否合法 代码来自吴自华 在计算时间复杂度时注意最多只有一个queen（这也太细节了，我直接忽略😫） const int d[8][2] = {{-1, 0}, {-1, -1}, {0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1}, {-1, 1}}; class Solution { vector\u003cvector\u003cint\u003e\u003e positions, possible; int n, ans = 0; vector\u003cint\u003e direction, step, xinit, yinit; bool valid(int x, int y) { return x \u003e= 1 \u0026\u0026 x \u003c= 8 \u0026\u0026 y \u003e= 1 \u0026\u0026 y \u003c= 8; } void check() { vector\u003cint\u003e x(xinit), y(yinit), s(step); bool go = true; while (go) { go = false; for (int i = 0; i \u003c n; ++i) { if (s[i] \u003e 0) { s[i]--; x[i] += d[direction[i]][0]; y[i] += d[direction[i]][1]; } if (s[i]) go = true; } for (int i = 0; i \u003c n; ++i) for (int j = i + 1; j \u003c n; ++j) if (x[i] == x[j] \u0026\u0026 y[i] == y[j]) return; } ans++; } void dfs(int i) { if (i == n) { check(); } else { direction.push_back(0); step.push_back(0); dfs(i + 1); direction.pop_back(); step.pop_back(); for (int j = 1; j \u003c 8; ++j) { for (int k : possible[i]) { int x = positions[i][0] + d[k][0] * j, y = positions[i][1] + d[k][1] * j; if (valid(x, y)) { direction.push_back(k); step.push_back(j); dfs(i + 1); direction.pop_back(); step.pop_back(); } } } } } public: int countCombinations(vector\u003cstring\u003e\u0026 pieces, vector\u003cvector\u003cint\u003e\u003e\u0026 positions) { n = pieces.size(); possible = vector\u003cvector\u003cint\u003e\u003e(n); this-\u003epositions = positions; xinit = vector\u003cint\u003e(n), yinit = vector\u003cint\u003e(n); for (int i = 0; i \u003c n; ++i) { xinit[i] = positions[i][0], yinit[i] = positions[i][1]; if (pieces[i] != \"rook\") { possible[i].emplace_back(1); possible[i].emplace_back(3); possible[i].emplace_back(5); possible[i].emplace_back(7); } if (pieces[i] != \"bishop\") { possible[i].emplace_back(0); possible[i].emplace_back(2); possible[i].emplace_back(4); possible[i].emplace_back(6); } } dfs(0); return ans; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:41:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:42:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求有多少个n的排列有k个逆序对（n\u003c=1000, k\u003c=1000） ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:42:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 裸dp，设dp[i][j]表示i的排列有j个逆序对的答案，对于数字i，它可以插到i-1的排列的任何位置而产生逆序对 dp[i][j] = dp[i-1][max(0, j-i+1)] + .. + dp[i-1][j] 初始化dp=0, dp[1][0] = 1，注意初始化和特判 class Solution { public int kInversePairs(int n, int k) { if (k \u003e n * (n - 1) / 2) return 0; final long mod = (long) (1e9 + 7); long[][] dp = new long[n + 1][k + 1]; long[] presum = new long[k + 1]; dp[1][0] = 1; Arrays.fill(presum, 1); for (int i = 2; i \u003c= n; ++i) { for (int j = 0; j \u003c= k; ++j) { if (j \u003e i * (i - 1) / 2) break; else { //dp[i][j] = (presum[j] - presum[Math.max(j - i, )]); if (j - i \u003e= 0) { dp[i][j] = presum[j] - presum[j - i]; }else { dp[i][j] = presum[j]; } dp[i][j] += mod; dp[i][j] %= mod; } } presum[0] = dp[i][0]; for (int p = 1; p \u003c= k; ++p) { presum[p] = presum[p - 1] + dp[i][p]; presum[p] %= mod; } } return (int) dp[n][k]; } } // 2 2 (0) // 3 2 (2) // 3 3 (1) ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:42:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"区间dp Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:43:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:43:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 这个题的本质是猜一个数后，会转到左边区间还是右边区间，然后一直重复，所以是个区间dp。设dp[i][j]表示从i到j的答案，对于某个区间，枚举区间的每个数作为猜测的数，dp[i][j] = max(dp[i][k-1], dp[k+1][j]) + val[k]，注意特判猜测的数为左端点和右端点，初始化为最大值，dp[i][i] = 0 class Solution { public int getMoneyAmount(int n) { int[][] dp = new int[n + 1][n + 1]; for (int i = 0; i \u003c n + 1; ++i) { for (int j = 0; j \u003c n + 1; ++j) { dp[i][j] = Integer.MAX_VALUE; } } for (int len = 1; len \u003c= n; ++len) { for (int i = 1; i \u003c= n - len + 1; ++i) { if (len == 1) { dp[i][i] = 0; }else { for (int j = i; j \u003c= i + len - 1; ++j) { if (j == i) { dp[i][i + len - 1] = Math.min(dp[i][i + len - 1], dp[i + 1][i + len - 1] + j); }else if (j == i + len - 1) { dp[i][i + len - 1] = Math.min(dp[i][i + len - 1], dp[i][i + len - 2] + j); }else { dp[i][i + len - 1] = Math.min(dp[i][i + len - 1], Math.max(dp[i][j - 1], dp[j + 1][i + len - 1]) + j); } } } } } return dp[1][n]; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:43:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:44:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:44:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public: bool checkAlmostEquivalent(string word1, string word2) { int num1[26] = {0}; int num2[26] = {0}; for (char i : word1) { num1[i - 'a']++; } for (char i : word2) { num2[i - 'a']++; } for (int i = 0; i \u003c 26; ++i) { if (abs(num1[i] - num2[i]) \u003e 3) return false; } return true; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:44:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"小模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:45:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:45:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public: vector\u003cint\u003e maximumBeauty(vector\u003cvector\u003cint\u003e\u003e\u0026 items, vector\u003cint\u003e\u0026 queries) { int qn = (int) queries.size(); int in = (int) items.size(); vector\u003cint\u003e ans(qn); vector\u003cpair\u003cint, int\u003e\u003e Q; for (int i = 0; i \u003c qn; ++i) { Q.emplace_back(queries[i], i); } sort(Q.begin(), Q.end()); vector\u003cpair\u003cint, int\u003e\u003e tmp; for (auto i : items) { tmp.emplace_back(i[0], i[1]); } sort(tmp.begin(), tmp.end()); int cnt = 0; int mx = 0; for (int i = 0; i \u003c qn; ++i) { while (cnt \u003c in and tmp[cnt].first \u003c= Q[i].first) { mx = max(mx, tmp[cnt].second); cnt++; } ans[Q[i].second] = mx; } return ans; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:45:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:46:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:46:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意题目说机器人走到头如果没有下一步是不会转向的 注意用周期优化 降低dirt！！ class Robot { public: int dir; // 0 right 1 up 2 left 3 down int w, h; int x, y; int circle; Robot(int width, int height) { dir = 0; w = width; h = height; x = 0; y = 0; circle = (w + h) * 2 - 4; } void move(int num) { //cout \u003c\u003c num \u003c\u003c \": \"; while (num \u003e 0) { if (dir == 0) { if (w - 1 - x \u003e= num) { x += num; num = 0; }else { num -= (w - 1 - x); x = w - 1; num %= circle; if (num != 0) dir ++; dir %= 4; } } else if (dir == 3) { if (y \u003e= num) { y -= num; num = 0; }else { num -= y; y = 0; num %= circle; if (num != 0) dir ++; dir %= 4; } } else if (dir == 2) { if (x \u003e= num) { x -= num; num = 0; }else { num -= x; x = 0; num %= circle; if (num != 0) dir++; dir %= 4; } } else { if (h - 1 - y \u003e= num) { y += num; num = 0; }else { num -= (h - 1 - y); y = h - 1; num %= circle; if (num != 0) dir++; dir %= 4; } } } //cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c ' ' \u003c\u003c dir \u003c\u003c '\\n'; } vector\u003cint\u003e getPos() { return vector\u003cint\u003e{x, y}; } string getDir() { if (dir == 0) return \"East\"; if (dir == 1) return \"North\"; if (dir == 2) return \"West\"; return \"South\"; } }; /** * Your Robot object will be instantiated and called as such: * Robot* obj = new Robot(width, height); * obj-\u003emove(num); * vector\u003cint\u003e param_2 = obj-\u003egetPos(); * string param_3 = obj-\u003egetDir(); */ ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:46:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"数论 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:47:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 强烈建议阅读英文题面 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:47:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 只有被转换奇数次的才会亮着，也就是约数有奇数个的才行，约数有奇数个的是完全平方数，所以就是求n以内的完全平方数个数 注意如果出现精度问题要+0.0000001这种 class Solution { public int bulbSwitch(int n) { return (int) Math.sqrt(n); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:47:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"扫描线 结论 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:48:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 坐标系上有n个矩形，问是否这n个矩形不重叠且可以组成恰1个矩形 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:48:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 如果可以拼成1个矩形，需要满足除边缘的线，组成的区间都有左边矩形和右边矩形匹配，因为最终只能是1个矩形，所以每条竖线只能合并成1个区间（且原来的碎片区间不相交）而不是分裂的几个区间，比如说 这是我一开始的想法，后来被证伪，反例是 所以应该是除边缘线外可以是分裂的区间，边缘线必须合并成1个区间 class Solution { public boolean isRectangleCover(int[][] rectangles) { int L, R; L = Integer.MAX_VALUE; R = Integer.MIN_VALUE; int n = rectangles.length; for (int[] rectangle : rectangles) { L = Math.min(L, rectangle[0]); R = Math.max(R, rectangle[2]); } HashMap\u003cInteger, ArrayList\u003cint[]\u003e\u003e LineL = new HashMap\u003c\u003e(); HashMap\u003cInteger, ArrayList\u003cint[]\u003e\u003e LineR = new HashMap\u003c\u003e(); HashSet\u003cInteger\u003e Line = new HashSet\u003c\u003e(); for (int[] rectangle : rectangles) { Line.add(rectangle[0]); Line.add(rectangle[2]); int[] tmp = {rectangle[1], rectangle[3]}; if (!LineR.containsKey(rectangle[0])) { LineR.put(rectangle[0], new ArrayList\u003c\u003e()); } LineR.get(rectangle[0]).add(tmp); if (!LineL.containsKey(rectangle[2])) { LineL.put(rectangle[2], new ArrayList\u003c\u003e()); } LineL.get(rectangle[2]).add(tmp); } for (Map.Entry\u003cInteger, ArrayList\u003cint[]\u003e\u003e entry : LineL.entrySet()) { entry.getValue().sort((a, b) -\u003e { if (a[0] != b[0]) return a[0] - b[0]; return a[1] - b[1]; }); } for (Map.Entry\u003cInteger, ArrayList\u003cint[]\u003e\u003e entry : LineR.entrySet()) { entry.getValue().sort((a, b) -\u003e { if (a[0] != b[0]) return a[0] - b[0]; return a[1] - b[1]; }); } for (int i : Line) { if (i == L) { List\u003cint[]\u003e tmp = LineR.get(i); for (int j = 1; j \u003c tmp.size(); ++j) { if (tmp.get(j)[0] == tmp.get(j - 1)[1]) continue; return false; } }else if (i == R) { List\u003cint[]\u003e tmp = LineL.get(i); for (int j = 1; j \u003c tmp.size(); ++j) { if (tmp.get(j)[0] == tmp.get(j - 1)[1]) continue; return false; } }else { if (!LineL.containsKey(i)) return false; if (!LineR.containsKey(i)) return false; List\u003cint[]\u003e tmpl = new ArrayList\u003c\u003e(), tmpr = new ArrayList\u003c\u003e(); List\u003cint[]\u003e tmp = LineL.get(i); int cnt = tmp.get(0)[0]; for (int j = 1; j \u003c tmp.size(); ++j) { if (tmp.get(j)[0] == tmp.get(j - 1)[1]) continue; tmpl.add(new int[]{cnt, tmp.get(j - 1)[1]}); cnt = tmp.get(j)[0]; } tmpl.add(new int[]{cnt, tmp.get(tmp.size() - 1)[1]}); tmp = LineR.get(i); cnt = tmp.get(0)[0]; for (int j = 1; j \u003c tmp.size(); ++j) { if (tmp.get(j)[0] == tmp.get(j - 1)[1]) continue; tmpr.add(new int[]{cnt, tmp.get(j - 1)[1]}); cnt = tmp.get(j)[0]; } tmpr.add(new int[]{cnt, tmp.get(tmp.size() - 1)[1]}); if (tmpl.size() != tmpr.size()) return false; for (int j = 0; j \u003c tmpl.size(); ++j) { if (tmpl.get(j)[0] == tmpr.get(j)[0] \u0026\u0026 tmpl.get(j)[1] == tmpr.get(j)[1]) continue; return false; } } } return true; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:48:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:49:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:49:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 小技巧是用二进制存信息优化 class Solution { public int maxProduct(String[] words) { int n = words.length; int[] num = new int[n]; int ans = 0; for (int j = 0; j \u003c n; ++j) { int tmp = 0; for (int i = 0; i \u003c words[j].length(); ++i) { tmp |= (1 \u003c\u003c (words[j].charAt(i) - 'a')); } num[j] = tmp; } for (int i = 0; i \u003c n; ++i) { for (int j = i + 1; j \u003c n; ++j) { if ((num[j] \u0026 num[i]) == 0) { ans = Math.max(ans, words[i].length() * words[j].length()); } } } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:49:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp 分类讨论 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:50:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:50:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 正则表达式匹配最高效的做法应该是用状态机？ 很好的dp题，细节比较多（官方题解似乎很简洁🤔） dp[i][j]表示s串前i个和p串的前j个是否匹配 如果s[i] = p[j] 那一定可以匹配， dp[i][j] = dp[i-1][j-1] 否则如果p[j] 是个字母，由于两个字母不同，一定不匹配 dp[i][j] = false 否则如果p[j]是’.’，它可以匹配任意一个字母，可以匹配dp[i][j] = dp[i-1][j-1] 否则如果p[j] = ‘*’， 这个比较麻烦 如果p[j-1] = s[i] 则这个*可以把前面的字母和自己吞掉，可以把自己吞掉，可以复制前面的字母，所以 dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j-1] 否则如果p[j-1]是个字母，那*只能把前面的字母吞掉，dp[i][j] = dp[i][j-2] 否则如果p[j-1]是’.’， 那它可以当做任何一个字母，dp[i][j] = dp[i][j-2] || dp[i][j-1] || dp[i-1][j-1] 不可能出现两个连续的’*’ 初始化 dp = false, dp[0][0] = true 这么做有几个漏洞 “aab”, “cab” 无法通过，因为一开始就不匹配，后面都匹配不了（这肯能和代码有关），所以需要在s串和p串加个’a’来启动匹配 “aaa”, “.*” 无法通过，最后漏考虑了一种情况，因为 “.*” 的 ‘.’ 可以是任意字母，所以dp[i][j] |= dp[i-1][j]，即当前s串的最后一个字母一定能匹配 有罚时的比赛应该考虑怎么通过想这些样例来降低dirt！！ class Solution { public boolean isMatch(String s, String p) { s = new StringBuilder(s).insert(0, 'a').toString(); // insert 'a' in front to make aligned, pass \"aab\", \"c*a*b\" p = new StringBuilder(p).insert(0, 'a').toString(); int sn = s.length(), pn = p.length(); s = new StringBuilder(s).insert(0, 'a').toString(); p = new StringBuilder(p).insert(0, 'a').toString(); boolean[][] dp = new boolean[sn + 1][pn + 1]; dp[0][0] = true; for (int i = 1; i \u003c= sn; ++i) { for (int j = 1; j \u003c= pn; ++j) { if (s.charAt(i) == p.charAt(j)) { dp[i][j] = dp[i - 1][j - 1]; } else if ('a' \u003c= p.charAt(j) \u0026\u0026 p.charAt(j) \u003c= 'z') { dp[i][j] = false; } else if (p.charAt(j) == '.') { dp[i][j] = dp[i - 1][j - 1]; } else if (p.charAt(j) == '*') { if (p.charAt(j - 1) == s.charAt(i)) { dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j - 1]; } else if (p.charAt(j - 1) \u003e= 'a' \u0026\u0026 p.charAt(j - 1) \u003c= 'z') { dp[i][j] = dp[i][j - 2]; } else if (p.charAt(j - 1) == '.') { dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j - 1] || dp[i - 1][j]; // add dp[i - 1][j] to pass \"aaa\", \".*\" } } } } return dp[sn][pn]; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:50:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"预处理 数位dp 递归 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:51:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:51:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 预处理dp[i]表示小于等于i位数的1的个数 对于数n，比如它为114514，就可以先算1-99999中1的个数，然后计算100000-114514的1的个数，接下来算最高位的1，有14515个，最后递归算1-14514的1的个数 再比如7355608，可以先算1-999999的1的个数，然后计算1000000-7355608的1的个数，接下来算最高位1，有1000000个，再算2000000-7355608，这等价于递归算1-355608中1的个数 class Solution { int[] dp = new int[11]; public int countDigitOne(int n) { dp[1] = 1; for (int i = 2; i \u003c 11; ++i) { dp[i] += dp[i - 1]; dp[i] += 9 * dp[i - 1] + Math.pow(10, i - 1); } return cal(n); } private int digitNum(int n) { if (n == 0) return 1; int res = 0; while (n != 0) { res++; n /= 10; } return res; } private int cal(int n) { int num = digitNum(n); if (num == 1) { return n \u003c 1 ? 0 : 1; } int ans = dp[num - 1]; int tmp = (int) (n / Math.pow(10, num - 1)); tmp--; ans += tmp * dp[num - 1]; ans += Math.min(n - Math.pow(10, num - 1) + 1, Math.pow(10, num - 1)); ans += cal((int) (n % Math.pow(10, num - 1))); return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:51:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"bfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:52:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 将二叉树序列化和反序列化，不管实现逻辑，只要能保证不同二叉树对应不同序列即可 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:52:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 本来想试试用prufer code，顺便复习一波，后来发现prufer code只能用在labeled tree 只要bfs层序遍历，多记一层的空节点 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { if (root == null) return \"null\"; StringBuilder sb = new StringBuilder(); Queue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(){{add(root);}}; while (!q.isEmpty()) { TreeNode tmp = q.poll(); if (tmp == null) { sb.append(\",null\"); } else { if (tmp != root) sb.append(','); sb.append(String.valueOf(tmp.val)); } if (tmp != null) { q.add(tmp.left); q.add(tmp.right); } } //System.out.println(sb.toString()); return sb.toString(); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if (data.equals(\"null\")) return null; String[] d = data.split(\",\"); TreeNode root = new TreeNode(Integer.parseInt(d[0])); Queue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(){{add(root);}}; int cur = 1; while (!q.isEmpty()) { TreeNode tmp = q.poll(); String left = d[cur]; String right = d[cur + 1]; cur += 2; if (!left.equals(\"null\")) { TreeNode lnode = new TreeNode(Integer.parseInt(left)); tmp.left = lnode; q.add(lnode); } if (!right.equals(\"null\")) { TreeNode rnode = new TreeNode(Integer.parseInt(right)); tmp.right = rnode; q.add(rnode); } } return root; } } // Your Codec object will be instantiated and called as such: // Codec codec = new Codec(); // codec.deserialize(codec.serialize(root)); ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:52:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"双端队列 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:53:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 经典的滑动窗口 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:53:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 参考此处 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 0) return new int[0]; int n = nums.length; int[] ans = new int[n - k + 1]; Deque\u003cInteger\u003e dq = new LinkedList\u003c\u003e(); for (int i = 0; i \u003c n; ++i) { if (!dq.isEmpty() \u0026\u0026 dq.peekFirst() \u003c= i - k) { dq.pollFirst(); } while (!dq.isEmpty() \u0026\u0026 nums[dq.peekLast()] \u003c= nums[i]) { dq.pollLast(); } dq.offerLast(i); if (i \u003e= k - 1) { ans[i - k + 1] = nums[dq.peekFirst()]; } } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:53:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"堆 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:54:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:54:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 三年前啥也不会的我在紫书上看到这个题以为无解。。。😄 参考此处 class MedianFinder { /** initialize your data structure here. */ Queue\u003cInteger\u003e minHeap, maxHeap; public MedianFinder() { minHeap = new PriorityQueue\u003c\u003e((a, b) -\u003e a - b); maxHeap = new PriorityQueue\u003c\u003e((a, b) -\u003e b - a); } public void addNum(int num) { if (maxHeap.isEmpty()) { maxHeap.add(num); } else { if (num \u003e maxHeap.peek()) { minHeap.add(num); } else { maxHeap.add(num); } } if (maxHeap.size() \u003e minHeap.size() + 1) { minHeap.add(maxHeap.poll()); } if (minHeap.size() \u003e maxHeap.size() + 1) { maxHeap.add(minHeap.poll()); } } public double findMedian() { if (maxHeap.size() == minHeap.size() + 1) { return maxHeap.peek(); } else if (minHeap.size() == maxHeap.size() + 1) { return minHeap.peek(); } else { return (minHeap.peek() + maxHeap.peek()) / 2.0; } } } /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */ ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:54:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"归并排序 树状数组 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:55:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求逆序对个数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:55:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 经典的就是归并排序求，但是这个细节太多不好写，树状数组思路比较直接 求三元逆序组参考此处 归并排序 class Solution { int[] tmp; public int reversePairs(int[] nums) { int n = nums.length; if (n \u003c 2) return 0; tmp = new int[n]; return cal(nums, 0, n - 1); } private int cal(int[] nums, int l, int r) { if (l == r) return 0; int mid = l + (r - l) / 2; int leftCount = cal(nums, l, mid); int rightCount = cal(nums, mid + 1, r); if (nums[mid] \u003c= nums[mid + 1]) { return leftCount + rightCount; } return leftCount + rightCount + crossCount(nums, l, mid, r); } private int crossCount(int[] nums, int l, int mid, int r) { for (int i = l; i \u003c= r; ++i) { tmp[i] = nums[i]; } int res = 0; int ptrL = l, ptrR = mid + 1; for (int i = l; i \u003c= r; ++i) { if (ptrL == mid + 1) { nums[i] = tmp[ptrR]; ptrR++; } else if (ptrR == r + 1) { nums[i] = tmp[ptrL]; ptrL++; } else if (tmp[ptrL] \u003c= tmp[ptrR]) { nums[i] = tmp[ptrL]; ptrL++; } else { nums[i] = tmp[ptrR]; ptrR++; res += mid - ptrL + 1; } } return res; } } 树状数组 class Solution { public int reversePairs(int[] nums) { int n = nums.length; int[] tmp = new int[n]; System.arraycopy(nums, 0, tmp, 0, n); Arrays.sort(tmp); for (int i = 0; i \u003c n; ++i) { nums[i] = Arrays.binarySearch(tmp, nums[i]) + 1; } FenwickTree fenwickTree = new FenwickTree(n); int ans = 0; for (int i = 0; i \u003c n; ++i) { ans += i - fenwickTree.sum(nums[i]); fenwickTree.add(nums[i], 1); } return ans; } } class FenwickTree { //[1, n] private int[] bit; private int n; public FenwickTree(int n) { this.bit = new int[n + 1]; this.n = n; } public int sum(int i) { int s = 0; while (i \u003e 0) { s += bit[i]; i -= i \u0026 -i; } return s; } public void add(int i, int x) { while (i \u003c= n) { bit[i] += x; i += i \u0026 -i; } } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:55:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"数论 结论 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:56:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给定一个正整数 n ，你可以做如下操作： 如果 n 是偶数，则用 n / 2替换 n 。 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。 n 变为 1 所需的最小替换次数是多少？ ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:56:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 直接搜索或者 对于奇数+1还是-1，分情况讨论 可以发现奇数n%4=1选-1，否则选+1 注意特判3和int溢出，这个也太细节了😣，什么时候能做到思维严谨，都是以前养成的不好习惯 class Solution { public int integerReplacement(int n) { long nn = n; int ans = 0; while (nn != 1) { if (nn == 3) return ans + 2; if ((nn \u0026 1) == 1) { if ((nn \u003e\u003e 1 \u0026 1) == 1) { nn++; } else { nn--; } } else { nn /= 2; } ans++; } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:56:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"k进制 思维 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:57:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:57:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 经典面试题，用k进制做 class Solution { public int poorPigs(int buckets, int minutesToDie, int minutesToTest) { return (int) Math.ceil(Math.log(buckets) / Math.log(minutesToTest / minutesToDie + 1)); } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:57:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:58:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 实现随机取1-1e8中的数字，取过的数字不再取的方法 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:58:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 用哈希表，将取过的数据交换到后面，没取的数交换到前面。假设还能取x个，这样每次都随机取1-x，这里面包含了之前被交换过来没取过的数 class Solution { Map\u003cInteger, Integer\u003e mp; int m, n; int curNum; Random random; public Solution(int m, int n) { this.m = m; this.n = n; mp = new HashMap\u003c\u003e(); random = new Random(); curNum = m * n; } public int[] flip() { int tmp = random.nextInt(curNum); curNum--; int id = mp.getOrDefault(tmp, tmp); mp.put(tmp, mp.getOrDefault(curNum, curNum)); return new int[]{id / n, id % n}; } public void reset() { mp.clear(); curNum = m * n; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(m, n); * int[] param_1 = obj.flip(); * obj.reset(); */ ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:58:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"可重置节点并查集 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:59:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:59:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 按时间顺序用并查集模拟，但是需要撤销操作。做法是把这个时刻的点都加完，遍历这一轮的点，如果和0不在一个集合里，就重置par[x] = x 主要是和 “重置节点” 结合 class Solution { public: vector\u003cint\u003e findAllPeople(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 meetings, int firstPerson) { queue\u003cint\u003e q; int par[n]; int rankk[n]; for (int i = 0; i \u003c n; ++i) { par[i] = i; rankk[i] = 0; } function\u003cint(int)\u003e find = [\u0026](int x) { if (par[x] == x) return x; return par[x] = find(par[x]); }; auto unite = [\u0026](int x, int y) { x = find(x); y = find(y); if (x == y) return ; if (rankk[x] \u003c rankk[y]) par[x] = y; else { par[y] = x; if (rankk[x] == rankk[y]) rankk[x]++; } }; auto same = [\u0026](int x, int y) { return find(x) == find(y); }; auto reset = [\u0026](int x) { par[x] = x; rankk[x] = 0; }; map\u003cint, vector\u003cpair\u003cint, int\u003e\u003e\u003e mp; for (auto\u0026 i : meetings) { mp[i[2]].emplace_back(i[0], i[1]); } mp[0].emplace_back(0, firstPerson); for (auto\u0026 [x, y] : mp) { for (auto\u0026 [i, j] : y) { unite(i, j); q.push(i); q.push(j); } while (!q.empty()) { int tmp = q.front(); q.pop(); if (!same(tmp, 0)) reset(tmp); } } vector\u003cint\u003e ans; for (int i = 0; i \u003c n; ++i) if (same(0, i)) ans.push_back(i); return ans; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:59:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 双指针 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:60:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:60:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 bf或者 二分第k大的数的值x（在0-1） 检测小于等于x的数有几个，如果小于k，l=mid，否则r=mid 用双指针i,j表示arr[i]/arr[j]是否小于等于x，如果是则i++，否则counter+=i 遍历每个j，i跟随着移动（类似于用归并排序算逆序对时，算跨过左右两个区间的逆序对个数） 时间复杂度O(n*logC)，C为(3e4)^2 class Solution { public int[] kthSmallestPrimeFraction(int[] arr, int k) { double l = 0, r = 1; final double eps = 1e-9; int n = arr.length; while (r - l \u003e= eps) { double mid = (l + r) / 2; int count = 0; int cnti = 0; int ansi = 0, ansj = n - 1; for (int j = 1; j \u003c n; ++j) { while (true) { if ((double) arr[cnti] / arr[j] \u003c= mid) { if (arr[cnti] * arr[ansj] \u003e arr[j] * arr[ansi]) { ansi = cnti; ansj = j; } cnti++; } else { count += cnti; break; } } } if (count == k) return new int[]{arr[ansi], arr[ansj]}; if (count \u003e k) r = mid; else l = mid; } return null; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:60:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:61:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:61:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 二分 class Solution { public int findNthDigit(int n) { long l = 1, r = n; while (l \u003c= r) { long mid = l + (r - l) / 2; long cnt = count(mid); if (cnt \u003c n) l = mid + 1; else r = mid - 1; } long ct = count(l); ct -= n; String s = String.valueOf(l); return (int) (s.charAt((int) (s.length() - ct - 1)) - '0'); } public long count(long x) { int digitNum = 0; long tmp = x; while (tmp \u003e 0) { tmp /= 10; digitNum++; } long res = 0; for (int i = 1; i \u003c digitNum; ++i) { res += 9 * Math.pow(10, i - 1) * i; } res += (x - Math.pow(10, digitNum - 1) + 1) * digitNum; return res; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:61:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"欧拉降幂 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:62:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求a ^ b % 1337 ， b是大数 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:62:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 除了欧拉降幂就不会做了捏😭 class Solution { public long quickPow(long x, long n, long mod) { long res = 1; while (n \u003e 0) { if (n % 2 == 1) res = res * x % mod; x = x * x % mod; n \u003e\u003e= 1; } return res; } public int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } public int superPow(int a, int[] b) { long phi = 1140; int n = b.length; long now = 0; long multiple = 1; for (int i = n - 1; i \u003e= 0; --i) { now += b[i] * multiple % phi; now %= phi; multiple *= 10; multiple %= phi; } if (gcd(a, 1337) == 1) { return (int) quickPow(a, now, 1337); } else { return (int) quickPow(a, now + phi, 1337); } } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:62:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"完全背包 四平方和定理 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:63:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求1个正整数最少可以表示成几个完全平方数之和 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:63:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 完全背包或 四平方数之和（Lagrange’s four-square theorem），任何一个正整数都可以表示成最多四个完全平方数之和，特殊地，如果一个数不能表示成4^k*(8m+7)，(k\u003e=0, m\u003e=0)的形式，那它最多只需要三个数 class Solution: def numSquares(self, n: int) -\u003e int: dp = [100000 for i in range(10005)] dp[0] = 0 a = [] k = 1 while k * k \u003c= n + 5: a.append(k * k) k += 1 sz = len(a) for i in range(1, sz + 1): for j in range(a[i - 1], n + 1): dp[j] = min(dp[j], dp[j - a[i - 1]] + 1) return dp[n] class Solution { public int numSquares(int n) { //Lagrange's four-square theorem if (isPerfectSquare(n)) return 1; for (int i = 1; i * i \u003c n; ++i) { if (isPerfectSquare(n - i * i)) return 2; } // 4 ^ k * (8 * m + 7) while (n % 4 == 0) { n /= 4; } if (n % 8 == 7) return 4; return 3; } private boolean isPerfectSquare(int n) { int x = (int) Math.sqrt(n); return x * x == n; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:63:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:64:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 求网格某个连通块的边界 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:64:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { private int[][] grid; private int cl; private int[][] dir = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; private int n, m; public int[][] colorBorder(int[][] grid, int row, int col, int color) { Queue\u003cint[]\u003e q = new ArrayDeque\u003c\u003e(); this.grid = grid; this.cl = grid[row][col]; this.n = grid.length; this.m = grid[0].length; dfs(row, col); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if (this.grid[i][j] == -1) { boolean ok = true; for (int k = 0; k \u003c 4; ++k) { int tx = i + dir[k][0]; int ty = j + dir[k][1]; if (!(tx \u003e= 0 \u0026\u0026 tx \u003c n \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c m \u0026\u0026 this.grid[tx][ty] == -1)) { ok = false; break; } } if (!ok) q.add(new int[]{i, j}); } } } for (int[] i : q) { grid[i[0]][i[1]] = color; } for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if (grid[i][j] == -1) grid[i][j] = cl; } } return grid; } private void dfs(int x, int y) { grid[x][y] = -1; for (int i = 0; i \u003c 4; ++i) { int tx = x + dir[i][0]; int ty = y + dir[i][1]; if (tx \u003e= 0 \u0026\u0026 tx \u003c n \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c m \u0026\u0026 grid[tx][ty] == cl) dfs(tx, ty); } } } // [[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]] // 1 // 3 // 1 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:64:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"欧拉路径 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:65:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:65:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 hierholzer算法，注意删边，不要判断边是否被遍历过 参考 class Solution { public: vector\u003cvector\u003cint\u003e\u003e validArrangement(vector\u003cvector\u003cint\u003e\u003e\u0026 pairs) { vector\u003cint\u003e id; for (auto i : pairs) { id.push_back(i[0]); id.push_back(i[1]); } sort(id.begin(), id.end()); id.erase(unique(id.begin(), id.end()), id.end()); int n = (int) id.size(); vector\u003cint\u003e G[n]; auto get_id = [\u0026](int x) { return lower_bound(id.begin(), id.end(), x) - id.begin(); }; auto get_val = [\u0026](int x) { return id[x]; }; vector\u003cint\u003e indegree(n), outdegree(n); for (auto i : pairs) { G[get_id(i[0])].push_back(get_id(i[1])); outdegree[get_id(i[0])]++; indegree[get_id(i[1])]++; } int s = -1, t = -1; for (int i = 0; i \u003c n; ++i) { if (outdegree[i] - indegree[i] == 1) s = i; if (indegree[i] - outdegree[i] == 1) t = i; } if (s == -1) s = 0; if (t == -1) t = 1; stack\u003cint\u003e st; //unordered_map\u003cpair\u003cint, int\u003e, bool, pair_hash\u003e used; function\u003cvoid(int)\u003e dfs = [\u0026](int x) { while (!G[x].empty()) { int tmp = G[x].back(); G[x].pop_back(); dfs(tmp); } st.push(x); }; dfs(s); vector\u003cint\u003e tmp; while (!st.empty()) { tmp.push_back(st.top()); st.pop(); } vector\u003cvector\u003cint\u003e\u003e ans; for (int i = 0; i \u003c (int) tmp.size() - 1; ++i) { ans.push_back({get_val(tmp[i]), get_val(tmp[i + 1])}); } return ans; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:65:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"前缀和 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:66:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:66:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int[] maxSumOfThreeSubarrays(int[] nums, int k) { long mx = -1; int left = 0, mid = 0, right = 0; int n = nums.length; long[] data = new long[n - k + 2]; long tmp = 0; for (int i = 0; i \u003c k; ++i) { tmp += nums[i]; } for (int i = 1; i \u003c= n - k + 1; ++i) { data[i] = tmp; if (i != n - k + 1) { tmp -= nums[i - 1]; tmp += nums[i + k - 1]; } } int[] premaxId = new int[n - k + 2]; int[] sufmaxId = new int[n - k + 2]; long[] premax = new long[n - k + 2]; long[] sufmax = new long[n - k + 3]; long cntMx = -1; for (int i = 1; i \u003c= n - k + 1; ++i) { if (data[i] \u003e cntMx) { cntMx = data[i]; premaxId[i] = i; } else premaxId[i] = premaxId[i - 1]; premax[i] = Math.max(premax[i - 1], data[i]); } cntMx = -1; for (int i = n - k + 1; i \u003e= 1; --i) { if (data[i] \u003e= cntMx) { cntMx = data[i]; sufmaxId[i] = i; } else sufmaxId[i] = sufmaxId[i + 1]; sufmax[i] = Math.max(sufmax[i + 1], data[i]); } for (int i = 2; i \u003c n - k + 1; ++i) { long tmpval = data[i]; if (i - k \u003e= 1) tmpval += premax[i - k]; else continue; if (i + k \u003c= n - k + 1) tmpval += sufmax[i + k]; else continue; if (tmpval \u003e mx) { mx = tmpval; left = premaxId[i - k]; mid = i; right = sufmaxId[i + k]; } } return new int[]{left - 1, mid - 1, right - 1}; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:66:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"分类讨论 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:67:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:67:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public boolean validTicTacToe(String[] board) { char[][] Board = new char[3][3]; for (int i = 0; i \u003c 3; ++i) { for (int j = 0; j \u003c 3; ++j) { Board[i][j] = board[i].charAt(j); } } int xnum = 0, onum = 0; boolean xwin = false, owin = false; for (int i = 0; i \u003c 3; ++i) for (int j = 0; j \u003c 3; ++j) if (Board[i][j] == 'X') xnum++; else if (Board[i][j] == 'O') onum++; if (Board[0][0] == Board[0][1] \u0026\u0026 Board[0][1] == Board[0][2] \u0026\u0026 Board[0][2] == Board[0][0]) { if (Board[0][0] == 'X') xwin = true; else if (Board[0][0] == 'O') owin = true; } if (Board[1][0] == Board[1][1] \u0026\u0026 Board[1][1] == Board[1][2] \u0026\u0026 Board[1][2] == Board[1][0]) { if (Board[1][0] == 'X') xwin = true; else if (Board[1][0] == 'O') owin = true; } if (Board[2][0] == Board[2][1] \u0026\u0026 Board[2][1] == Board[2][2] \u0026\u0026 Board[2][2] == Board[2][0]) { if (Board[2][0] == 'X') xwin = true; else if (Board[2][0] == 'O') owin = true; } if (Board[0][0] == Board[1][0] \u0026\u0026 Board[1][0] == Board[2][0] \u0026\u0026 Board[2][0] == Board[0][0]) { if (Board[0][0] == 'X') xwin = true; else if (Board[0][0] == 'O') owin = true; } if (Board[0][1] == Board[1][1] \u0026\u0026 Board[1][1] == Board[2][1] \u0026\u0026 Board[2][1] == Board[0][1]) { if (Board[0][1] == 'X') xwin = true; else if (Board[0][1] == 'O') owin = true; } if (Board[0][2] == Board[1][2] \u0026\u0026 Board[1][2] == Board[2][2] \u0026\u0026 Board[2][2] == Board[0][2]) { if (Board[0][2] == 'X') xwin = true; else if (Board[0][2] == 'O') owin = true; } if (Board[0][0] == Board[1][1] \u0026\u0026 Board[1][1] == Board[2][2] \u0026\u0026 Board[2][2] == Board[0][0]) { if (Board[0][0] == 'X') xwin = true; else if (Board[0][0] == 'O') owin = true; } if (Board[0][2] == Board[1][1] \u0026\u0026 Board[1][1] == Board[2][0] \u0026\u0026 Board[2][0] == Board[0][2]) { if (Board[0][2] == 'X') xwin = true; else if (Board[0][2] == 'O') owin = true; } if (xwin \u0026\u0026 owin) return false; if (!xwin \u0026\u0026 !owin) { if (xnum == onum || xnum == onum + 1) return true; else return false; } else { if (xwin) { if (xnum == onum + 1) return true; else return false; // xnum != onum } else { if (xnum == onum) return true; else return false; } } } } // [\"XXX\",\"XOO\",\"OO \"] ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:67:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"前缀和 贪心 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:68:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:68:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 至多拐弯一次，注意细节 class Solution { public: int maxTotalFruits(vector\u003cvector\u003cint\u003e\u003e\u0026 f, int st, int k) { int n = (int) f.size(); vector\u003cint\u003e presum(2e5 + 10); unordered_map\u003cint, int\u003e mp; for (int i = 0; i \u003c n; ++i) { mp[f[i][0] + 1] = f[i][1]; } for (int i = 1; i \u003c 2e5 + 10; ++i) { if (mp.find(i) != mp.end()) { presum[i] = presum[i - 1] + mp[i]; } else { presum[i] = presum[i - 1]; } } int mx = -1; st++; if (k == 0) return mp[st]; for (int i = 1; i \u003c= 2e5 + 3; ++i) { int now = 0; if (abs(st - i) \u003e k) continue; if (i \u003c= st) { now += presum[st] - presum[i - 1]; int rem = k - 2 * (st - i); if (rem \u003c= 0 ) { mx = max(mx, now); continue; } else if (st + rem \u003e 2e5 + 3) { now += presum[2e5 + 3] - presum[st]; mx = max(mx, now); continue; } now += presum[st + rem] - presum[st]; } else { now += presum[i] - presum[st - 1]; int rem = k - 2 * (i - st); if (rem \u003c= 0) { mx = max(now, mx); continue; } else if (st - rem \u003c= 0) { now += presum[st - 1] - presum[0]; mx = max(mx, now); continue; } now += presum[st - 1] - presum[st - rem - 1]; } mx = max(mx, now); } return mx; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:68:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"贪心 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:69:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:69:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int maxIncreaseKeepingSkyline(int[][] grid) { int n = grid.length; int m = grid[0].length; int[] maxrow = new int[n]; int[] maxcol = new int[n]; for (int i = 0; i \u003c n; ++i) { int mx = -1; for (int j = 0; j \u003c m; ++j) { mx = Math.max(mx, grid[i][j]); } maxrow[i] = mx; } for (int i = 0; i \u003c m; ++i) { int mx = -1; for (int j = 0; j \u003c n; ++j) { mx = Math.max(mx, grid[j][i]); } maxcol[i] = mx; } int ans = 0; for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { ans += Math.min(maxcol[j], maxrow[i]) - grid[i][j]; //System.out.print(Math.min(maxcol[j], maxrow[i]) + \" \"); } //System.out.println(); } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:69:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"思维 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:70:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:70:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 奇妙利用查询的特殊性，参考这位大佬，思路真的十分神奇巧妙 class SORTracker { public: set\u003cpair\u003cint, string\u003e\u003e st; set\u003cpair\u003cint, string\u003e\u003e::iterator ite; SORTracker() { st.insert({0, \"\"}); ite = st.begin(); } void add(string name, int score) { pair\u003cint, string\u003e p = make_pair(-score, name); st.insert(p); if (p \u003c *ite) ite--; } string get() { return ite++-\u003esecond; } }; /** 1. Your SORTracker object will be instantiated and called as such: 2. SORTracker* obj = new SORTracker(); 3. obj-\u003eadd(name,score); 4. string param_2 = obj-\u003eget(); */ ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:70:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs 图论 技巧 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:71:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 有n个人，每个人都有一个喜欢的人，让他们中的几个围着一个圆桌，满足所有人喜欢的人都坐在ta的旁边，求最多可以安排几个人 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:71:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 假设a喜欢b，则他们之间建立一条a指向b的有向边，组成有向图（可能不连通） 经分析可以发现有两种方式满足条件 把基环内向树最大的环放上去（只能放一个环） 把类似于a-\u003eb-\u003ec-\u003ed\u003c-\u003ee\u003c-f\u003c-g结构放上去（全都放） 分别求这两种情况 对于第一种，dfs，用着色判断这个点是没遍历过，还是当前遍历的序列，还是以前遍历的 对于第二种，把环长度为2的单独存（假设u\u003c-\u003ev），把边反向，求u往非v方向的最长链+v往非u方向的方向的最长链，注意基环内向树变成基环外向树，一个点能延伸的最长链等于所连接点的最长链的最大值+1 class Solution { List\u003cInteger\u003e[] G; int[] sta, d; int max_circle = 0; int max_chain = 0; List\u003cint[]\u003e mu_pair; public int maximumInvitations(int[] fav) { int n = fav.length; G = new ArrayList[n + 3]; mu_pair = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c n; ++i) { G[i] = new ArrayList\u003c\u003e(); } for (int i = 0; i \u003c n; ++i) { G[fav[i]].add(i); } sta = new int[n + 3]; d = new int[n + 3]; for (int i = 0; i \u003c n; ++i) { if (sta[i] == 0) dfs1(i); } for (int[] i : mu_pair) { max_chain += dfs2(i[0], i[1]); max_chain += dfs2(i[1], i[0]); } return Math.max(max_circle, max_chain); } public void dfs1(int x) { sta[x] = 1; for (int i : G[x]) { if (sta[i] == 0) { d[i] = d[x] + 1; dfs1(i); } else if (sta[i] == 1) { int now_circle = d[x] - d[i] + 1; if (now_circle == 2) { mu_pair.add(new int[]{x, i}); } else { max_circle = Math.max(max_circle, now_circle); } } } sta[x] = 2; } public int dfs2(int x, int p) { if (G[x].isEmpty() || (G[x].size() == 1 \u0026\u0026 G[x].get(0) == p)) { return 1; } int ret = 0; for (int i : G[x]) { if (i != p) { ret = Math.max(ret, dfs2(i, x)); } } return ret + 1; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:71:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dp 记忆化搜索 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:72:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:72:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意判断平局的条件 class Solution { static final int WIN = 3; static final int LOSE = 4; static final int DRAW = 0; static final int MOUSE_WIN = 1; static final int CAT_WIN = 2; int n; int[][] G; int[][][] dp; // mouse cat round, val is WIN / LOSE public int catMouseGame(int[][] graph) { this.n = graph.length; this.G = graph; dp = new int[n + 2][n + 2][n * 2 + 2]; for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c n; ++j) { Arrays.fill(dp[i][j], -1); } } int result = getResult(1, 2, 0); if (result == WIN) return MOUSE_WIN; else if (result == LOSE) return CAT_WIN; else return DRAW; } public int getResult(int mouse, int cat, int round) { if (dp[mouse][cat][round] != -1) return dp[mouse][cat][round]; if (round \u003e= 2 * n) { dp[mouse][cat][round] = DRAW; return DRAW; } if (mouse == 0) { if (round % 2 == 0) { dp[mouse][cat][round] = WIN; return WIN; } else { dp[mouse][cat][round] = LOSE; return LOSE; } } if (mouse == cat) { if (round % 2 == 0) { dp[mouse][cat][round] = LOSE; return LOSE; } else { dp[mouse][cat][round] = WIN; return WIN; } } boolean draw = false; boolean mouseRound = round % 2 == 0; int curMove = round % 2 == 0 ? mouse : cat; int curResult; for (int i : G[curMove]) { if (!mouseRound \u0026\u0026 i == 0) continue; if (mouseRound) { curResult = getResult(i, cat, round + 1); } else { curResult = getResult(mouse, i, round + 1); } if (curResult == LOSE) { dp[mouse][cat][round] = WIN; return WIN; } else if (curResult == DRAW) { draw = true; } } if (draw) { dp[mouse][cat][round] = DRAW; return DRAW; } else { dp[mouse][cat][round] = LOSE; return LOSE; } } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:72:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"bfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:73:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 有一个数组，初始时在0位置，每次可以选择向前一个位置或向后一个位置，或者跳到和当前值相同的位置，不能跳出界，求最少几次到最后一个位置 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:73:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 转化成图，bfs求最短路，注意标记走过的点和值 class Solution { public int minJumps(int[] arr) { Map\u003cInteger, List\u003cInteger\u003e\u003e mp = new HashMap\u003c\u003e(); int n = arr.length; boolean[] vis = new boolean[n]; Set\u003cInteger\u003e hoge = new HashSet\u003c\u003e(); for (int i = 0; i \u003c n; ++i) { mp.putIfAbsent(arr[i], new ArrayList\u003cInteger\u003e()); mp.get(arr[i]).add(i); } int ans = 0; Queue\u003cInteger\u003e q = new ArrayDeque\u003c\u003e(); q.offer(0); vis[0] = true; int num = 0; while (!q.isEmpty()) { if (num == 0) { num = q.size(); ans++; } num--; int cnt = q.poll(); if (cnt == n - 1) return ans - 1; int val = arr[cnt]; if (cnt - 1 \u003e= 0 \u0026\u0026 !vis[cnt - 1]) { q.offer(cnt - 1); } if (cnt + 1 \u003c n \u0026\u0026 !vis[cnt + 1]) { q.offer(cnt + 1); } if (hoge.contains(val)) continue; List\u003cInteger\u003e tmp = mp.get(val); for (int i = 0; i \u003c tmp.size(); ++i) { if (!vis[tmp.get(i)]) { q.offer(tmp.get(i)); vis[tmp.get(i)] = true; } } hoge.add(val); } return 0; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:73:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"穷举 模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:74:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:74:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意细节，减少dirt class Solution { public boolean isAdditiveNumber(String num) { int n = num.length(); if (n \u003c 3) return false; // split after index for (int i = 0; i \u003c n - 2; ++i) { for (int j = i + 1; j \u003c n - 1; ++j) { // checkPtr is the beginning of the number need checking int checkPtr = j + 1; String first = num.substring(0, i + 1); String second = num.substring(i + 1, j + 1); while (checkPtr \u003c n) { if (haveLeadingZero(first) || haveLeadingZero(second)) break; String tmp = addForBigInteger(first, second); if (haveLeadingZero(tmp)) break; if (num.length() \u003e= checkPtr + tmp.length() \u0026\u0026 tmp.equals(num.substring(checkPtr, checkPtr + tmp.length()))) { checkPtr += tmp.length(); first = second; second = tmp; } else break; } if (checkPtr == n) return true; } } return false; } private String addForBigInteger(String x, String y) { int len = Math.max(x.length(), y.length()); StringBuffer sb1 = new StringBuffer(x); StringBuffer sb2 = new StringBuffer(y); sb1.reverse(); sb2.reverse(); while (sb1.length() \u003c len) { sb1.append('0'); } while (sb2.length() \u003c len) { sb2.append('0'); } StringBuffer sb = new StringBuffer(); boolean carry = false; for (int i = 0; i \u003c len; ++i) { int foo = sb1.charAt(i) - '0'; int bar = sb2.charAt(i) - '0'; int tmp = foo + bar + (carry ? 1 : 0); sb.append((char) (tmp % 10 + '0')); if (tmp \u003e 9) carry = true; else carry = false; } if (carry) sb.append('1'); sb.reverse(); return sb.toString(); } private boolean haveLeadingZero(String x) { if (x.isEmpty()) return true; if (x.length() == 1) return false; return x.charAt(0) == '0'; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:74:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"归纳 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:75:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:75:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int removePalindromeSub(String s) { int n = s.length(); for (int i = 0; i \u003c n; ++i) { if (s.charAt(i) != s.charAt(n - 1 - i)) return 2; } return 1; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:75:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"贪心 技巧 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:76:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:76:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 如果没有空间限制直接用前后缀 在遍历的过程中维护三元组的第一个数和第二个数，贪心地选择最小的数作为第一个数和第二个数 注意注释的部分，我本来是这样写的，[2,3,1,4]这个用例错误，当遍历到1时，第一个数变成1，第二个数变成无穷，导致找不到三元组，实际上只应该更新第一个数即第一个数是1，第二个数是3，这个意思是已经有正序的二元组（还差第三个数），且第二个数最小为3 应该在提交前用一些容易想到的corner case来测试，比如说一个数、两个数、[2,3,1,4]等等 class Solution { public boolean increasingTriplet(int[] nums) { int n = nums.length; int first = nums[0]; int second = Integer.MAX_VALUE; for (int i = 1; i \u003c n; ++i) { if (nums[i] \u003e second) return true; if (nums[i] \u003c first) { // second = Integer.MAX_VALUE; first = nums[i]; } else if (nums[i] \u003e first) { second = nums[i]; } } return false; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:76:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"堆 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:77:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 合并k个有序链表 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:77:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists == null) return null; PriorityQueue\u003cListNode\u003e pq = new PriorityQueue\u003c\u003e((x, y) -\u003e x.val - y.val); int n = lists.length; ListNode ptrListNode = new ListNode(); ListNode ans = ptrListNode; for (int i = 0; i \u003c n; ++i) { if (lists[i] == null) continue; pq.offer(lists[i]); } while (!pq.isEmpty()) { ListNode cntListNode = pq.poll(); ptrListNode.next = cntListNode; ptrListNode = ptrListNode.next; if (cntListNode.next != null) pq.offer(cntListNode.next); } return ans.next; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:77:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:78:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:78:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 模拟 class StockPrice { Map\u003cInteger, Integer\u003e prices; TreeSet\u003cInteger\u003e treeSet; Map\u003cInteger, Integer\u003e num; int lastestTimestamp; public StockPrice() { prices = new HashMap\u003c\u003e(); treeSet = new TreeSet\u003c\u003e(); num = new HashMap\u003c\u003e(); lastestTimestamp = -1; } public void update(int timestamp, int price) { lastestTimestamp = Math.max(timestamp, lastestTimestamp); int prevPrice = prices.getOrDefault(timestamp, -1); prices.put(timestamp, price); if (prevPrice == -1) { num.put(price, num.getOrDefault(price, 0) + 1); } else { num.put(prevPrice, num.get(prevPrice) - 1); num.put(price, num.getOrDefault(price, 0) + 1); } treeSet.add(price); } public int current() { return prices.get(lastestTimestamp); } public int maximum() { while (num.getOrDefault(treeSet.last(), 0) == 0) { treeSet.remove(treeSet.last()); } return treeSet.last(); } public int minimum() { while (num.getOrDefault(treeSet.first(), 0) == 0) { treeSet.remove(treeSet.first()); } return treeSet.first(); } } /** * Your StockPrice object will be instantiated and called as such: * StockPrice obj = new StockPrice(); * obj.update(timestamp,price); * int param_2 = obj.current(); * int param_3 = obj.maximum(); * int param_4 = obj.minimum(); */ ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:78:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"贪心 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:79:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:79:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 石子数对3取模 枚举alice选择1和选择2的情况，对于每个人，假设当前和为1，则优先选择1，如果没有1再选择0，如果当前和为2，则优先选择2，如果没有2则选择0，如果都没得选就输了 为什么这样贪心是对的，可以看做选择1而不是选择0，是对自己有好处，对别人有坏处（损人又利己），而选择0是对自己有好处，对别人没坏处 class Solution { public boolean stoneGameIX(int[] stones) { int n = stones.length; boolean aliceTurn = true; boolean aliceWin1 = false, aliceWin2 = false; int zeroNum = 0, oneNum = 0, twoNum = 0; for (int i : stones) { if (i % 3 == 0) zeroNum++; else if (i % 3 == 1) oneNum++; else twoNum++; } int cnt; int cntOneNum = oneNum, cntTwoNum = twoNum; int cntZeroNum = zeroNum; aliceTurn = true; if (cntOneNum \u003e 0) { cnt = 1; cntOneNum--; aliceTurn = !aliceTurn; while (true) { if (cntZeroNum == 0 \u0026\u0026 cntOneNum == 0 \u0026\u0026 cntTwoNum == 0) { aliceWin1 = false; break; } if (cnt == 1 \u0026\u0026 cntOneNum \u003e 0) { cntOneNum--; cnt = 2; aliceTurn = !aliceTurn; } else if (cnt == 2 \u0026\u0026 cntTwoNum \u003e 0) { cntTwoNum--; cnt = 1; aliceTurn = !aliceTurn; } else if (cnt == 1 \u0026\u0026 cntOneNum == 0 \u0026\u0026 cntZeroNum \u003e 0) { cntZeroNum--; aliceTurn = !aliceTurn; } else if (cnt == 2 \u0026\u0026 cntTwoNum == 0 \u0026\u0026 cntZeroNum \u003e 0) { cntZeroNum--; aliceTurn = !aliceTurn; } else { if (aliceTurn) { aliceWin1 = false; break; } else { aliceWin1 = true; break; } } } } cntOneNum = oneNum; cntTwoNum = twoNum; cntZeroNum = zeroNum; aliceTurn = true; if (cntTwoNum \u003e 0) { cnt = 2; cntTwoNum--; aliceTurn = !aliceTurn; while (true) { if (cntZeroNum == 0 \u0026\u0026 cntOneNum == 0 \u0026\u0026 cntTwoNum == 0) { aliceWin2 = false; break; } if (cnt == 1 \u0026\u0026 cntOneNum \u003e 0) { cntOneNum--; cnt = 2; aliceTurn = !aliceTurn; } else if (cnt == 2 \u0026\u0026 cntTwoNum \u003e 0) { cntTwoNum--; cnt = 1; aliceTurn = !aliceTurn; } else if (cnt == 1 \u0026\u0026 cntOneNum == 0 \u0026\u0026 cntZeroNum \u003e 0) { cntZeroNum--; aliceTurn = !aliceTurn; } else if (cnt == 2 \u0026\u0026 cntTwoNum == 0 \u0026\u0026 cntZeroNum \u003e 0) { cntZeroNum--; aliceTurn = !aliceTurn; } else { if (aliceTurn) { aliceWin2 = false; break; } else { aliceWin2 = true; break; } } } } return aliceWin1 || aliceWin2; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:79:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"模拟 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:80:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:80:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public int numberOfMatches(int n) { int ans = 0; while (n \u003e 1) { ans += n / 2; if (n % 2 == 1) { n++; } n /= 2; } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:80:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"排序 后缀 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:81:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:81:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 排序，维护后缀最大值 注意特判边界 class Solution { public int numberOfWeakCharacters(int[][] properties) { Arrays.sort(properties, (x, y) -\u003e { return x[0] == y[0] ? (x[1] - y[1]) : (x[0] - y[0]); }); int n = properties.length; int ans = 0; int[] sufmax = new int[n]; sufmax[n - 1] = properties[n - 1][1]; for (int i = n - 2; i \u003e= 0; --i) { sufmax[i] = Math.max(sufmax[i + 1], properties[i][1]); } int ptr = 1; for (int i = 0; i \u003c n - 1; ++i) { while (ptr \u003c n \u0026\u0026 properties[ptr][0] \u003c= properties[i][0]) ptr++; if (ptr \u003e= n) break; if (sufmax[ptr] \u003e properties[i][1]) ans++; } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:81:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"bfs Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:82:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:82:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 bfs class Solution { public int[][] highestPeak(int[][] isWater) { int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; int n = isWater.length; int m = isWater[0].length; int[][] ans = new int[n][m]; for (int i = 0; i \u003c n; ++i) { Arrays.fill(ans[i], -1); } Queue\u003cint[]\u003e queue = new ArrayDeque\u003c\u003e(); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if (isWater[i][j] == 1) { ans[i][j] = 0; queue.offer(new int[]{i, j}); } } } while (!queue.isEmpty()) { int[] tmp = queue.poll(); int x = tmp[0], y = tmp[1]; for (int i = 0; i \u003c 4; ++i) { int dx = x + dir[i][0]; int dy = y + dir[i][1]; if (dx \u003e= 0 \u0026\u0026 dx \u003c n \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c m \u0026\u0026 ans[dx][dy] == -1) { ans[dx][dy] = ans[x][y] + 1; queue.offer(new int[]{dx, dy}); } } } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:82:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"哈希表 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:83:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:83:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 Java语法注意点\r注意int[]不能作为HashMap的Key，理论上可以但这样得不到想要的结果，比如插入[1, 2]数组，调用containsKey(new int[]{1, 2})找不到，原因是containsKey只会识别相同的对象，而这两个对象虽然值相同，但地址不同，java在比较两个对象是否是同一个时，会先比较hashcode，如果hashcode不同就不是同一个，如果hashcode相同就会调用equals()方法，所以可以通过重写hashcode()和equals()方法达到目的，但这样比较麻烦，这就像c++中unordered_map\u003cpair\u003cint, int\u003e, int\u003e mp;或者unordered_map\u003cvector\u003cint\u003e, int\u003e mp;一样需要一个hash_pair。如果数组作为TreeMap的Key，会报错，因为数组没有实现Comparable，无法比较（排序） 用List\u003cInteger\u003e作为HashMap的Key是可以的（Map\u003cList\u003cInteger\u003e, Integer\u003e mp; mp.put(Arrays.asList(1, 2), 3;）， 因为 java.util.Collection自己有hashcode()和equals()且是比较值是否相同的 不过用List\u003cInteger\u003e作为Key很慢，慎用 用List作为Key的TLE版本 class DetectSquares { Map\u003cList\u003cInteger\u003e, Integer\u003e mp; public DetectSquares() { mp = new HashMap\u003c\u003e(); } public void add(int[] point) { mp.put(Arrays.asList(point[0], point[1]), mp.getOrDefault(Arrays.asList(point[0], point[1]), 0) + 1); } public int count(int[] point) { int ans = 0; int x = point[0], y = point[1]; for (int i = 1; i \u003c= 1000; ++i) { ans += mp.getOrDefault(Arrays.asList(x - i, y), 0) * mp.getOrDefault(Arrays.asList(x, y - i), 0) * mp.getOrDefault(Arrays.asList(x - i, y - i), 0); ans += mp.getOrDefault(Arrays.asList(x - i, y), 0) * mp.getOrDefault(Arrays.asList(x, y + i), 0) * mp.getOrDefault(Arrays.asList(x - i, y + i), 0); ans += mp.getOrDefault(Arrays.asList(x, y - i), 0) * mp.getOrDefault(Arrays.asList(x + i, y), 0) * mp.getOrDefault(Arrays.asList(x + i, y - i), 0); ans += mp.getOrDefault(Arrays.asList(x + i, y), 0) * mp.getOrDefault(Arrays.asList(x, y + i), 0) * mp.getOrDefault(Arrays.asList(x + i, y + i), 0); } return ans; } } /** * Your DetectSquares object will be instantiated and called as such: * DetectSquares obj = new DetectSquares(); * obj.add(point); * int param_2 = obj.count(point); */ c++ 用pair作为Key的TLE版本 class DetectSquares { public: struct pair_hash { template\u003cclass T1, class T2\u003e std::size_t operator()(const std::pair\u003cT1, T2\u003e \u0026p) const { auto h1 = std::hash\u003cT1\u003e{}(p.first); auto h2 = std::hash\u003cT2\u003e{}(p.second); return h1 ^ h2; } }; unordered_map\u003cpair\u003cint, int\u003e, int, pair_hash\u003e mp; DetectSquares() { } void add(vector\u003cint\u003e point) { mp[{point[0], point[1]}]++; } int count(vector\u003cint\u003e point) { int ans = 0; int x = point[0], y = point[1]; for (int i = 1; i \u003c= 1000; ++i) { ans += mp[{x - i, y}] * mp[{x, y - i}] * mp[{x - i, y - i}]; ans += mp[{x - i, y}] * mp[{x, y + i}] * mp[{x - i, y + i}]; ans += mp[{x, y - i}] * mp[{x + i, y}] * mp[{x + i, y - i}]; ans += mp[{x + i, y}] * mp[{x, y + i}] * mp[{x + i, y + i}]; } return ans; } }; 用哈希表嵌套哈希表，TLE，没有用判断优化的版本（单样例没超时，总时间超时） class DetectSquares { Map\u003cInteger, Map\u003cInteger, Integer\u003e\u003e mp; public DetectSquares() { mp = new HashMap\u003c\u003e(); } public void add(int[] point) { int x = point[0], y = point[1]; mp.putIfAbsent(x, new HashMap\u003c\u003e()); Map\u003cInteger, Integer\u003e tmp = mp.get(x); tmp.put(y, tmp.getOrDefault(y, 0) + 1); mp.put(x, tmp); } public int count(int[] point) { int ans = 0; int x = point[0], y = point[1]; for (int i = 1; i \u003c= 1000; ++i) { ans += mp.getOrDefault(x - i, new HashMap\u003c\u003e()).getOrDefault(y, 0) * mp.getOrDefault(x, new HashMap\u003c\u003e()).getOrDefault(y - i, 0) * mp.getOrDefault(x - i, new HashMap\u003c\u003e()).getOrDefault(y - i, 0); ans += mp.getOrDefault(x - i, new HashMap\u003c\u003e()).getOrDefault(y, 0) * mp.getOrDefault(x, new HashMap\u003c\u003e()).getOrDefault(y + i, 0) * mp.getOrDefault(x - i, new HashMap\u003c\u003e()).getOrDefault(y + i, 0); ans += mp.getOrDefault(x, new HashMap\u003c\u003e()).getOrDefault(y - i, 0) * mp.getOrDefault(x + i, new HashMap\u003c\u003e()).getOrDefault(y, 0) * mp.getOrDefault(x + i, new HashMap\u003c\u003e()).getOrDefault(y - i, 0); ans += mp.getOrDefault(x + i, new HashMap\u003c\u003e()).getOrDefault(y, 0) * mp.getOrDefault(x, new HashMap\u003c\u003e()).getOrDefault(y + i, 0) * mp.getOrDefault(x + i, new HashMap\u003c\u003e()).getOrDefault(y + i, 0); } return ans; } } /** * Your DetectSquares object will be instantiated and called as such: * DetectSquares obj = new DetectSquares(); * obj.add(point); * int param_2 = obj.count(point); */ 优化后的AC代码（还可以再优化） class DetectSquares { Map\u003cInteger, Map\u003cInteger, Integer\u003e\u003e mp; public Dete","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:83:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"哈希表 Easy ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:84:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:84:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 class Solution { public String[] uncommonFromSentences(String s1, String s2) { Map\u003cString, Integer\u003e mp = new HashMap\u003c\u003e(); String[] word1 = s1.split(\" \"); String[] word2 = s2.split(\" \"); for (String i : word1) { mp.put(i, mp.getOrDefault(i, 0) + 1); } for (String i : word2) { mp.put(i, mp.getOrDefault(i, 0) + 1); } List\u003cString\u003e ans = new ArrayList\u003c\u003e(); for (Map.Entry\u003cString, Integer\u003e entry : mp.entrySet()) { if (entry.getValue() == 1) ans.add(entry.getKey()); } return ans.toArray(new String[0]); } } 注意通过toArray(new String[0])这种方法来转变成String数组，如果在前面加(String[]) 强制类型转化会转化失败，因为toArray不知道转化成什么类型，返回一个object，虽然前者也是返回obj，但指定了类型 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:84:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"并查集 状态压缩 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:85:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:85:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 周赛的一道题，思路很简单，当时一直TLE，然后一直想着优化代码。赛后发现是时间复杂度算错了，原来以为时间复杂度是O(n*26*26)，后来发现如果数组中存在大量重复字符串时，比如说在计算not change部分时，“abc”会遍历一遍所有“abc”的下标，这样时间复杂度就是O(n*n)，其实只要遍历第一个“abc”的下标就行，预处理时把所有相同字符串加到一个集合中 为什么会犯这种错误或找不出错？可能是因为在做题时很少有时间复杂度算错的情况，大多数都是代码冗余或数据结构或者STL低效的问题，所以条件反射地往这方面想 我如何找出这个错误？先是花大量的时间在优化代码上，后来我企图测试是哪部分代码直接造成超时，最后发现当预处理二进制和not change部分共存时，超时，我仔细地看了一遍预处理二进制的代码，发现没有任何问题（甚至还怀疑是不是用for each更快），然后将not change的遍历mp[cnt]数组注释掉，发现这两部分代码可以共存，很大概率是这条代码超时，后来就想到如果存在很多一样的字符串，那么每次都需要完整遍历一遍，时间复杂度是O(n*n) 不知道怎样快速查找出错误，一直都在摸索，只能说下次要再检查一遍时间复杂度是否算对 最开始还忘记算相同的情况（not change） class Solution { public: vector\u003cint\u003e par; vector\u003cint\u003e rankk; void init(int n) { for (int i = 0; i \u003c n; i++) { par[i] = i; rankk[i] = 0; } } int find(int x) { if (par[x] == x) return x; else return par[x] = find(par[x]); } void unite(int x, int y) { x = find(x); y = find(y); if (x == y) return; if (rankk[x] \u003c rankk[y]) par[x] = y; else { par[y] = x; if (rankk[x] == rankk[y]) rankk[x]++; } } bool same(int x, int y) { return find(x) == find(y); } vector\u003cint\u003e groupStrings(vector\u003cstring\u003e \u0026words) { unordered_map\u003cint, vector\u003cint\u003e\u003e mp; int n = (int) words.size(); par.resize(n + 10); rankk.resize(n + 10); init(n + 5); vector\u003cint\u003e bin(n + 10); for (int i = 0; i \u003c n; ++i) { int tmp = 0; for (int j = 0; j \u003c words[i].length(); ++j) { tmp |= (1 \u003c\u003c (words[i][j] - 'a')); } mp[tmp].push_back(i); bin[i] = tmp; } // !!! for (auto [i, j] : mp) { for (int k = 0; k \u003c (int) j.size() - 1; ++k) { unite(j[k], j[k + 1]); } } for (int i = 0; i \u003c n; ++i) { int cnt = bin[i]; vector\u003cint\u003e exist, notexist; for (int j = 0; j \u003c 26; ++j) { if (cnt \u003e\u003e j \u0026 1) { exist.push_back(j); } else { notexist.push_back(j); } } // delete for (int j : exist) { int tmp = cnt ^ (1 \u003c\u003c j); if (mp.find(tmp) != mp.end()) { unite(i, mp[tmp][0]); } } // add for (int j : notexist) { int tmp = cnt | (1 \u003c\u003c j); if (mp.find(tmp) != mp.end()) { unite(i, mp[tmp][0]); } } // replace for (int j : exist) { for (int k : notexist) { int tmp = cnt ^ (1 \u003c\u003c j); tmp |= (1 \u003c\u003c k); if (mp.find(tmp) != mp.end()) { unite(i, mp[tmp][0]); } } } // not change if (mp.find(cnt) != mp.end()) { unite(i, mp[cnt][0]); } } unordered_map\u003cint, int\u003e sz; int ans1, ans2; ans2 = -1; for (int i = 0; i \u003c n; ++i) { sz[find(i)]++; } ans1 = (int) sz.size(); for (auto [i, j] : sz) { ans2 = max(ans2, j); } return vector\u003cint\u003e{ans1, ans2}; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:85:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"分治 状压 二分 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:86:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:86:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 meet in the middle 分治把前一半2^15的情况枚举出来，把后一半2^15的情况枚举出来，然后枚举前一半，在后一半中二分查找，时间复杂度O(nlogn) n最大2^15 class Solution { public: int minimumDifference(vector\u003cint\u003e\u0026 nums) { int n = (int) nums.size(); n /= 2; unordered_map\u003cint, vector\u003cint\u003e\u003e mpL, mpR; vector\u003cint\u003e L(nums.begin(), nums.begin() + n); vector\u003cint\u003e R(nums.begin() + n, nums.end()); for (int i = 1; i \u003c= n; ++i) { int ss = (1 \u003c\u003c i) - 1; while (ss \u003c (1 \u003c\u003c n)) { int tmp = 0; for (int j = 0; j \u003c n; ++j) { if (ss \u003e\u003e j \u0026 1) { tmp += L[j]; } else { tmp -= L[j]; } } mpL[i].push_back(tmp); int x = ss \u0026 -ss, y = ss + x; ss = ((ss \u0026 ~y) / x \u003e\u003e 1) | y; } } // i = 0 mpL[0].push_back(-accumulate(L.begin(), L.end(), 0)); for (int i = 1; i \u003c= n; ++i) { int ss = (1 \u003c\u003c i) - 1; while (ss \u003c (1 \u003c\u003c n)) { int tmp = 0; for (int j = 0; j \u003c n; ++j) { if (ss \u003e\u003e j \u0026 1) { tmp += R[j]; } else { tmp -= R[j]; } } mpR[i].push_back(tmp); int x = ss \u0026 -ss, y = ss + x; ss = ((ss \u0026 ~y) / x \u003e\u003e 1) | y; } } // i = 0 mpR[0].push_back(-accumulate(R.begin(), R.end(), 0)); int ans = 0x3f3f3f3f; for (int i = 0; i \u003c= n; ++i) { sort(mpL[i].begin(), mpL[i].end()); mpL[i].erase(unique(mpL[i].begin(), mpL[i].end()), mpL[i].end()); sort(mpR[i].begin(), mpR[i].end()); mpR[i].erase(unique(mpR[i].begin(), mpR[i].end()), mpR[i].end()); } for (int i = 0; i \u003c= n; ++i) { for (int j : mpL[i]) { auto ite = lower_bound(mpR[n - i].begin(), mpR[n - i].end(), -j); if (ite != mpR[n - i].end()) { ans = min(ans, abs(j + *ite)); } if (ite != mpR[n - i].begin()) { ite--; ans = min(ans, abs(j + *ite)); } } } return ans; } }; ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:86:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"字典树 异或 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:87:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 给一长度为2e4的数组，每个值最大为2e4，求有多少个数对，异或值在low和high之间 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:87:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 遍历数组建字典树，对于当前数，查询字典树中有多少个数满足条件，再把这个数插入到字典树中 查询字典树有多少个数满足条件，可以查询字典树中有多少个数异或\u003c=high，有多少个\u003c=low-1，相减 查询字典树中有多少个数和y异或值\u003c=x，就是从根节点往下遍历，如果x的当前位为0，则只能找和y相同的位，如果x的当前位为1，那和y当前位相同的位之后的所有节点都满足条件，和y当前位不同的继续往下搜，所以维护每个节点下面存了几个数 维护每个节点下面存了几个数，用sz[i]表示i节点存了几个数，只要在每次插入的时候，给沿途的每个节点sz[i]++就行 时间复杂度O(2e4 * 15) class Solution { int[][] next; int cnt; int[] sz; int low, high; public void insert(int num) { int p = 0; for (int i = 14; i \u003e= 0; --i) { int c = (num \u003e\u003e i \u0026 1) == 1 ? 1 : 0; if (next[p][c] == 0) { ++cnt; next[p][c] = cnt; } p = next[p][c]; sz[p]++; } } public int count(int x) { return countLessThanOrEquals(high, x) - countLessThanOrEquals(low - 1, x); } public int countLessThanOrEquals(int bd, int x) { int p = 0; int ret = 0; for (int i = 14; i \u003e= 0; --i) { int cx = (x \u003e\u003e i \u0026 1) == 1 ? 1 : 0; int cbd = (bd \u003e\u003e i \u0026 1) == 1 ? 1 : 0; if (cbd == 0) { if (next[p][cx] == 0) { return ret; } p = next[p][cx]; if (i == 0) { ret += sz[p]; return ret; } } else { if (next[p][cx] != 0) { ret += sz[next[p][cx]]; } if (next[p][cx ^ 1] != 0) { p = next[p][cx ^ 1]; } else { return ret; } if (i == 0) { ret += sz[p]; return ret; } } } return 0; } public int countPairs(int[] nums, int low, int high) { this.low = low; this.high = high; int n = nums.length; next = new int[16 * (n + 2)][2]; sz = new int[16 * (n + 2)]; int ans = 0; for (int i : nums) { ans += count(i); insert(i); } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:87:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"二分 贪心 结论 Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:88:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:88:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 二分找答案，假设最长时间是k，有一个结论是，\u003e=k的电池只会给一个电脑供电，不会出现给一个电脑供一会儿电，再转移给另一个电脑的情况，因为这样不会更优 所以每个电池能提供的电是min(pi, k)，累加就是总的能提供的电，check就是判断总的电和nk的大小，如果大于nk，一定存在一种调度满足每个电脑同时充k时间（可以把电池看做电量为1的若干电池去填充） class Solution { public long maxRunTime(int n, int[] batteries) { long l = 1, r = (long)1e14 + 10; while (l \u003c= r) { long mid = l + (r - l) / 2; long tmp = 0; for (int i : batteries) { tmp += Math.min(i, mid); } if (tmp \u003e= n * mid) { l = mid + 1; } else { r = mid - 1; } } return l - 1; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:88:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"bfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:89:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 有一个1e6*1e6的格子，有200个障碍，求能否从s点到t点，只能4方向走 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:89:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 因为只有200个障碍，所以看s点有没有被障碍围起来，看t点有没有被障碍围起来即可 由于障碍45°斜着排，把点困在某个角落里，能困住的格子最多，或者用的障碍最少，即最优。这样点最多只能到达400步以内的格子，所以只要bfs判断点能否到达400步以外的格子就行，两个一起搜，如果搜的过程中，能碰到对方也行 然后我超时了。。。单样例200+ms，我懵逼了，时间复杂度O(6.4e5)，leetcode的超时到底是怎么算的，单样例能过，总的就超时？难道还要算样例总时间？这合理吗 所以我被迫用另一个方法，最优的障碍设置使得点最多访问200*(200-1)/2个格子，所以bfs判断访问了多少个格子，而不是能否到达400步以外的格子，这样时间复杂度从O(6.4e5)降到O(4e4)，单样例10+ms 谢谢你，leetcode，让我去想更高效的方法🙏 最初TLE代码 class Solution { public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) { final long STEP = 410; final int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; Map\u003cLong, Integer\u003e used = new HashMap\u003c\u003e(); long sx = source[0], sy = source[1]; long tx = target[0], ty = target[1]; Set\u003cLong\u003e b = new HashSet\u003c\u003e(); for (int[] i : blocked) { b.add((long) (i[0] * 1e6 + i[1])); } Queue\u003cLong\u003e q = new ArrayDeque\u003c\u003e(); q.offer((long) (sx * 1e6 + sy)); used.put((long) (sx * 1e6 + sy), 0); boolean sok = false, tok = false; while (!q.isEmpty()) { long val = q.poll(); long cntx = (long) (val / 1e6); long cnty = (long) (val % 1e6); for (int i = 0; i \u003c 4; ++i) { long dx = cntx + dir[i][0]; long dy = cnty + dir[i][1]; if (dx == tx \u0026\u0026 dy == ty) return true; if (dx \u003e= 0 \u0026\u0026 dx \u003c 1e6 \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c 1e6 \u0026\u0026 !b.contains((long) (dx * 1e6 + dy)) \u0026\u0026 !used.containsKey((long) (dx * 1e6 + dy))) { used.put((long) (dx * 1e6 + dy), used.get(val) + 1); q.offer((long) (dx * 1e6 + dy)); if (used.get((long) (dx * 1e6 + dy)) \u003e= STEP) { sok = true; q.clear(); used.clear(); break; } } } } q.offer((long) (tx * 1e6 + ty)); used.put((long) (tx * 1e6 + ty), 0); while (!q.isEmpty()) { long val = q.poll(); long cntx = (long) (val / 1e6); long cnty = (long) (val % 1e6); for (int i = 0; i \u003c 4; ++i) { long dx = cntx + dir[i][0]; long dy = cnty + dir[i][1]; if (dx == sx \u0026\u0026 dy == sy) return true; if (dx \u003e= 0 \u0026\u0026 dx \u003c 1e6 \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c 1e6 \u0026\u0026 !b.contains((long) (dx * 1e6 + dy)) \u0026\u0026 !used.containsKey((long) (dx * 1e6 + dy))) { used.put((long) (dx * 1e6 + dy), used.get(val) + 1); q.offer((long) (dx * 1e6 + dy)); if (used.get((long) (dx * 1e6 + dy)) \u003e= STEP) { tok = true; q.clear(); break; } } } } if (sok \u0026\u0026 tok) return true; return false; } } 以为不是时间复杂度的问题，想去优化代码，提取重复的代码，改版的TLE代码 class Solution { public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) { final long STEP = 410; final int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; Map\u003cLong, Integer\u003e used = new HashMap\u003c\u003e(); long sx = source[0], sy = source[1]; long tx = target[0], ty = target[1]; Set\u003cLong\u003e b = new HashSet\u003c\u003e(); for (int[] i : blocked) { b.add((long) (i[0] * 1e6 + i[1])); } Queue\u003cLong\u003e q = new ArrayDeque\u003c\u003e(); q.offer((long) (sx * 1e6 + sy)); used.put((long) (sx * 1e6 + sy), 0); boolean sok = false, tok = false; while (!q.isEmpty()) { long val = q.poll(); long cntx = (long) (val / 1e6); long cnty = (long) (val % 1e6); for (int i = 0; i \u003c 4; ++i) { long dx = cntx + dir[i][0]; long dy = cnty + dir[i][1]; if (dx == tx \u0026\u0026 dy == ty) return true; long tmp = (long) (dx * 1e6 + dy); if (dx \u003e= 0 \u0026\u0026 dx \u003c 1e6 \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c 1e6 \u0026\u0026 !b.contains(tmp) \u0026\u0026 !used.containsKey(tmp)) { used.put(tmp, used.get(val) + 1); q.offer(tmp); if (used.get(tmp) \u003e= STEP) { sok = true; q.clear(); //used.clear(); break; } } } } if (!sok) return false; q.offer((long) (tx * 1e6 + ty)); used.put((long) (tx * 1e6 + ty), 0); while (!q.isEmpty()) { long val = q.poll(); long cntx = (long) (val / 1e6); long cnty = (long) (val % 1e6); for (int i = 0; i \u003c 4; ++i) { long dx = cntx + dir[i][0]; long dy = cnty + dir[i][1]; if (dx == sx \u0026\u0026 dy == sy) return true; long tmp = (long) (dx * 1e6 + dy); if (dx \u003e= 0 \u0026\u0026 dx \u003c 1e6 \u0026\u0026 dy \u003e= 0 \u0026\u0026 dy \u003c 1e6 \u0026\u0026 !b.contains(tmp) \u0026\u0026 !used.containsKey(tmp)) { used.put(tmp, used.get(val) + 1); q.offer(tmp); if (used.get(tmp) \u003e= STEP) { tok = true; q.clear(); break; } } } } if (sok \u0026\u0026 tok) return true; return false; } } 优化时间复杂度的AC代码 class Solution { public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) { final long COUNT = 20010; final int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; Map\u003cLong, Inte","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:89:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs Hard ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:90:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:90:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 注意到边权\u003e=10，最大时间\u003c=100和最多4条出边这种反常数据范围，直接搜索时间复杂度O(4^10)，注意回溯时不要记录是否访问过，应该记录访问次数，因为可以重复访问，如果回溯撤销了就相当于没访问过，这不是我们想要的 注意特判只有一个点 class Solution { int ans; int[] used; int[] values; Map\u003cInteger, List\u003cint[]\u003e\u003e mp; int maxTime; public void dfs(int vertex, int cost, int value) { if (vertex == 0 \u0026\u0026 used[vertex] \u003e 0) { if (cost \u003c= maxTime) { ans = Math.max(ans, value); //return; } } used[vertex]++; List\u003cint[]\u003e list = mp.getOrDefault(vertex, null); if (list == null) return; for (int[] i : list) { if (i[1] + cost \u003e maxTime) continue; if (used[i[0]] \u003e 0) dfs(i[0], i[1] + cost, value); else dfs(i[0], i[1] + cost, value + values[i[0]]); } used[vertex]--; } public int maximalPathQuality(int[] values, int[][] edges, int maxTime) { ans = values[0]; int n = values.length; used = new int[n + 5]; this.values = values; this.maxTime = maxTime; mp = new HashMap\u003c\u003e(); for (int[] i : edges) { mp.putIfAbsent(i[0], new LinkedList\u003c\u003e()); int[] tmp = new int[]{i[1], i[2]}; List\u003cint[]\u003e list = mp.get(i[0]); list.add(tmp); mp.put(i[0], list); mp.putIfAbsent(i[1], new LinkedList\u003c\u003e()); tmp = new int[]{i[0], i[2]}; list = mp.get(i[1]); list.add(tmp); mp.put(i[1], list); } dfs(0, 0, values[0]); return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:90:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"dfs 回溯 Medium ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:91:0","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题意 题链 ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:91:1","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["problemlist"],"content":"题解 暴搜 class Solution { int ans; int[][] grid; static int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; int n, m; public void dfs(int x, int y, int gold) { ans = Math.max(ans, gold); int tmp = grid[x][y]; grid[x][y] = 0; for (int i = 0; i \u003c 4; ++i) { int nx = x + dir[i][0]; int ny = y + dir[i][1]; if (nx \u003e= 0 \u0026\u0026 nx \u003c n \u0026\u0026 ny \u003e= 0 \u0026\u0026 ny \u003c m \u0026\u0026 grid[nx][ny] != 0) { dfs(nx, ny, gold + grid[nx][ny]); } } grid[x][y] = tmp; } public int getMaximumGold(int[][] grid) { this.n = grid.length; this.m = grid[0].length; this.grid = grid; for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c m; ++j) { if (grid[i][j] != 0) { dfs(i, j, grid[i][j]); } } } return ans; } } ","date":"2021-10-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/:91:2","tags":["problemlist"],"title":"每日一题 (LeetCode)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode/"},{"categories":["linux"],"content":"simplest colorful bash promt","date":"2021-03-17","objectID":"/simplest-colorful-bash-promt/","tags":["shell","linux"],"title":"simplest colorful bash promt","uri":"/simplest-colorful-bash-promt/"},{"categories":["linux"],"content":" ######################### begin ############################### bash_prompt() { local NO_FORMAT=\"\\[\\033[0m\\]\" local ORANGE_BOLD=\"\\[\\033[1;38;5;208m\\]\" local TOXIC_GREEN_BOLD=\"\\[\\033[1;38;5;118m\\]\" local RED_BOLD=\"\\[\\033[1;38;5;1m\\]\" local CYAN_BOLD=\"\\[\\033[1;38;5;87m\\]\" local BLACK_BOLD=\"\\[\\033[1;38;5;0m\\]\" local WHITE_BOLD=\"\\[\\033[1;38;5;15m\\]\" local GRAY_BOLD=\"\\[\\033[1;90m\\]\" local BLUE_BOLD=\"\\[\\033[1;38;5;74m\\]\" local PROMT_USER_COLOR=$CYAN_BOLD local PROMT_AT_COLOR=$WHITE_BOLD local PROMT_HOST_COLOR=$CYAN_BOLD local PROMT_COLON_COLOR=$WHITE_BOLD local PROMT_PATH_COLOR=$ORANGE_BOLD local PROMT_DOLLAR_COLOR=$WHITE_BOLD local PROMT_INPUT_COLOR=$TOXIC_GREEN_BOLD local PROMT_USER=$\"$PROMT_USER_COLOR\\u\" local PROMT_AT=$\"$PROMT_AT_COLOR@\" local PROMT_HOST=$\"$PROMT_HOST_COLOR\\h\" local PROMT_COLON=$\"$PROMT_COLON_COLOR:\" local PROMT_PATH=$\"$PROMT_PATH_COLOR\\w\" local PROMT_DOLLAR=$\"$PROMT_DOLLAR_COLOR$\" local PROMT_INPUT=$\"$PROMT_INPUT_COLOR\" PS1=\"${PROMT_USER}${PROMT_AT}${PROMT_HOST}${PROMT_COLON}${PROMT_PATH}${PROMT_DOLLAR} ${PROMT_INPUT}\" none=\"$(tput sgr0)\" trap 'echo -ne \"${none}\"' DEBUG } bash_prompt unset bash_prompt ################################# end ############################### inspired by https://github.com/ChrisTitusTech/scripts add the code to ~/.bashrc and run source ~/.bashrc you can rewrite PS1 to make it more fancy, like time display, graph ","date":"2021-03-17","objectID":"/simplest-colorful-bash-promt/:0:0","tags":["shell","linux"],"title":"simplest colorful bash promt","uri":"/simplest-colorful-bash-promt/"},{"categories":["GAME"],"content":"steep","date":"2021-03-02","objectID":"/steep/","tags":[],"title":"steep","uri":"/steep/"},{"categories":["GAME"],"content":"steep是育碧在2016年12月2日发行的滑雪游戏 在steam上要一百多，在育碧商城上免费 在很早以前就看过有人玩育碧的肖恩怀特滑雪 但是一直找不到，可能因为知名度很低 后来育碧出了steep 游戏风景很好 有很多玩法：跳伞、单板滑雪、雪橇、翼装飞行等 操作难度较大，手残党会自闭 小黑盒评分（仅供参考） 故事发生在阿尔卑斯山。。。 ","date":"2021-03-02","objectID":"/steep/:0:0","tags":[],"title":"steep","uri":"/steep/"},{"categories":["GAME"],"content":"极限竞速地平线4","date":"2021-03-02","objectID":"/%E6%9E%81%E9%99%90%E7%AB%9E%E9%80%9F%E5%9C%B0%E5%B9%B3%E7%BA%BF4/","tags":[],"title":"极限竞速地平线4","uri":"/%E6%9E%81%E9%99%90%E7%AB%9E%E9%80%9F%E5%9C%B0%E5%B9%B3%E7%BA%BF4/"},{"categories":["GAME"],"content":"Forza Horizon 4是微软在2018年10月2日发行的开车游戏 用xbox玩就很爽 风景做得很不错 有关汽车的专业知识做得很丰富 嘉年华的各种活动安排得很合理 整个游戏体系很完善 小黑盒评分 真正的赛车游戏只玩过地平线和极品飞车，然而极品飞车没怎么玩，没有什么印象，因为地平线做得太好了。 《极限竞速：地平线4》的开放世界以英国为背景，地图更广阔真实，而且官方还确认本作中将会拥有450辆汽车。此外，《极限竞速：地平线4》中还拥有季节变化系统，在完全共享的开放世界中，可以让玩家同步一天的时间、季节、天气。 ","date":"2021-03-02","objectID":"/%E6%9E%81%E9%99%90%E7%AB%9E%E9%80%9F%E5%9C%B0%E5%B9%B3%E7%BA%BF4/:0:0","tags":[],"title":"极限竞速地平线4","uri":"/%E6%9E%81%E9%99%90%E7%AB%9E%E9%80%9F%E5%9C%B0%E5%B9%B3%E7%BA%BF4/"},{"categories":["GAME"],"content":"赛博朋克2077","date":"2021-03-02","objectID":"/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B2077/","tags":[],"title":"赛博朋克2077","uri":"/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B2077/"},{"categories":["GAME"],"content":"cyberpunk2077是CD Projekt RED开发的rpg游戏 经历了一次次跳票，终于在年底玩到这款游戏 小黑盒的评分 小黑盒社区的玩家评分并不高，很多人都很失望 确实游戏内容和宣传内容有很多不符，可以说宣传的内容过于夸大 像地铁系统、超梦只是概念的东西 前期bug超多 十足的养成游戏 总体还行，希望波兰蠢驴能够再完善一下游戏 《赛博朋克 2077》是一款开放世界动作冒险游戏，故事发生在夜之城。这是一座五光十色的大都会，权力更迭和身体改造是不变的主题。您扮演一名野心勃勃的雇佣兵：V，正在追寻一种独一无二的植入体。只要得到它，就能掌握获得永生的关键。您可以自定义角色的义体、技能和玩法，探索包罗万象的城市。您做出的选择也将会对剧情和周遭的世界产生影响。 ","date":"2021-03-02","objectID":"/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B2077/:0:0","tags":[],"title":"赛博朋克2077","uri":"/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B2077/"},{"categories":["note","slam"],"content":"非线性优化","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"相关知识 主要是对高数、概率论、线性代数、数值计算方法、数学建模的一些复习和补充 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:0","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"矩阵求导 一篇矩阵求导入门的非常好的文章 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:1","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"全概率公式 $$ P(B)=\\sum_{i=1}^{n} P\\left(A_{i}\\right) P\\left(B \\mid A_{i}\\right) $$ ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:2","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"贝叶斯公式 $$ P\\left(B_{i} \\mid A\\right)=\\frac{P\\left(B_{i}\\right) P\\left(A \\mid B_{i}\\right)}{\\sum_{j=1}^{n} P\\left(B_{j}\\right) P\\left(A \\mid B_{j}\\right)} $$ ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:3","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"先验概率、后验概率、似然概率 已知车祸、酒驾、高峰可能造成堵车 先验概率（prior probability） 人通过直觉知道它的概率或通过实验（大数定律）获得它的概率 此处为P(X=车祸)， P(X=酒驾)， P(X=高峰) 似然概率（likelihood probability） 指某种原因下出现某种结果的概率 P(Y=堵车|X=车祸) ， P(Y=堵车|X=酒驾)， P(Y=堵车|X=高峰) 最大似然估计（maximum likelihood estimation）MLE 使似然概率最大的估计 后验概率（posterior probability） 指某种结果下推测由某种原因导致的概率 P(X=车祸|Y=堵车)， P(X=酒驾|Y=堵车)， P(X=高峰|Y=堵车) 最大后验估计（maximum a posterior estimation）MAP 使后验概率最大的估计 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:4","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"正态分布 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:5","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"数学期望 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:6","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"方差 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:7","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"协方差 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:8","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"n维正态分布 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:9","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"二次型 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:10","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"最小二乘法解超定方程组 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:11","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"向量的范数 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:12","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"矩阵的范数 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:13","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"求特征值和特征向量 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:14","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"非线性规划算法 无约束非线性规划：梯度下降法，牛顿法，高斯牛顿法 有约束非线性规划：SUMT外点法（罚函数法）， SUMT内点法（障碍函数法） SUMT=sequential unconstrained minimization technique ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:15","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"梯度下降法 gradient descent ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:16","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"牛顿法 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:1:17","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"状态估计问题 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:2:0","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"批量状态估计和最大后验估计 考虑经典的slam模型 $$ \\left\\{\\begin{array}{l}\\boldsymbol{x}_{k}=f\\left(\\boldsymbol{x}_{k-1}, \\boldsymbol{u}_{k}, \\boldsymbol{w}_{k}\\right) \\\\\\boldsymbol{z}_{k, j}=h\\left(\\boldsymbol{y}_{j}, \\boldsymbol{x}_{k}, \\boldsymbol{v}_{k, j}\\right)\\end{array}\\right. $$ x是位姿，u是传感器输入，y是路标点，z是产生的观测数据，w，v是噪声 具体地，xk由SE(3)的变换矩阵表示，暂不考虑传感器的输入形式 假设在xk处对路标yj进行了一次观测，对应到图像上的像素位置zk,j，那么观测方程可以表示成 $$ s \\boldsymbol{z}_{k, j}=\\boldsymbol{K}\\left(\\boldsymbol{R}_{k} \\boldsymbol{y}_{j}+\\boldsymbol{t}_{k}\\right) $$ K是相机内参，s是像素点的距离，也是(Rkyj+tk)的第三个分量，如果使用变换矩阵Tk描述位姿，yj必须以齐次坐标描述，计算完后转为非齐次 考虑噪声 一般假设wk，vk,j满足μ=0的正态分布 $$ \\boldsymbol{w}_{k} \\sim \\mathcal{N}\\left(\\mathbf{0}, \\boldsymbol{R}_{k}\\right), \\boldsymbol{v}_{k} \\sim \\mathcal{N}\\left(\\mathbf{0}, \\boldsymbol{Q}_{k, j}\\right) $$ slam的问题变成通过带噪声的z，u来推断位姿x和地图y，这就是状态估计 处理状态估计的方法 incremental 增量/渐近/滤波器 扩展卡尔曼滤波 batch 批量（把数据攒起来，然后处理这段时间的，相当于一段时间一段时间地处理） batch的方法可以在更大的范围内达到最优，incremental只关心当前 batch方法在视觉slam中更常用，或者将两者结合 考虑1到N的所有时刻，假设有M个路标点 位姿和地图表示为 $$ x=\\left\\{x_{1}, \\ldots, x_{N}\\right\\}, \\quad y=\\left\\{y_{1}, \\ldots, y_{M}\\right\\} $$ 从概率学来看就是求 $$ P(\\boldsymbol{x}, \\boldsymbol{y}\\mid \\boldsymbol{z}, \\boldsymbol{u}) $$ 如果只考虑观测方程（即只有一张张图像），则变成 $$ P(\\boldsymbol{x}, \\boldsymbol{y}\\mid \\boldsymbol{z}) $$ 此问题也称sfm（structure from motion）即如何从许多图像中重建三维空间结构 根据bayes rule $$ \\underbrace{P(x, y \\mid z, u)}_{\\text{posterior}}=\\frac{P(z, u \\mid x, y) P(x, y)}{P(z, u)} \\propto \\underbrace{P(z, u \\mid x, y)}_{\\text {likelihood }} \\underbrace{P({x},{y})}_{\\text {prior }} . $$ 直接求后验概率分布是很困难的，但是可以求一个最优估计，由于分母p(z, u)与x，y无关，所以可省略 那么求后验概率就变成 $$ (\\boldsymbol{x}, \\boldsymbol{y})^{*}{ }_{\\mathrm{MAP}}=\\arg \\max P(\\boldsymbol{x}, \\boldsymbol{y} \\mid \\boldsymbol{z}, \\boldsymbol{u})=\\arg \\max P(\\boldsymbol{z}, \\boldsymbol{u} \\mid \\boldsymbol{x}, \\boldsymbol{y}) P(\\boldsymbol{x}, \\boldsymbol{y}) $$ 由上式可知求map就是最大化likelihood和prior的乘积 当不知道位姿和路标大概在什么地方时，就没有了先验 $$ (x, y)_{\\text {MAP }}^{*}=\\arg \\max P(z, u \\mid x, y)=(x, y)_{\\text {MLE }}^{*} $$ 这就变成了直接求最大似然估计 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:2:1","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"最小二乘 观测方程 $$ \\boldsymbol{z}_{k, j}=h\\left(\\boldsymbol{y}_{j}, \\boldsymbol{x}_{k}\\right)+\\boldsymbol{v}_{k, j} $$ 噪声服从正态分布 $$ \\boldsymbol{v}_{k} \\sim N\\left(0, \\boldsymbol{Q}_{k, j}\\right) $$ 所以概率也服从正态分布 $$ P\\left(\\boldsymbol{z}_{j, k} \\mid \\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)=N\\left(h\\left(\\boldsymbol{y}_{j}, \\boldsymbol{x}_{k}\\right), \\boldsymbol{Q}_{k, j}\\right) $$ 考虑单次观测的MLE，使用最小化负对数求正态分布的MLE $$ P(\\boldsymbol{x})=\\frac{1}{\\sqrt{(2 \\pi)^{N} \\operatorname{det}(\\boldsymbol{\\Sigma})}} \\exp \\left(-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right) $$ $$ -\\ln (P(\\boldsymbol{x}))=\\frac{1}{2} \\ln \\left((2 \\pi)^{N} \\operatorname{det}(\\boldsymbol{\\Sigma})\\right)+ \\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{T} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu}) $$ 问题变成 $$ \\begin{aligned}\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)^{*} \u0026=\\arg \\max \\mathcal{N}\\left(h\\left(\\boldsymbol{y}_{j}, \\boldsymbol{x}_{k}\\right), \\boldsymbol{Q}_{k, j}\\right) \\\\\u0026=\\arg \\min \\left(\\left(\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\right)^{\\mathrm{T}} \\boldsymbol{Q}_{k, j}^{-1}\\left(\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\right)\\right)\\end{aligned} $$ 这是一个二次型，这个二次型称为马哈拉诺比斯距离（mahalanobis distance），又叫马氏距离，(Qi,j)-1为信息矩阵 考虑批处理，输入和观测、输入和输入、观测和观测之间互相独立 $$ P(z, u \\mid x, y)=\\prod_{k} P\\left(u_{k} \\mid x_{k-1}, x_{k}\\right) \\prod_{k, j} P\\left(z_{k, j} \\mid x_{k}, y_{j}\\right) $$ 这说明z和u可以单独处理 定义误差 $$ \\begin{aligned}e_{u, k} \u0026=\\boldsymbol{x}_{k}-f\\left(\\boldsymbol{x}_{k-1}, \\boldsymbol{u}_{k}\\right) \\\\\\boldsymbol{e}_{\\boldsymbol{z}, j, k} \u0026=\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\end{aligned} $$ 本来的问题是 $$ \\begin{aligned}\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)^{*} \u0026=\\arg \\min \\left(\\left(\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\right)^{\\mathrm{T}} \\boldsymbol{Q}_{k, j}^{-1}\\left(\\boldsymbol{z}_{k, j}-h\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)\\right)\\right)\\end{aligned} $$ 因为加了批处理，问题变成了 $$ \\sum\\left(\\boldsymbol{x}_{k}, \\boldsymbol{y}_{j}\\right)^{*} $$ $$ \\min J(\\boldsymbol{x}, \\boldsymbol{y})=\\sum_{k} e_{\\boldsymbol{u}, k}^{\\mathrm{T}} \\boldsymbol{R}_{k}^{-1} \\boldsymbol{e}_{\\boldsymbol{u}, k}+\\sum_{k} \\sum_{j} \\boldsymbol{e}_{\\boldsymbol{z}, k, j}^{\\mathrm{T}} \\boldsymbol{Q}_{k, j}^{-1} \\boldsymbol{e}_{\\boldsymbol{z}, k, j} $$ 这可以看成是最小二乘问题，解等价于MLE ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:2:2","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"批量状态估计例子 假设运动方程和观测方程是 $$ \\begin{array}{ll}\\boldsymbol{x}_{k}=\\boldsymbol{x}_{k-1}+\\boldsymbol{u}_{k}+\\boldsymbol{w}_{k}, \u0026 \\boldsymbol{w}_{k} \\sim \\mathcal{N}\\left(0, \\boldsymbol{Q}_{k}\\right) \\\\\\boldsymbol{z}_{k}=\\boldsymbol{x}_{k}+\\boldsymbol{n}_{k}, \u0026 \\boldsymbol{n}_{k} \\sim \\mathcal{N}\\left(0, \\boldsymbol{R}_{k}\\right)\\end{array} $$ 这个式子没有y，y是常量，y是世界坐标系的路标点 这可以表示一辆在x轴上行驶的车 取时间k=1, 2, 3，已知u，y，x0（初始状态），进行状态估计 位姿 $$ x=\\left[x_{0}, x_{1}, x_{2}, x_{3}\\right]^{\\mathrm{T}} $$ 观测 $$ z=\\left[ z_{1}, z_{2}, z_{3}\\right]^{\\mathrm{T}} $$ 传感器输入 $$ u=\\left[ u_{1}, u_{2}, u_{3}\\right]^{\\mathrm{T}} $$ 由之前的推导知 $$ \\begin{aligned}x_{\\text {map }}^{*} \u0026=\\arg \\max P(\\boldsymbol{x} \\mid \\boldsymbol{u}, \\boldsymbol{z})=\\arg \\max P(\\boldsymbol{u}, \\boldsymbol{z} \\mid \\boldsymbol{x}) \\\\\u0026=\\prod_{k=1}^{3} P\\left(\\boldsymbol{u}_{k} \\mid \\boldsymbol{x}_{k-1}, \\boldsymbol{x}_{k}\\right) \\prod_{k=1}^{3} P\\left(\\boldsymbol{z}_{k} \\mid \\boldsymbol{x}_{k}\\right)\\end{aligned} $$ $$ P\\left(\\boldsymbol{u}_{k} \\mid \\boldsymbol{x}_{k-1}, \\boldsymbol{x}_{k}\\right)=\\mathcal{N}\\left(\\boldsymbol{x}_{k}-\\boldsymbol{x}_{k-1}, \\boldsymbol{Q}_{k}\\right) $$ $$ P\\left(\\boldsymbol{z}_{k} \\mid \\boldsymbol{x}_{k}\\right)=\\mathcal{N}\\left(\\boldsymbol{x}_{k}, \\boldsymbol{R}_{k}\\right) $$ $$ \\boldsymbol{e}_{\\boldsymbol{u}, k}=\\boldsymbol{x}_{k}-\\boldsymbol{x}_{k-1}-\\boldsymbol{u}_{k}, \\quad \\boldsymbol{e}_{z, k}=\\boldsymbol{z}_{k}-\\boldsymbol{x}_{k}, $$ 最小二乘的目标函数 $$ \\min \\sum_{k=1}^{3} e_{u, k}^{\\mathrm{T}} \\boldsymbol{Q}_{k}^{-1} e_{\\boldsymbol{u}, k}+\\sum_{k=1}^{3} \\boldsymbol{e}_{\\boldsymbol{z}, k}^{\\mathrm{T}} \\boldsymbol{R}_{k}^{-1} \\boldsymbol{e}_{z, k} $$ 定义向量 $$ \\boldsymbol{y}=[\\boldsymbol{u}, \\boldsymbol{z}]^{\\mathrm{T}} $$ $$ y-\\boldsymbol{H} \\boldsymbol{x}=\\boldsymbol{e} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{\\Sigma}) $$ $$ \\boldsymbol{H}=\\left[\\begin{array}{cccc}1 \u0026 -1 \u0026 0 \u0026 0 \\\\0 \u0026 1 \u0026 -1 \u0026 0 \\\\0 \u0026 0 \u0026 1 \u0026 -1 \\\\0 \u0026 1 \u0026 0 \u0026 0 \\\\0 \u0026 0 \u0026 1 \u0026 0 \\\\0 \u0026 0 \u0026 0 \u0026 1\\end{array}\\right] $$ $$ \\Sigma=\\operatorname{diag}\\left(Q_{1}, Q_{2}, Q_{3}, R_{1}, R_{2}, R_{3}\\right) $$ 整个问题可以写成 $$ \\boldsymbol{x}_{\\text {map }}^{*}=\\arg \\min \\boldsymbol{e}^{\\mathrm{T}} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{e} $$ $$ \\boldsymbol{x}_{\\text {map }}^{*}=\\left(\\boldsymbol{H}^{\\mathrm{T}} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{H}\\right)^{-1} \\boldsymbol{H}^{\\mathrm{T}} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{y} $$ 这个公式只针对例子 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:2:3","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"非线性最小二乘 考虑这个问题 $$ \\min _{x} \\frac{1}{2}\\|f(x)\\|_{2}^{2} $$ x是n维向量 一般直观的求法是dF/dx=0，当dF/dx不好求时用迭代法 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:0","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"梯度下降法 见相关知识部分 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:1","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"牛顿法 见相关知识部分 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:2","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"高斯牛顿法 最速下降法和牛顿法虽然直观，但实用当中存在一些缺点 最速下降法会碰到zigzag问题（过于贪婪） 牛顿法迭代次数少，但需要计算复杂的Hessian矩阵 能否回避Hessian的计算？ guass-newton 将f(x)进行一阶的泰勒展开（注意x是n维向量） $$ f(\\boldsymbol{x}+\\Delta \\boldsymbol{x}) \\approx f(\\boldsymbol{x})+\\boldsymbol{J}(\\boldsymbol{x})^{\\mathrm{T}} \\Delta \\boldsymbol{x} $$ J(x)是否转置都可以，取决于求导用的分子布局还是分母布局，不过一般要统一并且灵活应用 J(x)T类似于df(x)/dx，是n*1的列向量，J(x)是Jacobi矩阵 寻找Δx，使得 $\\|f(\\boldsymbol{x}+\\Delta \\boldsymbol{x})\\|^{2}$ 最小 $$\\Delta \\boldsymbol{x}^{*}=\\arg \\min _{\\Delta \\boldsymbol{x}} \\frac{1}{2}\\left\\|f(\\boldsymbol{x})+\\boldsymbol{J}(\\boldsymbol{x})^{\\mathrm{T}} \\Delta \\boldsymbol{x}\\right\\|^{2}$$ 1/2是系数，加与不加无所谓 $$\\begin{aligned}\\frac{1}{2}\\left\\|f(x)+J(x)^{\\mathrm{T}} \\Delta x\\right\\|^{2} \u0026=\\frac{1}{2}\\left(f(x)+J(x)^{\\mathrm{T}} \\Delta x\\right)^{\\mathrm{T}}\\left(f(x)+J(x)^{\\mathrm{T}} \\Delta x\\right) \\\\\u0026=\\frac{1}{2}\\left(\\|f(x)\\|_{2}^{2}+2 f(x) J(x)^{\\mathrm{T}} \\Delta x+\\Delta x^{\\mathrm{T}} J(x) J(x)^{\\mathrm{T}} \\Delta x\\right) \\end{aligned}$$ 求上式对于Δx的导数，并令其为0 $$J(x) f(x)+J(x) J^{\\top}(x) \\Delta x=0$$ $$\\underbrace{\\boldsymbol{J}(\\boldsymbol{x}) \\boldsymbol{J}^{\\mathrm{T}}}_{\\boldsymbol{H}(\\boldsymbol{x})}(\\boldsymbol{x}) \\Delta \\boldsymbol{x}=\\underbrace{-\\boldsymbol{J}(\\boldsymbol{x}) f(\\boldsymbol{x})}_{\\boldsymbol{g}(\\boldsymbol{x})} $$ $$H \\Delta x=g$$ 在牛顿法中 $$\\nabla f\\left(x^{(k)}\\right)+H\\left(x^{(k)}\\right)\\left(x-x^{(k)}\\right)=0$$ $$J+H\\Delta x = 0$$ GN法就是用JJT代替H GN法的迭代步骤如下 给定初值$x_0$ 对于第k次迭代，求$J(x_k)$和误差$f(x_k)$ （因为$H\\Delta x=g$中需要） 求增量方程 $H \\Delta x_k = g$ 若$\\Delta x_k$ 足够小，则停止，否则$x_{k+1}=x_k+\\Delta x$，跳2 可以看出主要是求$H\\Delta x=g$中的$\\Delta x$ 有些GN法的变种为 $$(\\Delta \\boldsymbol{x}, \\alpha)^{*}=\\arg \\min \\left\\| f(x+\\alpha \\Delta x) \\right\\|^{2}$$ 求完Δx后求α ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:3","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"列文伯格-马夸尔特法 levenberg-marquadt GN法只能在展开点附近有较好的近似效果，LM法一定程度上修正了GN法的缺点，收敛速度比GN法慢 LM法给Δx加一个范围，称为信赖域（trust region），这个范围定义了什么情况下近似是有效的，这类方法也叫信赖域法（trust region method） 用ρ来刻画近似好坏程度 $$\\rho=\\frac{f(x+\\Delta x)-f(x)}{J(x)^{T} \\Delta x}$$ 再次声明J的转置取决于求导用的分子布局还是分母布局，其实没有差别 这个式子的分子是实际情况，分母是近似情况 ρ接近1，近似效果好，太小，缩小近似范围，太大，扩大近似范围 所以对GN法改造后的LM法如下 给初值$x_0$和初始优化半径μ 对于第k次迭代，在GN法上增加trust region求解，μ是信赖域半径，D是系数矩阵 $$ \\min _{\\Delta \\boldsymbol{x}_{k}} \\frac{1}{2}\\left\\|f\\left(\\boldsymbol{x}_{k}\\right)+\\boldsymbol{J}\\left(\\boldsymbol{x}_{k}\\right)^{T} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2}, \\quad \\text { s.t. }\\left\\|\\boldsymbol{D} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2} \\leq \\mu $$ 根据它，计算ρ $$\\rho=\\frac{f(x+\\Delta x)-f(x)}{J(x)^{T} \\Delta x}$$ 若ρ\u003e3/4， μ=2μ 若ρ\u003c1/4，μ=0.5μ 若μ大于某阈值，则认为近似可行，$x_{k+1}=x_k+\\Delta x$ 判断算法是否收敛，不收敛跳2，否则结束 近似范围扩大的倍数和阈值都是可调的 对于 $\\left\\|\\boldsymbol{D} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2} \\leq \\mu$ 可以认为Δx限定在半径为μ的球中，带上D之后变成椭球 列文伯格说D取I（单位阵），马夸尔特说D取非负数对角阵（实际通常用$J^TJ$的对角元素平方根，使得在梯度小的维度上约束范围大一点） 对于这个带约束的非线性优化，可用拉格朗日乘数法解（Lagrange Multiplier Method）（另一种方法是罚函数法） $$\\mathcal{L}\\left(\\Delta \\boldsymbol{x}_{k}, \\lambda\\right)=\\frac{1}{2}\\left\\|f\\left(\\boldsymbol{x}_{k}\\right)+\\boldsymbol{J}\\left(\\boldsymbol{x}_{k}\\right)^{\\mathrm{T}} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2}+\\frac{\\lambda}{2}\\left(\\left\\|\\boldsymbol{D} \\Delta \\boldsymbol{x}_{k}\\right\\|^{2}-\\mu\\right)$$ 和GN法一样，令 $$\\frac{d\\mathcal{L}\\left(\\Delta \\boldsymbol{x}_{k}, \\lambda\\right)}{d\\Delta x_k}=0$$ $$\\left(\\boldsymbol{H}+\\lambda \\boldsymbol{D}^{\\mathrm{T}} \\boldsymbol{D}\\right) \\Delta \\boldsymbol{x}_{k}=\\boldsymbol{g}$$ 假设D=I $$(\\boldsymbol{H}+\\lambda \\boldsymbol{I}) \\Delta \\boldsymbol{x}_{k}=\\boldsymbol{g}$$ 总结：初值很重要 ","date":"2021-03-01","objectID":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/:3:4","tags":["slam"],"title":"非线性优化","uri":"/%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/"},{"categories":["note","slam"],"content":"相机模型","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"针孔相机模型 针孔相机模型和畸变模型把三维点投影到相机内的二维平面，构成相机的内参数（intrinsics） 根据三角形的相似性 $$ \\frac{Z}{f}=-\\frac{X}{X^{\\prime}}=-\\frac{Y}{Y^{\\prime}} $$ 把成像平面翻转到前面 $$ \\frac{Z}{f}=\\frac{X}{X^{\\prime}}=\\frac{Y}{Y^{\\prime}} $$ $$ \\begin{array}{l}X^{\\prime}=f \\frac{X}{Z} \\\\ Y^{\\prime}=f \\frac{Y}{Z}\\end{array} $$ 把成像平面投影到像素平面 像素坐标系和成像坐标系之间相差了一个缩放和原点的平移 用u轴和v轴表示像素坐标系 设像素坐标系在u轴上缩放了α倍，在v轴上缩放了β倍，原点平移了[cx, cy]T，投影坐标和像素坐标的关系是 $$ \\left\\{\\begin{array}{l}u=\\alpha X^{\\prime}+c_{x} \\\\ v=\\beta Y^{\\prime}+c_{y}\\end{array}\\right. $$ 代入此式 $$ \\begin{array}{l}X^{\\prime}=f \\frac{X}{Z} \\\\Y^{\\prime}=f \\frac{Y}{Z}\\end{array} $$ fx=αf，fy=βf $$ \\left\\{\\begin{array}{l}u=f_{x} \\frac{X}{Z}+c_{x} \\\\v=f_{y} \\frac{Y}{Z}+c_{y}\\end{array}\\right. $$ 将上式矩阵化（左侧是齐次式，右侧是非齐次式） $$ \\left(\\begin{array}{l}u \\\\v \\\\1\\end{array}\\right)=\\frac{1}{Z}\\left(\\begin{array}{ccc}f_{x} \u0026 0 \u0026 c_{x} \\\\0 \u0026 f_{y} \u0026 c_{y} \\\\0 \u0026 0 \u0026 1\\end{array}\\right)\\left(\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right) \\triangleq \\frac{1}{Z} K P $$ 一般习惯这样写 $$ Z\\left(\\begin{array}{l}u \\\\v \\\\1\\end{array}\\right)=\\left(\\begin{array}{ccc}f_{x} \u0026 0 \u0026 c_{x} \\\\0 \u0026 f_{y} \u0026 c_{y} \\\\0 \u0026 0 \u0026 1\\end{array}\\right)\\left(\\begin{array}{l}X \\\\Y \\\\Z\\end{array}\\right) \\triangleq K P $$ K就是相机的内参数（camera intrinsics），在相机出厂时已经固定，是个常量 有些相机生产厂商会告诉你内参，有些不会。需要自己确定相机内参就叫做标定 在最开始的问题中，拿一个坐标点p进行投影。但这个p是相对于相机的坐标，实际应该是相对于世界的坐标Pw，所以要做一个转换。这个转换实际上只需要做一个旋转和平移就行，这在之前已经讨论过 假设相机的位姿由旋转矩阵R和平移向量t表示，那么世界坐标系到相机坐标系的转换如下 $$ Z P_{u v}=Z\\left[\\begin{array}{l}u \\\\v \\\\1\\end{array}\\right]=K\\left(R P_{w}+t\\right)=K T P_{w} $$ T为变换矩阵，=KTPw这个式子隐含了一次齐次坐标到非齐次坐标的转换 相机的位姿R，t为相机的外参（camera extrinsics） 归一化处理，令z=1，即所有的点都假设在归一化平面上 $$ \\left(R P_{\\mathrm{w}}+t\\right)=\\underbrace{[X, Y, Z]^{\\mathrm{T}}}_{\\text {相机坐标 }} \\rightarrow \\underbrace{[X / Z, Y / Z, 1]^{\\mathrm{T}}}_{\\text {归一化坐标 }} . $$ 这样归一化坐标左乘内参就可以得到像素坐标，上式也说明单目视觉中点的深度信息丢失了 投影的顺序：世界-相机-归一化平面-像素 ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:1:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"畸变模型 畸变（distortion）又叫失真，类似于这样 径向畸变由透镜形状引起的，分为桶形畸变和枕形畸变。 桶形畸变：放大率随着与光轴之间距离增加而减小 枕形畸变：放大率随着与光轴之间距离增加而增加 切向畸变是成像平面与透镜不平行引起的 数学表示径向畸变和切向畸变 考虑归一化平面（z=1）上的一点p，坐标[x,y]T，极坐标[r,θ]T 附加：如何理解切向畸变就是发生旋转？ 径向畸变 $$ \\begin{array}{l}x_{\\text {distrred }}=x\\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\\right) \\\\y_{\\text {distorted }}=y\\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\\right)\\end{array} $$ (xdistorted, ydistorted)是径向畸变后的归一化坐标 切向畸变 $$ \\begin{array}{l}x_{\\text {distorted }}=x+2 p_{1} x y+p_{2}\\left(r^{2}+2 x^{2}\\right) \\\\y_{\\text {distorred }}=y+p_{1}\\left(r^{2}+2 y^{2}\\right)+2 p_{2} x y\\end{array} $$ 径向畸变+切向畸变 $$ \\left\\{\\begin{array}{l}x_{\\text {distorted }}=x\\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\\right)+2 p_{1} x y+p_{2}\\left(r^{2}+2 x^{2}\\right) \\\\y_{\\text {distorted }}=y\\left(1+k_{1} r^{2}+k_{2} r^{4}+k_{3} r^{6}\\right)+p_{1}\\left(r^{2}+2 y^{2}\\right)+2 p_{2} x y\\end{array}\\right. $$ 实际可灵活保留各项系数 投影到像素平面 $$ \\left\\{\\begin{array}{l}u=f_{x} x_{\\text {distorted }}+c_{x} \\\\v=f_{y} y_{\\text {distorted }}+c_{y}\\end{array}\\right. $$ 去畸变（undistort）的方式有两种，对整张图去畸变，然后就可以用针孔模型，第二种从畸变图像上的某个点出发，根据畸变方程还原。实际上第一种更好用。 总结 ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:2:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"双目相机模型 由于用了归一化平面（z=1），所以散失了深度，怎么求像素平面上每个像素的深度？ 用双目相机 $$ \\frac{z-f}{z}=\\frac{b-u_{L}+u_{R}}{b} $$ $$ z=\\frac{f b}{d}, \\quad d=u_{L}-u_{R} $$ UR是负数，b是基线，d是视差 视差d的计算很难，需要知道左边像素点在右边图像中对应哪个。由于计算量，双目深度的估计仍需要使用cpu和fpga ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:3:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"RGB-D模型 红外结构光原理 structured light ：发射光线，根据返回的结构光图案判断 飞行时间原理 time-of-flight ToF ：发射光线，接收，计算时间差 像素的深度信息形成点云（point cloud） RGB-D相机的缺点：红外光容易受到日光或其他传感器发射的红外光干扰，不能在室外使用。同时使用多个RGB-D会互相干扰，透射材质的物体难以反射红外光。 ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:4:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","slam"],"content":"图像 计算机如何处理图像？ ","date":"2021-03-01","objectID":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/:5:0","tags":["slam"],"title":"相机模型","uri":"/%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B/"},{"categories":["note","courses"],"content":"编译原理小练习","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"随便记录一下 图源 ","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:0:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"词法分析程序设计 import sys #种别编码表 dict = {'begin' : 1, 'if' : 2, 'then' : 3, 'while' : 4, 'do' : 5, 'end' : 6, '+' : 13, '-' : 14, '*' : 15, '/' : 16, ':' : 17, ':=' : 18, '\u003c' : 20, '\u003c\u003e' : 21, '\u003c=' : 22, '\u003e' : 23, '\u003e=' : 24, '=' : 25, ';' : 26, '(' : 27, ')' : 28, '#' : 0} #一些关键字 word = ['begin', 'if', 'then', 'while', 'do', 'end'] #s是关键字时的处理 def do_word(s): print('(%d, %s) ' % (dict[s], s), end='') #s是id时的处理 def do_id(s): print('(%d, \\'%s\\') ' % (10, s), end='') #s是数字时的处理 def do_num(s): print('(%d, %s) ' % (11, s), end='') #s是符号时的处理 def do_symbol(s): print('(%d, %s) ' % (dict[s], s), end='') def main(): with open('in.txt', 'r') as f: tmpio = sys.stdin sys.stdin = f str = input() #print(str) i = 0 while str[i] != '#': # #是结束标志 ch = str[i] if ch == ' ': #空格直接跳过 i += 1 continue if ch.isalpha(): #如果是字母就一直搜素知道非数字和非字母，这样就能取到关键字或标识符 tmp_str = '' while ch.isalnum(): tmp_str += ch i += 1 ch = str[i] if tmp_str in word: #如果是关键字 do_word(tmp_str) else : do_id(tmp_str) #否则是标识符 elif ch.isnumeric(): #取得这个数字 tmp_str = '' while ch.isnumeric(): tmp_str += ch i += 1 ch = str[i] do_num(tmp_str) else: #判断是否是两个字符组成的符号 tmp_str = '' if str[i] == ':' and str[i + 1] == '=': tmp_str = ':=' i += 1 elif str[i] == '\u003c' and str[i + 1] == '\u003e': tmp_str = '\u003c\u003e' i += 1 elif str[i] == '\u003c' and str[i + 1] == '=': tmp_str = '\u003c=' i += 1 elif str[i] == '\u003e' and str[i + 1] == '=': tmp_str = '\u003e=' i += 1 else: tmp_str = ch #一个字符组成的符号 do_symbol(tmp_str) i += 1 print('(0, #)') sys.stdin = tmpio if __name__ == '__main__': main() function func(){ var tmp = document.getElementById('qwe'); var str = tmp.value; var fstr = ''; // tmp = document.getElementById('zxc'); // tmp.value = str; function do_word(s) { fstr += '('; fstr += dict[s]; fstr += ', '; fstr += s; fstr += ') '; } function do_id(s) { fstr += '('; fstr += 10; fstr += ', '; fstr += s; fstr += ') '; } function do_num(s) { fstr += '('; fstr += 11; fstr += ', '; fstr += s; fstr += ') '; } function do_symbol(s) { fstr += '('; fstr += dict[s]; fstr += ', '; fstr += s; fstr += ') '; } function contains(arr, obj) { var i = arr.length; while (i--) { if (arr[i] === obj) { return true; } } return false; } var dict = {'begin' : 1, 'if' : 2, 'then' : 3, 'while' : 4, 'do' : 5, 'end' : 6, '+' : 13, '-' : 14, '*' : 15, '/' : 16, ':' : 17, ':=' : 18, '\u003c' : 20, '\u003c\u003e' : 21, '\u003c=' : 22, '\u003e' : 23, '\u003e=' : 24, '=' : 25, ';' : 26, '(' : 27, ')' : 28, '#' : 0}; var word = new Array('begin', 'if', 'then', 'while', 'do', 'end'); var i = 0; while(str[i] != '#'){ var ch = str[i]; if(ch == ' '){ i++; continue; } if((ch \u003e= 'a' \u0026\u0026 ch \u003c= 'z') || (ch \u003e= 'A' \u0026\u0026 ch \u003c= 'Z')){ var tmp_str = ''; while((ch \u003e= 'a' \u0026\u0026 ch \u003c= 'z') || (ch \u003e= 'A' \u0026\u0026 ch \u003c= 'Z') || (ch \u003e= '0' \u0026\u0026 ch \u003c= '9')){ tmp_str += ch; i++; ch = str[i]; } if(contains(word, tmp_str)){ do_word(tmp_str); }else do_id(tmp_str); }else if(ch \u003e= '0' \u0026\u0026 ch \u003c= '9'){ var tmp_str = ''; while (ch \u003e= '0' \u0026\u0026 ch \u003c= '9'){ tmp_str += ch; i++; ch = str[i]; } do_num(tmp_str); }else{ var tmp_str = ''; if(str[i] == ':' \u0026\u0026 str[i + 1] == '='){ tmp_str = ':='; i++; }else if(str[i] == '\u003c' \u0026\u0026 str[i + 1] == '\u003e'){ tmp_str = '\u003c\u003e'; i++; }else if(str[i] == '\u003c' \u0026\u0026 str[i + 1] == '='){ tmp_str = '\u003c='; i++; }else if(str[i] == '\u003e' \u0026\u0026 str[i + 1] == '='){ tmp_str= '\u003e='; i++; }else tmp_str = ch; do_symbol(tmp_str); i++; } } fstr += '(0, #)'; tmp = document.getElementById('zxc'); tmp.value = fstr; } ","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:1:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"基于语法制导翻译的表达式转换编译器 function func2() { var tmp = document.getElementById('qwe'); var str = tmp.value; var fstr = ''; var st_lex = []; var st_tok = []; const NUM = 256, DIV = 257, MOD = 258, ID = 259, DONE = 260, NONE = -1, EOSTR = '\\0'; const BUF_SIZE = 100, SYM_SIZE = 200; var lookahead, lineno = 1, tokenval = NONE; var lexbuf = ''; var I = 0; var eflag = false; var estr = ''; function emit(type, tval) { switch (type) { case '+': case '-': case '*': case '/': fstr += type; break; case DIV: fstr += 'div'; break; case MOD: fstr += 'mod'; break; case NUM: fstr += tval; break; case ID: fstr += st_lex[tval]; break; default: return; } } function error(s) { fstr += 'line ' + lineno + ': ' + s + '\\n'; eflag = true; estr = fstr; //add a teiminate statement tmp = document.getElementById('zxc'); tmp.value = fstr; //alert('qqq'); throw new Error ('error'); } function insert(s, num) { if(st_lex.length \u003e= SYM_SIZE){ error('symbol table full'); } st_lex.push(s); st_tok.push(num); } function init() { insert('', 0); insert('div', DIV); insert('mod', MOD); } function lookup(s) { for(var i = 1; i \u003c st_lex.length; ++i){ if(st_lex[i] == s) return i; } return 0; } function lex() { var tmp; while(true){ tmp = str[I]; I++; if(tmp == ' ' || tmp == '\\t') continue; else if(tmp == '\\n'){ lineno++; }else if(tmp \u003e= '0' \u0026\u0026 tmp \u003c= '9'){ I--; var tt = ''; while(tmp \u003e= '0' \u0026\u0026 tmp \u003c= '9'){ tt += tmp; I++; tmp = str[I]; } tokenval = parseInt(tt); return NUM; }else if((tmp \u003e= 'a' \u0026\u0026 tmp \u003c= 'z') || (tmp \u003e= 'A' \u0026\u0026 tmp \u003c= 'Z')){ var pos, ind = 0; lexbuf = ''; while ((tmp \u003e= 'a' \u0026\u0026 tmp \u003c= 'z') || (tmp \u003e= 'A' \u0026\u0026 tmp \u003c= 'Z') || (tmp \u003e= '0' \u0026\u0026 tmp \u003c= '9')){ lexbuf += tmp; tmp = str[I]; I++; ind++; var tmps = lexbuf; if(tmps == 'DIV' || tmps == 'MOD'){ break; } if(ind \u003e= BUF_SIZE){ error('the length of identifier is too long'); } } if(tmp != '#'){ I--; } pos = lookup(lexbuf); if(pos == 0){ insert(lexbuf, ID); tokenval = st_lex.length - 1; return ID; }else if(st_lex[pos] == 'div' || st_lex[pos] == 'mod'){ if(st_lex[pos] == 'div'){ tokenval = DIV; return DIV; }else { tokenval = MOD; return MOD; } }else { tokenval = pos; return ID; } }else if(tmp == '#'){ return DONE; }else{ tokenval = NONE; return tmp; } } } function match(x) { if(lookahead == x){ lookahead = lex(); }else error('syntax error'); } function factor() { switch (lookahead) { case '(': match('('); express(); match(')'); break; case NUM: emit(NUM, tokenval); match(NUM); break; case ID: emit(ID, tokenval); match(ID); break; default: error('syntax error'); } } function term() { var tmp; factor(); while(true){ switch (lookahead) { case '*': case '/': case DIV: case MOD: tmp = lookahead; match(lookahead); factor(); emit(tmp, NONE); continue; default: return ; } } } function express() { var tmp; term(); while (true){ switch (lookahead) { case '+': case '-': tmp = lookahead; match(lookahead); term(); emit(tmp, NONE); continue; default: return ; } } } function parse() { lookahead = lex(); while (lookahead != DONE){ express(); match(';'); fstr += '\\n'; } } init(); parse(); tmp = document.getElementById('zxc'); tmp.value = fstr; //if(eflag) tmp.value = estr; else tmp.value = fstr; } ","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:2:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"说明语句的词法分析器 import sys ind = 0 id = [] #存标识符名称 tp = [] #存标识符类型 val = [] #存标识符的值 def judge_is_id(s): #是否满足标识符的条件 if s.count(' ') \u003e 0: return False if not s[0].isalpha(): return False return True def main(): with open('in.txt', 'r') as f: tmpio = sys.stdin sys.stdin = f str = input() int_num = char_num = string_num = float_num = 0 #计数 i = 0 while str[i] != ';': #分号表示结束 if str[i] == ' ': #空格跳过 i += 1 continue if str[i] != 'c': #第一个字符不为c，说明不是const print('It is not a constant declaration statement!') print('Please input a string again!') sys.exit() elif i + 6 \u003e len(str): #说明不存在const这个单词 print('It is not a constant declaration statement!') print('Please input a string again!') sys.exit() elif str[i : i + 5] != 'const': #开头是c但是单词不是const print('It is not a constant declaration statement!') print('Please input a string again!') sys.exit() else: str = str[i + 5: -1] #是const，截掉这个单词 break i = 0 foo = str.split(',') #按逗号分割 #print(foo) for cnt in foo: left = (cnt.split('=')[0]) #等号左边的量 right = cnt.split('=')[1] #等号右边的数值 left = left.strip() #消掉前后的空格 right = right.strip() if not judge_is_id(left): #不是标识符 id.append(left) tp.append('Wrong! It is not an identifier!') val.append(' ') #print('Wrong! It is not an identifier!') #sys.exit() else: left.strip() id.append(left) if right[0] == '\\'' and right[2] == '\\'' : #值所代表的的字符串中有两个单引号，且距离为1，说明是char类型 tp.append('char') val.append(right[1]) elif right.count('\\'') == 2: #有两个单引号，但是其中的字符大于1 tp.append('more than one character in \\'') val.append(' ') #print('more than one character in \\'\\'') #sys.exit() elif right.count('\\\"') == 2: #有两个双引号是string类型 tp.append('string') val.append(right[1: -1]) else : #剩下的情况是数字或非法 if right.count('.') == 1 and right.split('.')[0].isdigit() and right.split('.')[1].isdigit() : if right.split('.')[0][0] == '0': #上面的语句说明含有一个小数点，且小数点左右两边都是数字，这可能是个小数 tp.append('numbers cannot started with zero') #有前导0不行，这里没有考虑0.xxx的情况 val.append(' ') #print('numbers cannot started with zero') #sys.exit() else: #合法的小数 tp.append('float') val.append(right) elif not right.isdigit(): #含有非数字成分，说明这不是一个数字 tp.append('Wrong constant') val.append(' ') #print('Wrong constant') #sys.exit() elif right[0] == '0': #是数字但是含有前导0 tp.append('numbers cannot started with zero') val.append(' ') #print('numbers cannot started with zero') #sys.exit() else : #合法的数字 tp.append('integer') val.append(right) #print(len(id), len(tp), len(val)) bar = len(id) #输出 for i in range(bar): print('%s ( %s, %s )' % (id[i], tp[i], val[i])) for i in range(bar): #统计 if tp[i] == 'integer': int_num += 1 if tp[i] == 'char': char_num += 1 if tp[i] == 'string': string_num += 1 if tp[i] == 'float': float_num += 1 print('%s = %d, %s = %d, %s = %d, %s = %d' % ('int_num', int_num, 'char_num', char_num, 'string_num', string_num, 'float_num', float_num) ) sys.stdin = tmpio if __name__ == '__main__': main() function func3() { var tmp = document.getElementById('qwe'); var str = tmp.value; var fstr = ''; var id = [], tp = [], val = []; function judge_is_id(s) { if ((s.split(' ')).length - 1 \u003e 0){ return false; } if(!((s[0] \u003e= 'a' \u0026\u0026 s[0] \u003c= 'z') || (s[0] \u003e= 'A' || s[0] \u003c= 'Z'))){ return false; } return true; } var int_num, char_num, string_num, float_num; int_num = char_num = string_num = float_num = 0; var i = 0; while (str[i] != ';'){ if(str[i] == ' '){ i++; continue; } if(str[i] != 'c'){ fstr += 'It is not a constant declaration statement!\\n'; fstr += 'Please input a string again!'; tmp = document.getElementById('zxc'); tmp.value = fstr; throw new Error('error'); }else if(i + 6 \u003e str.length){ fstr += 'It is not a constant declaration statement!\\n'; fstr += 'Please input a string again!'; tmp = document.getElementById('zxc'); tmp.value = fstr; throw new Error('error'); }else if(str.slice(i, i + 5) != 'const'){ fstr += 'It is not a constant declaration statement!\\n'; fstr += 'Please input a string again!'; tmp = document.getElementById('zxc'); tmp.value = fstr; throw new Error('error'); }else{ str = str.slice(i + 5, str.length - 1); break; } } var foo = str.","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:3:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["note","courses"],"content":"基于预测分析方法的表达式语法 import sys #预测分析表 dict = { 'S' : { 'm' : 'AT', '(' : 'AT' }, 'T' : { '+' : '+AT', ')' : '$', '#' : '$', }, 'A' : { 'm' : 'BU', '(' : 'BU' }, 'U' : { '+' : '$', '*' : '*BU', ')' : '$', '#' : '$' }, 'B' : { 'm' : 'm', '(' : '(S)' } } #非终结符 no_tm = ['m', '+', '*', '(', ')', '#'] #输出一行包含序号，分析栈，输入栈，所用产生式 def PRINT(no, stk, s, pd): if stk[-1:] not in no_tm: print('%d\\t%-10s%10s\\t%s-\u003e%s' % (no, stk, s, stk[-1:], pd)) else : print('%d\\t%-10s%10s\\t%s' % (no, stk, s, pd)) def main(): with open('in.txt', 'r') as f: tmpio = sys.stdin sys.stdin = f stri = input() num = 1 #序号 prod = '' #产生式 ind = 0 #输入串的下标 stack = '#S' #分析栈 while len(stack) != 1: #说明只剩# if stack[-1:] == stri[ind]: #分析栈的栈顶等于输入串的栈顶，说明非终结符匹配 PRINT(num, stack, stri, '\\'' + stri[ind] + '\\' match') stri = ' ' * (ind + 1) + stri[ind+1:] ind += 1 num += 1 stack = stack[:-1] elif stack[-1:] in no_tm: #分析栈的栈顶不等于输入串的栈顶又不是非终结符，说明不匹配 PRINT(num, stack, stri, '[ERROR] not match') sys.exit() elif stri[ind] not in dict[stack[-1:]].keys(): #在预测分析表中没有填产生式，出错 PRINT(num, stack, stri, '[ERROR] not match') sys.exit() else: #利用产生式，出栈和入栈 prod = dict[stack[-1:]][stri[ind]] PRINT(num, stack, stri, prod) num += 1 stack = stack[:-1] if prod != '$': stack += prod[::-1] PRINT(num, stack, stri, 'acc') #出错的全都中途退出了，能走到这步的都是acc sys.stdin = tmpio if __name__ == '__main__': main() function func4() { var tmp = document.getElementById('qwe'); var str = tmp.value; var fstr = ''; var dict = { 'S' : { 'm' : 'AT', '(' : 'AT' }, 'T' : { '+' : '+AT', ')' : '$', '#' : '$', }, 'A' : { 'm' : 'BU', '(' : 'BU' }, 'U' : { '+' : '$', '*' : '*BU', ')' : '$', '#' : '$' }, 'B' : { 'm' : 'm', '(' : '(S)' } }; no_tm = ['m', '+', '*', '(', ')', '#']; function PRINT(no, stk, s, pd) { var tchar = stk.slice(stk.length - 1, stk.length); if(no_tm.indexOf(tchar) == -1){ while(stk.length \u003c 20){ stk += ' '; } while (s.length \u003c 20){ s = ' ' + s; } fstr += no; fstr += ('\\t' + stk + s + '\\t\\t\\t' + tchar + '-\u003e' + pd + '\\n'); }else{ while(stk.length \u003c 20){ stk += ' '; } while (s.length \u003c 20){ s = ' ' + s; } fstr += no; fstr += ('\\t' + stk + s + '\\t\\t\\t' + pd + '\\n'); } } var num = 1; var ind = 0; var stack = '#S'; while (stack.length != 1){ if(stack.slice(stack.length - 1, stack.length) == str[ind]){ PRINT(num, stack, str, '\\'' + str[ind] + '\\' match'); tt_str = str; str = ''; for(var j = 0; j \u003c ind + 1; ++j){ str += ' '; } str += tt_str.slice(ind + 1, tt_str.length); ind++; num++; stack = stack.slice(0, stack.length - 1); }else if(no_tm.indexOf(stack.slice(stack.length - 1, stack.length)) != -1){ PRINT(num, stack, str, '[ERROR] not match'); tmp = document.getElementById('zxc'); tmp.value = fstr; throw new Error('error'); }else if(!(str[ind] in dict[stack.slice(stack.length - 1, stack.length)])){ PRINT(num, stack, str, '[ERROR] not match'); tmp = document.getElementById('zxc'); tmp.value = fstr; throw new Error('error'); }else{ var prod = dict[stack.slice(stack.length - 1, stack.length)][str[ind]]; PRINT(num, stack, str, prod); num++; stack = stack.slice(0, stack.length - 1); if(prod != '$'){ stack += prod.split(\"\").reverse().join(\"\"); } } } PRINT(num, stack, str, 'acc'); tmp = document.getElementById('zxc'); tmp.value = fstr; } ","date":"2021-01-21","objectID":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/:4:0","tags":["cs"],"title":"编译原理小练习","uri":"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["problemlist"],"content":"9th hhucpc (Senior)","date":"2020-12-09","objectID":"/9th-hhucpcsenior/","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"u1s1,zyyyyy出的题目真的好好，补题的过程学到了好多（好菜啊o(╥﹏╥)o 题目链接 只贴了代码，题解参考此处 ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:0:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"A ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:1:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"签到 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main(){ int n; int a[105]; cin \u003e\u003e n; int s, m, b; s = m = b = 0; for(int i = 0; i \u003c n; ++i){ double x; cin \u003e\u003e x; if(x == 2 or x == 2.5 or x == 3) s++; else if(x == 5 or x == 5.5 or x == 6) m++; else b++; } cout \u003c\u003c \"Small: \" \u003c\u003c s \u003c\u003c endl \u003c\u003c \"Medium: \" \u003c\u003c m \u003c\u003c endl \u003c\u003c \"Big: \" \u003c\u003c b \u003c\u003c endl; return 0; } ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:1:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"B ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:2:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"贪心 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll a[100005]; ll b[100005]; int main(){ ll n; ll x, y, z; cin \u003e\u003e n; for(int i = 1; i \u003c= n; ++i) cin \u003e\u003e a[i]; cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; ll mi = 100000000000; ll ans = n; b[0] = x; for(int i = 1; i \u003c= n; ++i) b[i] = b[i - 1] + z; bool ok = true; for(int i = n; i \u003e 0; --i){ if(b[i] \u003c= a[i]){ ok = false; break; } if(b[i] - z - y \u003e a[i] and mi \u003e (y + z)){ ans--; b[i] = b[i] - z - y; mi = min(b[i] - a[i], mi- y - z); } mi = min(mi, b[i] - a[i]); } if(!ok) puts(\"HHUTQL\"); else cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:2:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"C ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:3:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"线段树 没板子就不写了 o(╥﹏╥)o ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:3:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"D ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:4:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"状态压缩 / dfs暴搜 #include \"bits/stdc++.h\" using namespace std; typedef long long ll; ll n, m, c; ll w[25]; ll v[25]; vector\u003cpair\u003cll, ll\u003e\u003e conflict; ll ind[1005]; ll to_ind(ll x){ return ind[x]; } bool ok(ll x){ for(auto i : conflict){ ll l = i.first; ll r = i.second; if((x \u003e\u003e l \u0026 1) and (x \u003e\u003e r \u0026 1)) return false; } return true; } ll cal(ll x){ ll sumw = 0; ll sumv = 0; for(ll i = 0; i \u003c n; ++i){ if(x \u003e\u003e i \u0026 1){ sumw += w[i]; sumv += v[i]; if(sumw \u003e m) return 0; } } return sumv; } int main() { ll _; cin \u003e\u003e _; while (_--) { conflict.clear(); cin \u003e\u003e n \u003e\u003e m \u003e\u003e c; for(ll i = 0; i \u003c n; ++i){ ll x, y, z; cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; w[i] = y; v[i] = z; ind[x] = i; } for(ll i = 0; i \u003c c; ++i){ ll x, y; cin \u003e\u003e x \u003e\u003e y; conflict.emplace_back(to_ind(x), to_ind(y)); } ll ans = 0; for(ll i = 0; i \u003c (1 \u003c\u003c n); ++i){ if(ok(i)){ ans = max(ans, cal(i)); } } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:4:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"E ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:5:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"打表 矩阵快速幂 #include \"bits/stdc++.h\" using namespace std; using ll = long long; const ll mod = 1000000007; typedef vector\u003cll\u003e vec; typedef vector\u003cvector\u003cll\u003e\u003e mat; mat mul(mat \u0026A , mat \u0026B){ mat C(A.size() , vec(B[0].size())); for(ll i = 0; i \u003c A.size() ; ++i){ for(ll k = 0 ; k \u003c B.size() ; ++k){ for(ll j = 0 ; j \u003c B[0].size() ; ++j){ C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % mod; } } } return C; } mat pow_mat(mat A , ll n){ mat B(A.size() , vec(A.size())); for(ll i = 0 ; i \u003c A.size() ; ++i){ B[i][i] = 1; } while(n \u003e 0){ if(n \u0026 1) B = mul(B , A); A = mul(A , A); n \u003e\u003e= 1; } return B; } int main() { // ll n = 1; // ll ans = 0; // vector\u003cll\u003e vt; // vector\u003cll\u003e tt; // for(ll i = 0; i \u003c n; ++i){ // tt.push_back(i % 3); // } // for(ll i = 0; i \u003c (1 \u003c\u003c n); ++i){ // vt.clear(); // for(ll j = 0; j \u003c n; ++j){ // if(i \u003e\u003e j \u0026 1){ // vt.push_back(j % 3); // } // } // bool ok = true; // for(ll j = 0; j \u003c vt.size(); ++j){ // if(vt[j] != tt[j]){ // ok = false; // break; // } // } // if(ok) ans++; // } // cout \u003c\u003c ans - 1 \u003c\u003c endl; ll g1 = 1, g2 = 2, g3 = 3; ll _; cin \u003e\u003e _; while (_--) { //此处有md渲染有bug，所以这样写 mat core = {{1, 0, 1, 1}}, {1, 0, 0, 0}, {0, 1, 0, 0}, {{0, 0, 0, 1}}; ll n; cin \u003e\u003e n; if(n \u003c= 3){ cout \u003c\u003c n \u003c\u003c endl; continue; } n -= 3; core = pow_mat(core, n); ll ans = 0; ans += core[0][0] * g3; ans %= mod; ans += core[0][1] * g2; ans %= mod; ans += core[0][2] * g1; ans %= mod; ans += core[0][3]; ans %= mod; cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:5:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"F ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:6:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"分治 01背包 二分 前缀 #include \"bits/stdc++.h\" using namespace std; typedef long long ll ; int n, c; const int maxn = 1005; const int maxm = 32007; int dp1[maxm]; int dp2[maxm]; int n1; int n2; int W; vector\u003cint\u003e w1, v1, w2, v2; const int limit = (1 \u003c\u003c 10); vector\u003cpair\u003cint, int\u003e\u003e vt1; vector\u003cint\u003e vt2; int premax[maxm]; // 1 for big , 2 for small int main() { cin \u003e\u003e n \u003e\u003e c; memset(premax, -1, sizeof(premax)); W = maxm - 3; // for test w1.push_back(0); w2.push_back(0); v1.push_back(0); v2.push_back(0); for(int i = 0; i \u003c n; ++i){ int x, y; cin \u003e\u003e x \u003e\u003e y; if(x \u003e= limit){ ++n1; w1.push_back((x \u003e\u003e 10)); v1.push_back(y); }else { ++n2; w2.push_back(x); v2.push_back(y); } } for(int i = 1; i \u003c= n1; ++i) for(int j = W; j \u003e= w1[i]; --j) dp1[j] = max(dp1[j], dp1[j - w1[i]] + v1[i]); for(int i = 1; i \u003c= n2; ++i) for(int j = W; j \u003e= w2[i]; --j) dp2[j] = max(dp2[j], dp2[j - w2[i]] + v2[i]); for(int i = 0; i \u003c= W; ++i){ vt1.emplace_back((i \u003c\u003c 10), dp1[i]); } premax[0] = dp2[0]; for(int i = 1; i \u003c= W; ++i){ premax[i] = max(premax[i - 1], dp2[i]); } int ans = 0; for(int i = 0; i \u003c W; ++i){ int cnt = vt1[i].first; int rem = c - cnt; if(rem \u003e= 0 and rem \u003c W) ans = max(ans, vt1[i].second + premax[rem]); } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:6:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"G ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:7:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"图论 dfs #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int V; const int maxv = 1e5 + 10; vector\u003cint\u003e G[maxv]; int od[maxv]; bool ok ; void dfs(int x, int f, int d){ for(int i = 0; i \u003c G[x].size(); ++i){ int to = G[x][i]; if(to == f) continue; if(od[to] != 0){ if((d + 1 - od[to]) \u0026 1){ ok = true; break; } }else { od[to] = d + 1; dfs(to, x, d + 1); } } } int main(){ int m; cin \u003e\u003e V \u003e\u003e m; for(int i = 0; i \u003c m; ++i){ int u, v; cin \u003e\u003e u \u003e\u003e v; G[u].push_back(v); G[v].push_back(u); } if(m \u003e= V){ for(int i = 1; i \u003c= V; ++i){ if(od[i] == 0){ dfs(i, -1, 1); od[i] = 1; } } }else ok = false; if(ok) puts(\"yes\"); else puts(\"NO\"); return 0; } ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:7:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"H ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:8:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"欧拉降幂 快速幂 快速乘 #include \"bits/stdc++.h\" using namespace std; typedef long long ll ; inline ll qmul(ll x, ll y, ll mod) { return ( x * y - (ll) ( (long double) x / mod*y )*mod + mod ) % mod; } ll qpow(ll x, ll n, ll mod){ ll res =1; while(n\u003e0) { if(n\u00261) res=qmul(res, x, mod)%mod; x=qmul(x, x, mod)%mod; n\u003e\u003e=1; } return res; } ll phi(ll n) { ll res=n; for(ll i=2;i*i\u003c=n;i++) { if(n%i==0) { res=res/i*(i-1); while(n%i==0) n/=i; } } if(n!=1) res=res/n*(n-1); return res; } char n[100005]; int main() { int _; cin \u003e\u003e _; while (_--) { ll ans ; ll m; scanf(\"%s\", n); scanf(\"%lld\", \u0026m); ll tmpn = 0; ll tmp_phi = phi(m); ll len = strlen(n); if(len \u003c= 16){ ll tmp_mul = 1; for(int i = len - 1; i \u003e= 0; --i){ tmpn += (n[i] - '0') * tmp_mul; tmp_mul *= 10; } ll tmp_ans = qpow(3, tmpn, m); ans = tmp_ans; ans -= 2; ans += m; ans %= m; }else { for(int i = 0; i \u003c len; ++i){ tmpn = tmpn * 10 + (n[i] - '0'); tmpn %= tmp_phi; } tmpn += tmp_phi; ll tmp_ans = qpow(3, tmpn, m); ans = tmp_ans; ans -= 2; ans += m; ans %= m; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:8:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"I ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:9:0","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["problemlist"],"content":"二分 贪心 #include \"bits/stdc++.h\" using namespace std; typedef long long ll ; const int maxn = 1e5 + 10; int a[maxn]; int b[maxn]; int n, m; bool check(int x){ int i = 0, j = 0; while(i \u003c n and j \u003c m){ if(abs(a[i] - b[j]) \u003c= x){ ++i, ++j; }else { ++j; } } return i == n; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int _; cin \u003e\u003e _; while (_--) { cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c n; ++i){ cin \u003e\u003e a[i]; } for(int i = 0; i \u003c m; ++i){ cin \u003e\u003e b[i]; } sort(a, a + n); sort(b, b + m); int l = 0, r = 5 * 1e8 + 3; int mid; while (l \u003c= r){ mid = (l + r) \u003e\u003e 1; if(check(mid)){ r = mid - 1; }else { l = mid + 1; } } cout \u003c\u003c l \u003c\u003c endl; } return 0; } ","date":"2020-12-09","objectID":"/9th-hhucpcsenior/:9:1","tags":["cpp","number_theory","graph_theory","dp","dfs","greedy","binary_search","segment_tree","prefix"],"title":"9th hhucpc (Senior)","uri":"/9th-hhucpcsenior/"},{"categories":["codeforces"],"content":"Codeforces Round #688 (Div. 2) A~D","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Cancel the Trains ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:1:0","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一个铁路网，和每个火车所在的铁路（都在起点），每一时刻走一格，问有几辆车会相撞 ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:1:1","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 编号相同的横向和列向火车会相撞 #include \"bits/stdc++.h\" using namespace std; using ll = long long; int a[105]; int b[105]; int main() { int _; cin \u003e\u003e _; while (_--) { int n, m; cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c n; ++i){ cin \u003e\u003e a[i]; } for(int i = 0; i \u003c m; ++i){ cin \u003e\u003e b[i]; } int num = 0; for(int i = 0; i \u003c n; ++i){ for(int j = 0; j \u003c m; ++j){ if(a[i] == b[j]) num++; } } cout \u003c\u003c num \u003c\u003c endl; } return 0; } ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:1:2","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"B. Suffix Operations ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:2:0","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一个数组，刚开始时可以选择将一个数改成任何数，也可以不改，做以下操作直到每个数相等 将某一后缀都加1或减1 求最小该操作数 ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:2:1","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 如果没有刚开始的操作，那么操作数是固定的，是前一个数减后一个数再求和 然后再尝试修改每个数，中途求操作数的最小值 #include \"bits/stdc++.h\" using namespace std; using ll = long long; ll a[200005]; int main() { int _; cin \u003e\u003e _; while (_--) { ll n; cin \u003e\u003e n; for(int i = 0; i \u003c n; ++i) cin \u003e\u003e a[i]; ll ans = 0; for(int i = 0; i \u003c n - 1; ++i){ ans += abs(a[i] - a[i + 1]); } ll tmp = ans; for(int i = 1; i \u003c n - 1; ++i){ ll tt = tmp - abs(a[i - 1] - a[i]); tt -= abs(a[i] - a[i + 1]); tt += abs(a[i - 1] - a[i + 1]); ans = min(ans, tt); } ll tt = tmp - abs(a[n - 2] - a[n - 1]); ans = min(ans, tt); tt = tmp - abs(a[0] - a[1]); ans = min(ans, tt); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:2:2","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"C. Triangles ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:3:0","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一个正方形，每个格子都填数字0~9，对于每个数字，求对应数字的最大面积的三角形，该三角形满足以下条件 顶点可重合 顶点必须在该数字的格子上 允许将其中一个格子改成任何数字（也可以不改） 至少有一条边竖直或水平 如果这条边由两个重合的点组成，则这条边竖直且水平 ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:3:1","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 模拟 #include \"bits/stdc++.h\" using namespace std; using ll = long long; char a[2005][2005]; char b[2005][2005]; int origin[10][2005]; int dynamic[10][2005]; int low[10]; int hi[10]; int ans[10]; int main() { int _; cin \u003e\u003e _; while (_--) { memset(origin, -1, sizeof(origin)); memset(dynamic, -1, sizeof(dynamic)); memset(low, 0x3f, sizeof(low)); memset(hi, -1, sizeof(hi)); memset(ans, 0, sizeof(ans)); int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; ++i) cin \u003e\u003e a[i]; for(int i = 0; i \u003c n; ++i){ vector\u003cint\u003e x[10]; for(int j = 0; j \u003c n; ++j){ low[a[i][j] - '0'] = min(low[a[i][j] - '0'], i); hi[a[i][j] - '0'] = max(hi[a[i][j] - '0'], i); dynamic[a[i][j] - '0'][i] = max(dynamic[a[i][j] - '0'][i], abs(0 - j)); dynamic[a[i][j] - '0'][i] = max(dynamic[a[i][j] - '0'][i], abs(n - 1 - j)); x[a[i][j] - '0'].push_back(j); } for(int p = 0; p \u003c 10; ++p){ //sort(x[p].begin(), x[p].end()); if(x[p].size() \u003c 2) continue; origin[p][i] = *max_element(x[p].begin(), x[p].end()) - *min_element(x[p].begin(), x[p].end()); } } for(int i = 0; i \u003c 10; ++i){ int tmp = 0; //origin for(int j = 0; j \u003c n; ++j){ if(origin[i][j] == -1) continue; tmp = max(tmp, origin[i][j] * max(abs(j - 0), abs(n - 1 - j))); } //dynamic if(low[i] == 0x3f3f3f3f or hi[i] == -1) continue; for(int j = 0; j \u003c n; ++j){ if(dynamic[i][j] == -1) continue; tmp = max(tmp, dynamic[i][j] * max(abs(j - low[i]), abs(j - hi[i]))); } ans[i] = tmp; } //cout \u003c\u003c hi[2] \u003c\u003c endl; for(int i = 0; i \u003c n; ++i){ for(int j = 0; j \u003c n; ++j){ b[i][j] = a[j][i]; } } for(int i = 0; i \u003c n; ++i){ for(int j = 0; j \u003c n; ++j){ a[i][j] = b[i][j]; } } memset(origin, -1, sizeof(origin)); memset(dynamic, -1, sizeof(dynamic)); memset(low, 0x3f, sizeof(low)); memset(hi, -1, sizeof(hi)); for(int i = 0; i \u003c n; ++i){ vector\u003cint\u003e x[10]; for(int j = 0; j \u003c n; ++j){ low[a[i][j] - '0'] = min(low[a[i][j] - '0'], i); hi[a[i][j] - '0'] = max(hi[a[i][j] - '0'], i); dynamic[a[i][j] - '0'][i] = max(dynamic[a[i][j] - '0'][i], abs(0 - j)); dynamic[a[i][j] - '0'][i] = max(dynamic[a[i][j] - '0'][i], abs(n - 1 - j)); x[a[i][j] - '0'].push_back(j); } for(int p = 0; p \u003c 10; ++p){ //sort(x[p].begin(), x[p].end()); if(x[p].size() \u003c 2) continue; origin[p][i] = *max_element(x[p].begin(), x[p].end()) - *min_element(x[p].begin(), x[p].end()); } } for(int i = 0; i \u003c 10; ++i){ int tmp = 0; //origin for(int j = 0; j \u003c n; ++j){ if(origin[i][j] == -1) continue; tmp = max(tmp, origin[i][j] * max(abs(j - 0), abs(n - 1 - j))); } //dynamic if(low[i] == 0x3f3f3f3f or hi[i] == -1) continue; for(int j = 0; j \u003c n; ++j){ if(dynamic[i][j] == -1) continue; tmp = max(tmp, dynamic[i][j] * max(abs(j - low[i]), abs(j - hi[i]))); } ans[i] = max(ans[i], tmp); } for(int i = 0; i \u003c 10; ++i){ printf(\"%d%c\", ans[i], i == 9 ? '\\n' : ' '); } } return 0; } ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:3:2","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"D. Checkpoints ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:4:0","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 有n个阶段，有些阶段有检查点，每次有一半的概率通过阶段，如果没有通过，则返回到之前最近的一个检查点（保证第一个阶段是检查点）（如果该阶段是检查点且没通过，则不动（即返回自身）），直到通过所有阶段 给定k为通过所有阶段的期望尝试值，求一种可能的阶段数和检查点设置情况（1为设置检查点，0为没有检查点） ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:4:1","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 构造 奇数一定无解 考虑10000。。。的情况，如果是10，则需要6次，第一阶段的时刻是[1,2,4,5]第二个阶段的时刻是[3,6] 如果是100，则需要14次，第一阶段的时刻是[1,2,4,5,8,9,11,12]第二个阶段的时刻是[3,6,10,13]，第三个阶段的时刻是[7,14]，经过分析和找规律发现如果10000的长度为i，则答案为2^i - 2，这样问题就转化成对k求变形二进制，然后将1000序列接在一起 #include \"bits/stdc++.h\" using namespace std; using ll = long long; int main() { int _; cin \u003e\u003e _; while (_--) { vector\u003cint\u003e ans; ll n; cin \u003e\u003e n; if(n \u0026 1) { puts(\"-1\"); continue; } for(ll i = 60; i \u003e= 1; --i){ ll tmp = (2ll \u003c\u003c i) - 2; while (n \u003e= tmp){ n -= tmp; ans.push_back(1); ans.insert(ans.end(), i - 1, 0); } } cout \u003c\u003c ans.size() \u003c\u003c endl; for(int i = 0; i \u003c ans.size(); ++i){ cout \u003c\u003c ans[i] \u003c\u003c \" \\n\"[i == ans.size() - 1]; } } return 0; } ","date":"2020-12-05","objectID":"/codeforces-round-688-div.-2-a~d/:4:2","tags":["cpp","greedy","construct","implementation"],"title":"Codeforces Round #688 (Div. 2) A~D","uri":"/codeforces-round-688-div.-2-a~d/"},{"categories":["abc"],"content":"abc184","date":"2020-12-02","objectID":"/abc184/","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"A - Determinant ","date":"2020-12-02","objectID":"/abc184/:1:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 求二阶行列式 ","date":"2020-12-02","objectID":"/abc184/:1:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 #include \"bits/stdc++.h\" using namespace std; using ll = long long; int main() { int a, b, c, d; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d; cout \u003c\u003c a * d - c * b \u003c\u003c endl; return 0; } ","date":"2020-12-02","objectID":"/abc184/:1:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"B - Quizzes ","date":"2020-12-02","objectID":"/abc184/:2:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 给n个问题，和答题情况，答对加1，答错减1（为0不扣分），初始分数x，求最终分数 ","date":"2020-12-02","objectID":"/abc184/:2:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 #include \"bits/stdc++.h\" using namespace std; using ll = long long; int main() { int n, k; cin \u003e\u003e n \u003e\u003e k; for(int i = 0; i \u003c n; ++i){ char ch; cin \u003e\u003e ch; //cout \u003c\u003c ch; if(ch == 'o') k++; if(ch == 'x' and k \u003e 0) k--; } cout \u003c\u003c k \u003c\u003c endl; return 0; } ","date":"2020-12-02","objectID":"/abc184/:2:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"C - Super Ryuma ","date":"2020-12-02","objectID":"/abc184/:3:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 对于题目给定的图（点击标题转到原题），小黄点可以到达以它为中心的红色领域，已知小黄点的位置和目标，求最少几步能到达目标 ","date":"2020-12-02","objectID":"/abc184/:3:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 感觉这题比传统的C难 最多只需要三步，如果小黄点和目标重合，0步，目标在小黄点的领域内，1步 最难的就是判断2步，满足这几种情况就是2步，其余就是3步 以小黄点为中心的领域和目标为中心的领域相交（坐标和奇偶） 两个点的曼哈顿距离不大于6 以小黄点为中心的领域的斜线部分和目标的曼哈顿距离不大于3（其实就是和目标为中心的领域的中间那一块）（此处斜线部分有两条，所以分两种情况） #include \"bits/stdc++.h\" using namespace std; using ll = long long; int main() { int a, b, c, d; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d; int ans = 3; if(a == c and b == d) ans = 0; else if(a + b == c + d or a - b == c - d or abs(a - c) + abs(b - d) \u003c= 3) ans = 1; else if(abs(c + d - (a + b)) \u003c= 3 or abs(c - d + b - a) \u003c= 3 or (a + b) % 2 == (c + d) % 2 or abs(a - c) + abs(b - d) \u003c= 6) ans = 2; cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2020-12-02","objectID":"/abc184/:3:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"D - increment of coins ","date":"2020-12-02","objectID":"/abc184/:4:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 三个袋子放着a b c数量的金币、银币、铜币(a,b,c \u003c 100)，做以下操作直到有一个袋子数量满100 从某个袋子中拿走一个币，再放回两个相同的币 问操作次数的期望值 ","date":"2020-12-02","objectID":"/abc184/:4:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 概率dp（没怎么做过） dp[i][j][k] 表示袋子中分别剩下i j k个时的概率 所有100*100*100种情况求和就是答案（从样例2可以分析得到） 初始化 dp[a][b][c] = 1 #include\u003cbits/stdc++.h\u003e using namespace std; double dp[110][110][110]; int main(){ int a, b, c; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; dp[a][b][c] = 1; double ans = 0; for(int i = 0; i \u003c 100; ++i){ for(int j = 0; j \u003c 100; ++j){ for(int k = 0; k \u003c 100; ++k){ if(i + j + k == 0) continue; ans += dp[i][j][k]; dp[i + 1][j][k] += dp[i][j][k] * i / (i + j + k); dp[i][j + 1][k] += dp[i][j][k] * j / (i + j + k); dp[i][j][k + 1] += dp[i][j][k] * k / (i + j + k); } } } printf(\"%.9f\\n\", ans); return 0; } ","date":"2020-12-02","objectID":"/abc184/:4:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"E - Third Avenue ","date":"2020-12-02","objectID":"/abc184/:5:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 给一个网格，上面有障碍，起点，终点和小写字母，从起点出发，对于当前这个没有障碍的格子，可以选择走一步（相邻四个格子），如果这个格子是小写字母就可以传送到另一个小写字母上，问最少需要几步到达终点 ","date":"2020-12-02","objectID":"/abc184/:5:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 基础bfs #include\u003cbits/stdc++.h\u003e using namespace std; int dist[2010][2010]; char maze[2010][2010]; int h, w; vector\u003cpair\u003cint, int\u003e\u003e a[26]; int dir[4][2] ; int main(){ memset(dist, 0x3f, sizeof(dist)); cin \u003e\u003e h \u003e\u003e w; int sx, sy, gx, gy; for(int i = 1; i \u003c= h; ++i){ cin \u003e\u003e maze[i] + 1; } for(int i = 1; i \u003c= h; ++i){ for(int j = 1; j \u003c= w; ++j){ if(maze[i][j] == 'S'){ sx = i, sy = j; } if(maze[i][j] == 'G'){ gx = i, gy = j; } } } // for(int i = 1; i \u003c= h; ++i){ // for(int j = 1; j \u003c= w; ++j) // { // cout \u003c\u003c maze[i][j]; // } // cout \u003c\u003c '\\n'; // } for(int i = 1; i \u003c= h; ++i){ for(int j = 1; j \u003c= w; ++j){ if(isalpha(maze[i][j]) and maze[i][j] != 'S' and maze[i][j] != 'G'){ a[maze[i][j] - 'a'].emplace_back(i, j); } } } dist[sx][sy] = 0; queue\u003cpair\u003cint, int\u003e\u003e q; q.push({sx, sy}); bool got = false; while(!q.empty() and !got){ auto tmp = q.front(); q.pop(); int tx = tmp.first; int ty = tmp.second; for(int i = 0; i \u003c 4; ++i){ int fx = tx + dir[i][0]; int fy = ty + dir[i][1]; if(fx \u003e= 1 and fy \u003e= 1 and fx \u003c= h and fy \u003c= w and maze[fx][fy] != '#' and dist[fx][fy] \u003e dist[tx][ty] + 1){ dist[fx][fy] = dist[tx][ty] + 1; if(fx == gx and fy == gy){ got = true; break; } q.push({fx, fy}); } } if(isalpha(maze[tx][ty]) and maze[tx][ty] != 'S' and maze[tx][ty] != 'G') { for(auto i : a[maze[tx][ty] - 'a']){ auto cx = i.first ; auto cy = i.second; if(cx == tx and cy == ty) continue; if(dist[cx][cy] \u003e dist[tx][ty] + 1){ dist[cx][cy] = dist[tx][ty] + 1; if(cx == gx and cy == gy){ got = true; break; } q.push({cx, cy}); } } } } if(got) cout \u003c\u003c dist[gx][gy] \u003c\u003c endl; if(!got){ puts(\"-1\"); } return 0; } ","date":"2020-12-02","objectID":"/abc184/:5:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"F - Programming Contest ","date":"2020-12-02","objectID":"/abc184/:6:0","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题意 给n（n=40）个数，选择其中0个或几个使得和不大于t，求最大可能的和 ","date":"2020-12-02","objectID":"/abc184/:6:1","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["abc"],"content":"题解 经典问题 由于n=40，枚举超时，考虑折半枚举，集合大小为2^20，然后对于一个集合中的每个数，二分查找另一个集合满足条件的最大值 以下代码手写二分，也可以用内置函数，主要是想练一下手写二分 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll a[45]; vector\u003cll\u003e vt1; vector\u003cll\u003e vt2; vector\u003cll\u003e foo1; vector\u003cll\u003e foo2; ll n; ll t; bool check(ll x, ll tp){ return foo2[x] + tp \u003c= t; } int main(){ cin \u003e\u003e n \u003e\u003e t; for(ll i = 1; i \u003c= n; ++i){ cin \u003e\u003e a[i]; } for(ll i = 1; i \u003c= n / 2; ++i){ vt1.push_back(a[i]); } for(ll i = n / 2 + 1; i \u003c= n; ++i){ vt2.push_back(a[i]); } ll len1 = n / 2; ll len2 = n - n / 2; for(ll i = 0; i \u003c (1 \u003c\u003c len1); ++i){ ll tmp = 0; for(ll j = 0; j \u003c len1; ++j){ if(i \u003e\u003e j \u0026 1){ tmp += vt1[j]; } } foo1.push_back(tmp); } for(ll i = 0; i \u003c (1 \u003c\u003c len2); ++i){ ll tmp = 0; for(ll j = 0; j \u003c len2; ++j){ if(i \u003e\u003e j \u0026 1){ tmp += vt2[j]; } } foo2.push_back(tmp); } foo1.push_back(0); foo2.push_back(0); sort(foo1.begin(), foo1.end()); sort(foo2.begin(), foo2.end()); vector\u003cll\u003e::iterator it; it = unique(foo1.begin(), foo1.end()); foo1.erase(it, foo1.end()); it = unique(foo2.begin(), foo2.end()); foo2.erase(it, foo2.end()); //for(ll i : foo2) cout \u003c\u003c i \u003c\u003c \" \"; len1 = foo1.size(); len2 = foo2.size(); ll mx = -1; for(ll i = 0; i \u003c len1; ++i){ ll tmp = foo1[i]; ll l = 0, r = len2 - 1; while(l \u003c= r){ ll mid = (l + r) \u003e\u003e 1; if(check(mid, tmp)){ mx = max(mx, tmp + foo2[mid]); l = mid + 1; }else r = mid - 1; } } cout \u003c\u003c mx \u003c\u003c endl; //cout \u003c\u003c qq1 \u003c\u003c \" \" \u003c\u003c qq2 \u003c\u003c endl; //cout \u003c\u003c foo2[6]; return 0; } ","date":"2020-12-02","objectID":"/abc184/:6:2","tags":["cpp","bfs","dp","binary_search"],"title":"abc184","uri":"/abc184/"},{"categories":["note","courses"],"content":"8086指令系统","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"8086寄存器 mem 存储器操作数 acc 累加器操作数 dest 目标操作数 src 源操作数 disp 8位或16位偏移量，可用符号地址表示 DATA 8位或16位数据 port 输入输出端口 ( ) 表示寄存器的内容 [ ] 表示存储器的内容或偏移地址 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:0:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"数据传送 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"传送数据 MOV move 指令格式：MOV dst, src; 操作：dest src WORD PTR 字长度标记 BYTE PTR 字节长度标记 DWORD PTR 双字长度标记 （伪指令） IP不能作目的寄存器； 不允许 mem2 ← mem1（存储器）； 不允许 segreg ← segreg（段寄存器）； 立即数不允许作为目的操作数； 源操作数与目的操作数类型要一致。 MOV AL, BL; MOV [DI], AX; MOV CX, [1000H]; MOV BL, 40 MOV WORD PTR[SI], 01H; 几种不允许传送的解决办法： 用寄存器如AX作桥梁。 存储器←存储器： MOV AX，MEM1 MOV MEM2，AX 段寄存器←段寄存器： MOV AX，DS MOV ES，AX 段寄存器←立即数： MOV AX，DATA MOV DS，AX PUSH/POP 由SS指示堆栈段的段基址； 堆栈指针SP始终指向堆栈的顶部； SP的初值规定了所用堆栈区的大小； 堆栈的最高地址叫栈底。 PUSH src ; src为16位操作数 PUSH reg ； PUSH mem/reg PUSH segreg 例如： PUSH AX； PUSH [BX]； PUSH DS ； PUSH AX ；将AX内容压栈 执行操作： [(SP)-1]←高字节(AH) [(SP)-2]←低字节(AL) (SP) ← (SP) - 2 POP dest 例： POP BX ； 将栈顶内容弹至BX 执行操作： (BL) ←[SP] (BH) ← [(SP)+ 1] (SP) ← (SP) + 2 XCHG exchange 格式：XCHG reg，mem/reg 功能：交换两操作数的内容。 要求：两操作数中必须至少有一个在寄存器中； 操作数不能为段寄存器和立即数； 源和目地操作数类型要一致。 举例： XCHG AX，BX XCHG [2000]，CL XLAT translate 执行的操作：AL←[(BX)+(AL)] 又叫查表转换指令，它可根据表项序号查出表中对应代码的内容。执行时先将表的首地址（偏移地址）送到BX中，表项序号存于AL中。 XLAT是一条隐含寻址的指令。使用前要给隐含操作数赋初值。 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:1","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"传送地址 LEA load effective address 用途：用于传送操作数的偏移地址 传送偏移地址：LEA reg，mem ； 将指定内存单元的偏移地址送到指定寄存器 要求： 源操作数必须是一个存储器操作数； 目的操作数必须是一个16位的通用寄存器。 例： LEA BX，[SI+10H] 设：（SI）=1000H 则执行该指令后，（BX）=1010H 注意以下指令差别： LEA BX，[2000H] ;将存储单元的偏移地址取到 BX MOV BX， [2000H] ;将存储单元中的内容取到 BX LDS LES ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:2","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"输入输出 只限于用累加器AL或AX来传送信息。 功能: (累加器)←→I/O端口 IN 格式: IN acc, port ；port端口号0～255H IN acc, DX；DX表示的端口范围达64K 例: IN AL，80H ；(AL）←(80H端口) IN AL，DX ；(AL）←((DX)) IN AX，DX ； (AL）←((DX))，(AH）←((DX+1)) OUT 格式：OUT port, acc OUT DX, acc 例： OUT 68H，AX ；(68H）←（AL） ；(69H）←（AH） OUT DX，AL ；((DX))←(AL) 在使用间接寻址的IN/OUT指令时，要事先用传送指令把I/O端口号设置到DX寄存器，如： MOV DX，220H IN AL，DX ;将220H端口内容读入AL ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:3","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"例子 例2.5 内存中自TABLE开始的16个单元连续存放着自然数0到15的平方值(构成一个平方表)，任给一整数M在XX单元中(该数为0≤M≤15)，查表求M的平方值，并将结果存入YY单元中。 解: LEA BX，TABLE MOV AL，XX XLAT MOV YY，AL ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:4","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"算术运算 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"加法 ADD 不带进位的加法指令ADD 格式： ADD acc, data ADD mem/reg, data ADD mem/reg1, mem/reg2 实例： ADD AL，30H ADD SI，[BX+20H] ADD CX，SI ADD [DI]，200H ADD指令对6个状态标志均产生影响。 例：已知(BX)=E75FH，指令 ADD BX, 8046H 执行后，状态标志各是多少？ E75FH = 1 1 1 0 0 1 1 1 0 1 0 1 1 1 1 1 8046H = 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 0 1 1 0 0 1 1 1 1 0 1 0 0 1 0 1 结果：CF=1, ZF=0, PF=1, AF=1, OF=1, SF=0 PF：低8位中1的个数是否为偶数！ ADC add with carry 带进位位的加法指令ADC ADC指令在形式上和功能上与ADD类似，只是相加时还要包括进位标志CF的内容，例如： ADC AL，68H ;AL←(AL)+68H+(CF) ADC AX，CX ;AX←(AX)+(CX)+(CF) ADC BX，[DI] ; BX←(BX)+[DI+1][DI]+(CF) ADC指令用于多字节加法运算中 ADD/ADC对条件标志位的影响： SF = 1 结果为负，否则为0 ZF = 1结果为0 CF = 1 和的最高有效位有向高位的进位 OF = 1 两个操作数符号相同，而结果符号与之相反 CF位表示无符号数相加的溢出。 OF位表示带符号数相加的溢出。 INC increase 1 加1指令INC（单操作数指令） 格式：INC reg/mem 功能：类似于C语言中的++操作：对指定的操作数加1。 例： INC AL INC SI INC BYTE PTR[BX+4] 注：本指令不影响CF标志。 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:1","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"减法 SUB substract 不带借位的减法指令SUB 格式： SUB dest, src 操作： dest←(dest)-(src) 注：1.源和目的操作数不能同时为存储器操作数 2.立即数不能作为目的操作数 例： SUB AL，60H SUB [BX+20H]，DX SUB AX，CX SBB substract with borrow 带借位的减法指令SBB SBB指令主要用于多字节的减法。 格式： SBB dest, src 操作： dest←(dest)-(src)-(CF) 例： SBB AX，CX SBB WORD PTR[SI]，2080H SBB [SI],DX DEC decrease 1 作用类似于C语言中的”－－”操作符。 格式：DEC opr 操作：opr←(opr)-1 例： DEC CL DEC BYTE PTR[DI+2] DEC SI NEG negative 求补(负)指令NEG 格式： NEG opr ;补码表示的带符号数 操作： opr← 0-(opr) 对一个操作数取补码相当于用0减去此操作数，故利用NEG指令可得到负数的绝对值。 例：若(AL)=0FCH（ -4的补码）， 则执行 NEG AL， (AL)=04H，CF=1。 即得到4(-4的绝对值)。 CMP compare 比较指令CMP 格式： CMP dest, src 操作： (dest)-(src) CMP也是执行两个操作数相减，但结果不送目标操作数，其结果只反映在标志位上。 例： CMP AL，0AH CMP CX，SI CMP DI，[BX+03] 根据标志位来判断比较的结果 根据ZF判断两个数是否相等。若ZF=1，则两数相等。 若两个数不相等,则分两种情况考虑: ①比较的是两个无符号数 若CF=0，则dest＞src; 若CF=1，则dest＜src。 ②比较的是两个有符号数 若OF⊕SF=0，则dest＞src; 若OF⊕SF=1，则dest＜src。 比较指令在使用时，一般在其后紧跟一条条件转移指令，判断比较结果的转向。 举例：比较AL、BL、CL中带符号数的大小，将 最小数放在AL中。 程序： CMP AL,BL ；AL和BL比较 JNG BBB ；若AL≤BL,则转 XCHG AL,BL ；若AL＞BL,则交换 BBB: CMP AL,CL ；AL和CL比较 JNG CCC ；若AL≤CL,则转 XCHG AL,CL ；若AL＞CL,则交换 CCC: HLT ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:2","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"乘除法 进行乘法时： 8位× 8位→16位乘积 16位× 16位→32位乘积 进行除法时： 16位/8位→8位商 32位/16位→16位商 对被除数、商及余数存放有如下规定： 被除数 商 余数 字节除法 AX AL AH 字除法 DX:AX AX DX MUL multiplication 无符号数的乘法指令MUL(mem/reg) 格式： MUL src；src的长度确定乘法类型 操作：字节操作数 (AX) ← (AL) × (src) 字操作数 (DX, AX) ← (AX) × (src) 指令例子： MUL BL ；(AL)×(BL),乘积在AX中 MUL CX ；(AX)×(CX),乘积在DX,AX中 MUL BYTE PTR[BX] 乘法指令对CF/OF的影响： CF/OF = 0/0 乘积的高一半为零，否则1/1 高一半为有效数字 例：(AL) = A5H，(BL) = 11H (1) MUL BL ; (AX) ← (AL)×(BL) ; A5×11= 0AF5 ; (AX) = 0AF5H CF=OF=1 IMUL integer multiplication DIV 无符号数除法指令DIV 格式： DIV src； src的长度确定除法类型 操作：字节操作 (AL) ← (AX) / (SRC) 的商 (AH) ← (AX) / (SRC) 的余数 字操作 (AX) ← (DX, AX) / (SRC) 的商 (DX) ← (DX, AX) / (SRC) 的余数 指令例子： DIV CL DIV WORD PTR[BX] 注：若除数为零或AL中商大于FFH,(或AX中商大于FFFFH)，则CPU产生一个类型0的内部中断。 IDIV ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:3","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"例子 例 下列程序段完成S=(a×b+c)/a的运算，其中变量a、b、c和S均为带符号的字数据,结果的商存入S，余数则不计，填空完成下列程序。 MOV AX，a ;取得被乘数a IMUL b ;a×b在DX:AX中 MOV CX，DX MOV BX，AX MOV AX，c CWD ;c扩展为双字节，在DX:AX中 ADD AX，BX ;a×b+c在DX:AX中 ADC DX，CX ；高位相加 IDIV a ;(a×b+c)/a,商存入S MOV S，AX ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:4","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"逻辑 逻辑运算指令 运算规则：按位操作，无进/借位 对标志位的影响(除NOT指令外)： CF OF SF ZF PF AF 0 0 * * * 无定义 * 根据运算结果设置 AND 逻辑”与” AND 对两个操作数进行按位逻辑“与”操作。 格式：AND dest, src 用途：保留操作数的某几位，清零其他位。 例1： 保留AL中低4位，高4位清0。 AND AL, 0FH 例2：测试AL的bit7, bit5, bit2是否都是1。 AND AL, 10100100B CMP AL, 10100100B JZ YES … … ；不全为1时的处理 YES: OR 逻辑”或” OR 对两个操作数进行按位逻辑”或”操作。 格式：OR dest, src 用途：对操作数的某几位置1； 对两操作数进行组合。 例：把AL的第5位置为1 OR AL, 00100000B NOT 逻辑“非”(取反) NOT 对操作数进行按位逻辑”非”操作。 格式：NOT mem/reg 例： NOT CX NOT BYTE PTR[DI] XOR 逻辑”异或” XOR 对两个操作数按位进行”异或”操作。 格式：XOR dest, src 用途：对reg清零(自身异或) 把reg/mem的某几位变反(与’1’异或) 例1：把AX寄存器清零。 XOR AX, AX MOV AX, 0 AND AX, 0 SUB AX, AX 例2：把DH的bit4,3变反 XOR DH,18H TEST 测试指令TEST 操作与AND指令类似,但不将”与”的结果送回,只影响标志位。 TEST指令常用于位测试,与条件转移指令一起用。 例：测试AL的内容是否为负数。 TEST AL, 80H ；检查AL中D7=1？ JNZ MINUS ；是1(负数)，转MINUS … … ；否则为正数 MINUS: … 例子 例 已知寄存器DX：AX的内容为32位带符号数，编写一段程序使DX：AX的内容成为原来数据的绝对值。 解: TEST DX，8000H ;测试符号位，产生状态 JZ EXIT ;符号位=0，结束 NEG DX ;求绝对值 NEG AX SBB DX，0 EXIT:HLT ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:3:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"移位 SHL/SHR/SAR 非循环移位指令 算术左移指令 SAL(Shift Arithmetic Left) 算术右移指令 SAR(Shift Arithmetic Right) 逻辑左移指令 SHL(Shift Left) 逻辑右移指令 SHR(Shift Right) 这4条指令的格式相同,以SAL为例： SAL mem/reg, CL（移位位数大于1） 1（移位位数等于1） 算术移位——把操作数看做有符号数； 逻辑移位——把操作数看做无符号数。 移位位数放在CL寄存器中，如果只移1位,也 可以直接写在指令中。例如： MOV CL, 4 SHR AL, CL ；AL中的内容右移4位 影响C, P, S, Z, O标志。 结果未溢出时： 左移1位≡操作数×2 右移1位≡操作数 / 2 ROL/ROR/RCL/RCR rotate left rotate left with carry 循环移位指令 不含进位位的循环左移指令 ROL 不含进位位的循环右移指令 ROR 含进位位的循环左移指令 RCL 含进位位的循环右移指令 RCR 格式同非循环移位指令。 移位位数放在CL寄存器中，如果只移1位, 也可以直接写在指令中。 循环移位指令只影响标志位CF和OF。 例1：将AL的高4位与低4位互换。 MOV CL, 4 ROL AL, CL ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:4:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"串操作 串：顺序放在内存中的一组相同类型的数据。 串操作：对串中的元素进行相同的操作。 串操作的寻址方式： 源操作数指针———DS:SI(DS可超越) 目的操作数指针——ES:DI 每次串操作后： 串操作指令自动修改SI和DI——字节:±1，字:±2。DF标志决定±。注意：退出串操作后，指针指向最后操作的元素的下一个元素。 可完成存储单元到存储单元的传送、比较（也仅是串指令可以） 有的串操作指令前面可加重复前缀。当使用重复前缀时，操作重复次数由CX决定(CX自动减量)。该指令重复执行,直至(CX)=0为止。 执行串指令之前，应先进行如下设置： 源串首地址（末地址）→ SI 目的串首地址（末地址）→ DI 串长度 → CX 建立方向标志（CLD使DF=0(增)，STD使DF=1 (减) ） 重复前缀 REP ；无条件重复 REPE/REPZ ；当相等/为零时重复 REPNE/REPNZ ；当不相等/不为零时重复 MOVS move string 串传送指令MOVSB / MOVSW 指令执行的操作为： MOVSB ； ((ES):(DI))←((DS):(SI)) SI±1, DI±1 MOVSW ； ((ES):(DI+1)(DI))←((DS):(SI+1)(SI)) SI±2, DI±2 注意： src用DS:SI寻址, dest用ES:DI寻址 例 编写将数据段中自AREA1开始的100个字数据搬到附加段中以AREA2开始的数据区中的程序段。 解： ① 用基本串传送指令 LEA SI，AREA1 LEA DI，AREA2 MOV CX，100 CLD DONE: MOVSW LOOP DONE 用重复串传送指令 LEA SI， AREA1 LEA DI， AREA2 MOV CX， 100 CLD REP MOVSW STOS store string 串存储指令STOSB / STOSW 写指令的操作为： 对字节：((ES):(DI))←(AL) DI±1 对字：((ES):(DI+1)(DI))←(AX) DI±2 本指令用于把一块存储区域填充成某一 初始值(即对存储区进行初始化)。 LODS load string 串读取指令LODSB / LODSW 执行的操作为： 对字节：(AL)←((DS):(SI)) SI±1 对字：(AX)←((DS):(SI+1)(SI)) SI±2 串读取指令通常不加重复前缀。 LODSB等价于: MOV AL,[SI］ INC SI LODSW等价于: MOV AX,[SI] INC SI INC SI CMPS compare string 串比较指令CMPSB / CMPSW 指令执行的操作为： CMPSB ；((DS):(SI))-((ES):(DI)) SI±1, DI±1 CMPSW ；((DS):(SI+1)(SI))-((ES):(DI+1)(DI)) SI±2, DI±2 比较的结果只反映在标志位上，串本身无变化。 本指令可用来检查两个串是否相等。 与重复前缀REPZ/REPE、REPNZ/REPNE结合使用。 SCAS scan string 串扫描SCASB / SCASW 执行的操作： 对字节：(AL)－((ES):(DI)) DI±1 对字： (AX)－((ES):(DI＋1)(DI)) DI±2 搜索指令执行的仍是比较(减法)操作,结果只影响标志位。 要搜索的关键字放在AL(字节)或AX(字)中。 本指令用于在串中查找指定的信息。 与重复前缀REPZ/REPE、REPNZ/REPNE结合使用。 SCAS指令加上重复前缀后,可对串进行连续扫描比较： 若前缀为REPZ，则表示比较结果相等(ZF=1)且串未结束(CX≠0)，则继续比较。 若前缀为REPNZ，则表示比较结果不相等(ZF=0)且串未结束(CX≠0)，就继续比较。 REP ；无条件重复 REPE/REPZ ；当相等/为零时重复 REPNE/REPNZ ；当不相等/不为零时重复 CMPS、SCAS与REPE/REPZ的使用： 满足下列两个条件时，重复扫描和比较： （1）CX≠0；重复次数还未完成； （2）ZF=1；目的操作数等于源操作数或扫描值。 CMPS、SCAS与REPNE/REPNZ的使用： 满足下列两个条件时，重复扫描和比较： （1）CX≠0；表示重复次数还未完成； （2）ZF=0；目的操作数不等于源操作数或扫描值。 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:5:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"控制操作 控制类指令包括程序转移指令和处理机控制指令 程序控制转移指令 转移指令（JMP, JNZ） 调用和返回指令（Call/RET） 循环控制指令(LOOP) 中断指令 这类指令的共同特点是可改变程序的正常执行顺序,使之转移。而改变程序的执行顺序,本质上就是要改变CS:(E)IP的内容这类指令对标志位无影响。 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:0","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"转移指令 转移指令的实质：改变IP(或CS)的内容。 所有转移指令不会影响标志位。 分为无条件转移和条件转移两种。 JMP jump 无条件转移指令 – JMP 本指令无条件转移到指定的目标地址,以执行从该地址开始的程序段。 ① 段内直接转移（相对转移） 转移的目标地址由指令直接给出。指令中直接给出的目标地址实际上是一个相对于IP的位移量。 位移量 转移范围 汇编语言中格式 8位 -128～+127 JMP SHORT OPRD 16位 -32768～+32767 JMP NEAR PTR OPRD 例： JMP 0120H ；直接转向0120H JMP SHORT LPI ；转向LPI JMP NEAR PTR BBB ；转向BBB 由于是段内转移,故转移后CS内容保持不变。 ②段内间接转移 转移的目标地址(偏移量)由寄存器或存储单元的内容给出。 例1： JMP SI 若指令执行前(SI)=1200H，则指令执行后，(IP)=1200H,于是转向代码段的偏移地址1200H处执行。 注意：目标地址以段内偏移的形式给出，而不是相对于IP的位移量，所以它是一个16位的操作数。 例2： JMP [BX+DI] 设指令执行前: (DS)=3000H, (BX)=1300H, (DI)=1200H, (32500H)=2350H； 则指令执行后:(IP)=2350H 在汇编语言中,段内间接寻址通常写成： JMP WORD PTR[BX+DI] 表示所取得的目标地址是一个字。 ③段间直接转移 在指令中直接给出要转移到的目的段地址和偏移地址。 例： JMP 2000:1000H 执行时,(IP)←1000H,(CS)←2000H 注：直接地址为符号地址时，段间直接转移指令中的符号地址前应加操作符FAR PTR。 例： JMP FAR PTR far_label 其中的far_label为远类型的标号。 ④段间间接转移 转移的目的地址(段和偏移)在两个相邻的字存储单元中。 例如： JMP DWORD PTR [SI] 设指令执行前:(DS)=4000H，(SI)=1212H, (41212H)=1000H，(41214H)=4A00H 则指令执行后:(IP)=1000H，(CS)=4A00H，于是转到4B000H处开始执行指令。 例中的DWORD PTR表示转移地址是一个双字。 判断无符号数的大小 JXX 条件转移指令 - JXX 条件转移指令可实现程序的条件分支。 条件转移指令根据标志位的状态来决定是否进行分支转移。 格式： JXX label ；xx为条件名称缩写 条件转移指令只能是段内直接转移，且指令的转移范围为指令所在位置的-128～+127字节。 判断无符号数的大小 JA/JNBE ；高于/不低于且不等于，则转移(A＞B) 条件为: CF=0∧ZF=0 JAE/JNB ；高于或等于/不低于，则转移(A≥B) 条件为: CF=0∨ZF=1 JB/JNAE ；低于/不高于且不等于，则转移(A\u003cB) 条件为: CF=1∧ZF=0 JBE/JNA ； 低于或等于/不高于，则转移(AB) 条件为: CF=1∨ZF=1 Not, Above, Bellow, Equal 判断有符号数的大小 JG/JNLE ；大于/不小于且不等于，则转移(A＞B) 条件为: (SF⊕OF=0)∧ZF=0 JGE/JNL ；大于或等于/不小于，则转移(A≥B) 条件为: (SF⊕OF=0)∨ZF=1 JL/JNGE ；小于/不大于且不等于，则转移(A＜B) 条件为: (SF⊕OF=1)∧ZF=0 JLE/JNG ；小于或等于/不大于，则转移(A≤B) 条件为: (SF⊕OF=1)∨ZF=1 Not, larGe , Little, Equal 根据单个标志位设置的条件转移指令 JC ；CF=1,则转移 JNC ；CF=0,则转移 JE/JZ ；结果为零(ZF=1),则转移 JNZ/JNE ；结果不为零(ZF=0),则转移 JP/JPE ；奇偶标志PF=1(偶),则转移 JNP/JPO ；奇偶标志PF=0(奇),则转移 JS ；SF=1,则转移 JNS ；SF=0,则转移 JO ；OF=1,则转移 JNO ；OF=0,则转移 根据CX内容来决定是否转移的转移指令 JCXZ label 若(CX)=0, 则转移到label处开始执行。 例子 例：在8000H开始的长度为1000字节的字符串中查找’S’，若找到，把其偏移地址记录在ADDR中，否则ADDR单元置为0FFFFH。 MOV DI, 8000H MOV CX, 1000 MOV AL, ’S’ MOV ADDR, 0FFFFH GOON: SCASB LOOPNZ GOON ; (CX)≠0∧ZF=0时，循环。 JNZ DONE ；ZF=0，转移。 DEC DI ；找到 MOV ADDR, DI DONE: HLT ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:1","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"循环控制指令 用在循环程序中以确定是否要继续循环。 循环次数通常置于CX中。 转移的目标应在距离本指令-128～+127的范围之内。 循环控制指令不影响标志位。 LOOP (1)LOOP 格式：LOOP label 操作：(CX)-1→CX； 若(CX)≠0,则转至label处执行； 否则退出循环,执行LOOP后面的指令。 LOOP指令与下面的指令段等价： DEC CX JNZ label (2) LOOPZ (LOOPE) 格式：LOOPZ label 操作：(CX)-1→CX； 若(CX)≠0∧ZF=1,则转至label处继续循环； 否则退出循环,执行LOOP后面的指令。 (3) LOOPNZ (LOOPNE) 格式：LOOPNZ label 操作：(CX)-1→CX； 若(CX)≠0∧ZF=0,则转至label处继续循环； 否则退出循环,执行LOOP后面的指令。 例子 例1：给1A000H开始的256个内存单元均减去1，若发现某个单元减为0则立即退出循环，其后的单元不再减1。 MOV AX, 1A00H MOV DS, AX ；段基址 MOV DI, 0 ；偏移量 MOV CX, 256 ；循环次数 GOON: DEC BYTE PTR[DI] ；减1 INC DI ；移动指针 CMP BYTE PTR[DI-1],0 LOOPNZ GOON HLT ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:2","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"过程调用和返回指令 过程(子程序) 一段具有特定功能的，供其它程序调用的公用程序。 特点 调用子程序时，IP(CS)的内容被压入堆栈栈顶。从子程序返回时，栈顶的内容又被弹出到IP(CS)。 子程序执行结束后一般均要返回调用程序。 一次定义，可多次调用； 可带参数调用，以完成不同的功能。 优点 程序代码短, 结构清晰, 便于编程、调试、修改和阅读。 两条相关指令： 子程序调用指令 CALL 子程序返回指令 RET CALL 调用指令CALL 一般格式：CALL sub ;sub为子程序的入口。 根据子程序入口的寻址方式，子程序调用有四类。 ① 段内直接调用 子程序的偏移地址直接由CALL指令给出。 格式：CALL near_proc CALL执行时，它首先将IP内容压栈，然后把指令中给出的位移量加到IP上。 注：经汇编后的调用地址是相对于CALL的下一条指令的位移量。 例： CALL 0120H ;子程序偏移地址由指令给出 程序可能浮动，所以只记相对位移量。 RET return 返回指令RET 段内返回指令RET的操作为： IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2 段间返回指令RET的操作为： IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2 CS←((SP)+1,(SP)) ;栈顶内容弹出到CS SP←(SP)+2 另有一种带立即数返回指令：RET n 其中n为偶数，表示从栈顶弹出地址后另外丢弃的字节数。 例： RET 4 ;返回后再丢弃栈顶的4个字节 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:3","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"中断指令 8086/8088 CPU在程序中允许安排一条中断指令来引起一个中断过程,这种中断叫内部中断,或叫软中断。 中断指令共有三条： (1) INT n 执行类型n的中断服务程序，N=0～255 (2) INTO 执行溢出中断的中断服务程序； (3) IRET 从中断服务程序返回调用程序。 INT interrupt 1、INT n ;n=0～255,为中断类型号 本指令的操作步骤为： ①((SP)-1,(SP)-2)←(FLAGS)，SP←(SP)-2 保护标志寄存器的内容 ②IF←0,TF←0 中断服务程序中禁止外部INTR中断和单步中断 ③((SP)-1,(SP)-2)←(CS)，SP←(SP)-2，CS←(n4+2) 中断服务程序的段地址送入CS。n4为向量地址。该向量地址中的内容即为中断服务程序入口地址。 ④((SP)-1,(SP)-2)←(IP)，SP←(SP)-2，IP←(n*4) 中断服务程序的偏移地址送IP。 INT指令只影响IF和TF, 对其余标志位无影响。 INT指令可用于调用系统服务程序，如INT 21H。 INFO interrupt overflow 溢出中断INTO INTO检查溢出标志OF, 如果OF=1, 则启动一个类型4的中断过程；如果OF=0,不做任何操作。 通常INTO指令安排在有符号数算术运算指令后面。如： IMUL DX INTO ;若溢出，则启动INT 4,否则继续 MOV RESULT, AX MOV RESULT+2, DX …… IRET interrupt return 中断返回指令IRET 用于从中断服务程序返回到被中断的程序。任何中断服务程序不管是外部中断引起的, 还是内部中断引起的, 最后都要用IRET返回。 该指令执行的操作为 IP←((SP)+1,(SP)) ;栈顶内容弹出到IP SP←(SP)+2 CS←((SP)+1,(SP)) ;栈顶内容弹出到CS SP←(SP)+2 FLAGS←((SP)+1,(SP)) ;栈顶内容弹出到FLAG SP←(SP)+2 ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:4","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","courses"],"content":"标志位操作指令 1.标志操作指令：用来设置标志位的状态。 （1）CF设置指令 CLC 0→CF STC 1→CF CMC CF变反 （2）DF设置指令 CLD 0→DF (串操作的指针移动方向从低到高) STD 1→DF (串操作的指针移动方向从高到低) （3）IF设置指令 CLI 0→IF (禁止INTR中断) STI 1→IF (开放INTR中断) ","date":"2020-11-07","objectID":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:6:5","tags":["cs","assembly"],"title":"8086指令系统","uri":"/8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["note","slam"],"content":"李群与李代数","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"群 与视觉slam有关的群 三维旋转矩阵构成了特殊正交群(special orthogonal group) $$S O(3)=\\left\\{R \\in \\mathbb{R}^{3 \\times 3} \\mid R R^{T}=I, \\operatorname{det}(R)=1\\right\\}$$ 三维变换矩阵构成了特殊欧氏群（special euclidean group） $$SE(3)=\\left\\{T=\\left[\\begin{array}{cc}R \u0026 t \\\\0^{T} \u0026 1\\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4} \\mid R \\in SO(3), t \\in \\mathbb{R}^{3}\\right\\} $$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:1:0","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"群的定义 群（group）是一种集合加上一种运算的代数结构 记集合为A，运算为·，那么当运算满足以下性质时，称（A，·）成群 $$ \\begin{array}{ll}\\text { 1. 封闭性: } \\quad \\forall a_{1}, a_{2} \\in A, \\quad a_{1} \\cdot a_{2} \\in A \\text { . }\\end{array} \\\\ \\text { 2. 结合律: } \\quad \\forall a_{1}, a_{2}, a_{3} \\in A, \\quad\\left(a_{1} \\cdot a_{2}\\right) \\cdot a_{3}=a_{1} \\cdot\\left(a_{2} \\cdot a_{3}\\right) \\text { . } \\\\ \\begin{array}{llll}\\text { 3. 幺元: } \u0026 \\exists a_{0} \\in A, \u0026 \\text { s.t. } \\quad \\forall a \\in A, \u0026 a_{0} \\cdot a=a \\cdot a_{0}=a \\text { . }\\end{array} \\\\ \\begin{array}{llll}\\text { 4. 逆: } \u0026 \\forall a \\in A, \u0026 \\exists a^{-1} \\in A, \u0026 \\text { s.t. } \u0026 a \\cdot a^{-1}=a_{0} \\text { . }\\end{array} $$ 如果满足交换律，就是交换群，矩阵很少有交换群 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:1:1","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李群与李代数 李群与李代数在wiki上的定义 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:0","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李群的定义 李群是指具有光滑（连续）性质的群，SO(3)和SE(3)表示的空间的旋转和变换，它一定是连续的，所以是李群。 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:1","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数的引出 对于任意旋转矩阵 $R$ $$\\boldsymbol{R} \\boldsymbol{R}^{T}=\\boldsymbol{I}$$ 它是对时间的函数 $$\\boldsymbol{R}(t) \\boldsymbol{R}(t)^{T}=\\boldsymbol{I}$$ 等式两边对时间求导 （矩阵对标量求导就是每个entry求导后转置） $$\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}+\\boldsymbol{R}(t) \\dot{\\boldsymbol{R}}(t)^{T}=0$$ $$\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}=-\\left(\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}\\right)^{T}$$ 引入向量与反对称矩阵的转换标志 $$\\boldsymbol{a}^{\\wedge}=\\boldsymbol{A}=\\left[\\begin{array}{ccc}0 \u0026 -a_{3} \u0026 a_{2} \\\\a_{3} \u0026 0 \u0026 -a_{1} \\\\-a_{2} \u0026 a_{1} \u0026 0\\end{array}\\right], \\quad \\boldsymbol{A}^{\\vee}=\\boldsymbol{a}$$ 由于 $\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}$ 是一个反对称矩阵，所以有 $$\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}=\\phi(t)^{\\wedge}$$ $$\\dot{\\boldsymbol{R}}(t)=\\phi(t)^{\\wedge} \\boldsymbol{R}(t)$$ 可以看出对 $R$ 求导就是左乘一个 $\\phi(t)^{\\wedge}$ 在原点处 $t_0 = 0$ ，假设 $R(0) = I$，在原点处泰勒展开 $$\\begin{aligned}\\boldsymbol{R}(t) \u0026 \\approx \\boldsymbol{R}\\left(t_{0}\\right)+\\dot{\\boldsymbol{R}}\\left(t_{0}\\right)\\left(t-t_{0}\\right) \\\u0026=\\boldsymbol{I}+\\boldsymbol{\\phi}\\left(t_{0}\\right)^{\\wedge}(t)\\end{aligned}$$ 可以看出 $\\phi$ 反应了 $R$ 导数的性质，故称它为 $SO(3)$ 原点附近的正切空间（tangent space），设 $\\phi(t_0) = \\phi_0$ $$\\dot{\\boldsymbol{R}}(t)=\\phi\\left(t_{0}\\right)^{\\wedge} \\boldsymbol{R}(t)=\\boldsymbol{\\phi}_{0}^{\\wedge} \\boldsymbol{R}(t)$$ 将它看成一阶线性齐次微分方程，解得 $$\\boldsymbol{R}(t)=\\exp \\left(\\boldsymbol{\\phi}_{0}^{\\wedge} t\\right)$$ 此处并不是传统意义上的 $e^{\\phi_0^{\\wedge} t}$ 该式说明对于任意 $t$ 都可以找到 $R$ 和 $\\phi$ 的对应关系，这称为指数映射（exponential map） $\\phi$ 就是 $SO(3)$ 对应的李代数 $so(3)$ 每个李群都有对应的李代数，李代数描述了李群的局部性质，准确地说，是单位元附近的正切空间 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:2","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数的定义 李代数由一个集合 $\\mathbb{V}$ ，一个数域 $\\mathbb{F}$ ，和一个二元运算 $[,]$ 组成。如果它们满足以下几条性质，称 $(\\mathbb{V}, \\mathbb{F},[,])$ 为一个李代数 $\\mathfrak{g}$ $$\\begin{array}{ll}\\text { 1. 封闭性 } \\quad \\forall \\boldsymbol{X}, \\boldsymbol{Y} \\in \\mathbb{V},[\\boldsymbol{X}, \\boldsymbol{Y}] \\in \\mathbb{V} \\text { . }\\end{array}$$ $$\\text { 2. 叉线性 } \\quad \\forall \\boldsymbol{X}, \\boldsymbol{Y}, \\boldsymbol{Z} \\in \\mathbb{V}, a, b \\in \\mathbb{F}, \\text { 有: }$$ $$[a \\boldsymbol{X}+b \\boldsymbol{Y}, \\boldsymbol{Z}]=a[\\boldsymbol{X}, \\boldsymbol{Z}]+b[\\boldsymbol{Y}, \\boldsymbol{Z}], \\quad[\\boldsymbol{Z}, a \\boldsymbol{X}+b \\boldsymbol{Y}]=a[\\boldsymbol{Z}, \\boldsymbol{X}]+b[\\boldsymbol{Z}, \\boldsymbol{Y}]$$ $$\\text { 3. 自反性 } \\quad \\forall \\boldsymbol{X} \\in \\mathbb{V},[\\boldsymbol{X}, \\boldsymbol{X}]=\\mathbf{0} \\text { . }$$ $$\\text { 4. 雅可比等价 } \\quad \\forall X, Y, Z \\in \\mathbb{V},[X,[Y, Z]]+[Z,[Y, X]]+[Y,[Z, X]]=0$$ 二元运算被称为李括号（lie bracket），表达了两个元素的差异 李代数的例子，集合是三维向量，数域是实数，二元运算是叉积 $$\\mathfrak{g} = (\\mathbb{R}^3, \\mathbb{R}, ×)$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:3","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数so(3) $$\\mathfrak{s} \\mathfrak{o}(3)=\\left\\{\\boldsymbol{\\phi} \\in \\mathbb{R}^{3}, \\boldsymbol{\\Phi}=\\boldsymbol{\\phi}^{\\wedge} \\in \\mathbb{R}^{3 \\times 3}\\right\\}$$ $$\\Phi=\\phi^{\\wedge}=\\left[\\begin{array}{ccc}0 \u0026 -\\phi_{3} \u0026 \\phi_{2} \\\\\\phi_{3} \u0026 0 \u0026 -\\phi_{1} \\\\-\\phi_{2} \u0026 \\phi_{1} \u0026 0\\end{array}\\right] \\in \\mathbb{R}^{3 \\times 3}$$ $$\\left[\\phi_{1}, \\phi_{2}\\right]=\\left(\\Phi_{1} \\Phi_{2}-\\Phi_{2} \\Phi_{1}\\right)^{\\vee}$$ 它们是一个由三维向量组成的集合，每个向量对应一个反对称矩阵，可以用于表达旋转矩阵的导数 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:4","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数se(3) $$\\mathfrak{s e}(3)=\\left\\{\\boldsymbol{\\xi}=\\left[\\begin{array}{c}\\rho \\\\\\phi\\end{array}\\right] \\in \\mathbb{R}^{6}, \\boldsymbol{\\rho} \\in \\mathbb{R}^{3}, \\boldsymbol{\\phi} \\in \\mathfrak{s} \\mathfrak{o}(3), \\boldsymbol{\\xi}^{\\wedge}=\\left[\\begin{array}{cc}\\phi^{\\wedge} \u0026 \\rho \\\\0^{T} \u0026 0\\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4}\\right\\}$$ 前三维为平移，后三维为旋转，就是so(3)中的元素，此处 ^ 不再表示反对称 可以简单地理解成se(3)就是由一个平移加上一个so(3)元素构成的向量，虽然此处并不是直接平移 $$\\boldsymbol{\\xi}^{\\wedge}=\\left[\\begin{array}{cc}\\phi^{\\wedge} \u0026 \\rho \\\\0^{T} \u0026 0\\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4}$$ $$\\left[\\xi_{1}, \\xi_{2}\\right]=\\left(\\xi_{1}^{\\wedge} \\xi_{2}^{\\wedge}-\\xi_{2}^{\\wedge} \\xi_{1}^{\\wedge}\\right)^{\\vee}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:2:5","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"指数映射和对数映射 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:0","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"SO(3)上的指数映射 指数映射 $$R=\\exp \\left(\\phi^{\\wedge}\\right)$$ 有泰勒展式得 $$\\exp \\left(\\phi^{\\wedge}\\right)=\\sum_{n=0}^{\\infty} \\frac{1}{n !}\\left(\\phi^{\\wedge}\\right)^{n}$$ 由于幂次太多不好计算，考虑将 $\\phi$ 分解成 $\\theta a$ ，因为 $\\phi$ 是三维向量，可以分解成方向和模长，此处 $||a|| =1$，这样又如下两条性质 $$\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}=\\boldsymbol{a} \\boldsymbol{a}^{T}-\\boldsymbol{I}$$ $$\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}=-\\boldsymbol{a}^{\\wedge}$$ 这样就可以对泰勒展式进行化简 $$ \\begin{aligned}\\exp \\left(\\phi^{\\wedge}\\right) \u0026=\\exp \\left(\\theta \\boldsymbol{a}^{\\wedge}\\right)=\\sum_{n=0}^{\\infty} \\frac{1}{n !}\\left(\\theta \\boldsymbol{a}^{\\wedge}\\right)^{n} \\\\\u0026=\\boldsymbol{I}+\\theta \\boldsymbol{a}^{\\wedge}+\\frac{1}{2 !} \\theta^{2} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\frac{1}{3 !} \\theta^{3} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\frac{1}{4 !} \\theta^{4}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{4}+\\ldots \\\\\u0026=\\boldsymbol{a} \\boldsymbol{a}^{T}-\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\theta \\boldsymbol{a}^{\\wedge}+\\frac{1}{2 !} \\theta^{2} \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}-\\frac{1}{3 !} \\theta^{3} \\boldsymbol{a}^{\\wedge}-\\frac{1}{4 !} \\theta^{4}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{2}+\\ldots \\\\\u0026=\\boldsymbol{a} \\boldsymbol{a}^{T}+\\left(\\theta-\\frac{1}{3 !} \\theta^{3}+\\frac{1}{5 !} \\theta^{5}-\\ldots\\right) \\boldsymbol{a}^{\\wedge}-\\left(1-\\frac{1}{2 !} \\theta^{2}+\\frac{1}{4 !} \\theta^{4}-\\ldots\\right) \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\\\\u0026=\\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\boldsymbol{I}+\\sin \\theta \\boldsymbol{a}^{\\wedge}-\\cos \\theta \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge} \\\\\u0026=(1-\\cos \\theta) \\boldsymbol{a}^{\\wedge} \\boldsymbol{a}^{\\wedge}+\\boldsymbol{I}+\\sin \\theta \\boldsymbol{a}^{\\wedge} \\\\\u0026=\\cos \\theta \\boldsymbol{I}+(1-\\cos \\theta) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\sin \\theta \\boldsymbol{a}^{\\wedge}\\end{aligned} $$ 最终结果 $$\\exp \\left(\\theta \\boldsymbol{a}^{\\wedge}\\right)=\\cos \\theta \\boldsymbol{I}+(1-\\cos \\theta) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\sin \\theta \\boldsymbol{a}^{\\wedge}$$ 这与罗德里格斯公式一致，说明so(3)实际上就是由所谓的旋转向量组成的空间。这样so(3)中任意一个向量对应到了SO(3)中的旋转矩阵 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:1","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"so(3)上的对数映射 反过来可以定义对数映射，表示SO(3)到so(3) $$\\phi=\\ln (R)^{\\vee}=\\left(\\sum_{n=0}^{\\infty} \\frac{(-1)^{n}}{n+1}(R-I)^{n+1}\\right)^{\\vee}$$ 但实际不应该这样求，更简单的方法是 $$\\theta=\\arccos \\left(\\frac{\\operatorname{tr}(\\boldsymbol{R})-1}{2}\\right)$$ $$\\boldsymbol{R} \\boldsymbol{n}=\\boldsymbol{n}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:2","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"总结 指数映射是满射，不是单射，这意味着可能存在多个so(3)对应同一个SO(3)。但是，把旋转角固定在[-π,+π]之间，就是一一对应的 旋转矩阵的导数可以由旋转向量指定。总结一下就是 $R$ 对时间求导后的 $\\dot{\\boldsymbol{R}}(t) \\boldsymbol{R}(t)^{T}$ 是个反对称矩阵，那就有个 $\\phi$ 它是个三维向量，变成旋转向量，指数映射刚好可以从罗德里格斯公式求出 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:3","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"SE(3)上的指数映射 求解过程与so(3)相似 $$\\begin{aligned}\\exp \\left(\\boldsymbol{\\xi}^{\\wedge}\\right) \u0026=\\left[\\begin{array}{ccc}\\sum_{n=0}^{\\infty} \\frac{1}{n !}\\left(\\phi^{\\wedge}\\right)^{n} \u0026 \\sum_{n=0}^{\\infty} \\frac{1}{(n+1) !}\\left(\\phi^{\\wedge}\\right)^{n} \\rho \\\\\u0026 0^{T} \u0026 1\\end{array}\\right] \\\\\u0026 \\triangleq\\left[\\begin{array}{cc}R \u0026 J \\rho \\\\0^{T} \u0026 1\\end{array}\\right]=T\\end{aligned}$$ $$\\begin{aligned}\\sum_{n=0}^{\\infty} \\frac{1}{(n+1) !}\\left(\\phi^{\\wedge}\\right)^{n} \u0026=I+\\frac{1}{2 !} \\theta \\boldsymbol{a}^{\\wedge}+\\frac{1}{3 !} \\theta^{2}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{2}+\\frac{1}{4 !} \\theta^{3}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{3}+\\frac{1}{5 !} \\theta^{4}\\left(\\boldsymbol{a}^{\\wedge}\\right)^{4} \\ldots \\\\\u0026=\\frac{1}{\\theta}\\left(\\frac{1}{2 !} \\theta^{2}-\\frac{1}{4 !} \\theta^{4}+\\cdots\\right)\\left(\\boldsymbol{a}^{\\wedge}\\right)+\\frac{1}{\\theta}\\left(\\frac{1}{3 !} \\theta^{3}-\\frac{1}{5} \\theta^{5}+\\cdots\\right)\\left(\\boldsymbol{a}^{\\wedge}\\right)^{2}+\\boldsymbol{I} \\\\\u0026=\\frac{1}{\\theta}(1-\\cos \\theta)\\left(\\boldsymbol{a}^{\\wedge}\\right)+\\frac{\\theta-\\sin \\theta}{\\theta}\\left(\\boldsymbol{a} \\boldsymbol{a}^{\\mathrm{T}}-\\boldsymbol{I}\\right)+\\boldsymbol{I} \\\\\u0026=\\frac{\\sin \\theta}{\\theta} \\boldsymbol{I}+\\left(1-\\frac{\\sin \\theta}{\\theta}\\right) \\boldsymbol{a} \\boldsymbol{a}^{\\mathrm{T}}+\\frac{1-\\cos \\theta}{\\theta} \\boldsymbol{a}^{\\wedge} \\stackrel{\\text { def }}{=} \\boldsymbol{J}\\end{aligned}$$ $$\\boldsymbol{J}=\\frac{\\sin \\theta}{\\theta} \\boldsymbol{I}+\\left(1-\\frac{\\sin \\theta}{\\theta}\\right) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\frac{1-\\cos \\theta}{\\theta} \\boldsymbol{a}^{\\wedge}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:4","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"se(3)上的对数映射 由以下两条可以求出 $\\phi$ $$\\theta=\\arccos \\left(\\frac{\\operatorname{tr}(\\boldsymbol{R})-1}{2}\\right)$$ $$\\boldsymbol{R} \\boldsymbol{n}=\\boldsymbol{n}$$ 由 $\\phi$ 可以求出 $J$，$\\rho$ 可以通过解线性方程求得 $$t=J \\rho$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:5","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"总结 转换关系 (image)\r","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:3:6","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"李代数求导与扰动模型 ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:0","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"BCH公式与近似形式 由于李群上无加法，所以很难对李群求导，有两个思路。利用李代数上加法定义李群元素的导数？利用指数映射和对数映射完成转换 要解决的基本问题：李代数上的加法是否等价于李群上的乘法？即下式是否成立？ $$\\exp \\left(\\phi_{1}^{\\wedge}\\right) \\exp \\left(\\phi_{2}^{\\wedge}\\right)=\\exp \\left(\\left(\\phi_{1}+\\phi_{2}\\right)^{\\wedge}\\right) ?$$ $$\\ln{(\\exp{(A)} \\exp{(B)})} = A + B ?$$ 答案是不成立，计算公式是BCH公式 $$\\ln (\\exp (\\boldsymbol{A}) \\exp (\\boldsymbol{B}))=\\boldsymbol{A}+\\boldsymbol{B}+\\frac{1}{2}[\\boldsymbol{A}, \\boldsymbol{B}]+\\frac{1}{12}[\\boldsymbol{A},[\\boldsymbol{A}, \\boldsymbol{B}]]-\\frac{1}{12}[\\boldsymbol{B},[\\boldsymbol{A}, \\boldsymbol{B}]]+\\cdots$$ 当其中一个为小量时，bch拥有线性近似表示（分为左乘模型和右乘模型） $$\\ln \\left(\\exp \\left(\\phi_{1}^{\\wedge}\\right) \\exp \\left(\\phi_{2}^{\\wedge}\\right)\\right)^{\\vee} \\approx\\left\\{\\begin{array}{ll}J_{l}\\left(\\phi_{2}\\right)^{-1} \\phi_{1}+\\phi_{2} \u0026 \\text { if } \\phi_{1} \\text { is small } \\\\J_{r}\\left(\\phi_{1}\\right)^{-1} \\phi_{2}+\\phi_{1} \u0026 \\text { if } \\phi_{2} \\text { is small }\\end{array}\\right.$$ $$\\boldsymbol{J}_{l}=\\boldsymbol{J}=\\frac{\\sin \\theta}{\\theta} \\boldsymbol{I}+\\left(1-\\frac{\\sin \\theta}{\\theta}\\right) \\boldsymbol{a} \\boldsymbol{a}^{T}+\\frac{1-\\cos \\theta}{\\theta} \\boldsymbol{a}^{\\wedge}$$ $$\\boldsymbol{J}_{l}^{-1}=\\frac{\\theta}{2} \\cot \\frac{\\theta}{2} \\boldsymbol{I}+\\left(1-\\frac{\\theta}{2} \\cot \\frac{\\theta}{2}\\right) \\boldsymbol{a} \\boldsymbol{a}^{T}-\\frac{\\theta}{2} \\boldsymbol{a}^{\\wedge}$$ $$J_{r}(\\phi)=J_{l}(-\\phi)$$ 这样就解决了李群乘法和李代数加法的问题 SO(3)上的BCH近似 $$\\exp \\left(\\Delta \\phi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right)=\\exp \\left(\\left(\\phi+J_{l}^{-1}(\\phi) \\Delta \\phi\\right)^{\\wedge}\\right)$$ $$\\exp \\left((\\phi+\\Delta \\phi)^{\\wedge}\\right)=\\exp \\left(\\left(J_{l} \\Delta \\phi\\right)^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right)=\\exp \\left(\\phi^{\\wedge}\\right) \\exp \\left(\\left(J_{r} \\Delta \\phi\\right)^{\\wedge}\\right)$$ SE(3)上的BCH近似 $$\\begin{array}{l}\\exp \\left(\\Delta \\xi^{\\wedge}\\right) \\exp \\left(\\xi^{\\wedge}\\right) \\approx \\exp \\left(\\left(\\mathcal{J}_{l}^{-1} \\Delta \\xi+\\xi\\right)^{\\wedge}\\right) \\\\\\exp \\left(\\xi^{\\wedge}\\right) \\exp \\left(\\Delta \\xi^{\\wedge}\\right) \\approx \\exp \\left(\\left(\\mathcal{J}_{r}^{-1} \\Delta \\xi+\\xi\\right)^{\\wedge}\\right)\\end{array}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:1","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"问题引出 假设机器人的位姿为 $T$ ，它观测到一个世界坐标系位于 $p$ 的点，产生一个观测数据 $z$ ，假设噪声是 $w$ $$z = Tp + w$$ 误差 $$e = z - Tp$$ 假设一共有 $N$ 个这样的路标点和观测，就有 $N$ 个式子。那么对机器人进行位姿估计相当于寻找一个最优的 $T$ ，使得误差最小化 $$\\min _{\\boldsymbol{T}} J(\\boldsymbol{T})=\\sum_{i=1}^{N}\\left\\|\\boldsymbol{z}_{i}-\\boldsymbol{T} \\boldsymbol{p}_{i}\\right\\|_{2}^{2}$$ 求解类似问题都要用到导数，由于$SO(3)$ $SE(3)$上没有很好地定义加法，所以求导很麻烦 它们的李代数上定义了良好的加法，所以用李代数求导 这样就有两种思路： 对 $R$ 对应的李代数加上小量，求相对于小量的变化率（导数模型） 对 $R$ 左乘或右乘一个小量，求相对于小量的李代数的变化率（扰动模型） ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:2","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"求导模型 考虑 $SO(3)$ 上的情况，假设对一个空间点 $p$ 进行旋转，得到 $Rp$ 现在要计算旋转之后的点的坐标相对于旋转的导数，非正式地记为 $$\\frac{\\partial(\\boldsymbol{R} \\boldsymbol{p})}{\\partial \\boldsymbol{R}}$$ 由于它在李群上不好计算，所以转成李代数 设 $R$ 对应的李代数为 $\\phi$ $$ \\begin{aligned}\\frac{\\partial\\left(\\exp \\left(\\phi^{\\wedge}\\right) p\\right)}{\\partial \\phi} \u0026=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\exp \\left((\\phi+\\delta \\phi)^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\delta \\phi} \\\\\u0026=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\exp \\left(\\left(J_{l} \\delta \\phi\\right)^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\delta \\phi} \\\\\u0026 \\approx \\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\left(I+\\left(J_{l} \\delta \\phi\\right)^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\delta \\phi} \\\\\u0026=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{\\left(J_{l} \\delta \\phi\\right)^{\\wedge} \\exp \\left(\\phi^{\\wedge}\\right) p}{\\delta \\phi} \\\\\u0026=\\lim _{\\delta \\phi \\rightarrow 0} \\frac{-\\left(\\exp \\left(\\phi^{\\wedge}\\right) p\\right)^{\\wedge} J_{l} \\delta \\phi}{\\delta \\phi}=-(R p)^{\\wedge} J_{l}\\end{aligned} $$ 这样就推导出旋转后的点相对于李代数的导数 $$\\frac{\\partial(\\boldsymbol{R} \\boldsymbol{p})}{\\partial \\boldsymbol{\\phi}} = -(\\boldsymbol{R} p)^{\\wedge} \\boldsymbol{J}_{l}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:3","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"扰动模型(左乘） 对 $R$ 左乘一个扰动 $\\Delta R$ ，设左扰动对应的李代数为 $\\varphi$，对 $\\varphi$ 求导 $$\\begin{aligned}\\frac{\\partial(R p)}{\\partial \\varphi} \u0026=\\lim _{\\varphi \\rightarrow 0} \\frac{\\exp \\left(\\varphi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\varphi} \\\\\u0026 \\approx \\lim _{\\varphi \\rightarrow 0} \\frac{\\left(1+\\varphi^{\\wedge}\\right) \\exp \\left(\\phi^{\\wedge}\\right) p-\\exp \\left(\\phi^{\\wedge}\\right) p}{\\varphi} \\\\\u0026=\\lim _{\\varphi \\rightarrow 0} \\frac{\\varphi^{\\wedge} R p}{\\varphi}=\\lim _{\\varphi \\rightarrow 0} \\frac{-(R p)^{\\wedge} \\varphi}{\\varphi}=-(R p)^{\\wedge}\\end{aligned}$$ SE(3)上的扰动模型 $$\\frac{\\partial(T p)}{\\partial \\delta \\xi}=\\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\exp \\left(\\delta \\xi^{\\wedge}\\right) \\exp \\left(\\xi^{\\wedge}\\right) p-\\exp \\left(\\xi^{\\wedge}\\right) p}{\\delta \\xi} \\\\ \\approx \\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\left(I+\\delta \\xi^{\\wedge}\\right) \\exp \\left(\\xi^{\\wedge}\\right) p-\\exp \\left(\\xi^{\\wedge}\\right) p}{\\delta \\xi} \\\\ =\\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\delta \\boldsymbol{\\xi}^{\\wedge} \\exp \\left(\\boldsymbol{\\xi}^{\\wedge}\\right) \\boldsymbol{p}}{\\delta \\boldsymbol{\\xi}} \\\\ =\\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\left[\\begin{array}{cc}\\delta \\phi^{\\wedge} \u0026 \\delta \\rho \\\\0^{T} \u0026 0\\end{array}\\right]\\left[\\begin{array}{c}R p+t \\\\1\\end{array}\\right]}{\\delta \\xi} \\\\=\\lim _{\\delta \\xi \\rightarrow 0} \\frac{\\left[\\begin{array}{c}\\delta \\phi^{\\wedge}(\\boldsymbol{R} p+\\boldsymbol{t})+\\delta \\boldsymbol{\\rho} \\\\0\\end{array}\\right]}{\\delta \\boldsymbol{\\xi}}=\\left[\\begin{array}{cc}\\boldsymbol{I} \u0026 -(\\boldsymbol{R} \\boldsymbol{p}+\\boldsymbol{t})^{\\wedge} \\\\\\mathbf{0}^{T} \u0026 \\mathbf{0}^{T}\\end{array}\\right] \\triangleq(\\boldsymbol{T} \\boldsymbol{p})^{\\odot}$$ ","date":"2020-11-07","objectID":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/:4:4","tags":["slam"],"title":"李群与李代数","uri":"/%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/"},{"categories":["note","slam"],"content":"三维空间的刚体运动","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"内积与外积 内积 外积 定义 ^ 符号 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:1:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"欧氏变换 euclidean transform ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"单次欧氏变换 同一个向量在两个坐标系中的表示，坐标系的变换包括一次旋转和一次平移 旋转 R为旋转矩阵（rotation matrix），它是一个行列式为1的正交矩阵（又叫特殊正交矩阵）（正交矩阵即逆为自身转置的矩阵）。反之，行列式为1的正交矩阵也是一个旋转矩阵，所以可以将n维旋转矩阵的集合定义为 SO(n) 是特殊正交群 （special orthogonal group） $$ a{}’=R^{-1}a=R^Ta $$ R的逆矩阵或转置矩阵刻画了相反的旋转 平移 $$ a{}’=Ra+t $$ $$ a_1=R_{12}a_2+t_{12} $$ t12表示2到1的变换 注意 t12 != -t21 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:1","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"多次欧氏变换 由于这种形式在多次变换之后会显得很冗长，所以采取以下措施 其中T是变换矩阵（transform matrix），a转变成齐次坐标 这样多次转换就变成 （约定之后的Ta，a就是齐次坐标化的，而Ra，a就是原来的） 对于变换矩阵T，满足该形式的矩阵可以构成特殊欧氏群（special euclidean group） T的逆表示相反的变换 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:2:2","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"旋转向量 由于旋转矩阵用16个量来表达6个自由度的变换显得很多余，为了减少变量，引入旋转向量 实际上，任意的旋转都可以有旋转轴和旋转角度来刻画 假设旋转轴为一个单位长度的向量n，旋转角度为θ 根据罗德里格斯公式（rodrigues’s formula） 对等式两边求迹（trace）得到角度的表示 由于旋转轴上的向量在旋转后不发生变化，所以 n是R在特征值为1时的特征向量 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:3:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"欧拉角 由于旋转向量和旋转矩阵不够直观，所以引入欧拉角 欧拉角把旋转分解成绕三个轴各自的旋转，由于分解方式很多，这里介绍最著名的rpy角 yaw-pitch-roll 绕物体的z轴旋转，得到yaw 绕旋转之后的y轴旋转，得到pitch 绕旋转之后的x轴旋转，得到roll 欧拉角的重大缺点就是万向锁问题（gimbal lock），当某个轴旋转90度时，第一次旋转和第三次旋转将使用同一个轴，这样就散失了一个自由度（这被称为奇异性问题），理论上可以证明，只要想用3个实数来表达三维旋转，都会出现奇异性问题，所以很少在slam中使用欧拉角，只用来验证自己的算法 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:4:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数 四元数可视化的网站 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:0","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"复数 欧拉公式 把复平面的向量旋转x度，相当于乘上e^(ix) ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:1","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数的定义 它有1个实部，3个虚部，虚部分别对应空间坐标系的三个坐标轴 自己和自己的运算像复数，自己和别人的运算像叉乘 乘以i相当于绕轴旋转180度，i^2=-1意味着绕i轴旋转360度后得到一个相反的东西（这是个定义） 补充 ijk = -1 四元数也可以这样表示 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:2","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数的运算 加减法 乘法 向量形式 模长 共轭 四元数共轭与其本身相乘会得到一个实四元数，其实部为模长的平方 $$ q^*q=qq*=[s_a ^ 2 + v^Tv, 0]^T $$ 逆 如果q为单位四元数，其逆和共轭就是同一个量 $$ qq^{-1}=q^{-1}q=1 $$ 乘法的逆类似于矩阵 $$ (q_aq_b)^{-1} = q_b^{-1}q_a^{-1} $$ 数乘 点乘 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:3","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数表示旋转 假设点p = [x, y, z] 是最初的点，旋转后变成 p' 先将p变成虚四元数 $$ p = [0, x, y, z]^T = [0, v]^T $$ p’可以这样求得 $$ p{}’=qpq^{-1} $$ 这里的乘法均为四元数乘法，结果也是四元数。最后把p’的虚部取出，就是旋转后的坐标。可以验证，计算后的实部为0 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:4","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"四元数到其他旋转表示的变换 假设 $$ q=[s,v]^T $$ $$ q=[q_0, q_1,q_2, q_3]^T $$ 从四元数得到旋转矩阵 $$ R=vv^T + s^2I+2sv^{\\wedge}+(v^{\\wedge})^2 $$ 从四元数得到旋转向量 从旋转向量到四元数 ","date":"2020-10-23","objectID":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/:5:5","tags":["slam"],"title":"三维空间的刚体运动","uri":"/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"},{"categories":["note","slam"],"content":"今天你也要来点cmake吗","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"前言 很早就想写cmake，但是一直懒得写 今天也随便写点cmake 官方对cmake的解释 CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK. 按我的理解，cmake就是工程构建工具（多用于c++） ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:1:0","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"实践 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:0","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"预备 以一道题目来介绍cmake最基本的用法，这个例子不会用到任何ide，实际上用ide应该更好 实验环境 ubuntu 16.04 LTS cmake的安装见此处 题目如下，由于题意不清，仅供参考，实际的构建和题目有点差别 这个实验分成两部分，编写共享库并安装，使用库和头文件 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:1","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"编写共享库并安装 编写静态库的操作和它差不多 首先建立tt文件夹，作为工程的总文件夹 在tt文件夹下建立build文件夹作为存放外部编译的中间文件，lib文件夹存放生成的库，CMakeLists.txt（按我的理解，这个文件就像cpu里的控制器，MakeFile文件夹之于CMakeLists.txt就像低级语言之于高级语言），src 文件夹放置该工程的源代码 文章最后有文件结构，看得更直观 tt/CMakeLists.txt tt文件夹下的CMakeLists.txt cmake_minimum_required(VERSION 3.5) project(sayHello) add_subdirectory(lib) add_subdirectory(src) 解释一下，cmake_minimum_required 声明版本，不加构建的时候会报不是很严重的错 project 声明该工程的名字 add_subdirectory 关联子目录 如果是add_subdirectory(aaa bbb) 就是当外部编译时本该在build/aaa下生成的目标二进制文件，现在生成到了build/bbb下 tt/lib lib文件夹放三个文件，与库有关 hello.c #include \"hello.h\" #include \u003cstdio.h\u003e void sayHello(){printf(\"hello slam\\n\");} hello.h #pragma once void sayHello(); CMakeLists.txt （为了追踪，这几乎每个文件夹都有） add_library(hello SHARED hello.c) set(CMAKE_INSTALL_PREFIX /usr/local) install(TARGETS hello LIBRARY DESTINATION lib) install(FILES hello.h DESTINATION include) 解释一下 add_library(hello SHARED hello.c) 第一个参数指库的名字，如果是hello，库的名字会自动变成libhello 第二个参数指代库的类型（共享库（动态库），静态库） ，分别对应 SHARED STATIC ，如果是动态库则生成 libhello.so 如果是静态库，则生成 libhello.a ，第三个参数是库的源代码 set(CMAKE_INSTALL_PREFIX /usr/local) CMAKE_INSTALL_PREFIX这是一个cmake变量，安装时路径是\u003cprefix\u003e/\u003ccustom\u003e install(TARGETS hello LIBRARY DESTINATION lib) 安装路径，第一个参数是静态库、动态库、目标二进制专用，hello指代库的名称（add_library时已指定），最后一个参数就是自定义相对路径，所以它会被装在/usr/local/lib 下 install(FILES hello.h DESTINATION include) 第一个参数表明待安装的是文件，它将被装在 /usr/local/include 下 构建 在build文件夹下 sudo cmake .. sudo make sudo make install 解释一下，这是cmake的最常用、最基本的命令， ..表示用上一级的CMakeLists.txt install是安装命令，构建之后，会在build文件夹下生成与tt文件夹下类似的文件（注意这句话） (忽略tt前面的前缀） 可以看到库和头文件已经按照题目要求成功安装（安装的目的在于可以使用） ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:2","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"使用库 tt/src 在src文件夹编写要使用库的源代码 useHello.c （注意hello.h要用双引号，不能用尖括号） #include \"hello.h\" int main(int argc, char** argv){sayHello();} CMakeLists.txt add_executable(sayHello useHello.c) include_directories(/usr/local/include) link_directories(/usr/local/lib) target_link_libraries(sayHello hello) 解释一下，add_executable(sayHello useHello.c) 第一个参数是程序名（自定义），第二个参数是程序源文件，这条指令的作用就是它的名字所描述的 include_directories(/usr/local/include) 注意，这条语句并不是包含了哪些目录的库（这么理解似乎也没什么问题），而是在包含库之后，它应该在哪个路径下搜索，由于hello.h是相对路径，如果装在/usr/include就没事了，因为它是默认的搜索路径，但是现在装在了 /usr/local/include 所以就要增加搜索路径（导向作用） link_directories(/usr/local/lib) 这条语句和上一条是相似的，我一直觉得它写成 library_directories 应该更好理解（其实没有这条指令，又想到include是动词，link也是动词就没事了），所以这条命令就是增加库的搜索路径（是的，不仅要搜索头文件，还要搜索库，因为头文件里什么也没有，只有一堆函数的空壳，实际的内容在源文件里(hello.c)，它和头文件一起生成了 libhello.so)，这也就是为什么有下一条指令的原因 target_link_libraries(sayHello hello) 用来连接目标二进制和库，至于为什么是 sayHello ，第一条指令已经给出 在build文件夹下构建，看到build文件夹下也有个 src文件夹，正如之前 build文件夹下有了lib一样 运行tt/build/src/sayHello 可以看到终端输出 hello world ，表明使用库成功 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:2:3","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["note","slam"],"content":"文件结构 tt --------------------------- | | build ------------------- | 。。。 | 。。。 lib ---------------------- | hello.c | hello.h | CMakeLists.txt src ----------------------- | useHello.c | CMakeLists.txt CMakeLists.txt ------------ cmake好难，还有很多想写。。。下次一定 ","date":"2020-10-06","objectID":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/:3:0","tags":["cpp","slam"],"title":"今天你也要来点cmake吗","uri":"/%E4%BB%8A%E5%A4%A9%E4%BD%A0%E4%B9%9F%E8%A6%81%E6%9D%A5%E7%82%B9cmake%E5%90%97/"},{"categories":["codeforces"],"content":"Codeforces Round #672 (Div. 2) A~D","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Cubes Sorting ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:1:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数列，每次操作交换相邻的两个数，问是否需要达到n(n-1)/2次操作才可以让数列递增 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:1:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 判断数列是否严格单调递减 #include \"bits/stdc++.h\" using namespace std; using ll = long long; int main() { int _; cin \u003e\u003e _; while (_--) { vector\u003cint\u003e vt; int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; ++i){ int u; cin \u003e\u003e u; vt.push_back(u); } bool ok = false; for(int i = 0; i \u003c n - 1; i ++){ if(vt[i] \u003e vt[i + 1]) continue; else { ok = true; break; } } if(ok) puts(\"YES\"); else puts(\"NO\"); } return 0; } ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:1:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"B. Rock and Lever ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:2:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数列，判断有多少对数满足 x \u0026 y \u003e= x ^ y ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:2:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 根据位运算的定义，两个数的最高位（1）互相对齐就行，即二进制位数相等 #include \"bits/stdc++.h\" using namespace std; using ll = long long; int main() { ll _; cin \u003e\u003e _; while (_--) { ll n; cin \u003e\u003e n; map\u003cll, ll\u003e mp; for(ll i = 0; i \u003c n; ++i){ ll u; cin \u003e\u003e u; ll v = u; ll tmp = 0; while(v != 0){ v \u003e\u003e= 1; tmp++; } mp[tmp]++; } ll ans = 0; for(auto i : mp){ ans += i.second * (i.second - 1) / 2; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:2:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"C1. Pokémon Army (easy version) ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:3:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数列，选择一些数，按顺序执行加减交替操作，求可得到的最大值（第一个是加） ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:3:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 dp #include \"bits/stdc++.h\" using namespace std; using ll = long long; ll dp[300005][2]; ll a[300005]; int main() { ll _; cin \u003e\u003e _; while (_--) { memset(dp, 0, sizeof(dp)); ll n, q; cin \u003e\u003e n \u003e\u003e q; for(ll i = 1; i \u003c= n; ++i){ cin \u003e\u003e a[i]; } dp[1][0] = a[1]; dp[1][1] = 0; for(ll i = 2; i \u003c= n; ++i){ dp[i][0] = max(dp[i-1][0], dp[i-1][1] + a[i]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] - a[i]); } cout \u003c\u003c max(dp[n][0], dp[n][1]) \u003c\u003c endl; } return 0; } ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:3:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"C2. Pokémon Army (hard version) ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:4:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 在C1的基础上，增加q次操作，每次操作交换两个位置的数值，每次操作询问可得到的最大值 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:4:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 对于数列中的数值大小，波峰一定是加操作，波谷一定是减操作，对于每次的交换操作， 先消去这两个数（和它左右两个数）的影响，因为左右两个数决定了它是波峰还是波谷还是其他，交换后的数可能会影响原来左右的两个数 再加上交换数值后的影响（即该点和左右是否是波峰、波谷） #include \"bits/stdc++.h\" using namespace std; using ll = long long; const int maxn = 300005; ll a[maxn]; int pos[maxn]; int n, q; ll ans; void init(){ a[0] = a[n + 1] = 0; pos[0] = pos[n + 1] = -1; for(int i = 1; i \u003c= n; ++i){ if(a[i] \u003e a[i - 1] and a[i] \u003e a[i + 1]) { pos[i] = 1; ans += a[i]; }else if(a[i] \u003c a[i - 1] and a[i] \u003c a[i + 1]){ pos[i] = -1; ans -= a[i]; }else{ pos[i] = 0; } } } void did(int x){ if(x \u003c= 0 or x \u003e n) return; if(pos[x] == 1){ pos[x] = 0; ans -= a[x]; }else if(pos[x] == -1){ pos[x] = 0; ans += a[x]; } } void update(int x){ if(x \u003c= 0 or x \u003e n) return ; if(pos[x] == 0 and a[x] \u003e a[x + 1] and a[x] \u003e a[x - 1]) { pos[x] = 1; ans += a[x]; }else if(pos[x] == 0 and a[x] \u003c a[x + 1] and a[x] \u003c a[x - 1]){ pos[x] = -1; ans -= a[x]; } } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int _; cin \u003e\u003e _; while (_--) { ans = 0; cin \u003e\u003e n \u003e\u003e q; for(int i = 1; i \u003c= n; ++i) cin \u003e\u003e a[i]; init(); cout \u003c\u003c ans \u003c\u003c endl; while(q--){ int l, r; cin \u003e\u003e l \u003e\u003e r; did(l); did(l - 1); did(l + 1); did(r); did(r - 1); did(r + 1); swap(a[l], a[r]); update(l); update(l - 1); update(l + 1); update(r); update(r - 1); update(r + 1); cout \u003c\u003c ans \u003c\u003c endl; } } return 0; } ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:4:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"D. Rescue Nibel! ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:5:0","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 有n盏灯，每盏灯有打开的时间和关闭的时间l，r，选择其中k盏，满足存在某一时刻这k盏灯同时亮，求选择方案数 ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:5:1","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 离散化，枚举每个时间点，查看有多少盏灯之前就亮着，多少盏灯加入到亮的行列，排列组合 #include \"bits/stdc++.h\" using namespace std; using ll = long long; const ll mod = 998244353; ll n, k; ll ans; set\u003cll\u003e L; unordered_map\u003cll, vector\u003cll\u003e \u003e R; priority_queue\u003cll, vector\u003cll\u003e, greater\u003c\u003e \u003e pq; const ll maxn = 300005; ll inv[maxn]; ll fac[maxn]; ll cnt; ll tmp; inline ll C(ll m,ll n){ return fac[n]*inv[m]%mod*inv[n-m]%mod; } inline ll A(ll m,ll n){ return fac[n]*inv[n-m]%mod; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); for(ll i=0;i\u003cmaxn;i++){ fac[i]=1; } for(ll i=2;i\u003cmaxn;i++){ fac[i]=(fac[i-1]*i)%mod; } inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003cmaxn;i++){ inv[i]=(mod-mod/i)*inv[mod%i]%mod; } for(ll i=2;i\u003cmaxn;i++){ inv[i]=(inv[i]*inv[i-1])%mod; } cin \u003e\u003e n \u003e\u003e k; for(int i = 0; i \u003c n; ++i){ ll l, r; cin \u003e\u003e l \u003e\u003e r; R[l].push_back(r); L.insert(l); } for(auto i : L){ tmp = 0; cnt = pq.size(); while(!pq.empty()){ if(pq.top() \u003c i){ pq.pop(); cnt--; }else break; } for(auto j : R[i]){ pq.push(j); tmp++; } if(tmp + cnt \u003c k) continue; for(ll e = 1; e \u003c= min(k, tmp); ++e){ if(tmp \u003e= e and cnt \u003e= k - e) ans += C(e, tmp) * C(k - e, cnt) % mod; } } cout \u003c\u003c ans % mod \u003c\u003c endl; return 0; } ","date":"2020-09-25","objectID":"/codeforces-round-672-div.-2-a~d/:5:2","tags":["cpp","greedy","data_structure","dp","bit","counting"],"title":"Codeforces Round #672 (Div. 2) A~D","uri":"/codeforces-round-672-div.-2-a~d/"},{"categories":["algorithm"],"content":"FFT \u0026 NTT","date":"2020-09-24","objectID":"/fft-ntt/","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"前言 一篇没什么用的文章，记录一下FFT和NTT的板子 fft和ntt的原理参考FFT \u0026 NTT ","date":"2020-09-24","objectID":"/fft-ntt/:1:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"概述 fft和ntt差不多，基础用法就是加速多项式乘法，把多项式从系数表示转成点值表示来方便计算，而要转成点值表示，不能选择任意点。有些点的若干次方是1（实际上可以是-1,+i,-i等等），这样不需要做所有的次方运算，而这些点在复平面单位圆上。在ntt中是拿原根替换fft的单位根。 它们的时间复杂度都是O(nlgn) ","date":"2020-09-24","objectID":"/fft-ntt/:2:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"优缺点 ntt能取模，没有浮点精度误差，但是系数必须是整数，模数通常是998244353，原根是3 fft和ntt还有很多扩充的技巧和应用 以多项式乘法为例 ","date":"2020-09-24","objectID":"/fft-ntt/:3:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"模板 ","date":"2020-09-24","objectID":"/fft-ntt/:4:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"fft typedef complex\u003cdouble\u003e cp ; const double pi = acos(-1); int m, n; const int maxn = 4 * 1e6 + 2; //记得开大点 因为2的幂次，最好乘4 cp a[maxn], b[maxn]; // a表示第一个多项式的系数（按幂次递增） int rev[maxn]; int bt; // 扩展成2的次幂后的二进制位数 int mn; //相乘后的最高次幂即mn = m + n，m和n分别是最高次幂 int fmn; //扩展成2的次幂的最高次幂 void fft(cp* x, int len, int sign){ //sign表示共轭复数的符号 for(int i = 0; i \u003c len; ++i){ if(i \u003c rev[i]) swap(x[i], x[rev[i]]); } for(int i = 1; i \u003c len; i \u003c\u003c= 1){ cp tmp(cos(pi / i), sign * sin(pi / i)); for(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){ cp omega(1, 0); for(int l = 0; l \u003c i; l++, omega *= tmp){ cp p = x[j + l], q = omega * x[j + l + i]; x[j + l] = p + q, x[j + l + i] = p - q; } } } } ","date":"2020-09-24","objectID":"/fft-ntt/:4:1","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"ntt const ll mod = 998244353; //一般意义下的模数 const ll g = 3; //998244353对应的原根 ll m, n; const ll maxn = 4 * 1e6 + 2; //记得开大点 ll a[maxn], b[maxn]; ll rev[maxn]; ll bt; ll mn; ll fmn; ll qpow(ll x, ll nn){ ll res = 1; while(nn \u003e 0){ if(nn \u0026 1) res = res * x % mod; x = x * x % mod; nn \u003e\u003e= 1; } return res; } void ntt(ll x[], ll len, int type){ for(ll i = 0; i \u003c len; ++i){ if(i \u003c rev[i]) swap(x[i], x[rev[i]]); } for(ll i = 1; i \u003c len; i *= 2){ ll tmp = qpow(g, (mod - 1) / (i * 2) ); if(type == -1) tmp = qpow(tmp, mod - 2); for(ll j = 0; j \u003c len; j += i * 2){ ll omega = 1; for(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){ ll p = x[j + k], q = omega * x[j + k + i] % mod; x[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod; } } } } ","date":"2020-09-24","objectID":"/fft-ntt/:4:2","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"模板题 ","date":"2020-09-24","objectID":"/fft-ntt/:5:0","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"多项式乘法 题目 fft实现 #include \"bits/stdc++.h\" using namespace std; typedef long long ll ; typedef complex\u003cdouble\u003e cp ; const double pi = acos(-1); int m, n; const int maxn = 4 * 1e6 + 2; //记得开大点 cp a[maxn], b[maxn]; int rev[maxn], ans[maxn]; int bt; int mn; int fmn; void fft(cp* x, int len, int sign){ for(int i = 0; i \u003c len; ++i){ if(i \u003c rev[i]) swap(x[i], x[rev[i]]); } for(int i = 1; i \u003c len; i \u003c\u003c= 1){ cp tmp(cos(pi / i), sign * sin(pi / i)); for(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){ cp omega(1, 0); for(int l = 0; l \u003c i; l++, omega *= tmp){ cp p = x[j + l], q = omega * x[j + l + i]; x[j + l] = p + q, x[j + l + i] = p - q; } } } } int main() { scanf(\"%d%d\", \u0026m, \u0026n); for(int i = 0; i \u003c= m; ++i){ scanf(\"%lf\", \u0026a[i]); } for(int i = 0; i \u003c= n; ++i){ scanf(\"%lf\", \u0026b[i]); } mn = m + n; for(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++; for(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1)); fft(a, fmn, 1); fft(b, fmn, 1); for(int i = 0; i \u003c= fmn; ++i) a[i] = a[i] * b[i]; fft(a, fmn, -1); for(int i = 0; i \u003c= mn; ++i) printf(\"%d \", (int)(a[i].real()/fmn + 0.5)); return 0; } ntt实现 #include \"bits/stdc++.h\" using namespace std; typedef long long ll ; const ll mod = 998244353; const ll g = 3; ll m, n; const ll maxn = 4 * 1e6 + 2; //记得开大点 ll a[maxn], b[maxn]; ll rev[maxn], ans[maxn]; ll bt; ll mn; ll fmn; ll qpow(ll x, ll nn){ ll res = 1; while(nn \u003e 0){ if(nn \u0026 1) res = res * x % mod; x = x * x % mod; nn \u003e\u003e= 1; } return res; } void ntt(ll x[], ll len, int type){ for(ll i = 0; i \u003c len; ++i){ if(i \u003c rev[i]) swap(x[i], x[rev[i]]); } for(ll i = 1; i \u003c len; i *= 2){ ll tmp = qpow(g, (mod - 1) / (i * 2) ); if(type == -1) tmp = qpow(tmp, mod - 2); for(ll j = 0; j \u003c len; j += i * 2){ ll omega = 1; for(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){ ll p = x[j + k], q = omega * x[j + k + i] % mod; x[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod; } } } } int main() { scanf(\"%d%d\", \u0026m, \u0026n); for(int i = 0; i \u003c= m; ++i){ scanf(\"%lld\", \u0026a[i]); a[i] += mod; a[i] %= mod; } for(int i = 0; i \u003c= n; ++i){ scanf(\"%lld\", \u0026b[i]); b[i] += mod; b[i] %= mod; } mn = m + n; for(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++; for(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1)); ntt(a, fmn, 1); ntt(b, fmn, 1); for(ll i = 0; i \u003c= fmn; ++i) a[i] = (a[i] * b[i]) % mod; ntt(a, fmn, -1); ll inv_fmn = qpow(fmn, mod - 2); for(ll i = 0; i \u003c= mn; ++i){ printf(\"%lld \", a[i] * inv_fmn % mod); } return 0; } ","date":"2020-09-24","objectID":"/fft-ntt/:5:1","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["algorithm"],"content":"高精度乘法 fft实现 #include \"bits/stdc++.h\" using namespace std; typedef complex\u003cdouble\u003e cp ; const double pi = acos(-1); int m, n; const int maxn = 4 * 1e6 + 2; //记得开大点 cp a[maxn], b[maxn]; int rev[maxn]; int ans[maxn]; int bt; int mn; int fmn; void fft(cp* x, int len, int sign){ for(int i = 0; i \u003c len; ++i){ if(i \u003c rev[i]) swap(x[i], x[rev[i]]); } for(int i = 1; i \u003c len; i \u003c\u003c= 1){ cp tmp(cos(pi / i), sign * sin(pi / i)); for(int k = i \u003c\u003c 1, j = 0; j \u003c len; j += k){ cp omega(1, 0); for(int l = 0; l \u003c i; l++, omega *= tmp){ cp p = x[j + l], q = omega * x[j + l + i]; x[j + l] = p + q, x[j + l + i] = p - q; } } } } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; m = s1.size() - 1; n = s2.size() - 1; for(int i = 0; i \u003c= m; ++i){ a[i] = (double) (s1[m - i] - '0'); } for(int i = 0; i \u003c= n; ++i){ b[i] = (double) (s2[n - i] - '0'); } mn = m + n; for(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++; for(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1)); fft(a, fmn, 1); fft(b, fmn, 1); for(int i = 0; i \u003c= fmn; ++i) a[i] = a[i] * b[i]; fft(a, fmn, -1); for(int i = 0; i \u003c= mn; ++i){ ans[i] += (int) (a[i].real() / fmn + 0.5); // 注意+= 不是 = ans[i + 1] += ans[i] / 10 ; ans[i] %= 10; } if((mn == 0 and ans[0] == 0) or (mn \u003e 0 and ans[1] == 0)) { puts(\"0\"); exit(0); } for(int i = mn + 1; i \u003e= 0; --i){ //进位 if(ans[i] == 0 and i == mn + 1) continue; cout \u003c\u003c ans[i]; } return 0; } ntt实现 #include \"bits/stdc++.h\" using namespace std; typedef long long ll ; const ll mod = 998244353; const ll g = 3; ll m, n; const ll maxn = 4 * 1e6 + 2; //记得开大点 ll a[maxn], b[maxn]; ll rev[maxn]; ll ans[maxn]; ll bt; ll mn; ll fmn; ll qpow(ll x,ll nn){ ll res = 1; while(nn \u003e 0){ if(nn \u0026 1) res = res * x % mod; x = x * x % mod; nn \u003e\u003e= 1; } return res; } void ntt(ll x[], ll len, int type){ for(ll i = 0; i \u003c len; ++i){ if(i \u003c rev[i]) swap(x[i], x[rev[i]]); } for(ll i = 1; i \u003c len; i *= 2){ ll tmp = qpow(g, (mod - 1) / (i * 2)); if(type == -1) tmp = qpow(tmp, mod - 2); for(ll j = 0; j \u003c len; j += i * 2){ ll omega = 1; for(ll k = 0; k \u003c i; ++k, omega = omega * tmp % mod){ ll p = x[j + k], q = omega * x[j + k + i] % mod; x[j + k] = (p + q) % mod, x[j + k + i] = (p - q + mod) % mod; } } } } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; m = s1.size() - 1; n = s2.size() - 1; for(int i = 0; i \u003c= m; ++i){ a[i] = s1[m - i] - '0'; } for(int i = 0; i \u003c= n; ++i){ b[i] = s2[n - i] - '0'; } mn = m + n; for(fmn = 1; fmn \u003c= mn; fmn \u003c\u003c= 1) bt++; for(int i = 0; i \u003c fmn; ++i) rev[i] = (rev[i \u003e\u003e 1] \u003e\u003e 1) | ((i \u0026 1) \u003c\u003c (bt - 1)); ntt(a, fmn, 1); ntt(b, fmn, 1); for(ll i = 0; i \u003c= fmn; ++i) { a[i] = a[i] * b[i] % mod; } ntt(a, fmn, -1); ll inv_fmn = qpow(fmn, mod - 2); for(ll i = 0; i \u003c= fmn; ++i){ ans[i] += a[i] * inv_fmn % mod; ans[i + 1] = ans[i] / 10; ans[i] %= 10; } if((mn == 0 and ans[0] == 0) or (mn \u003e 0 and ans[1] == 0)) { puts(\"0\"); exit(0); } for(int i = mn + 1; i \u003e= 0; --i){ //进位 if(ans[i] == 0 and i == mn + 1) continue; cout \u003c\u003c ans[i]; } return 0; } 接下来了解下trie树，国庆做点dp题 ","date":"2020-09-24","objectID":"/fft-ntt/:5:2","tags":["cpp","number_theory"],"title":"FFT \u0026 NTT","uri":"/fft-ntt/"},{"categories":["problemlist"],"content":"无聊的做题记录","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数学公式 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 错排公式 Dn = floor(n!/e + 0.5) = (n - 1) * (Dn-1 + Dn-2) D1 = 0 , D2 = 1 //457ms/1000ms 488k/32768k #include \"bits/stdc++.h\" using namespace std; using ll = long long; const ll mod = 998244353; int main() { ll n; cin \u003e\u003e n; ll one = 0, to = 1; ll ans = 0; for(int i = 2; i \u003c n; ++i){ ans = i * (one + to); ans %= mod; one = to; to = ans; } cout \u003c\u003c ans ; return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"贪心 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 最优策略一定是捕鱼和炖鱼并行，但是捕鱼的过程不能中断，所以就有时间浪费，分两种，1.在炖鱼结束前停止捕鱼，2.炖鱼结束前，捕一条鱼，炖鱼结束，捕鱼还没结束 对每一次炖鱼选择哪一种？2优于1在于同样是浪费时间，2可以多收获一条生鱼 所以每次都选择2策略，捕鱼顺序会影响时间，为了让浪费时间尽可能少，应该求出每一次炖鱼的“浪费时间”，然后从小到大排序，选择前“浪费时间的次数”个 //436ms/1000ms 4024kb/65536kb #include \"bits/stdc++.h\" using namespace std; using ll = long long; ll a[100005]; vector\u003cll\u003e b; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int _; cin \u003e\u003e _; while (_--) { b.clear(); int n, k; cin \u003e\u003e n \u003e\u003e k; ll ans = 0; ll sum = 0; for(int i = 0; i \u003c n; ++i) { cin \u003e\u003e a[i]; ans += a[i]; sum += a[i] / k; b.push_back(k - a[i] % k); } sort(b.begin(), b.end()); for(int i = 0; i \u003c n - sum - 1; ++i){ ans += b[i]; } ans += k; cout \u003c\u003c ans \u003c\u003c endl; } return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"树形dp dfs 数论 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 dp[i][j] 表示以 i 为根的树，i节点为j时的方案数 dp[i][j] = 每个子节点满足条件的方案数相乘（满足的条件是gcd(i,j) != w） 子节点又要求子节点所以形成dfs 由于求j满足gcd(i,j) = w比较好求（枚举w的倍数），所以满足条件的方案数是所有方案数减不满足条件方案数 所有方案数即dp[i][1] + dp[i][2] + … + dp[i][m] 这可以每次求完所有的dp[i][x] 之后求和，用sum[i]维护 整体过程就是先dfs子节点，处理完毕后遍历m，然后遍历每个子节点，算出该子节点对dp[i][j]的贡献（满足的方案数），最后求积，赋值给dp[i][j]，然后再遍历一遍m在线预处理sum[i] 时间复杂度 O(m^2logm) 如果m是1e5，可能需要莫比乌斯反演 注意这不是一棵树，是无向图 //537ms/1000ms 8192kb/262144kb #include \"bits/stdc++.h\" using namespace std; using ll = long long; const int maxn = 1005; ll sum[maxn]; const ll mod = 1e9 + 7; ll n, m; ll dp[maxn][maxn]; struct edge{ int to , next; ll w; }e[2*maxn]; int tot,head[maxn]; ll gcd(ll a, ll b){ return b ? gcd(b, a%b) : a; } void add_edge(int u, int v, ll w){ e[tot].to = v; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++; } void dfs(int x, int p){ for(int i = head[x]; ~i; i = e[i].next){ int v = e[i].to; if(v != p) dfs(v, x); } for(ll i = 1; i \u003c= m; ++i){ ll cnt = 1; for(int j = head[x]; ~j; j = e[j].next){ int v = e[j].to; ll w = e[j].w; if(v == p) continue; ll rem = sum[v]; for(ll k = w; k \u003c= m; k += w){ if(gcd(i, k) == w){ rem -= dp[v][k]; rem += mod; rem %= mod; } } cnt *= rem; cnt %= mod; } dp[x][i] = cnt; dp[x][i] %= mod; } for(ll i = 1; i \u003c= m; ++i){ sum[x] += dp[x][i]; sum[x] %= mod; } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); memset(head , -1 , sizeof(head)); cin \u003e\u003e n \u003e\u003e m; for(int i = 0; i \u003c n - 1; ++i){ int u, v, w; cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; add_edge(u, v, w); add_edge(v, u, w); } dfs(1, 0); cout \u003c\u003c sum[1] \u003c\u003c endl; return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp 乘法原理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 用dp处理排列组合问题，对于子序列的数量，考虑对前缀的依赖 dp[3] 表示扫描到当前abc的数量，dp[2]表示扫描到当前ab的数量，dp[1]表示扫描到当前a的数量，dp[0]表示扫描到当前单纯排列组合的数量 转移方程 dp[3] = dp[3] + dp[2] [ch[i] == 'c'] dp[2] = dp[2] + dp[1] [ch[i] == 'b'] dp[1] = dp[1] + dp[0] [ch[i] == 'a'] 当前字符是？时，它有三种情况a, b, c所以对于dp[0], dp[1], dp[2], dp[3]都乘以3 然后再分a, b, c三种情况 对于c，dp[3] += dp[2] （这是未扫描到当前的dp[2]）其他同理 初始化 dp[0] = 1 //61ms/1000ms 208kb/256mb #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 1e9 + 7; char a[200005]; ll dp[4]; int main(){ int n; cin \u003e\u003e n; cin \u003e\u003e a; dp[0] = 1; for(int i = 0; i \u003c n; ++i){ if(a[i] == 'a'){ dp[1] = (dp[1] + dp[0]) % mod; }else if(a[i] == 'b'){ dp[2] = (dp[2] + dp[1]) % mod; }else if(a[i] == 'c'){ dp[3] = (dp[3] + dp[2]) % mod; }else{ dp[3] = (3ll * dp[3] + dp[2]) % mod; dp[2] = (3ll * dp[2] + dp[1]) % mod; dp[1] = (3ll * dp[1] + dp[0]) % mod; dp[0] = (3ll * dp[0]) % mod; } } cout \u003c\u003c dp[3] \u003c\u003c endl; return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp bf 预处理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给定一个大写的字符串，每个大写的字母都代表三个字母的组合（qwe），每次释放一个qwe中的技能就会获得这个字母，至多只能获得三个，如果在已有三个字母的情况下获得释放技能，第一个字母将会被挤掉（类似于队列）当集齐该大写字母的三个字母组合时，释放r技能就能成功点亮这个大写字母，这时候字母队列中不会有任何变化，问最少需要释放几个技能把所有的大写字母按顺序点亮 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 按顺序暴力，由于大写字母对应的是技能的组合，总共有6种，所以求出前6种组合对后6种组合的影响，然后对每个都取最小值，这样就形成dp dp[i][j] 表示扫描完第 i 个大写字母时，对应的第 j 种组合（至多6种）的答案 初始化 dp[0][i] = 3 [0 \u003c= i \u003c 6] 状态转移方程 dp[i][j] = min(dp[i][j], dp[i - 1][k] + cot(string s[i - 1][k], string s[i][j]) 最后的答案就是 min(dp[s.len - 1][i]) [0 \u003c= i \u003c 6] 如果不做优化会超时，优化的方法就是两处预处理（在代码中标注） //358ms/1000ms 2772kb/1024mb #include \"bits/stdc++.h\" using namespace std; using ll = long long; const int maxn = 100005; //string s; char s[maxn]; unordered_map\u003cchar, int\u003e mp; //括号不匹配 char ch[11][7][4] = {{\"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\", \"QQQ\"}}, {\"QQW\", \"QWQ\", \"QQW\", \"QWQ\", \"WQQ\", \"WQQ\"}, {\"QQE\", \"QEQ\", \"QQE\", \"QEQ\", \"EQQ\", \"EQQ\"}, {\"WWW\", \"WWW\", \"WWW\", \"WWW\", \"WWW\", \"WWW\"}, {\"QWW\", \"QWW\", \"WQW\", \"WWQ\", \"WQW\", \"WWQ\"}, {\"WWE\", \"WEW\", \"WWE\", \"WEW\", \"EWW\", \"EWW\"}, {\"EEE\", \"EEE\", \"EEE\", \"EEE\", \"EEE\", \"EEE\"}, {\"QEE\", \"QEE\", \"EQE\", \"EEQ\", \"EQE\", \"EEQ\"}, {\"WEE\", \"WEE\", \"EWE\", \"EEW\", \"EWE\", \"EEW\"}, {{\"QWE\", \"QEW\", \"WQE\", \"WEQ\", \"EQW\", \"EWQ\"}}; int dp[maxn][6]; int did(string s1, string s2){ if(s1 == s2) return 0; if(s1[1] == s2[0] and s1[2] == s2[1]) return 1; if(s1[2] == s2[0]) return 2; return 3; } const int inf = 0x3f3f3f3f; //int get_id(char x){ // if(x == 'Y') return 0; // if(x == 'V') return 1; // if(x == 'G') return 2; // if(x == 'C') return 3; // if(x == 'X') return 4; // if(x == 'Z') return 5; // if(x == 'T') return 6; // if(x == 'F') return 7; // if(x == 'D') return 8; // return 9; //} int cot[11][7][11][7]; int main() { mp['Y'] = 0; mp['V'] = 1; mp['G'] = 2; mp['C'] = 3; mp['X'] = 4; mp['Z'] = 5; mp['T'] = 6; mp['F'] = 7; mp['D'] = 8; mp['B'] = 9; for(int i = 0; i \u003c 10; ++i){ for(int j = 0; j \u003c 6; ++j){ for(int k = 0; k \u003c 10; ++k){ for(int m = 0; m \u003c 6; ++m){ string s1 = ch[i][j]; string s2 = ch[k][m]; cot[i][j][k][m] = did(s1, s2); } } } } //cin \u003e\u003e s; scanf(\"%s\", s); int len = strlen(s); for(int i = 0; i \u003c= len; ++i) for(int j = 0; j \u003c 6; ++j) dp[i][j] = inf; //cout \u003c\u003c len \u003c\u003c endl; for(int i = 0; i \u003c 6; ++i){ dp[0][i] = 3; } for(int i = 1; i \u003c len; ++i){ int id1 = mp[s[i - 1]]; //在外层循环得到 int id2 = mp[s[i]]; for(int j = 0; j \u003c 6; ++j){ for(int k = 0; k \u003c 6; ++k){ dp[i][j] = min(dp[i][j], dp[i - 1][k] + cot[id1][k][id2][j]); //!!!此处预处理 //dp[i][j] = min(dp[i][j], dp[i - 1][k] + did(ch[id1][k], ch[id2][j])); } } } int ans = 0x3f3f3f3f; for(int i = 0; i \u003c 6; ++i){ ans = min(ans, dp[len - 1][i]); } cout \u003c\u003c ans + len \u003c\u003c endl; return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dfs 图论 乘法原理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给一个森林，每个连通块都是仙人掌图，每次删除一些边，使得它变成一个森林且每个连通块都是一棵树，问有多少种删边方法 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 根据仙人掌图的定义，对于每个环，至少删除一条边就能满足条件，所以计算每个环的边数 对于不在环上的边，可以任意删除或保留，假设每个环的边数为ci，不在环上的边数是r $$ ans = 2^r*\\prod (2^{c_i} - 1) $$ 对于找环的边数，可以用tarjan算法的思想，用dfs序来判断是否遍历过这个点，如果遍历过就说明形成环，dfs序相减就是环的长度 //358ms/1000ms 138640kb/1048576kb #include \"bits/stdc++.h\" using namespace std; using ll = long long; const int maxv = 300005; const ll mod = 998244353; const int maxn = 2000005; struct edge{ int to, nxt; }e[maxn]; int tot,head[maxn]; void add_edge(int u,int v){ e[tot].to = v; e[tot].nxt = head[u]; head[u] = tot++; } vector\u003cll\u003e res; int dfn[maxv],low[maxv]; bool in_stack[maxv]; stack\u003cint\u003e s; int tim; ll qpow(ll x,ll n){ ll res =1; while(n\u003e0){ if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } void tarjan_dfs(int x, int p){ for(int i = head[x]; ~i; i = e[i].nxt){ int v = e[i].to; if(v == p) continue; if(dfn[v] != 0){ res.push_back(dfn[x] + 1 - dfn[v]); }else{ dfn[v] = dfn[x] + 1; tarjan_dfs(v, x); } } } int main() { int n, m; while(scanf(\"%d%d\", \u0026n, \u0026m) != EOF){ //reset res.clear(); tim = 0; memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); memset(in_stack, 0, sizeof(in_stack)); while(!s.empty()) s.pop(); tot = 0; memset(head , -1 , sizeof(head)); for(int i = 0; i \u003c m; ++i){ int u, v; scanf(\"%d%d\", \u0026u, \u0026v); add_edge(u, v); add_edge(v, u); } for(int i = 1; i \u003c= n; ++i){ if(!dfn[i]){ dfn[i] = 1; tarjan_dfs(i, 0); } } ll rem = 0; for(ll i : res) { if(i \u003e 0) rem += i; } rem = m - rem; ll ans = 1; for(ll i : res){ if(i \u003c= 0) continue; ans *= qpow(2, i) - 1; ans += mod; ans %= mod; } ans *= qpow(2, rem); ans += mod; ans %= mod; printf(\"%lld\\n\", ans); //for(ll i : res) cout \u003c\u003c i \u003c\u003c \" \"; //for(int i = 1; i \u003c 6; ++i) cout \u003c\u003c dfn[i] \u003c\u003c \" \"; } return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp lis 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 在一个网格上有n个明星，他们出现的时间是0~ti，从(1,1)出发，每走一格消耗一个时间单位，问最多能碰见几个明星 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 注意一个重要条件：时间是按严格升序排的，r\u003c=500 类似于lis的dp，dp[i]表示最后碰见第i个人时的答案 ans = max(ans, dp[i]) [1 \u003c= i \u003c= n] dp[i] = max(dp[i], dp[j] + 1) 在lis中更新的条件是后面的数比前面的大，在这里条件是曼哈顿距离不大于时间差（已排好序） 这样时间复杂度就是O(n^2) 对于当前明星，它存活到ti，由于网格大小的限制，所以ti - 2r之前消失的明星一定可达，而(ti-2r, ti)这段时间的明星就需要一个一个判断 接下来有一个很巧妙的将时间复杂度降到O(nr)的优化 由于[0, ti-4r]已经用来更新过（更新到ti-2r）所以这段区间将不再使用（因为它的影响已经叠加在了[ti-4r,ti-2r]这段区间上了），所以只需要看[ti-4r,ti-2r]这段区间，加上需要一个一个判断的[ti-2r,ti)这段区间。最后只需要遍历[ti-4r,ti) 时间之所以能转化成明星的个数，就是因为时间是严格有序的 //702ms/2000ms 1572kb/256mb #include \"bits/stdc++.h\" using namespace std; using ll = long long; int r, n; const int maxn = 100005; int dp[maxn]; tuple\u003cint, int, int\u003e cel[maxn]; int dist(int i, int j){ return abs(get\u003c1\u003e(cel[i]) - get\u003c1\u003e(cel[j])) + abs(get\u003c2\u003e(cel[i]) - get\u003c2\u003e(cel[j])); } int main() { memset(dp, -1, sizeof(dp)); scanf(\"%d%d\", \u0026r, \u0026n); get\u003c0\u003e(cel[0]) = 0; get\u003c1\u003e(cel[0]) = 1; get\u003c2\u003e(cel[0]) = 1; for(int i = 1; i \u003c= n; ++i){ int t, x, y; scanf(\"%d%d%d\", \u0026t, \u0026x, \u0026y); get\u003c0\u003e(cel[i]) = t; get\u003c1\u003e(cel[i]) = x; get\u003c2\u003e(cel[i]) = y; } dp[0] = 0; for(int i = 1; i \u003c= n; ++i){ for(int j = max(0, i - 4 * r); j \u003c i; ++j){ if(dp[j] == -1) continue; if(dist(i, j) \u003c= get\u003c0\u003e(cel[i]) - get\u003c0\u003e(cel[j])) dp[i] = max(dp[i], dp[j] + 1); } } int ans = 0; for(int i = 1; i \u003c= n; ++i){ ans = max(ans, dp[i]); } printf(\"%d\\n\", ans); return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给俩数p,q，求最大的x满足p%x=0，x%q!=0 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 如果p%q!=0，x=p 否则对于pq相同的因子m，假设q中有n个m，那么就让p中m的个数减到n-1，得到一个tmp，这样就能保证p%tmp=0,tmp%q!=0，对于所有的因子产生的tmp取最大值 //46ms/1000ms 12kb/512mb #include \"bits/stdc++.h\" using namespace std; using ll = long long; vector\u003cpair\u003cll, ll\u003e\u003e vt; ll p, q; int main() { int _; cin \u003e\u003e _; while (_--) { ll ans = -1; cin \u003e\u003e p \u003e\u003e q; if(p % q != 0) ans = p; else{ vt.clear(); for(ll i = 2; i * i \u003c= q; ++i){ if(q % i == 0){ ll cot = 0; while(q % i == 0) { q /= i; cot++; } vt.emplace_back(i, cot); } } if(q \u003e 1) vt.emplace_back(q, 1); for(auto i : vt){ ll x = i.first; ll y = i.second; ll tmp = p; while(tmp % x == 0){ tmp /= x; } for(ll j = 0; j \u003c y - 1; ++j) tmp *= x; ans = max(ans, tmp); } } cout \u003c\u003c ans \u003c\u003c endl; } //for(auto i : vt){ // cout \u003c\u003c i.first \u003c\u003c \" \" \u003c\u003c i.second \u003c\u003c endl; //} return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dfs 剪枝 回溯 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 重点在于剪枝，还有如何把dfs写得好看点和回溯 此处做的两个剪枝是：如果当前最小不兼容性的和大于等于ans，剪枝。如果当前要处理的集合为空，则不进行下一个集合的处理（因为下一个集合也为空（按顺序放的），这时候放哪个空集无所谓） //308ms 32.6Mb class Solution { public: int m ; int ans; int n; int K; void dfs(vector\u003cint\u003e\u0026 nums, int index, vector\u003cset\u003cint\u003e\u003e\u0026 sts, int cnt){ if(index \u003e= n) { ans = min(ans, cnt); return ; } for(int i = 0; i \u003c K; ++i){ if(sts[i].empty()){ sts[i].insert(nums[index]); dfs(nums, index + 1, sts, cnt); sts[i].erase(nums[index]); return ; } if(sts[i].size() \u003c m and sts[i].find(nums[index]) == sts[i].end()){ int tmp_cnt = cnt + nums[index] - *sts[i].rbegin(); if(tmp_cnt \u003e= ans) continue; sts[i].insert(nums[index]); dfs(nums, index + 1, sts, tmp_cnt); sts[i].erase(nums[index]); } } } int minimumIncompatibility(vector\u003cint\u003e\u0026 nums, int k) { vector\u003cset\u003cint\u003e\u003e vt(k); sort(nums.begin(), nums.end()); K = k; ans = 0x3f3f3f3f; n = nums.size(); m = n / k; dfs(nums, 0, vt, 0); if(ans == 0x3f3f3f3f) ans = -1; return ans; } }; =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"状态压缩dp 预处理 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 和上面那题一样 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 第二种方法是状态压缩dp，（完全不会(╥╯^╰╥) ） 假设n是nums的长度，m是每个集合中的元素个数 foo[i]表示集合为i时的不兼容性，只需对集合中有m个元素时处理，其他情况都是inf，注意foo[0] = 0 dp[i]表示前i个数的最小不兼容性，ans = dp[(1«n) - 1] 对于每个集合i，枚举子集，对于子集大小为m的 dp[i] = min(dp[i], foo[sub] + dp[i ^ sub]) 注意初始化为dp = inf foo = inf dp[0] = 0 foo[0] = 0 //1128ms 13.4Mb class Solution { public: int minimumIncompatibility(vector\u003cint\u003e\u0026 nums, int k) { int n = nums.size(); int m = n / k; vector\u003cint\u003e cnt; vector\u003cint\u003e dp((1 \u003c\u003c n) + 5, 0x3f3f3f3f); vector\u003cint\u003e foo((1 \u003c\u003c n) + 5, 0x3f3f3f3f); dp[0] = 0; foo[0] = 0; for(int i = 0; i \u003c (1 \u003c\u003c n); ++i){ cnt.clear(); if(__builtin_popcount(i) == m){ for(int j = 0; j \u003c n; ++j){ if(i \u003e\u003e j \u0026 1){ cnt.push_back(nums[j]); } } sort(cnt.begin(), cnt.end()); bool ok = true; for(int j = 1; j \u003c m; ++j){ if(cnt[j] == cnt[j - 1]){ ok = false; break; } } if(ok) foo[i] = cnt[m - 1] - cnt[0]; } } for(int i = 0; i \u003c (1 \u003c\u003c n); ++i){ int sub = i; do{ if(__builtin_popcount(sub) == m){ dp[i] = min(dp[i], foo[sub] + dp[sub ^ i]); } sub = (sub - 1) \u0026 i; }while(sub != i); } int ans = dp[(1 \u003c\u003c n) - 1]; if(ans == 0x3f3f3f3f) ans = -1; return ans; } }; =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"博弈 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 在平面坐标系里，有一个token，初始在原点，两人轮流操作，直到不能操作判胜负，操作是将token向上或向右移k个单位，每次移动后token离原点的距离都不能超出d ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 记录一下看错题目，浪费一小时的惨痛经历 移动k个单位是沿一个方向 //46ms/2000ms 0kb/256mb #include \"bits/stdc++.h\" using namespace std; using ll = long long; int main() { ll _; cin \u003e\u003e _; while (_--) { ll d, k; cin \u003e\u003e d \u003e\u003e k; ll n = 0; while((n + k) * (n + k) * 2 \u003c= d * d){ n += k; } ll tmp = n + k; if(tmp * tmp + n * n \u003c= d * d) { n /= k ; n *= 2; n++; }else{ n /= k; n *= 2; } if(n \u0026 1) puts(\"Ashish\"); else puts(\"Utkarsh\"); } return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"树形dp dfs 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 给一棵树，每个节点有若干个人，从根节点开始，每个人可以选择去往一个子节点，直到这个节点没人，最后所有人都来到了叶子节点。将叶子节点的最大人数最小化 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 画了几下图，第一感觉是贪心+搜索，如果一直这样做的话，就有可能变成一个结论题，但是细节还是很难具体化，又有点像dp，树形dp应该是逻辑最清晰的 dp[i]表示以i为根的答案，最后输出dp[1] 初始化全为0 考虑转移方程，这个节点的答案一定不小于子节点的答案 dp[i] = max{dp[ch]} 考虑把该节点的人数转移到子树上（子树的叶子节点上），贪心地选择叶子人数少的，这样不会改变最大值，答案还是max{dp[ch]} 如果叶子人数少的被填满了，也就是现在每个叶子都均匀分配了，那就对剩下的人数继续均分 这样答案就大于max{dp[ch]}，答案更新为floor(sum[i] / leaf[i])，其中sum[i]表示i为根的树的总人数，leaf[i]表示i为根的树的叶子数 所以转移方程 dp[i] = max(max{dp[ch]}, floor(sum[i] / leaf[i])） //623ms/1000ms 30668kb/256mb #include \"bits/stdc++.h\" using namespace std; using ll = long long; vector\u003cll\u003e G[200005]; ll a[200005]; ll sum[200005]; ll leaf[200005]; ll dp[200005]; void dfs(ll x){ if(G[x].size() == 0) leaf[x] = 1; sum[x] = a[x]; for(ll i : G[x]){ dfs(i); sum[x] += sum[i]; leaf[x] += leaf[i]; dp[x] = max(dp[x], dp[i]); } dp[x] = max(dp[x], ll(ceil((double)sum[x] / leaf[x]))); } int main() { ll n; cin \u003e\u003e n; for(ll i = 2; i \u003c= n; ++i){ ll x; cin \u003e\u003e x; G[x].push_back(i); } for(ll i = 1; i \u003c= n; ++i){ cin \u003e\u003e a[i]; } dfs(1); cout \u003c\u003c dp[1] \u003c\u003c '\\n'; return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 有一排木板，无限多个，给r的倍数涂红色，b的倍数涂蓝色，r和b的倍数随便选一种颜色涂，将涂色的木板取出来，按原来的顺序排，问是否存在不少于k个连续的颜色相同的木板 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 假设r \u003e b，r和b共同的倍数一定染红色（因为红色间隔比较大），问题转化成两个红色木板间最多有几个蓝色木板，在这个区间里，第一个蓝色木板一定是所有长度为r的区间内离该区间左边红色木板最近的，由扩展欧几里得可知ax+by=c，x，y有整数解当c | gcd(a,b)，所以这个最近距离是gcd(r,b)，然后就可以求出最多的蓝色木板 31ms/2000ms 0kb/256mb #include \"bits/stdc++.h\" using namespace std; using ll = long long; int main() { int _; cin \u003e\u003e _; while (_--) { int r, b, k; cin \u003e\u003e r \u003e\u003e b \u003e\u003e k; if(r \u003c b) swap(r, b); if(floor((r - 1 - __gcd(r, b)) / (double) b) + 1 \u003c k) puts(\"OBEY\"); else puts(\"REBEL\"); } return 0; } =============================================================== ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 前缀 题目 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:0","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题意 在环上有n个数字，可以对每个数字进行+1或-1的操作，问最少需要几次操作使得环中存在一个长度为n的步长为1的顺时针的递增序列 ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:1","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 最关键的思路是其中一个数肯定不变 对于每个从环中任一位置开始的数列，假设其中一个数不变，求出操作数，再对所有操作数取min，这样时间复杂度为O(n*n*n)，考虑到对其他位置开始的序列，假设不变的数有可能是相同的，这样求别的数需要的操作数时就重复计算了 所以直接假设每个数为不变的数，然后遍历一遍2n个数，用前缀数组求出到这个数的操作数，对于长度为n的序列，操作数为pre[j] - pre[j - n] #include\u003cbits/stdc++.h\u003e using namespace std; int a[4005]; int pre[4005]; int ans; int main(){ int _; cin \u003e\u003e _; while(_--){ int n; cin \u003e\u003e n; ans = 0x3f3f3f3f; for(int i = 1; i \u003c= n; ++i){ cin \u003e\u003e a[i]; a[i + n] = a[i]; } for(int i = 1; i \u003c 2 * n; ++i){ int tmp = a[i] - i; for(int j = 1; j \u003c 2 * n; ++j){ pre[j] = pre[j - 1] + abs(a[j] - j - tmp); if(j \u003e= n){ ans = min(ans, pre[j] - pre[j - n]); } } } cout \u003c\u003c ans \u003c\u003c '\\n'; } return 0； } ","date":"2020-09-06","objectID":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:2","tags":["cpp","problemlist"],"title":"无聊的做题记录","uri":"/%E6%97%A0%E8%81%8A%E7%9A%84%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["Python web"],"content":"hhu_spider","date":"2020-08-11","objectID":"/hhu_spider/","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"hhu健康打卡脚本（返校版） ","date":"2020-08-11","objectID":"/hhu_spider/:1:0","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"环境 必装环境 python， requests 推荐环境 anaconda, pycharm ","date":"2020-08-11","objectID":"/hhu_spider/:1:1","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"功能说明 定时打卡、同时多人打卡、发邮件反馈打卡信息、失败重新打卡 （为什么不用发信息，国内手机号在twilio上不能用了） ","date":"2020-08-11","objectID":"/hhu_spider/:1:2","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"使用方法 在#**xxx** 中按xxx提示填入自己的相关信息 运行 关于定时打卡 将脚本传到服务器上，用cronb（linux系统）实现定时，可以选择发邮件反馈打卡情况 ","date":"2020-08-11","objectID":"/hhu_spider/:1:3","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"代码 import requests import sys import datetime import smtplib from email.mime.text import MIMEText from email.header import Header def send_email(status, email, abbr, now_time): mail_host = \"smtp.qq.com\" #现在是qq邮箱 mail_user = \"xxxxxxx\" #**发送打卡信息的邮箱** mail_pass = \"xxxxxxx\" #**邮箱授权码** sender = 'xxxxxxx' #**邮件发送方的邮箱** receivers = [] # 接收邮件方 receivers.append(email) if status: text = '打卡成功！！！' else : text = '打卡失败 T_T，请手动打卡' message = MIMEText(text + '今天是' + now_time + '\\n如有信息变动，请即时反馈\\n如果有一天没收到邮件请手动打卡', 'plain', 'utf-8') message['From'] = Header(\"xxxxxxx\", 'utf-8') #**邮件发送方的名字（自定义）** message['To'] = Header(abbr, 'utf-8') subject = text message['Subject'] = Header(subject, 'utf-8') try: smtpObj = smtplib.SMTP_SSL() smtpObj.connect(mail_host, 465) #在阿里云上要用465端口和ssl smtpObj.login(mail_user, mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print(\"邮件发送成功\") except smtplib.SMTPException: print(\"Error: 无法发送邮件\") def daka(user_data): session = requests.Session() headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } login_url = 'http://ids.hhu.edu.cn/amserver/UI/Login' user = user_data['user_name'] password = user_data['password'] data = { 'Login.Token1': user, 'Login.Token2': password, 'goto': 'http://my.hhu.edu.cn/loginSuccess.portal', 'gotoOnFail': 'http://my.hhu.edu.cn/loginFailure.portal' } login_response_text = session.post(url=login_url, headers=headers, data=data).text if 'handleLoginSuccessed' in login_response_text: print('登录成功') else: print('登录失败，请修改用户名和密码重新登录') sys.exit() ui_url = 'http://form.hhu.edu.cn/pdc/form/list' session.get(url=ui_url, headers=headers) form_url = 'http://form.hhu.edu.cn/pdc/formDesignApi/initFormAppInfo' data = { 'selfFormWid': 'A335B048C8456F75E0538101600A6A04' } form_response = session.post(url=form_url, data=data, headers=headers) print('获得表单界面状态码', form_response.status_code) post_url = 'http://form.hhu.edu.cn/pdc/formDesignApi/dataFormSave?wid=A335B048C8456F75E0538101600A6A04\u0026userId=' + user now_time = datetime.datetime.now().strftime('%Y/%m/%d') data = { 'DATETIME_CYCLE': now_time, 'XGH_336526': user_data['XGH_336526'], 'XM_1474': user_data['XM_1474'], 'SFZJH_859173': user_data['SFZJH_859173'], 'SELECT_941320': user_data['SELECT_941320'], 'SELECT_459666': user_data['SELECT_459666'], 'SELECT_814855': user_data['SELECT_814855'], 'SELECT_525884': user_data['SELECT_525884'], 'SELECT_125597': user_data['SELECT_125597'], 'TEXT_950231': user_data['TEXT_950231'], 'TEXT_937296': user_data['TEXT_937296'], 'RADIO_853789': '否', 'RADIO_43840': '否', 'RADIO_579935': '健康', 'RADIO_138407': '是', 'RADIO_546905':'', 'RADIO_314799':'', 'RADIO_209256':'', 'RADIO_836972':'', 'RADIO_302717':'', 'RADIO_701131':'', 'RADIO_438985':'', 'RADIO_467360':'', 'PICKER_956186':'', 'TEXT_434598':'', 'TEXT_515297':'', 'TEXT_752063':'' } post_response = session.post(url=post_url, data=data, headers=headers) print('提交表单后状态码', post_response.status_code) final_text = post_response.text print(final_text) if 'true' in final_text: print('今天是: ', now_time) print('打卡成功!!!') send_email(True, user_data['email'], user_data['abbr'], now_time) return True else: print('打卡失败') return False if __name__ == '__main__': users = [] user2 = { 'name' : 'xxxxxxx', #**打卡者姓名（为了区分不同打卡者）** 'user_name' : 'xxxxxxx', #**用户名（一般是学号）** 'password' : 'xxxxxxx', #**密码** 'XGH_336526': 'xxxxxxx', #**学号** 'XM_1474': 'xxxxxxx', #**姓名** 'SFZJH_859173': 'xxxxxxx', #**身份证号** 'SELECT_941320': 'xxxxxxx', #**学院（只能是选择列表中的值，比如：计信院）** 'SELECT_459666': 'xxxxxxx', #**年级（只能是选择列表中的值，比如：2019级）** 'SELECT_814855': 'xxxxxxx', #**专业（只能是选择列表中的值，比如：计算机）** 'SELECT_525884': 'xxxxxxx', #**班级（只能是选择列表中的值，比如：计算机19_2）** 'SELECT_125597': 'xxxxxxx', #**宿舍楼（只能是选择列表中的值，比如：江宁校区教学区25舍）** 'TEXT_950231': 'xxxxxxx', #**宿舍号，比如205** 'TEXT_937296': 'xxxxxxx', #**手机号码** 'email' : 'xxxxxxx', #**将打卡信息发送至这个邮箱** 'abbr' : 'xxxxxxx' #**名字缩写（用作邮件接受者的名字）** } user1 = { 'name' : 'xxxxxxx', #**打卡者姓名（为了区分不同打卡者）** 'user_name'","date":"2020-08-11","objectID":"/hhu_spider/:1:4","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"hhu查成绩脚本（新版教务系统） ","date":"2020-08-11","objectID":"/hhu_spider/:2:0","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"环境 必装环境 python , chaojiying_api , selenium , chromedriver , requests 推荐环境 anaconda , pycharm ","date":"2020-08-11","objectID":"/hhu_spider/:2:1","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"功能说明 查本学期成绩（可以通过修改源码变成查所有成绩）、查绩点排名 ","date":"2020-08-11","objectID":"/hhu_spider/:2:2","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"使用方法 把#**XXXX**按XXXX提示改成自己的信息 在chaojiying.py中填写自己的账号和密码 在主程序中可以修改要查成绩的学年学期，按{}中的值填写，对应关系如下 2020-2021学年1 {2020-2021-1-1} 2019-2020学年2 {2019-2020-2-1} 2019-2020学年1 {2019-2020-1-1} 2018-2019学年2 {2018-2019-2-1} 2018-2019学年1 {2018-2019-1-1} 运行 ","date":"2020-08-11","objectID":"/hhu_spider/:2:3","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"代码 chaojiying_Python/chaojiying.py #!/usr/bin/env python # coding:utf-8 import requests from hashlib import md5 class Chaojiying_Client(object): def __init__(self, username, password, soft_id): self.username = username password = password.encode('utf-8') self.password = md5(password).hexdigest() self.soft_id = soft_id self.base_params = { 'user': self.username, 'pass2': self.password, 'softid': self.soft_id, } self.headers = { 'Connection': 'Keep-Alive', 'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)', } def PostPic(self, im, codetype): \"\"\" im: 图片字节 codetype: 题目类型 参考 http://www.chaojiying.com/price.html \"\"\" params = { 'codetype': codetype, } params.update(self.base_params) files = {'userfile': ('ccc.jpg', im)} r = requests.post('http://upload.chaojiying.net/Upload/Processing.php', data=params, files=files, headers=self.headers) return r.json() def ReportError(self, im_id): \"\"\" im_id:报错题目的图片ID \"\"\" params = { 'id': im_id, } params.update(self.base_params) r = requests.post('http://upload.chaojiying.net/Upload/ReportError.php', data=params, headers=self.headers) return r.json() def main(): chaojiying = Chaojiying_Client('xxxxxx', 'xxxxxx', '912462') #用户中心\u003e\u003e软件ID 生成一个替换 96001 im = open('chaojiying_Python/captcha.png', 'rb').read() #本地图片文件路径 来替换 a.jpg 有时WIN系统须要// return chaojiying.PostPic(im, 1902)['pic_str'] #1902 验证码类型 官方网站\u003e\u003e价格体系 3.4+版 print 后要加() 主程序 import requests import chaojiying_Python.chaojiying as cjy from selenium import webdriver from time import sleep from PIL import Image from lxml import etree import sys import re from selenium.webdriver.chrome.options import Options def main(): id = 'xxxxxxx' #**学号** pwd = 'xxxxxxx' #**密码** chrome_options = Options() chrome_options.add_argument('--headless') chrome_options.add_argument('--disable-gpu') proxy_ip = {\"http\": '183.166.70.155:9999'} browser = webdriver.Chrome(executable_path='chromedriver.exe', chrome_options=chrome_options) #chrome \u003e 79 browser.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", { \"source\": \"\"\" Object.defineProperty(navigator, 'webdriver', { get: () =\u003e undefined }) \"\"\" }) browser.maximize_window() login_url = 'http://202.119.114.197/login' browser.get(url=login_url) sleep(2) # browser.quit() browser.save_screenshot('login_interface.png') captcha_img_ele = browser.find_element_by_xpath('//*[@id=\"captchaImg\"]') location = captcha_img_ele.location # 左上角 size = captcha_img_ele.size scale = 1 captcha_coordinates = ( int(location['x']) * scale, int(location['y']) * scale, int(location['x'] + size['width']) * scale, int(location['y'] + size['height']) * scale) i = Image.open('login_interface.png') frame = i.crop(captcha_coordinates) frame.save('chaojiying_Python/captcha.png') captcha_val = cjy.main() # print(captcha_val) id_input = browser.find_element_by_xpath('//*[@id=\"input_username\"]') id_input.send_keys(id) pwd_input = browser.find_element_by_xpath('//*[@id=\"input_password\"]') pwd_input.send_keys(pwd) captcha_input = browser.find_element_by_xpath('//*[@id=\"input_checkcode\"]') captcha_input.send_keys(captcha_val) login_button = browser.find_element_by_xpath('//*[@id=\"loginButton\"]') login_button.click() if 'errorCode=badCredentials' in browser.current_url: print('用户名或密码错，请重新登录') browser.quit() sys.exit() if 'errorCode=badCaptcha' in browser.current_url: print('验证码错，请重新登录') browser.quit() sys.exit() cookies = browser.get_cookies() query_url = 'http://202.119.114.197/student/integratedQuery/scoreQuery/allTermScores/data' data = { 'zxjxjhh': '2020-2021-1-1', #**此处可以修改要查成绩的学年学期** 'kch': '', 'kcm': '', 'pageNum': '1', 'pageSize': '30' } headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.146 Safari/537.36' } session = requests.Session() for cookie in cookies: session.cookies.set(cookie['name'], cookie['value']) reports = session.post(url=query_url, data=data, headers=headers).json()['list']['records'] # print(reports) gpa_url = 'http://202.119.114.197/st","date":"2020-08-11","objectID":"/hhu_spider/:2:4","tags":["python"],"title":"hhu_spider","uri":"/hhu_spider/"},{"categories":["Python web"],"content":"Python爬虫","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"urllib模块 不使用 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:1:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"requests模块 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"获得网页源码 import requests url = 'https://dyhgo.fun' response = requests.get(url) print(response.text) ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"带参数的url和UA伪装 #测试一下带参数的url和ua伪装 import requests url = 'https://www.baidu.com/s' name = input('输入您要搜索的内容，我们将返回百度搜索该信息的网页源码') params = { 'wd' : name } headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.get(url=url, params=params, headers=headers) print(response.text) ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：有道翻译查词 #有道翻译的结果获取，查询look单词并将结果存储 import requests import json params = { 'i': 'look', 'from': 'AUTO', 'to': 'AUTO', 'smartresult': 'dict', 'client': 'fanyideskweb', 'salt': '16119129043609', 'sign': '288cdf16af5fa68411381ba3c9f7f874', 'lts': '1611912904360', 'bv': '44a53b4124e8b822ebfd881c5a599938', 'doctype': 'json', 'version': '2.1', 'keyfrom': 'fanyi.web', 'action': 'FY_BY_REALTlME' } url = 'http://fanyi.youdao.com/translate_o?smartresult=dict\u0026smartresult=rule' headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.post(url=url, data=params, headers=headers) f = open('look.json', 'w', encoding='utf-8') json.dump(response.json(), fp=f, ensure_ascii=False) f.close() print(response.json()) ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:3","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：获取豆瓣影单 网站链接 #获取豆瓣影单 import requests import json url = 'https://movie.douban.com/j/chart/top_list' headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } params = { 'type': '24', 'interval_id': '100:90', 'action':'', 'start': '1', 'limit': '2' } response = requests.get(url=url, params=params, headers=headers) list_data = response.json() f = open('douban.json', 'w', encoding='utf-8') json.dump(list_data, fp=f, ensure_ascii=False) f.close() ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:4","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：kfc餐厅信息 网站链接 #kfc餐厅信息 import requests url = 'http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword' params = { 'cname':'', 'pid':'', 'keyword': '上海', 'pageIndex': '1', 'pageSize': '10' } headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.post(url=url, data=params, headers=headers) print(response.text) ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:5","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：药监局相关信息 注意数据由ajax加载 网站链接 #药监局相关数据 import requests import json url1 = 'http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsList' headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } data = { 'on': 'true', 'page': '1', 'pageSize': '15', 'productName':'', 'conditionType': '1', 'applyname':'', 'applysn':'' } id_list = [] response = requests.post(url=url1, data=data, headers=headers).json()['list'] for i in response: id_list.append(i['ID']) #print(id_list) detail_list = [] url2 = 'http://scxk.nmpa.gov.cn:81/xk/itownet/portalAction.do?method=getXkzsById' for id in id_list: data = { 'id' : id } response = requests.post(url=url2, data=data, headers=headers).json() detail_list.append(response) #print(response) with open('yaojianju.json', 'w', encoding='utf-8') as f: json.dump(detail_list, fp=f, ensure_ascii=False, indent=True) print('over') ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:2:6","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"数据解析 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:3:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"正则 基础用法参考此处 案例：下载糗事百科图片 网站链接 #下载糗事百科的图片 import requests url = 'https://pic.qiushibaike.com/system/pictures/12402/124029001/medium/J8FFRWUK30TM3X79.jpg' header = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.get(url=url, headers=header) image = response.content with open('qiutu.jpg', 'wb') as f: f.write(image) print('over') 案例：批量下载糗事百科图片 网站链接 #用正则表达式下载图片（可批量下载） # \u003cdiv class=\"thumb\"\u003e # # \u003ca href=\"/article/124031033\" target=\"_blank\"\u003e # \u003cimg src=\"//pic.qiushibaike.com/system/pictures/12403/124031033/medium/V35P60R0KM4YCY3Q.jpg\" alt=\"糗事#124031033\" class=\"illustration\" width=\"100%\" height=\"auto\"\u003e # \u003c/a\u003e # \u003c/div\u003e import requests import re url = 'https://www.qiushibaike.com/imgrank/' headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.get(url=url, headers=headers).text #print(response) regex = '\u003cdiv class=\"thumb\"\u003e.*?\u003cimg src=\"(.*?)\" alt.*?\u003c/div\u003e' img_list = re.findall(regex, response, re.S) #print(img_list) img_url = 'https:' + img_list[0] #print(img_url) response = requests.get(url=img_url, headers=headers).content #print(type(response)) with open('qiutu2.jpg', 'wb') as f : f.write(response) print('download successfully') ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:3:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"bs4 BeautifulSoup解析本地html #beautifulsoup解析本地html from bs4 import BeautifulSoup import requests with open('test.html', 'r', encoding='utf-8') as f: bs = BeautifulSoup(f, 'lxml') print(bs) BeautifulSoup解析当前获得的html源码 #beautifulsoup解析当前获得的html源码 from bs4 import BeautifulSoup import requests url = 'https://dyhgo.fun' print(BeautifulSoup(requests.get(url=url).text, 'lxml')) BeautifulSoup的使用 #beautifulsoup的使用，挺复杂的 from bs4 import BeautifulSoup with open('forbsfor.html', 'r', encoding='utf-8') as f: bs = BeautifulSoup(f, 'lxml') print(bs) print(bs.a) #print fitst a tag print(bs.div) print(bs.find('div')) #same as bs.div print(bs.find('div', class_='header-title')) #find tag by attribute, notice class print(bs.find('div', id = 'menu-toggle-mobile')) print(bs.find_all('a')) #get a list of all 'a' tags #css selector print(bs.select('.page-item')) #a list of tags which of class is 'page-item' print(bs.select('.header-wrapper \u003e .header-title \u003e a[0]')) #wrong statement print(bs.select('.header-wrapper \u003e .header-title \u003e a')[0]) #means level, return a list of all 'a' tags print(bs.select('.header-wrapper a')[0]) #space means cross level #get context or attribute print(bs.select('.header-wrapper a')[0].text) print(bs.select('.header-wrapper a')[0].get_text()) print(bs.select('.header-wrapper a')[0].string) print(bs.select('.header-title')[0].text) #get all text between this tag print(bs.select('.header-title')[0].get_text()) print(bs.select('.header-title')[0].string) #get direct text between this tag print(bs.select('.header-wrapper \u003e .header-title \u003e a')[0]['title']) 案例：爬取《三国演义》内容 网站链接 #爬取三国演义的内容 import requests from bs4 import BeautifulSoup url = 'https://www.shicimingju.com/book/sanguoyanyi.html' headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.get(url=url, headers=headers).text bs = BeautifulSoup(response, 'lxml') #mulu = bs.find('div', class_='book-mulu') a_list = bs.select('.book-mulu \u003e ul \u003e li \u003e a') #print(a_list) f = open('sanguo.txt', 'a', encoding='utf-8') for a in a_list[:3]: title = a.string.encode('iso-8859-1').decode('utf-8')#.encode('iso-8859-1') #print(title) url_detail = 'https://www.shicimingju.com/' + a['href'] #print(url_detail) #response_detail = requests.get(url=url_detail, headers=headers).text.encode('iso-8859-1') # ！！！！！！notice this statement is more common response_detail = requests.get(url=url_detail, headers=headers) response_detail.encoding = response_detail.apparent_encoding response_detail = response_detail.text bs = BeautifulSoup(response_detail, 'lxml') content_detail = bs.find('div', class_='chapter_content').text#.encode('iso-8859-1') # !!!!!text not string #print(type(content_detail)) f.write(title + ':' + content_detail + '\\n') #print(content_detail) print(title + 'download successfully') ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:3:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"xpath 很常用 基本用法 from lxml import etree import requests parser = etree.HTMLParser() url = 'https://dyhgo.fun' response = requests.get(url=url).text tree = etree.HTML(response) #without etree.HTMLParser print(tree.xpath('/html/head/title/text()')) xpath语法 from lxml import etree parser = etree.HTMLParser() tree = etree.parse('forbsfor.html', parser=parser) r = tree.xpath('/html/head/meta') #return a list r = tree.xpath('/html//meta') # // means cross level r = tree.xpath('//div') # means all tags named div r = tree.xpath('//div[@class = \"header-wrapper\"]') #with condition r = tree.xpath('(//div[@class = \"header-wrapper\"])[2]') #second div which of class is header-wrapper !!! notice the index is started from 1 r = tree.xpath('(//div[@class = \"header-wrapper\"])[1]/div/a/text()') #get DYH but doesn't work if replace '/div/' with '//' r = tree.xpath('(//div[@class = \"header-title\"])[1]//text()') # get ['\\r\\n ', 'DYH', '\\r\\n '] ok ! so '//text()' means all text and '/text()' means direct text r = tree.xpath('(//div[@class = \"header-title\"])[1]/a/@title') # get attribute of \u003ca\u003e print(r) 案例：获取58同城二手房信息 网站链接 #爬取58信息 notice : the info on website is random import requests from lxml import etree url = 'https://bj.58.com/ershoufang/' headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.get(url=url, headers=headers).text tree = etree.HTML(response) div_list = tree.xpath('(//section[@class = \"list\"])[1]/div') #print(div_list) for div in div_list: title = div.xpath('./a/div[@class = \"property-content\"]//h3/@title')[0] # '..' means upper level print(title) xpath或运算（案例：获取所有城市名称） 网站链接 #所有城市 xpath 与或运算 import requests from lxml import etree url = 'https://www.aqistudy.cn/historydata/' headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.get(url=url, headers=headers).text tree = etree.HTML(response) a_list = tree.xpath('//div[@class = \"bottom\"]/ul/li/a | //div[@class = \"bottom\"]/ul/div[2]/li/a') city_name = [] for a in a_list: city_name.append(a.xpath('./text()')[0]) print(city_name, len(city_name)) ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:3:3","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"验证码识别 使用超级鹰api 链接 点击此处下载Python版api 使用示例如下 import requests from lxml import etree import chaojiying_Python.chaojiying as rec url = 'https://so.gushiwen.cn/user/login.aspx?from=http://so.gushiwen.cn/user/collect.aspx' headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } response = requests.get(url=url, headers=headers).text tree = etree.HTML(response) img_url = 'https://so.gushiwen.cn/' + tree.xpath('//*[@id=\"imgCode\"]/@src')[0] response = requests.get(url=img_url, headers=headers).content with open('chaojiying_Python/b.png', 'wb') as f: f.write(response) print(rec.main()) ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:4:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"cookie(模拟登录） 案例：登录牛客竞赛网 #session can keep cookie import requests url = 'https://www.nowcoder.com/nccommon/login/do?token=' session = requests.Session() headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36', } data = { 'email': 'xxxxxxx', #登录账号（手机或邮箱） 'remember': 'false', 'cipherPwd': 'xxxxxxxxx' #加密后的密码（可通过抓包获取） } response = session.post(url=url, headers=headers, data=data) print(response.status_code) page_src = response.text profile_url = 'https://ac.nowcoder.com/sns/message/90625985/conversation-list?#/' profile_resopnse = session.get(url=profile_url, headers=headers) print(profile_resopnse.status_code) profile_src = profile_resopnse.text with open('wangye2.html', 'w', encoding='utf-8') as f: f.write(profile_src) ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:5:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"代理ip 代理ip的网站（大多数不好用） 代理ip池的github仓库 #use proxy ip import requests headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36', } src = requests.get(url='http://www.baidu.com/s?wd=ip', headers=headers, proxies={\"https\" : '183.166.102.222:9999'}).text ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:6:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"异步爬虫 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:7:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"进程池 from multiprocessing.dummy import Pool import time def tst(str): print(str, 'doing') time.sleep(2) print(str, 'done') pool = Pool(3) sta = time.time() lis = ['aa', 'bb', 'cc', 'dd'] pool.map(tst, lis) ed = time.time() print(ed - sta) #4s ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:7:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"案例：爬取梨视频网站视频 网站链接 #https://video.pearvideo.com/mp4/third/20210201/cont-1718821-15765543-134934-hd.mp4 #https://video.pearvideo.com/mp4/third/20210201/1612279360957-15765543-134934-hd.mp4 #pearvideo import requests from lxml import etree import random from multiprocessing.dummy import Pool headers = { 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36' } url = 'https://www.pearvideo.com/category_5' page_src = requests.get(url=url, headers=headers).text tree = etree.HTML(page_src) li_list = tree.xpath('//ul[@id = \"listvideoListUl\"]/li') vd_list = [] for li in li_list: if li == li_list[0]: continue #detail_url = 'https://www.pearvideo.com/' + li.xpath('./div/a/@href')[0] video_id = li.xpath('./div/a/@href')[0][6:] video_name = li.xpath('./div/a/div[@class = \"vervideo-title\"]/text()')[0] + '.mp4' #print(video_id, video_name) detail_url = 'https://www.pearvideo.com/videoStatus.jsp' params = { 'contId' : video_id, 'mrd' : str(random.random()) } new_headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36', 'Referer' : 'https://www.pearvideo.com/video_' + video_id } video_dict = requests.get(url=detail_url, headers=new_headers, params=params).json() raw_url = video_dict['videoInfo']['videos']['srcUrl'] #print(raw_url, video_name) left = raw_url.rfind('/') right = raw_url.find('-') true_url = raw_url.replace(raw_url[left + 1 : right], 'cont-' + video_id) #print(true_url, video_name) vd = { 'name' : video_name, 'url' : true_url } vd_list.append(vd) def store(vd): url = vd['url'] name = vd['name'] dat = requests.get(url=url, headers=headers).content print(name, 'downloading') with open(name, 'wb') as f: f.write(dat) print(name, 'done') pool = Pool(4) pool.map(store, vd_list) pool.close() pool.join() ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:7:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"selenium模块 以chrome为例 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"安装驱动 根据chrome的版本安装相应的chromedriver 链接 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"基本用法 windows系统 from selenium import webdriver from lxml import etree import time browser = webdriver.Chrome(executable_path='chromedriver.exe') browser.get(url='http://scxk.nmpa.gov.cn:81/xk/') page_src = browser.page_source tree = etree.HTML(page_src) li_list = tree.xpath('//ul[@id=\"gzlist\"]/li') for li in li_list: name = li.xpath('./dl/@title')[0] print(name) time.sleep(5) browser.quit() ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"一些操作 from selenium import webdriver import time browser = webdriver.Chrome(executable_path='chromedriver.exe') browser.maximize_window() browser.get(url='https://www.taobao.com/') time.sleep(1) search_input = browser.find_elements_by_id('q')[0] search_input.send_keys('ipad') time.sleep(1) btn = browser.find_elements_by_css_selector('.btn-search')[0] btn.click() time.sleep(1) browser.execute_script('window.scrollTo(0, document.body.scrollHeight)') time.sleep(2) browser.get('https://dyhgo.fun') time.sleep(5) browser.back() time.sleep(2) browser.forward() time.sleep(2) time.sleep(3) browser.quit() ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:3","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"无头浏览器 #phantomJs also works from selenium import webdriver import time from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument('--headless') chrome_options.add_argument('--disable-gpu') browser = webdriver.Chrome(executable_path='chromedriver.exe', chrome_options=chrome_options) browser.get(url='https://dyhgo.fun') page_src = browser.page_source time.sleep(2) print(page_src) browser.quit() ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:4","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"规避检测 版本chrome \u003c= 79 from selenium import webdriver import time from selenium.webdriver import ChromeOptions option = ChromeOptions() option.add_experimental_option('excludeSwitches', ['enable-automation']) browser = webdriver.Chrome(executable_path='chromedriver.exe', options=option) browser.get(url='https://dyhgo.fun') page_src = browser.page_source time.sleep(2) print(page_src) browser.quit() 版本chrome \u003e 79 from selenium import webdriver import time browser = webdriver.Chrome(executable_path='chromedriver.exe') browser.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", { \"source\": \"\"\" Object.defineProperty(navigator, 'webdriver', { get: () =\u003e undefined }) \"\"\" }) browser.get(url='https://dyhgo.fun') page_src = browser.page_source time.sleep(2) print(page_src) browser.quit() ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:8:5","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"scrapy框架 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:9:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"hhu爬虫 （已停止维护） ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:10:0","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"hhu健康打卡脚本（假期版） ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:10:1","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["Python web"],"content":"hhu查成绩脚本（新版教务系统） 点击此处 ","date":"2020-08-11","objectID":"/python%E7%88%AC%E8%99%AB/:10:2","tags":["python"],"title":"Python爬虫","uri":"/python%E7%88%AC%E8%99%AB/"},{"categories":["abc"],"content":"abc173","date":"2020-07-06","objectID":"/abc173/","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"A - Payment ","date":"2020-07-06","objectID":"/abc173/:0:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; cin\u003e\u003en; int i=1000; while(i\u003cn){ i+=1000; } cout\u003c\u003ci-n; return 0; } B - Judge Status Summary ","date":"2020-07-06","objectID":"/abc173/:1:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 1e5+2; int wa,tle,ac,re; int main(){ int n; cin\u003e\u003en; while(n--){ string s; cin\u003e\u003es; switch(s[0]){ case 'A':{ ac++; break; } case 'W':{ wa++; break; } case 'T':{ tle++; break; } default:{ re++; break; } } } cout\u003c\u003c\"AC x \"\u003c\u003cac\u003c\u003cendl\u003c\u003c\"WA x \"\u003c\u003cwa\u003c\u003cendl\u003c\u003c\"TLE x \"\u003c\u003ctle\u003c\u003cendl\u003c\u003c\"RE x \"\u003c\u003cre\u003c\u003cendl; return 0; } C - H and V ","date":"2020-07-06","objectID":"/abc173/:2:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; char a[7][7]; char b[7][7]; int n,m;int k; void row(int x){ for(int i=0;i\u003cm;i++){ b[x][i] = '.'; } } void col(int x){ for(int i=0;i\u003cn;i++){ b[i][x] = '.'; } } void sol(int x,int y){ for(int i=0;i\u003cn;i++){ if(x\u003e\u003ei\u00261){ row(i); } } for(int j=0;j\u003cm;j++){ if(y\u003e\u003ej\u00261){ col(j); } } } int cal(){ int ans =0; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ if(b[i][j] == '#') ans++; } } return ans; } int main(){ cin\u003e\u003en\u003e\u003em;cin\u003e\u003ek; char c; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ cin\u003e\u003ea[i][j]; } } int ans = 0; for(int i=0;i\u003c(1\u003c\u003cn);i++){ for(int j=0;j\u003c(1\u003c\u003cm);j++){ memcpy(b,a,sizeof(a)); sol(i,j); if (cal() == k) ans++; } } cout\u003c\u003cans\u003c\u003cendl; return 0; } D - Chat in a Circle ","date":"2020-07-06","objectID":"/abc173/:3:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll a[200005]; ll n; int main(){ cin\u003e\u003en; for(ll i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; } sort(a,a+n,[](int a,int b){return a\u003eb;}); if(n==2) { cout\u003c\u003ca[0]\u003c\u003cendl; exit(0); } n--; ll t; ll q = n; if(n\u00261){ t = (n-1)/2; t++; } else{ n++; t = (n-1)/2; t++; } ll ans = a[0]; for(ll i=1;i\u003ct;i++){ ans += 2LL * a[i]; } if(q%2 == 0){ ans -= a[t-1]; } cout\u003c\u003cans\u003c\u003cendl; return 0; } E - Multiplication 4 ","date":"2020-07-06","objectID":"/abc173/:4:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 1e9+7; ll a[200005]; ll n,k; int main(){ cin\u003e\u003en\u003e\u003ek; for(int i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; } sort(a,a+n); int L = 0,R = n-1; if(k\u00261){ if(a[n-1] \u003c 0){ ll ans = 1; for(int i=n-1;i\u003e=n-k;i--){ ans *= a[i]; ans %= mod; } if(ans \u003c 0) cout\u003c\u003cans+mod\u003c\u003cendl;else cout\u003c\u003cans\u003c\u003cendl; exit(0); } R--,k--; } while(k){ ll lv = a[L] * a[L+1]; ll rv = a[R] * a[R-1]; if(lv \u003c rv){ R -= 2; } else L += 2; k -= 2; } ll ans = 1; for(int i=0;i\u003cL;i++){ ans *= a[i]; ans %= mod; } for(int i=R+1;i\u003cn;i++){ ans *= a[i]; ans %= mod; } if(ans \u003c 0) cout\u003c\u003cans+mod\u003c\u003cendl; else cout\u003c\u003cans\u003c\u003cendl; return 0; } F - Intervals on Tree ","date":"2020-07-06","objectID":"/abc173/:5:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["abc"],"content":"题解 对于一个森林，点和边对连通图个数的贡献是每个点+1，每条边-1 所以计算点被遍历几次，边被遍历几次 这与区间的左右数字个数有关 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int n; int main(){ ll ans = 0; cin\u003e\u003en; for(int i=1;i\u003c=n;i++){ ans += (ll)i * (n-i+1); } int _ = n; _--; while(_--){ int a,b; cin\u003e\u003ea\u003e\u003eb; if(a \u003e b) swap(a,b); ans -= (ll)a * (n-b+1); } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-07-06","objectID":"/abc173/:6:0","tags":["cpp","graph_theory"],"title":"abc173","uri":"/abc173/"},{"categories":["problemlist"],"content":"某不科学的暑假做题记录","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"简单思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 直接法，注意数组大小爆long long #include\u003cbits/stdc++.h\u003e using ll = long long; const ll mod = 1e6+3; ll fac[mod+2]; int main(){ fac[0] = 1LL; fac[1] = 1LL; for(ll i=2;i\u003cmod+2;i++){ fac[i] = i*fac[i-1]; fac[i] %= mod; } ll n; while(std::cin\u003e\u003en){ if(n\u003e=mod) puts(\"0\");else std::cout\u003c\u003cfac[n]\u003c\u003cstd::endl; } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:1:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 排列组合 容斥原理 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 并查集模拟操作 每次的答案依赖于上一次的答案 对于当前给出的两个数 如果在一个集合内，则 ans = ans 如果不在一个集合内，假设一个在A集合，一个在B集合 num(S) 表示满足条件S的方案数 四元组为 Q 并查集的集合为 U 设合并A、B后的集合为C ans -= num(∃q ∈ Q , (q∈A) ∧ (Q\\q ∈ U\\(A , B) ) ) ans -= num(∃q ∈ Q , (q∈B) ∧ (Q\\q ∈ U\\(A , B) ) ) ans -= num(∃q1,q2 ∈ Q , (q1 ∈ A) ∧ (q2 ∈ B) ∧ (Q\\(q1 , q2) ∈ U\\(A , B) ) ans += num(∃q ∈ Q , (q ∈ C) ∧ (Q\\q ∈ U\\C) ) 由于12式和4式相抵消，所以实际只要操作3式 由于3式需要在并查集中选两个的方案数，所以维护两个变量 ans two (在并查集中选两个元素的方案数，选的元素可重复) 利用容斥原理和排列组合 num(∃q1,q2 ∈ Q , (q1 ∈ A) ∧ (q2 ∈ B) ∧ (Q\\(q1 , q2) ∈ U\\(A , B) ) = size(A) * size(B) * (two - (size(A) * (n - size(A)) - (size(B) * (n - size(B)) + size(A) * size(B) ) 更新完ans后更新two 初始化 ans = C(n,4) two = C(n,2) 数据规模大，用unsigned long long 注意这样初始化 ll ans = n*(n-1)/4*(n-2)/3*(n-3)/2; 而不是 ll ans = n*(n-1)*(n-2)*(n-3)/24; #include\u003cbits/stdc++.h\u003e using namespace std; using ll = unsigned long long; //using ld = long double; const int maxn = 1e5+3; ll n,m; ll par[maxn]; ll rankk[maxn]; ll sizz[maxn]; void init(ll n) { for(ll i=0;i\u003cn;i++) { par[i]=i; rankk[i]=0; } fill(sizz,sizz+n,1); } ll find(ll x) { if(par[x]==x) return x; else return par[x]=find(par[x]); } void unite(ll x,ll y) { x=find(x); y=find(y); if(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y,sizz[y]+=sizz[x]; else { par[y]=x; sizz[x]+=sizz[y]; if(rankk[x]==rankk[y]) rankk[x]++; } } bool same(ll x,ll y) { return find(x)==find(y); } int main(){ cin\u003e\u003en\u003e\u003em; ll two = n*(n-1)/2; ll ans = n*(n-1)/4*(n-2)/3*(n-3)/2; cout\u003c\u003cans\u003c\u003cendl; init(n); for(ll i=0;i\u003cm;i++){ ll x,y; cin\u003e\u003ex\u003e\u003ey; x--,y--; if(!same(x,y)){ ll szx = sizz[find(x)]; ll szy = sizz[find(y)]; ans -= (szx * szy * (two - szx * (n - szx) - szy * (n - szy) + szx * szy)); two -= szx * szy; unite(x,y); cout\u003c\u003cans\u003c\u003cendl; }else cout\u003c\u003cans\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:2:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"kmp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 先找既是前缀又是后缀的最长子串 这可以利用kmp的next数组 然后去掉原串的头尾作为匹配串，由next数组得到的作为模式串 再进行kmp匹配，如果匹配不成功，则在模式串中取前next[len]的长度 不断重复，直到与匹配串匹配 #include\u003cbits/stdc++.h\u003e using namespace std; char s[100005],p[100005],pp[100005],ppp[100005]; int n,m; int nextt[100005]; void get_next(){ int i=0,j=-1; nextt[0]=-1; while(i\u003cm){ if(j==-1 || p[i]==p[j]) nextt[++i]=++j; else j=nextt[j]; //!!! } } int kmp(){ int i=0,j=0; while(1){ if(s[i]==p[j]) i++,j++; else{ int t=nextt[j]; if(t==-1) i++,j=0; else j=t; } if(j\u003e=m) return i-m; if(i\u003e=n) return -1; } } int main(){ cin\u003e\u003ep; m = strlen(p); get_next(); int len = nextt[m]; strncpy(pp,p,len); len = strlen(p) - 2; strncpy(s,p+1,len); strcpy(p,pp); m = strlen(p); n = strlen(s); while(1){ if(kmp()!=-1){ cout\u003c\u003cp\u003c\u003cendl; break; }//else if(nextt[strlen(p)] == -1) break; else{ strncpy(ppp,p,nextt[strlen(p)]); //不能拷贝给自身 strcpy(p,ppp); m = strlen(p); //cerr\u003c\u003cp\u003c\u003cendl; } } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:3:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"换根dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 dpd[u] 表示以u为根的子树的连通块数 dpu[u] 表示u之上的连通块数 ans[u] 表示包含u的连通块数 假设 v 是 u 的子节点，p 是 u 的父节点 ，s 是 u 的兄弟节点 dpd[u] = (dpd[v1] + 1) * (dpd[v2] + 1) * (dpd[v3] + 1) * ... ans[u] = dpd[u] * (dpu[u] + 1) dpu[u] = ans[p] / (dpd[u] + 1) 当 (dpd[u] + 1) % mod = 0 时，模数无效，所以这种情况要特殊处理 dpu[u] = (dpu[p] + 1) * (dpd[s1] + 1) * (dpd[s2] + 1) * ... 两次dfs，一次求dpd，一次求dpu并更新ans #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 1e9 + 7; const int maxn = 1e6 + 5; struct edge{ int to , next; }e[maxn\u003c\u003c1]; ll tot,head[maxn\u003c\u003c1]; void add_edge(int u,int v){ e[tot].to = v; e[tot].next = head[u]; head[u] = tot++; } ll qpow(ll x,ll n) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } ll dpu[maxn],par[maxn],dpd[maxn],ans[maxn]; ll V; void dfs1(int u,int p){ dpd[u] = 1; par[u] = p; for(int i=head[u]; ~i ;i=e[i].next){ int v = e[i].to; if(v == p) continue; dfs1(v,u); dpd[u] *= (dpd[v] + 1); dpd[u] %= mod; } } void dfs2(int u,int p){ if(u != 1){ if((dpd[u] + 1) % mod){ dpu[u] = ans[p] * qpow(dpd[u] + 1 , mod - 2); dpu[u] %= mod; ans[u] = dpd[u] * (dpu[u] + 1); ans[u] %= mod; } else{ ll tmp = dpu[p] + 1; for(int i=head[p]; ~i ;i=e[i].next){ int v = e[i].to; if(v == par[p] or v == u) continue; tmp *= dpd[v] + 1; tmp %= mod; } dpu[u] = tmp; ans[u] = dpd[u] * (dpu[u] + 1); ans[u] %= mod; } } for(int i=head[u]; ~i ;i=e[i].next){ int v = e[i].to; if(v == p) continue; dfs2(v,u); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); memset(head,-1,sizeof(head)); cin\u003e\u003eV; for(int i=0;i\u003cV-1;i++){ ll x,y; cin\u003e\u003ex\u003e\u003ey; add_edge(x,y); add_edge(y,x); } dfs1(1,0); ans[1] = dpd[1]; dfs2(1,0); for(int i=1;i\u003c=V;i++){ cout\u003c\u003cans[i]\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:4:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"贪心 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把L大的放左边，把R大的放右边 假设L大的有a个，R大的有b个 可以把他们分开放置 先处理前a个位置（这些都放置L大的数） 再处理后b个位置（这些都放置R大的数） 对于前a个位置 遍历L大的集合（L大的排前面） 对于当前数，贪心地把它放在不超过k的最右边 如果不满足条件，就放在区间的最右边（此时放哪里，贡献都一样，为了给别的数腾出位置，贪心地放在最右边） 对于后b个位置 遍历R大的集合（R大的排前面） 对于当前数，贪心地把它放在超过k的最左边 如果不满足条件，就放在区间的最左边（此时放哪里，贡献都一样，为了给别的数腾出位置，贪心地放在最左边） #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; vector\u003cpair\u003cint,int\u003e\u003e vL; vector\u003cpair\u003cint,int\u003e\u003e vR; int t; int n; set\u003cint\u003e sL; set\u003cint\u003e sR; #define fi first #define se second int main(){ cin\u003e\u003et; while(t--){ ll ans = 0; cin\u003e\u003en; vL.clear(); vR.clear(); for(int i=0;i\u003cn;i++){ int k,l,r; cin\u003e\u003ek\u003e\u003el\u003e\u003er; if(l\u003cr) vR.push_back({l-r,k}); else vL.push_back({l-r,k}); ans += r; } for(int i=1;i\u003c=vL.size();i++) sL.insert(i); for(int i=vL.size()+1;i\u003c=n;i++) sR.insert(i); sort(vL.begin(),vL.end(),greater\u003cpair\u003cint,int\u003e\u003e()); sort(vR.begin(),vR.end()); for(auto i:vL){ auto tmp = sL.upper_bound(i.se); if(tmp == sL.begin()){ sL.erase(--sL.end()); }else{ ans += i.fi; sL.erase(--tmp); } } for(auto i:vR){ auto tmp = sR.upper_bound(i.se); if(tmp == sR.end()) { sR.erase(sR.begin()); ans += i.fi; } else{ sR.erase(tmp); } } cout\u003c\u003cans\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:5:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"栈 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 栈的经典应用 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll a[10005]; stack\u003cint\u003e sk; int ans[10005]; int main(){ ll n; cin\u003e\u003en; for(int i=0;i\u003cn;i++) { cin\u003e\u003ea[i]; } int i = 0; while(i \u003c n){ if(sk.empty() or a[i] \u003c= a[sk.top()]){ sk.push(i); i++; } else{ ans[sk.top()] = i; sk.pop(); } } while(!sk.empty()){ ans[sk.top()] = -1; sk.pop(); } for(int i=0;i\u003cn;i++) cout\u003c\u003cans[i]+1\u003c\u003c\" \"; cout\u003c\u003c\"\\n\"; return 0; } ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:6:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"树链剖分 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 树链剖分裸题 线段树需支持区间平方和操作 这道题用int不能过 注意细节 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll maxn = 1e5+10; struct edge{ ll to,nxt; }e[maxn\u003c\u003c1]; struct tnode{ ll w,l,r,siz,alazy; ll sq,mlazy=1LL; }tn[maxn\u003c\u003c2]; ll wch[maxn],sz[maxn],head[maxn],wt[maxn],dep[maxn],dfn[maxn],par[maxn],top[maxn],rdfn[maxn]; ll n,q; const ll mod = 23333; ll cnt_e; ll cnt_d; void add_edge(ll u,ll v){ e[++cnt_e].to = v; e[cnt_e].nxt = head[u]; head[u] = cnt_e; } void dfs1(ll u,ll p){ sz[u] = 1; for(ll i = head[u]; i ; i=e[i].nxt){ ll t = e[i].to; if(t != p){ dep[t] = dep[u] + 1; par[t] = u; dfs1(t,u); sz[u] += sz[t]; if(sz[t] \u003e sz[wch[u]]) wch[u] = t; } } } void dfs2(ll u,ll p,ll tp){ top[u] = tp; dfn[u] = ++cnt_d; rdfn[cnt_d] = u; if(wch[u]){ dfs2(wch[u],u,tp); } for(ll i=head[u]; i ; i=e[i].nxt){ ll t = e[i].to; if(t != p and t != wch[u]){ dfs2(t,u,t); } } } void pushup(ll u){ tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod; tn[u].sq = (tn[u\u003c\u003c1].sq + tn[u\u003c\u003c1|1].sq) % mod; } void build(ll u,ll l,ll r){ tn[u].l = l; tn[u].r = r; tn[u].siz = r - l + 1; if(l == r){ tn[u].w = wt[rdfn[l]]; tn[u].sq = wt[rdfn[l]] * wt[rdfn[l]]; return ; } ll mid = (l+r) \u003e\u003e 1; build(u\u003c\u003c1 , l , mid); build(u\u003c\u003c1|1 , mid+1 , r); pushup(u); } void pushdown(ll u){ if(tn[u].alazy != 0 or tn[u].mlazy != 1){ tn[u\u003c\u003c1].sq = ((tn[u\u003c\u003c1].sq + 2LL * tn[u\u003c\u003c1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1].siz % mod) % mod; tn[u\u003c\u003c1|1].sq = ((tn[u\u003c\u003c1|1].sq + 2LL * tn[u\u003c\u003c1|1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1|1].siz % mod) % mod; tn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1].siz * tn[u].alazy % mod) % mod; tn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1|1].siz * tn[u].alazy % mod) % mod; tn[u\u003c\u003c1].alazy = (tn[u\u003c\u003c1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u003c\u003c1|1].alazy = (tn[u\u003c\u003c1|1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u003c\u003c1].mlazy = (tn[u\u003c\u003c1].mlazy * tn[u].mlazy) % mod; tn[u\u003c\u003c1|1].mlazy = (tn[u\u003c\u003c1|1].mlazy * tn[u].mlazy) % mod; tn[u].alazy = 0; tn[u].mlazy = 1; } } ll query(ll u,ll l,ll r,ll t){ if(l\u003c=tn[u].l and r\u003e=tn[u].r) { if(t == 1) return tn[u].w; if(t == 2) return tn[u].sq; } ll ans = 0; pushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1; if(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r , t)) % mod; if(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r , t)) % mod; return ans; } void update(ll u,ll l,ll r,ll wa,ll wm){ if(l\u003c=tn[u].l and r\u003e=tn[u].r){ tn[u].sq = ((tn[u].sq + 2LL * tn[u].w * wa % mod) % mod + wa * wa % mod * tn[u].siz % mod) % mod; tn[u].w = (tn[u].w * wm % mod + tn[u].siz * wa % mod) % mod; tn[u].alazy = (tn[u].alazy * wm % mod + wa) % mod; tn[u].mlazy = (tn[u].mlazy * wm) % mod; return ; } pushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1; if(l\u003c=mid) update(u\u003c\u003c1, l , r , wa , wm); if(r\u003emid) update(u\u003c\u003c1|1, l , r , wa , wm); pushup(u); } int main(){ cin\u003e\u003en\u003e\u003eq; for(ll i=1;i\u003c=n;i++){ scanf(\"%lld\",\u0026wt[i]); } for(ll i=0;i\u003cn-1;i++){ ll x,y; scanf(\"%lld %lld\",\u0026x,\u0026y); add_edge(x,y); add_edge(y,x); } dfs1(1,0); dfs2(1,0,1); build(1,1,n); for(ll i=0;i\u003cq;i++){ ll t; scanf(\"%lld\",\u0026t); if(t==1){ ll x,y; scanf(\"%lld %lld\",\u0026x,\u0026y); update(1,dfn[x],dfn[x]+sz[x]-1,y%mod,1LL); } else{ ll x; scanf(\"%lld\",\u0026x); printf(\"%lld\\n\", query(1,dfn[x],dfn[x]+sz[x]-1,2)); } } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:7:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"计算几何 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 两两求圆心，圆心相同表示能在同一个圆上 求最多的圆心数量 需要固定一个点，每次换点时求一次max，如果在遍历完所有点对求max，就变成排列组合 #include\u003cbits/stdc++.h\u003e using namespace std; using db = double; struct point{ db x,y; }ps[2005]; map\u003cpair\u003cdb,db\u003e,int\u003e mp; db X,Y; inline db out(point a,point b,point c) { return (c.x - a.x) * (c.y - b.y) - (c.y - a.y) * (c.x - b.x); } bool circle_center(point a,point b,point c){ if(out(a,b,c) == 0 ) return false; db a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2; db a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2; db d = a1 * b2 - a2 * b1; X = a.x + (c1 * b2 - c2 * b1) / d , Y = a.y + (a1 * c2 - a2 * c1) / d; return true; } int main(){ int n; cin\u003e\u003en; for(int i=0;i\u003cn;i++) { cin\u003e\u003eps[i].x; cin\u003e\u003eps[i].y; } int ans = 0; for(int i=0;i\u003cn;i++){ mp.clear(); for(int j=i+1;j\u003cn;j++){ if(circle_center((point){0,0} , ps[i] , ps[j])) mp[{X,Y}]++; } int tmp = 0; for(auto i:mp) tmp = max(tmp , i.second); ans = max(ans , tmp); } cout\u003c\u003cans+1\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:8:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 并查集模改 细节参考官方题解 并查集模拟操作，链表维护相同颜色的节点 注意要记录初始的状态（debug好久） #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 8e5 + 10; vector\u003cint\u003e G[maxn]; list\u003cint\u003e ls[maxn]; int par[maxn]; void init(int n) { for(int i=0;i\u003cn;i++) { par[i]=i; ls[i].push_back(i); } } int find(int x) { if(par[x]==x) return x; else return par[x]=find(par[x]); } int main(){ int t; cin\u003e\u003et; while(t--){ int n,m; cin\u003e\u003en\u003e\u003em; //reset for(int i = 0;i\u003c=n;i++) { G[i].clear(); ls[i].clear(); } for(int i = 0;i\u003cm;i++){ int x,y; cin\u003e\u003ex\u003e\u003ey; G[x].push_back(y); G[y].push_back(x); } init(n); int q; cin\u003e\u003eq; while(q--){ int x; cin\u003e\u003ex; if(x != par[x]) continue; int sz = ls[x].size(); //记录初始的链表大小 int px = find(x); //记录初始的根节点 while(sz--){ int cnt = ls[x].front(); ls[x].pop_front(); for(int i:G[cnt]){ int pi = find(i); //记录初始的根节点 if(px == pi) continue; par[pi] = px; //这样合并 ls[x].splice(ls[x].end() , ls[pi]); } } } for(int i=0;i\u003cn;i++) cout\u003c\u003cfind(i)\u003c\u003c\" \"; puts(\"\"); } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:9:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 1和大于n/2的质数都不能匹配 先处理质因子稀有的数，就是从大到小遍历质数 然后把含有这个质因子的数两两匹配 如果含有这个质因子的数的个数是奇数个 就不匹配 2*p 这个数，留给下一个质因子，因为2是最多的质因子 #include \"bits/stdc++.h\" using namespace std; const int maxnn = 2e5+10; bool isprime[maxnn]; void e_sieve(int n = maxnn){ for(int i = 1;i\u003cn;i++){ isprime[i] = true; } isprime[0] = isprime[1] = false; for(int i = 2;i \u003c n;i++){ if(isprime[i]){ for(int j = 2 * i ; j \u003c n ; j += i){ isprime[j] = false; } } } } int use[maxnn] ; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); e_sieve(); int t; cin\u003e\u003et; while (t--){ int n; cin\u003e\u003en; for(int i = 1; i \u003c= n ; i++) use[i] = 0; vector\u003cpair\u003cint,int\u003e\u003e ans; for(int i = n/2 ; i \u003e= 2 ; --i){ if(isprime[i]){ vector\u003cint\u003e tmp; for(int j = i; j \u003c= n ; j += i){ if(use[j] == 0){ tmp.push_back(j); } } if(tmp.size() \u0026 1){ for(int x = 0 ; x \u003c tmp.size() ; ++x){ if(tmp[x] == i * 2) tmp.erase(tmp.begin() + x); } } for(int i = 0 ; i \u003c tmp.size() - 1 ; i += 2){ ans.push_back({tmp[i] , tmp[i+1]}); use[tmp[i]] = 1; use[tmp[i+1]] = 1; } } } //for(int i = 2; i \u003c 20 ; i++) cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cisprime[i]\u003c\u003c\"\\n\"; cout\u003c\u003cans.size()\u003c\u003cendl; for(auto i : ans){ cout\u003c\u003ci.first\u003c\u003c\" \"\u003c\u003ci.second\u003c\u003cendl; } } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:10:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 如果没有 d\u003cb f\u003cb 的条件直接让 d = f = b 如果 a/b 能约分成 a’ / b' 则 d = f = b' e = 1 , c = a‘+1（随便赋值） 如果 a/b不能约分 就把b分解质因数（预处理每个数最小的质因子） 设b分解成 p1 p2 如果p1 p2 有1 无解 否则根据通分公式 d = p1 , f = p2 cf - de = a 因为d f是b的因子 ，b 和 a 互质 ，所以gcd(f/a , d/a) = 1 -(d/a)e + c(f/a) = 1 用扩展欧几里得公式求出 c e e = -e 如果 e c有负数 ，正数化 然后 e c 都乘上 a #include \"bits/stdc++.h\" using namespace std; using ll = long long; const ll maxn = 2e6+10; ll gcd(ll a , ll b){ return b == 0 ? a : gcd(b , a % b); } bool isprime[maxn+1]; //is i a prime number ll minp[maxn+1]; void e_sieve(int n = maxn) { for(int i=0;i\u003c=n;i++) isprime[i]=true; //initialize isprime[0]=isprime[1]=false; for(int i=2;i\u003c=n;i++) { if(isprime[i]) { for(int j=2*i;j\u003c=n;j+=i) isprime[j]=false; } } for(ll i = 2 ; i \u003c= n; i++){ if(isprime[i]){ for(ll j = i; j \u003c= n; j += i){ if(minp[j] == 0) minp[j] = i; } } } } ll ex_gcd(ll a,ll b,ll\u0026 x,ll\u0026 y) { ll t,res; if(!b) { x=1;y=0;return a; } else { res=ex_gcd(b,a%b,x,y); t=x; x=y;y=t-a/b*y; return res; } } int main() { #ifdef LOCAL freopen(\"in1.txt\", \"r\", stdin); freopen(\"out1.txt\", \"w\", stdout); #endif e_sieve(); //for(int i = 2; i\u003c 100;i++) cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cminp[i]\u003c\u003cendl; int _; cin \u003e\u003e _; while (_--) { ll a, b; cin \u003e\u003e a \u003e\u003e b; ll c , d , e , f; ll t = gcd(a , b); if(t != 1){ a /= t; b /= t; d = f = b; e = 1; c = a + 1; cout\u003c\u003cc\u003c\u003c\" \"\u003c\u003cd\u003c\u003c\" \"\u003c\u003ce\u003c\u003c\" \"\u003c\u003cf\u003c\u003cendl; continue; } ll p1 = 1,p2 = b,p = minp[b]; if(p == 0) { cout\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003cendl; continue; } while(p2 % p == 0){ p2 /= p; p1 *= p; } if(p2 == 1){ cout\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003c\" \"\u003c\u003c-1\u003c\u003cendl; continue; } d = p1; f = p2; ex_gcd(d, f, e, c); e = -e; if(e \u003c= 0 or c \u003c= 0){ ll et = (e % f + f) % f; ll ct = (c % d + d) % d; ll mm = max(0ll , max((et - e) / f , (ct - c) / d)); e += f * mm; c += d * mm; } e *= a; c *= a; cout\u003c\u003cc\u003c\u003c\" \"\u003c\u003cd\u003c\u003c\" \"\u003c\u003ce\u003c\u003c\" \"\u003c\u003cf\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:11:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"计算几何 区间dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 很难的一道题 由于切割的方案数太多，所以考虑dp dp[i][j] 表示点 i 到点 j 的答案 转移方程 dp[i][j] = min(dp[i][j] , max( max (dp[i][k] , dp[k][j]) , area(ps[i] , ps[j] , ps[k]) ) ) 计算面积直接用外积 1/2 * (A-\u003eB) X (A-\u003eC) 由于题目存在凹多边形的情况 所以当有点在三角形 i j k中，这个区间不可分割（根据面积判断，这个技巧可以用于求一个点是否在凸多边形内） dp的初始化 dp[i][i+2] = area(ps[i] , ps[i+1] , ps[i+2]) dp[i][i] = dp[i][i+1] = 0 dp[i][i+m] = inf [m\u003e2] 几个注意点 用eps ， 初始化只有一类为inf ， 用外积求面积要加绝对值 ， dp的遍历先遍历区间长度（因为从小的先更新，大的区间依赖于小的，这也是很多区间dp要求的） #include \"bits/stdc++.h\" using namespace std; using ll = long long; const int inf = 0x3f3f3f3f; const int maxn = 105; double eps = 1e-10; struct point{ double x,y; }ps[maxn]; double dp[maxn][maxn]; int n; //a-\u003ec X b-\u003ec double area(point a,point b,point c) { return fabs((c.x - a.x) * (c.y - b.y) - (c.y - a.y) * (c.x - b.x)) / 2; } bool judge(int a,int b,int c){ double s = area(ps[a], ps[b], ps[c]); for(int i =1;i\u003c=n;i++){ if(i == a or i == b or i == c) continue; double t = area(ps[i],ps[a],ps[b]) + area(ps[i],ps[a],ps[c]) + area(ps[i],ps[b],ps[c]); if(fabs(t - s) \u003c eps) return false; } return true; } int main() { #ifdef LOCAL freopen(\"in1.txt\", \"r\", stdin); freopen(\"out1.txt\", \"w\", stdout); #endif ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while(cin\u003e\u003en){ for(int i=1;i\u003c=n;i++){ cin\u003e\u003eps[i].x\u003e\u003eps[i].y; if(i\u003e=3){ dp[i-2][i] = area(ps[i] , ps[i-1] , ps[i-2]); } } for(int len = 3 ; len \u003c= n ; len++){ for(int i = 1,j = i+len;j\u003c=n;i++,j++){ dp[i][j] = inf; for(int k = i + 1 ; k \u003c j ; k++){ if(judge(i,j,k)){ dp[i][j] = min(dp[i][j] , max(max(dp[i][k] , dp[k][j]) , area(ps[i] , ps[j] , ps[k]))); } } } } printf(\"%.1lf\\n\", dp[1][n]); } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:12:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"并查集 思维 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 选择权值不为0的极大连通块，全部-1，不断重复，并记录操作次数 由于点变成0后要从连通块中分裂出来很麻烦，所以考虑倒着来，即单个点合并成连通块 权值从大到小处理，对于u先假设它是单点，ans+=该点的权值，标记为访问 对于它相邻的点v，如果访问过（表示v比u权值大）但不在一个集合内，则合并，然后减去u的权值 因为u和v在一个集合内，v和u共享了u的权值次操作 注意用scanf //#include \"bits/stdc++.h\" #include \"iostream\" #include \"algorithm\" #include \"vector\" using namespace std; using ll = long long; const int maxn = 100005; pair\u003cint,int\u003e b[maxn]; vector\u003cint\u003e G[maxn]; //union find int par[maxn]; int rankk[maxn]; int sz[maxn]; int used[maxn]; void init(int n) { for(int i=0;i\u003cn;i++) { par[i]=i; rankk[i]=0; } } int find(int x) { if(par[x]==x) return x; else return par[x]=find(par[x]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y; else { par[y]=x; if(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y) { return find(x)==find(y); } int main() { #ifdef LOCAL freopen(\"in1.txt\", \"r\", stdin); freopen(\"out1.txt\", \"w\", stdout); #endif int _; cin \u003e\u003e _; while (_--) { int n,m; scanf(\"%d%d\",\u0026n,\u0026m); for(int i=0;i\u003c=n;i++) G[i].clear(); for(int i=1;i\u003c=n;i++) { scanf(\"%d\",\u0026b[i].first); b[i].second = i; } for(int i=0;i\u003cm;i++){ int u,v; scanf(\"%d%d\",\u0026u,\u0026v); G[u].push_back(v); G[v].push_back(u); } sort(b+1,b+n+1,[](pair\u003cint,int\u003e a,pair\u003cint,int\u003e b){return a.first\u003eb.first;}); init(n+1); for(int i=0;i\u003c=n;i++) used[i] = 0; ll ans = 0; for(int i=1;i\u003c=n;i++){ ans += b[i].first; used[b[i].second] = 1; for(int j:G[b[i].second]){ if(used[j]){ if(!same(b[i].second,j)){ unite(b[i].second,j); ans -= b[i].first; } } } } cout\u003c\u003cans\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:13:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"哈希 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把问题转化成求 A * B = C + Fk 由于k很大，所以这些数会溢出，用除余法哈希，除数选择不超过ull的数，然后遍历k找到满足C + Fk等于 A * B的k 实际上不哈希也可以，所以数都自然溢出（可以看做是特殊的哈希），也可以找到答案 #include \"bits/stdc++.h\" using namespace std; using ull = unsigned long long; ull fib[2000005]; ull a,b,c; int n; void init(){ fib[1] = 1; fib[2] = 2; for(int i=3;i\u003c2000005;i++){ fib[i] = fib[i-1] + fib[i-2]; } } void cal(ull \u0026x,int n){ x = 0; for(int i=1;i\u003c=n;i++){ int t; scanf(\"%d\",\u0026t); if(t){ x += fib[i]; } } } int main() { #ifdef LOCAL freopen(\"in1.txt\", \"r\", stdin); freopen(\"out1.txt\", \"w\", stdout); #endif init(); int _; cin \u003e\u003e _; while (_--) { a = b = c = 0; scanf(\"%d\",\u0026n); cal(a,n); scanf(\"%d\",\u0026n); cal(b,n); scanf(\"%d\",\u0026n); cal(c,n); a *= b; for(int i=1;i\u003c=n;i++){ if(fib[i] + c == a){ printf(\"%d\\n\",i); continue; //应该是break 但这样也不会超时 } } } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:14:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"置换群 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:15:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 求排列中每个循环的长度，对它们求lcm 注意大数（可不必取模） 贴一份队友的代码 def gcd(a, b): return a if b == 0 else gcd(b, a % b) def dfs(i): global vis u = i ans = 1 while p[i] != u: ans += 1 vis[i] = 1 i = p[i] return ans n = int(input()) MOD = pow(10, n) vis = [0] * 100007 p = [0] * 100007 pp = list(map(int, input().split())) for i in range(1, n + 1): p[i] = pp[i-1] ans = 1 for i in range(1, n + 1): if vis[i] == 1: continue k = dfs(i) ans = ((ans * k) // gcd(ans, k)) % MOD print(ans) =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:15:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 LIS 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:16:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 invert操作不会改变数的相对位置，drop2操作会改变数的相对位置 drop2操作是把最后一个数之前的数往数列头部移动 由于这两种操作的性质，把数列看成一个环 那么invert操作就是旋转环，drop2操作就是把最后一个数（在环里就是任意一个数）插到任意位置上 所以问题转化成对于一个数列（排列），最少有多少次“将任意数插入到任意位置上”的操作，使得数列递增 操作数 = n - len(LIS) , 对于环的不同起始位置求LIS，取最大值 时间复杂度 O(n*n*logn) #include \"bits/stdc++.h\" using namespace std; using ll = long long; int dp[505]; const int inf = 0x3f3f3f3f; int a[1010]; int main() { int n; int ma = -1 ; scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;++i){ cin\u003e\u003ea[i]; } int i,j; for(i=0;i\u003cn;i++){ fill(dp,dp+n,inf); for(j=i;j\u003ci+n;j++){ *lower_bound(dp,dp+n,a[j]) = a[j]; } ma = max(ma , (int)(lower_bound(dp,dp+n,inf) - dp)); a[j] = a[i]; } cout\u003c\u003cn-ma\u003c\u003c\"\\n\"; return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:16:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"数据结构 实现 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:17:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于每个数，判断能否把前min(i,k)个数作为一个排列，即在它的后面放置切割 判断是否是排列，即判断这些数中每个数是否只出现一次，出现次数可以用unordered_map记录(map超时) 想了一个非常复杂的方法，不知道怎么实现，以下是参考了别人的代码，实现效率非常高 #include \"iostream\" #include \"unordered_map\" #include \"cstring\" #pragma GCC optimize(2) using namespace std; typedef long long ll; int a[500005],cut[500005]; unordered_map\u003cint,int\u003e mp; inline int read() { int x=0;int f=1;char s=getchar(); while(s\u003c'0' or s\u003e'9') { if(s=='-') f-=1; s=getchar(); } while(s\u003e='0' and s\u003c='9') { x=x*10+s-'0'; s=getchar(); } return x*f; } int main() { int _; _ = read(); while (_--) { mp.clear(); int flag = 0; int n,k; n = read() , k = read(); for (register int i = 1; i \u003c= n; ++i) { a[i] = read(); if(a[i] \u003e k) { flag = 1; break; } } if(flag) { puts(\"NO\"); continue; } int dif_num = 0; memset(cut , 0 , sizeof(cut)); cut[0] = 1; for(register int i=1;i\u003c=n;++i){ if(i \u003e k) { if (mp[a[i - k]] == 1) dif_num-- ; mp[a[i - k]]--; } if(mp[a[i]] == 0) dif_num++; mp[a[i]]++; if(dif_num == k or dif_num == i){ cut[i] = (i\u003e=k ? cut[i-k] : 1); } } dif_num = 0 ; mp.clear(); flag = 0; for(register int i=n;i\u003e=max(n-k,0);--i){ if(dif_num == n-i and cut[i] == 1){ flag = 1; break; } if(mp[a[i]] == 0) dif_num++; mp[a[i]]++; } flag ? puts(\"YES\") : puts(\"NO\"); } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:17:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"状态压缩dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:18:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于铁路线，肯定是过某个点最划算，而且是过不同的点，即一个点一条线穿过 所以枚举即将被穿线的点集，每个点有被特定的一条线穿过，穿过的方式有横线、竖线（对于特定的点集，枚举横线竖线的所有情况） 对于每种情况，更新答案 （两条铁路重合的情况不会影响答案，因为这始终不是最优解） 玄学时间复杂度 O(sum(2^i * C(n,i) * n * n) 应该有千亿计算量 一直以为会超时，想把n*n优化成O(1) 无果，看了别人的做法，居然不会超时？？？ 最后跑了2700+ms ，时限是3000ms 注意long long的强制类型转化 实际上还有更快的暴力方法和dfs，但我不会 #include \"bits/stdc++.h\" using namespace std; using ll = long long; int n,x[16],y[16],d[16],D[16],p[16]; ll ans[16]; int main() { memset(ans , 0x3f , sizeof(ans)); cin \u003e\u003e n; for(int i=0;i\u003cn;i++){ cin\u003e\u003ex[i]\u003e\u003ey[i]\u003e\u003ep[i]; } for(int i=0;i\u003cn;i++){ D[i] = min(abs(x[i]) , abs(y[i])); } ans[0] = 0; for(int i=0;i\u003cn;i++){ ans[0] += (ll)D[i]*p[i]; } for(int i=1;i\u003c(1\u003c\u003cn);i++){ int j = i; do{ memcpy(d,D,sizeof(D)); for(int k=0;k\u003cn;k++){ if(i\u003e\u003ek\u00261){ if(j\u003e\u003ek\u00261){ for(int q=0;q\u003cn;q++){ d[q] = min(d[q] , abs(x[q] - x[k])); } } else{ for(int q=0;q\u003cn;q++){ d[q] = min(d[q] , abs(y[q] - y[k])); } } } } ll tmp = 0; for(int i=0;i\u003cn;i++) tmp += (ll)d[i] * p[i]; ans[__builtin_popcount(i)] = min(ans[__builtin_popcount(i)] , tmp); j = (j-1) \u0026 i; }while(j != i); } for(int i=0;i\u003c=n;i++) cout\u003c\u003cans[i]\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:18:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"01背包问题 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:19:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 01背包问题模改 dp[i][j][k] 表示前i个从者，前j个装备，容量为k的最大价值 由于从者和装备是平级的，所以分别对它们用01背包问题 但是有约束条件，装备数量不多于从者，从者最多选5个 所以应该这样dp ， dp[a][i][b][j][k] 表示从前i个选a个，从前j个选b个，容量为k的最大价值，其中a，b只需遍历到5 但这样内存超限，由于01背包问题可以从2维降到1维（重复利用，滚动原理），所以这个dp也可以将2维 dp[i][j][k] 表示选i个从者，j个装备，容量为k的最大价值 由于装备数量不多于从者，所以先枚举从者（即j=0），然后枚举不大于从者的装备 最后3重循环求最大值 #include \"bits/stdc++.h\" #include \"algorithm\" using namespace std; using ll = long long; int dp[6][6][140]; int a1[305],c1[305],a2[305],c2[305]; int main() { int n,m,c; cin\u003e\u003en\u003e\u003em\u003e\u003ec; for(int i=1;i\u003c=n;i++) cin\u003e\u003ea1[i]\u003e\u003ec1[i]; for(int i=1;i\u003c=m;i++) cin\u003e\u003ea2[i]\u003e\u003ec2[i]; memset(dp,0xc0,sizeof(dp)); dp[0][0][0] = 0; for(int i=1;i\u003c=n;i++){ for(int j=c;j\u003e=c1[i];j--){ for(int k=1;k\u003c=5;k++){ dp[k][0][j] = max(dp[k][0][j] , dp[k-1][0][j-c1[i]] + a1[i]); } } } for(int i=1;i\u003c=m;i++){ for(int j=c;j\u003e=c2[i];j--){ for(int k=1;k\u003c=5;k++){ for(int x=1;x\u003c=k;x++){ dp[k][x][j] = max(dp[k][x][j] , dp[k][x-1][j-c2[i]] + a2[i]); } } } } int ans = -1; for(int i=1;i\u003c=5;i++){ for(int j=0;j\u003c=i;j++){ for(int k=0;k\u003c=c;k++){ ans = max(ans , dp[i][j][k]); } } } cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:19:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"容斥原理 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:20:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 考虑特定的k种颜色的染色方案，那么答案就乘上 C(m,k) 如果是选k种颜色涂色，方案数就是 k(k-1)^(n-1) 但这是不多于k种颜色的方案，对于“恰好”的方案，可以考虑用容斥原理 设不多于k种颜色的方案为f(k) exactly(k) = f(k) - ( f(k-1) - ( f(k-2) - ( f(k-3) - ( f(k-4) -… f(1) )))) f(k) - part 锁定了第k个元素必须使用，f(k-1) - part锁定了k-1个元素必须使用，以此类推 把括号打开，就是容斥原理的结构 exactly(k) = f(k) - f(k-1) + f(k-2) - f(k-3) + f(k-4) … f(1) 由于在加减的过程中不断锁定第i个元素，但没有指定在哪个位置锁定这个元素，所以f要乘上所有的方案数 即F(i) = C(k,i)f(i) 所以答案为 $$ C_{m}^{k}\\sum\\limits_{i=0} ^ {k-1} {(-1)^iC_{k}^{k-i}(k-i)(k-i-1)^{n-1}} $$ #include \"bits/stdc++.h\" using namespace std; using ll = long long; ll ans,n,m,k; const int maxn = 1e6+10; const ll mod = 1e9+7; ll qpow(ll x,ll n) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } ll inv[maxn]; ll fac[maxn]; inline ll C(ll m,ll n){ return fac[n]*inv[m]%mod*inv[n-m]%mod; } int main() { for(ll i=0;i\u003cmaxn;i++){ fac[i]=1; } for(ll i=2;i\u003cmaxn;i++){ fac[i]=(fac[i-1]*i)%mod; } inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003cmaxn;i++){ inv[i]=(mod-mod/i)*inv[mod%i]%mod; } for(ll i=2;i\u003cmaxn;i++){ inv[i]=(inv[i]*inv[i-1])%mod; } int _; cin \u003e\u003e _; while (_--) { ll ckm = 1; ans = 0; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; for(ll i=0;i\u003ck;i++){ ckm *= (m-i); ckm %= mod; } ckm *= inv[k]; ckm %= mod; int sign = 1; for(int i = k; i \u003e0 ; --i){ ll tmp = 1; tmp *= C(i,k); tmp %= mod; tmp *= i; tmp %= mod; tmp *= qpow(i-1 , n-1); tmp %= mod; if(sign == 1) ans += tmp ; else ans -= tmp; ans += mod; ans %= mod; sign = -sign; } ans *= ckm; ans %= mod; cout\u003c\u003cans\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:20:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"bfs 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:21:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 问题转化成创建一条路径连通三个国家，使路径长度最短 那么路径一定汇集于一个点 这就是bfs问题，枚举每个点，求它们到每个国家的最小值，然后和的最小值就是答案，但这样会超时 以每个国家为起点，bfs到每个点，这样每个点会得到三个信息（分别到三个国家的最短距离），和的最小值就是答案，不会超时 当这个点是平地时，距离和-2，因为它被创造了三条公路 我的bug：用fill初始化产生错误，用memset初始化正常，bfs时当点是国家时，距离不需要+1 ， 在求距离和时，要将一个数强制类型转化成long long，它才会升级 #include \"bits/stdc++.h\" using namespace std; using ll = long long; int n,m; char maze[1005][1005]; int dist[1003][1003][4]; using pii = pair\u003cint,int\u003e; int dir[4][2] = { {0,1} , {1,0} , {-1,0} , {0,-1} }; const ll inf = 0x3f3f3f3f; void bfs(int x){ queue\u003cpii\u003e q; char ch = '0' + x; for(int i=0;i\u003cn;i++)for(int j=0;j\u003cm;j++){ if(maze[i][j] == ch) { dist[i][j][x] = 0; q.push({i,j}); } } while(q.size()){ pii tmp = q.front(); q.pop(); for(int i=0;i\u003c4;i++){ int xt = tmp.first + dir[i][0]; int yt = tmp.second + dir[i][1]; if(maze[xt][yt] == '#') continue; if(xt \u003c0 or yt\u003c0 or xt\u003e=n or yt\u003e=m) continue; int cost = (maze[xt][yt] == '.'); if(dist[tmp.first][tmp.second][x] + cost \u003c dist[xt][yt][x]){ dist[xt][yt][x] = dist[tmp.first][tmp.second][x] + cost; q.push({xt,yt}); } } } } int main() { cin\u003e\u003en\u003e\u003em; memset(dist , inf , sizeof(dist)); for(int i=0;i\u003cn;i++){ scanf(\"%s\",\u0026maze[i]); } bfs(1);bfs(2);bfs(3); ll ans = inf; for(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++){ if(maze[i][j] == '#') continue; ll sum = (ll)dist[i][j][1] + dist[i][j][2] + dist[i][j][3]; if(maze[i][j] == '.') sum -= 2; ans = min(ans , sum); } cout\u003c\u003c(ans == inf ? -1 : ans)\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:21:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dfs 图论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:22:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 把问题转化成求在所有简单路径中，每个点被遍历了几次，如果是偶数次，异或和为0，奇数次异或和为本身 这样就是图论中求所有简单路径XX被遍历几次的经典模型，基础的有边和点 如果是边 $$ f(edge) = size[x] * ( n - size[x]) $$ 如果是点，考虑三种情况，以这个点为端点，有n-1条，这个点的子树连到子树外面有 (size[x] - 1) * ( n - size[x]) ， 这个点的子节点的子树连到另外一个子节点的子树有 (sum(size[ch] * (size[x] - 1 - size[ch]))) / 2 除以2因为每个点都作为起点和终点一次，但这样只有一条 $$ f(node) = n-1 + (size[x] - 1) * (n-size[x]) + \\frac{\\sum\\limits_{} ^ {} {size[ch] * (size[x] - 1 - size[ch])} }{2} $$ 还有另一种算法 $$ f(node) = \\frac{\\sum{f(edge) [connected \\ to \\ node]+ n-1} }{2} $$ #include \"bits/stdc++.h\" using namespace std; using ll = long long; vector\u003cll\u003e G[500005]; ll sz[500005]; ll a[500005]; ll ans ; ll n; ll dfs(ll u,ll p){ sz[u] = 1; for(ll i:G[u]){ if(i == p) continue; sz[u] += dfs(i,u); } ll sum = 0; for(ll i:G[u]){ if(i == p) continue; sum += sz[i] * (sz[u] - 1 - sz[i]) ; } sum /= 2; sum += (sz[u] - 1) * (n - sz[u]); sum += n - 1; if(sum\u00261) ans ^= a[u]; return sz[u]; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003en; for(ll i=0;i\u003cn-1;i++){ ll x,y; cin\u003e\u003ex\u003e\u003ey; G[x].push_back(y); G[y].push_back(x); } for(ll i=1;i\u003c=n;i++) cin\u003e\u003ea[i]; dfs(1,0); cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:22:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 高精度 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:23:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 这道题主要是发现高精度，理论上ans会达到 1e9*1e5*1e5 以下是__int128的输入输出模板（支持负数） #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef __int128 INT ; const INT N=1e5+5; INT a[N],b[N],s[N],m[N]; inline INT read(){ INT x=0,f=1; char ch=getchar(); while(ch\u003c'0'||ch\u003e'9'){ if(ch=='-') f=-1; ch=getchar(); } while(ch\u003e='0'\u0026\u0026ch\u003c='9'){ x=x*10+ch-'0'; ch=getchar(); } return x*f; } inline void write(INT x){ if(x\u003c0){ putchar('-'); x=-x; } if(x\u003e9) write(x/10); putchar(x%10+'0'); } int main(){ INT t,n; t = read(); for(int u=1;u\u003c=t;u++){ n = read(); for(int i=1;i\u003c=n;i++) a[i] = read(); for(int i=1;i\u003c=n;i++) b[i] = read(); s[1] = a[1]; for(int i=2;i\u003c=n;i++){ s[i] = s[i-1] + a[i]; } m[1] = b[1]; for(int i=2;i\u003c=n;i++){ m[i] = min(b[i],m[i-1]); } INT ans = 0; INT cnt = a[1]; for(int i=2;i\u003c=n;i++){ if(b[i-1]\u003eb[i]){ ans += cnt * (m[i-1] - m[i]); } cnt = max(cnt,s[i]); } ans += cnt * m[n]; cout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": \"; write(b[1]); cout\u003c\u003c\" \"; write(ans); puts(\"\"); } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:23:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"思维 并查集 离散化 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:24:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 对于当前的一对数，给它们连一条边，对所有的对数都进行这样的操作，最后会形成很多连通块，如果连通块有环，则这些数都能被选择，否则其中有一个数不能被选择，因为数据大小，用unordered_map离散化 #include \"bits/stdc++.h\" using namespace std; using ll = long long; unordered_map\u003cint,int\u003e used; set\u003cint\u003e rt; unordered_map\u003cint,int\u003e rel; unordered_map\u003cint,int\u003e num; unordered_map\u003cint,int\u003e id; const int maxn = 2e5+10; int a[maxn],b[maxn]; //union find int par[maxn]; int rankk[maxn]; int sz[maxn]; void init(int n){ for(int i=0;i\u003cn;i++) { par[i]=i; rankk[i]=0; } } int find(int x){ if(par[x]==x) return x; else return par[x]=find(par[x]); } void unite(int x,int y){ x=find(x); y=find(y); if(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y; else{ par[y]=x; if(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y){ return find(x)==find(y); } int getid(int u){ return id[u]; } int main() { int _; cin \u003e\u003e _; for(int q=1;q\u003c=_;q++) { used.clear(); rt.clear(); rel.clear(); num.clear(); id.clear(); int n; scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++){ scanf(\"%d%d\",\u0026a[i],\u0026b[i]); } init(2*n+2); int cnt = 0; for(int i=0;i\u003cn;i++){ if(id[a[i]] == 0) id[a[i]] = ++cnt; if(id[b[i]] == 0) id[b[i]] = ++cnt; } for(int i=1;i\u003c=cnt;i++){ rt.insert(i); } for(int i=1;i\u003c=cnt;i++){ num[i] = 1; } // for(int i=1;i\u003c=cnt;i++){ // cout\u003c\u003cid[i]\u003c\u003c\" \"; // }puts(\"\"); for(int i=0;i\u003cn;i++){ int u = a[i],v = b[i]; //if(used[u] == 1 and used[v] == 1) continue; //used[u] = used[v] = 1; if(!same(getid(u) , getid(v))){ int urt = find(getid(u)); int vrt = find(getid(v)); int t1 = rel[urt],t2 = rel[vrt]; int t3 = num[urt],t4 = num[vrt]; rt.erase(urt); rt.erase(vrt); int t5 = t1 + t2 + 1; int t6 = t3 + t4; unite(getid(u),getid(v)); int uvrt = find(getid(u)); rel[uvrt] = t5; num[uvrt] = t6; rt.insert(uvrt); }else{ rel[find(getid(u))]++; } } ll ans = 0; for(int i:rt){ ans += (rel[i] \u003e= num[i] ? num[i] : num[i] - 1); //cout\u003c\u003crel[i]\u003c\u003c\" \"\u003c\u003cnum[i]\u003c\u003c\" \"\u003c\u003ci; //cout\u003c\u003cfind(getid(44)); } cout\u003c\u003c\"Case #\"\u003c\u003cq\u003c\u003c\": \"\u003c\u003cans\u003c\u003cendl； } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:24:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"模拟 枚举 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:25:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 三重循环枚举 #include \"bits/stdc++.h\" using namespace std; using ll = long long; const int maxn = 260; string cards[maxn][4]; bool check(int i,int j,int k){ bool flags[4] = {false}; for(int q=0;q\u003c4;q++){ string s1 = cards[i][q]; string s2 = cards[j][q]; string s3 = cards[k][q]; if((s1==\"[*]\" or s2==\"[*]\" or s3==\"[*]\") or (s1 == s2 and s2 == s3) or (s1 != s2 and s2 != s3 and s1 != s3)) flags[q] = true; } if(flags[0] and flags[1] and flags[2] and flags[3]) return true; return false; } int main() { int _; cin \u003e\u003e _; for(int u=1;u\u003c=_;u++) { int n; cin\u003e\u003en; //reset for(int i=0;i\u003c=n;i++){ for(int j=0;j\u003c4;j++){ cards[i][j].clear(); } } string s; for(int i=0;i\u003cn;i++) { cin\u003e\u003es; for(int j=0,k=0;j\u003cs.length();j++){ cards[i][k].push_back(s[j]); if(s[j]==']') k++; } } // for(int i=0;i\u003c4;i++){ // cout\u003c\u003ccards[0][i]\u003c\u003c\" \"; // } bool ok = false; for(int i=0;i\u003cn;i++){ if(ok) break; for(int j=i+1;j\u003cn;j++){ if(ok) break; for(int k=j+1;k\u003cn;k++){ if(ok) break; if(check(i,j,k)){ cout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": \"\u003c\u003ci+1\u003c\u003c\" \"\u003c\u003cj+1\u003c\u003c\" \"\u003c\u003ck+1\u003c\u003cendl; ok = true; } } } } if(!ok) cout\u003c\u003c\"Case #\"\u003c\u003cu\u003c\u003c\": -1\\n\"; } return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:25:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"dp 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:26:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 #include \"bits/stdc++.h\" using namespace std; const int maxn = 1e5 + 5; int a[maxn]; int dp[maxn][2]; int main() { int n; cin \u003e\u003e n; for(int i = 0; i \u003c n; i++){ cin \u003e\u003e a[i]; } if(a[0] == 0) dp[0][0] = 0, dp[0][1] = 1; if(a[0] == 1) dp[0][0] = 1, dp[0][1] = 0; for(int i = 1; i \u003c n; i++){ if(a[i] == 0){ dp[i][0] = min(dp[i-1][0] , dp[i-1][1] + 1); dp[i][1] = min(dp[i-1][0] + 2 , dp[i-1][1] + 1); } if(a[i] == 1){ dp[i][0] = min(dp[i-1][0] + 1 , dp[i-1][1] + 2); dp[i][1] = min(dp[i-1][0] + 1 , dp[i-1][1]); } } cout \u003c\u003c min(dp[n-1][0] , dp[n-1][1] + 1)\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:26:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"图论 题目 ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:27:0","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["problemlist"],"content":"题解 暴力O(n^2) ，所以考虑将问题本质化（结论化） 把问题转化成求一个点，使得它到集合中的点的最大距离最小，求值 这样这个点从直观上看应该处在这些点的中间，并且是集合中两个最远的点的中点 #include \"bits/stdc++.h\" using namespace std; using ll = long long; const int maxv = 3e5 + 5; const int max_logv = 20; vector\u003cint\u003e G[maxv]; int root; int parent[max_logv][maxv]; int depth[maxv]; void dfs(int v, int p, int d){ parent[0][v]=p; depth[v]=d; for(int i = 0; i \u003c G[v].size(); i++){ if(G[v][i] != p) dfs(G[v][i], v, d+1); } } void init(int V){ dfs(root, -1, 0); for(int k = 0; k+1 \u003c max_logv; k++){ for(int v = 0; v \u003c V; v++){ if(parent[k][v] \u003c 0) parent[k+1][v] = -1; else parent[k+1][v] = parent[k][parent[k][v]]; } } } int lca(int u,int v){ if(depth[u] \u003e depth[v]) swap(u, v); for(int k =0; k \u003c max_logv; k++){ if((depth[v] - depth[u]) \u003e\u003e k \u0026 1) v = parent[k][v]; } if(u == v) return u; for(int k = max_logv-1; k \u003e= 0; k--){ if(parent[k][u] != parent[k][v]){ u = parent[k][u]; v = parent[k][v]; } } return parent[0][u]; } int a[1000005]; int main() { int n; cin \u003e\u003e n; for(int i = 0; i \u003c n-1; i++){ int u, v; cin \u003e\u003e u \u003e\u003e v; G[u].push_back(v); G[v].push_back(u); } root = 1; init(n+1); int num ; cin \u003e\u003e num; for(int i = 0; i \u003c num; i++){ int m; cin \u003e\u003e m; int est = root; for(int j = 0; j \u003c m; j++){ cin \u003e\u003e a[j]; if(depth[a[j]] \u003e depth[est]) est = a[j]; } int ans = -1; for(int j = 0; j \u003c m; j++){ ans = max(ans, depth[est] + depth[a[j]] - 2 * depth[lca(est, a[j])]); } cout \u003c\u003c ((ans + 1) \u003e\u003e 1) \u003c\u003c endl; } return 0; } ","date":"2020-07-04","objectID":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/:27:1","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["abc"],"content":"abc172","date":"2020-06-28","objectID":"/abc172/","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"A - Calc ","date":"2020-06-28","objectID":"/abc172/:0:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:1:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ int a; cin\u003e\u003ea; cout\u003c\u003ca+a*a+a*a*a\u003c\u003cendl; return 0; } B - Minor Change ","date":"2020-06-28","objectID":"/abc172/:2:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:3:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ string s,t; cin\u003e\u003es\u003e\u003et; int ans = 0; for(int i=0;i\u003cs.length();i++){ if(s[i]!=t[i])ans++; } cout\u003c\u003cans\u003c\u003cendl; return 0; } C - Tsundoku ","date":"2020-06-28","objectID":"/abc172/:4:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:5:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 前缀和+双指针 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll a[200005]; ll b[200005]; int main(){ ll n,m,k; cin\u003e\u003en\u003e\u003em\u003e\u003ek; a[0] = 0; b[0] = 0; for(ll i=1;i\u003c=n;i++){ ll tmp; cin\u003e\u003etmp; a[i] = a[i-1] + tmp; } for(ll j=1;j\u003c=m;j++){ ll tmp; cin\u003e\u003etmp; b[j] = b[j-1] + tmp; } ll ans = 0; ll j = m; ll i; for(i=0;i\u003c=n;i++){ while(a[i] + b[j] \u003e k and j\u003e=0){ j--; } if(a[i] + b[j] \u003c= k) { ans = max(ans , i+j); //cerr\u003c\u003cj\u003c\u003cendl; } } cout\u003c\u003cans\u003c\u003cendl; return 0; } D - Sum of Divisors ","date":"2020-06-28","objectID":"/abc172/:6:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:7:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 筛法预处理因子个数，O(1)查询 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n; ll num[10000005]; void init(){ for(ll i=1;i\u003c=10000005;i++){ for(ll x=i;x\u003c10000005;x+=i){ num[x]++; } } } int main(){ init(); cin\u003e\u003en; ll ans = 0; for(ll i=1;i\u003c=n;i++){ ans += i*num[i]; } cout\u003c\u003cans\u003c\u003cendl; return 0; } E - NEQ ","date":"2020-06-28","objectID":"/abc172/:8:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:9:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 对于从M个选N个全排列的每一种方案都有对应的若干个情况，它们都是等价的 比如M=4 N=3 ，对于全排列的一种方案 123 与之对应的有第一个数字不能为1、第二个数字不能为2，第三个数字不能为3 第一个数字和第二个数字不能同时为12，第二个和第三个数字不能同时为23，第一个和第三个数字不能同时为13 第一个第二个第三个数字不能同时为123 这样就是基于容斥原理的排列组合 总的方案数是 $$ A_{M}^{N}*\\sum\\limits_{i=0} ^ {n} {C_{N}^{i}A_{M-i}^{N-i}(-1)^n} $$ #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n; ll m; const ll mod = 1e9+7; const ll maxn = 500005; ll inv[maxn+3]; ll fac[maxn+3]; inline ll A(ll n,ll m){ return fac[n]*inv[n-m]%mod; } inline ll C(ll n,ll m){ return A(n,m)*inv[m]%mod; } int main(){ cin\u003e\u003en\u003e\u003em; fac[0] = 1; fac[1] = 1; for(ll i=2;i\u003cmaxn;i++){ fac[i] = i * fac[i-1]; fac[i] %= mod; } inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=maxn;i++){ inv[i]=(mod-mod/i)*inv[mod%i]%mod; } for(ll i=2;i\u003c=maxn;i++){ inv[i]=(inv[i]*inv[i-1])%mod; } ll ans =0; for(ll i=0;i\u003c=n;i++){ ll tmp = C(n,i) * A(m-i,n-i); tmp %= mod; if(i%2==0){ ans += tmp; }else ans -= tmp; ans += mod; ans %= mod; } ans *= A(m,n); ans += mod; ans %= mod; cout\u003c\u003cans\u003c\u003cendl; //cout\u003c\u003ctmp\u003c\u003cendl; return 0; } F - Unfair Nim ","date":"2020-06-28","objectID":"/abc172/:10:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-28","objectID":"/abc172/:11:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["abc"],"content":"题解 题解url #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ ll n; cin\u003e\u003en; ll q,w; cin\u003e\u003eq\u003e\u003ew; ll x = 0; for(ll i=2;i\u003cn;i++){ ll tmp; cin\u003e\u003etmp; x ^= tmp; } ll d = (q+w-x) / 2; if(d\u003c0 or d\u003eq or (d\u0026x) or (q+w-x)%2==1){ cout\u003c\u003c-1\u003c\u003cendl; exit(0); } for(ll i=45;i\u003e=0;i--){ if(x\u003e\u003ei\u00261LL){ if(d+(1LL\u003c\u003ci) \u003c= q){ d += (1LL\u003c\u003ci); } } } if(d==0) cout\u003c\u003c-1\u003c\u003cendl; else cout\u003c\u003cq-d\u003c\u003cendl; return 0; } ","date":"2020-06-28","objectID":"/abc172/:12:0","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"/abc172/"},{"categories":["linux"],"content":"树莓派入门","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"树莓派官网 树莓派4b图解 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:0:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"烧录系统 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"格式化SD卡 用格式化工具SDFormatter V4.0 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:1","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"烧录镜像 从官网下载最新的镜像 打开Win32DiskImager.exe 选择下载的镜像 后面选择E盘 点击write，等待 完成 安装Linux文件查看工具Linux_Reader.exe，打开 可以看到linux的文件结构 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:2","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"放置空的ssh文件 这样允许树莓派用ssh远程连接 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:3","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"wifi配置 在boot盘中个创建文件wpa_supplicant.conf 在里面写入 country=CN ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=\"将我替换成第一个WiFi的名字，不删除引号,不能有中文\" psk=\"将我替换成WiFi密码，不删除引号\" priority=将我替换成数字，数字越大代表优先级越高 } network={ ssid=\"将我替换成第二个WiFi的名字，不删除引号,不能有中文\" psk=\"将我替换成WiFi密码，不删除引号\" priority=将我替换成数字，数字越大代表优先级越高 } 拔出u盘 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:1:4","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"开机 插入sd卡，电源线，就可以通电开机了 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:2:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"获取树莓派ip 如果是ios，可以下载dataplicity软件，在此之前需要到它的官网注册（激活）一下邮箱，然后才可以再软件中登录 确保ios设备和树莓派连同一个wifi，然后用这个软件扫描即可 如果是电脑端，可以让电脑和树莓派连到同一个wifi，然后打开advanced_ip_scanner.exe，扫描即可 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:3:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"远程登录 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:4:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"putty远程登录 打开远程ssh工具 putty.exe输入树莓派ip即可 默认用户名是pi 密码是raspberry ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:4:1","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"vncviewer远程登录 打开vnc viewer软件，输入树莓派ip即可，如果出现cannot currently show the desktop，调整分辨率即可 调整分辨率的方法是先用putty远程登录，然后输入sudo raspi-config 选择 display options 选择非默认的分辨率，最后finish ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:4:2","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"给apt-get换源 在终端输入sudo nano /etc/apt/sources.list 把第一行注释掉，在后面复制 deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi 点击右键和方向键下键粘贴，然后ctrl-o保存 运行sudo apt-get update ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:5:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"安装vim sudo apt-get install vim ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:6:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"给pip换源 sudo mkdir ~/.pip cd .pip sudo nano pip.conf 写入 [global] timeout = 10 index-url = http://mirrors.aliyun.com/pypi/simple/ extra-index-url= http://pypi.douban.com/simple/ [install] trusted-host= mirrors.aliyun.com pypi.douban.com ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:7:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"树莓派的一些设置 sudo raspi-config 进入到设置界面 选择 advanced options 选择 expand filesystem 可以将根目录扩展到sd卡，充分利用sd卡空间 选择 system options 选择 audio 选择 headphones 可以让声音通过耳机输出 在 display options 中按情况调节分辨率，选择 pixel doubling 可以将像素两倍显示，更清晰 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:8:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"安装中文字体和输入法 安装中文字体 sudo apt-get install fonts-wqy-zenhei 安装中文输入法 sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin 在右上角将google pinyin添加进去 下次开机生效，按 ctrl+space 切换输入法 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:9:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"安装teamviewer 进入官网 选择 armv7_32bits cd /home/pi/Downloads sudo dpkg -i 下载的文件名_armhf.deb sudo apt-get -f install sudo apt-get install gdebi 点击右上角的图标即可进入 需要注册账号 teamviewer遇到网络问题，设备可以断掉重连 另外一种内网穿透可以用sunny-ngrok ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:10:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["linux"],"content":"参考 https://blog.csdn.net/wu693966797/article/details/95936275 https://www.bilibili.com/video/BV1zb411x7yo 资源 百度网盘 提取码 92Mb 推荐淘宝购买店铺 ： 亚博智能科技 ","date":"2020-06-28","objectID":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/:11:0","tags":["cpp","linux"],"title":"树莓派入门","uri":"/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"},{"categories":["nowcoder"],"content":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"挺好的比赛 A-找规律 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:0:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 玄学题，打表找规律或者猜测规则是每次洗牌是将一个位置移动到另一个固定位置 13次洗牌之后所有的位置都占过一遍，所以13次是循环 要求洗牌5次的结果就是求9次两次洗牌的结果 #include\u003cbits/stdc++.h\u003e using namespace std; string s[30]; string t[30]; int a[30]; void init_a(){ for(int i=0;i\u003c13;i++){ for(int j=0;j\u003c13;j++){ if(s[i] == t[j]){ a[i] = j; break; } } } } void sol(){ for(int i=0;i\u003c13;i++){ t[a[i]] = s[i]; } for(int i=0;i\u003c13;i++){ s[i] = t[i]; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while(cin\u003e\u003es[0]){ for(int i=1;i\u003c13;i++) cin\u003e\u003es[i]; for(int i=0;i\u003c13;i++) cin\u003e\u003et[i]; init_a(); for(int i=0;i\u003c9;i++) sol(); for(int i=0;i\u003c13;i++) cout\u003c\u003cs[i]\u003c\u003c\" \"; cout\u003c\u003cendl; //cout\u003c\u003c\"end\"\u003c\u003cendl; } return 0; } B-签到题 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:1:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 排列组合 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 1e9+9; ll fac[100005]; ll inv[100005]; ll C(ll n,ll m){ return fac[n]*inv[m]%mod*inv[n-m]%mod; } ll A(ll n,ll m){ return fac[n]*inv[n-m]%mod; } int main(){ fac[0] = 1; fac[1] = 1; for(ll i=2;i\u003c100005;i++){ fac[i] = i * fac[i-1]; fac[i] %= mod; } inv[0] = 1; inv[1] = 1; //inv[0]=1 !!! for(ll i=2;i\u003c=100005;i++){ inv[i] = (mod-mod/i)*inv[mod%i]%mod; } for(ll i=2;i\u003c=100005;i++){ inv[i] = (inv[i]*inv[i-1])%mod; } ll n; while(cin\u003e\u003en){ cout\u003c\u003cn*C(n,2)%mod*A(n-1,n-2)%mod\u003c\u003cendl; } return 0; } C-救救AR ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:2:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题意 找规律 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; cin\u003e\u003en; if(n==1 or n==2 or n==3){ cout\u003c\u003c-1\u003c\u003cendl; } else{ if(n\u00261){ cout\u003c\u003c\"ARA\"; for(int i=0;i\u003cn/2;i++){ cout\u003c\u003c\"R\"; } cout\u003c\u003cendl; } else{ cout\u003c\u003c\"AA\"; for(int i=0;i\u003cn/2;i++) cout\u003c\u003c\"R\"; cout\u003c\u003cendl; } } return 0; } D-ar采蘑菇 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:3:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 状态压缩dp #include\u003ciostream\u003e #include\u003ccstring\u003e using namespace std; using ll = long long; int r[7],u[7]; int dp[105][105][35]; int main(){ int t; cin\u003e\u003et; int n,m,k; while(t--){ memset(r,0,sizeof(r)); memset(u,0,sizeof(u)); memset(dp,0,sizeof(dp)); cin\u003e\u003en\u003e\u003em\u003e\u003ek; for(int i=0;i\u003ck;i++){ string s; cin\u003e\u003es; for(int j=0;j\u003cs.length();j++){ if(s[j] == 'R') r[i]++; else u[i]++; } } dp[0][0][0] = 1; for(int i=0;i\u003c=n;i++){ for(int j=0;j\u003c=m;j++){ for(int st=0;st\u003c(1\u003c\u003ck);st++){ for(int q=0;q\u003ck;q++){ int nn = i - r[q]; int mm = j - u[q]; if(nn\u003c0 or nn\u003en or mm\u003c0 or mm\u003em) continue; if(st\u003e\u003eq\u00261){ dp[i][j][st] |= dp[nn][mm][st]; dp[i][j][st] |= dp[nn][mm][st^(1\u003c\u003cq)]; } } } } } int ans = 0; //等于0就ac,-1wa for(int i=0;i\u003c(1\u003c\u003ck);i++){ if(dp[n][m][i]){ ans = max(ans , __builtin_popcount(i)); } } cout\u003c\u003cans\u003c\u003cendl; } return 0; } E-呼兰河传 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:4:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 最大的lcm为全选取 经典的大数求lcm 暴力超时，且除以gcd无法取模 由于题目的数据规模可以去重 对于每一个因数，求这些数对于它幂次方贡献的最大值 最后遍历所有因数，对于最大贡献求积 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 1e9+9; ll pn[100005]; set\u003cll\u003e st; ll qpow(ll x,ll n) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } void did(ll x){ for(ll i=2;i*i\u003c=x;i++){ if(x%i==0){ ll num = 0; while(x%i==0){ x /= i; num++; } pn[i] = max(pn[i] , num); } } if(x != 1){ pn[x] = max(pn[x] , 1LL); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); ll n; cin\u003e\u003en; for(ll i=0;i\u003cn;i++){ ll x; cin\u003e\u003ex; st.insert(x); } for(ll i:st){ did(i); } ll ans = 1; for(ll i=2;i\u003c=1e5+2;i++){ ans *= qpow(i,pn[i]); ans %= mod; } cout\u003c\u003cans\u003c\u003cendl; return 0; } F-月出皎兮，佼人僚兮。 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:5:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 对于某一节点u，设子树颜色数最大是 p，颜色总数是sum，如果p*2 \u003e sum 最大匹配数是sum - p，否则都能匹配 sum/2 所以只要求子树颜色最多的数量 暴力dfs超时，所以用树上启发式合并 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll maxn = 2e5+3; struct edge{ int to,nxt; }e[maxn\u003c\u003c1]; ll sz[maxn],par[maxn],c[maxn],num[maxn],head[maxn],wch[maxn],tot[maxn],ans[maxn]; ll n; ll cnt; ll tmax; ll sum; void add_edge(ll u,ll v){ e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; } void dfs(ll u,ll p){ sz[u] = 1; for(ll i=head[u]; i ;i=e[i].nxt){ ll t = e[i].to; if(t != p){ dfs(t,u); sz[u] += sz[t]; if(sz[t] \u003e sz[wch[u]]) wch[u] = t; } } } void cal(ll u,ll p,ll wch,ll val){ tot[c[u]] += val * num[u]; sum += val * num[u]; tmax = max(tmax , tot[c[u]]); for(ll i=head[u]; i ; i=e[i].nxt){ ll t = e[i].to; if(t != p and t != wch){ cal(t,u,wch,val); } } } void dsu(ll u,ll p,ll kp){ for(ll i=head[u]; i ; i=e[i].nxt){ ll t = e[i].to; if(t != p and t != wch[u]){ dsu(t,u,0); } } if(wch[u]) dsu(wch[u],u,1); cal(u,p,wch[u],1); if(2*tmax \u003e sum) ans[u] = sum - tmax; else ans[u] = sum / 2; if(!kp) { cal(u,p,0,-1); tmax = 0; sum = 0; } } int main(){ cin\u003e\u003en; for(ll i=0;i\u003cn-1;i++){ ll x,y; cin\u003e\u003ex\u003e\u003ey; add_edge(x,y); add_edge(y,x); } for(ll i=1;i\u003c=n;i++){ ll x,y; cin\u003e\u003ex\u003e\u003ey; c[i] = x; num[i] = y; } dfs(1,0); dsu(1,0,1); for(int i=1;i\u003c=n;i++){ cout\u003c\u003cans[i]\u003c\u003cendl; } return 0; } G-寻找未曾见过的你 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:6:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 不会 H-AR的背包 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:7:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["nowcoder"],"content":"题解 不会 ","date":"2020-06-28","objectID":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/:8:0","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/"},{"categories":["note"],"content":"正则表达式","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"正则表达式的基础用法 在线测试网站 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"限定符 ？ used? 表示？前面的字符可有可无 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"限定符 * *之前的字符出现0或多次 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"限定符 + +之前的字符出现至少一次 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"出现指定次数 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"字符串重复出现 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:5:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"或运算 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:6:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"指定匹配哪些字符 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:7:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"\\d表示数字（元字符） ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:8:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"\\w表示所有的数字、字符、下划线 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:9:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"\\s表示空格、制表符、换行 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:10:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"其他说明 \\S 是\\s的补集 \\W是\\w的补集 \\D是\\d的补集 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:10:1","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":".表示任意字符（不包括换行符） ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:11:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"^a匹配行首的a ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:12:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"a$匹配行尾的a ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:13:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"贪婪匹配转懒惰匹配 ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:14:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["note"],"content":"例子：RGB ","date":"2020-06-25","objectID":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:15:0","tags":["cs"],"title":"正则表达式","uri":"/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["abc"],"content":"abc171","date":"2020-06-22","objectID":"/abc171/","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"A - αlphabet ","date":"2020-06-22","objectID":"/abc171/:0:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:1:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ char a; cin\u003e\u003ea; if(isupper(a)) cout\u003c\u003c'A';else cout\u003c\u003c'a'; return 0; } B - Mix Juice ","date":"2020-06-22","objectID":"/abc171/:2:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:3:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,k; cin\u003e\u003en\u003e\u003ek; int a[n]; for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; sort(a,a+n); int ans = 0; for(int i=0;i\u003ck;i++) ans+=a[i]; cout\u003c\u003cans\u003c\u003cendl; return 0; } C - One Quadrillion and One Dalmatians ","date":"2020-06-22","objectID":"/abc171/:4:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 类似于十进制转26进制 不同的是27是 aa ","date":"2020-06-22","objectID":"/abc171/:5:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 这个题目没有像正常的转化那样进位 所以对每一位求值前先减1 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ ll a; cin\u003e\u003ea; string s = \"\"; //a--; while(a!=0){ a--; s += (a%26) + 'a'; a /= 26; } reverse(s.begin(),s.end()); cout\u003c\u003cs\u003c\u003cendl; return 0; } D - Replacing ","date":"2020-06-22","objectID":"/abc171/:6:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:7:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 模拟 #include\u003cbits/stdc++.h\u003e using namespace std; long long a[100005]; int main(){ long long n; cin\u003e\u003en; long long sum = 0; for(long long i=0;i\u003cn;i++) { long long x; cin\u003e\u003ex; a[x]++; sum+=x; } long long q; cin\u003e\u003eq; for(long long i=0;i\u003cq;i++){ long long t,y; cin\u003e\u003et\u003e\u003ey; sum+=((y-t)*a[t]); cout\u003c\u003csum\u003c\u003cendl; a[y]+=a[t]; a[t] = 0; } return 0; } E - Red Scarf ","date":"2020-06-22","objectID":"/abc171/:8:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 对于一个数列，第一个位置的值是原数列其他位置的异或，依此类推 还原数列 ","date":"2020-06-22","objectID":"/abc171/:9:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 利用异或性质 #include\u003cbits/stdc++.h\u003e using namespace std; int a[200005]; int main() { int n; cin\u003e\u003en; int ans = 0; for(int i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; ans ^= a[i]; } for(int i=0;i\u003cn;i++){ cout\u003c\u003c(ans^a[i])\u003c\u003c\" \"; }cout\u003c\u003cendl; return 0; } F - Strivore ","date":"2020-06-22","objectID":"/abc171/:10:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-22","objectID":"/abc171/:11:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["abc"],"content":"题解 把问题转化成满足长度为n的，包含子序列s的字符串有几个 然后就变成排列组合题 考虑所有情况减去不包含子序列s的字符串 不含子序列s的字符串可以这样构造 目标串T可以包含子序列中的1个，2个，3个。。。s.length() - 1个 这样取子序列只能是前几个，因为取s的中间部分就一定不满足条件 对于其中一种情况，举个例子 s = \" acf\" 总长度为8 假设从s中选两个，那这两个就一定是 a c 假设它们被安排在这样的位置 12a45c78 那么1号和2号一定不能选到a，4号和5号一定不能选到c，7号和8号一定不能选到f 这样T就一定没有子序列s 对于除ac外的位置都有25种选择 所以这种情况（选两个）就有 $$ C_{8}^{2} * 25^6 $$ 种方案 所以对于所有情况(n是T的长度，s是子序列的长度)，方案数 $$ 26^{n} - \\sum\\limits_{i=0} ^ {s-1} {C_n^i*25^{n-i}} $$ #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 1e9+7; ll fac[2000005]; ll qpow(ll x,ll n) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } ll C(ll n,ll m){ return fac[n]*qpow(fac[m] , mod-2)%mod*qpow(fac[n-m] , mod-2)%mod; } int main(){ fac[0] = 1; fac[1] = 1; for(ll i=2;i\u003c2000002;i++){ fac[i] = i * fac[i-1]; fac[i] %= mod; } ll k; cin\u003e\u003ek; string ss; cin\u003e\u003ess; ll s = ss.size(); ll ans = 0; for(ll i=0;i\u003cs;i++){ ans += C(k+s , i) * qpow(25 , k+s-i); ans %= mod; } cout\u003c\u003c(qpow(26 , k+s) - ans + mod) % mod\u003c\u003cendl; return 0; } 如果用逆元 inline ll C(ll m,ll n){ return fac[n]*inv[m]%mod*inv[n-m]%mod; } inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){ inv[i]=(mod-mod/i)*inv[mod%i]%mod; } for(ll i=2;i\u003c=n;i++){ inv[i]=(inv[i]*inv[i-1])%mod; } ","date":"2020-06-22","objectID":"/abc171/:12:0","tags":["cpp","counting"],"title":"abc171","uri":"/abc171/"},{"categories":["Python web"],"content":"Django学习","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"跟着django文档实现投票app ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:0:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"需求 一个让人们查看和投票的公共站点。 一个让你能添加、修改和删除投票的管理站点。 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:1:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"环境 ide： pycharm community（不支持Django代码自动补全） 版本：django 2.1.1 数据库：sqlite ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:2:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"创建项目 django-admin startproject mysite 生成的文件结构 mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 开启服务器 python manage.py runserver ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:3:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"创建应用 python manage.py startapp polls 在polls下生成的文件结构 __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 创建polls/urls.py作为视图的路由 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:4:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"数据库配置 sqlite是其自带的数据库，使用其他数据库需要添加配置项 比如mysql，在mysite/settings中DATABASES应该这样写 DATABASES = { 'default': { # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE' : 'django.db.backends.mysql', 'NAME' : 'test_django', 'USER' : 'root', 'PASSWORD' : '123456', 'HOST' : 'localhost', 'PORT' : '3306', } } 在使用mysite/settings中的INSTALLED_APPS之前要在数据库中创建一些表，执行 python manage.py migrate ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:5:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"创建模型 在polls/models.py中写 __str__方法在命令行调试时有很好的输出 from django.db import models import datetime from django.utils import timezone # Create your models here. class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') def __str__(self): return self.question_text def was_published_recently(self): now = timezone.now() return now - datetime.timedelta(days=1) \u003c= self.pub_date \u003c= now #更改后台的显示方式 was_published_recently.admin_order_field = 'pub_date' was_published_recently.boolean = True was_published_recently.short_description = 'Published recently?' class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) def __str__(self): return self.choice_text ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:6:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"激活模型 polls/apps.py from django.apps import AppConfig class PollsConfig(AppConfig): name = 'polls' 把polls应用安装到项目中，在mysite/settings.py中 INSTALLED_APPS = [ 'polls.apps.PollsConfig', #可插拔 这么做，项目就会包含应用 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] 运行如下命令 python manage.py makemigrations polls 通过运行 makemigrations 命令，Django 会检测对模型文件的修改，并且把修改的部分储存为一次迁移。 运行如下命令，将会把模型的修改同步到数据库中 python manage.py migrate 在之后改模型要做这三步 修改模型 python manage.py makemigrations python manage.py migrate ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:7:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"API 打开python命令行 python manage.py shell Python 3.5.6 |Anaconda 4.2.0 (64-bit)| (default, Aug 26 2018, 16:05:27) [MSC v.1900 64 bit (AMD64)] Type \"copyright\", \"credits\" or \"license\" for more information. IPython 5.1.0 -- An enhanced Interactive Python. ? -\u003e Introduction and overview of IPython's features. %quickref -\u003e Quick reference. help -\u003e Python's own help system. object? -\u003e Details about 'object', use 'object??' for extra details. In [1]: from polls.models import Choice, Question In [2]: Question.objects.all() Out[2]: \u003cQuerySet [\u003cQuestion: what's up?\u003e]\u003e In [3]: Question.objects.filter(id=1) Out[3]: \u003cQuerySet [\u003cQuestion: what's up?\u003e]\u003e In [4]: Question.objects.filter(question_text__startswith='What') Out[4]: \u003cQuerySet [\u003cQuestion: what's up?\u003e]\u003e In [5]: Question.objects.get(id=2) --------------------------------------------------------------------------- DoesNotExist Traceback (most recent call last) \u003cipython-input-5-e5ad49b3e3e3\u003e in \u003cmodule\u003e() ----\u003e 1 Question.objects.get(id=2) D:\\anaconda\\lib\\site-packages\\django\\db\\models\\manager.py in manager_method(self, *args, **kwargs) 80 def create_method(name, method): 81 def manager_method(self, *args, **kwargs): ---\u003e 82 return getattr(self.get_queryset(), name)(*args, **kwargs) 83 manager_method.__name__ = method.__name__ 84 manager_method.__doc__ = method.__doc__ D:\\anaconda\\lib\\site-packages\\django\\db\\models\\query.py in get(self, *args, **kwargs) 397 raise self.model.DoesNotExist( 398 \"%s matching query does not exist.\" % --\u003e 399 self.model._meta.object_name 400 ) 401 raise self.model.MultipleObjectsReturned( DoesNotExist: Question matching query does not exist. In [6]: q = Question.objects.get(pk=1) In [7]: q.was_published_recently() Out[7]: False In [8]: q = Question.objects.get(pk=1) ...: In [9]: q.choice_set.all() Out[9]: \u003cQuerySet [\u003cChoice: not much\u003e, \u003cChoice: the sky\u003e, \u003cChoice: just hacking\u003e]\u003e In [10]: q.choice_set.create(choice_text='Not much', votes=0) Out[10]: \u003cChoice: Not much\u003e In [11]: c = q.choice_set.create(choice_text='Just hacking again', votes=0) In [12]: c.question Out[12]: \u003cQuestion: what's up?\u003e In [13]: q.choice_set.all() Out[13]: \u003cQuerySet [\u003cChoice: not much\u003e, \u003cChoice: the sky\u003e, \u003cChoice: just hacking\u003e, \u003cChoice: Not much\u003e, \u003cChoice: Just hacking again \u003e]\u003e In [14]: q.choice_set.count() Out[14]: 5 In [15]: c = q.choice_set.filter(choice_text__startswith='Just hacking') In [16]: c.delete() Out[16]: (2, {'polls.Choice': 2}) In [17]: quit() ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:8:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"Django管理页面 创建管理员账号 python manage.py createsuperuser 启动服务器，转到/admin/路径，进入管理员界面 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:9:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"编写视图 需求 问题索引页——展示最近的几个投票问题。 问题详情页——展示某个投票的问题和不带结果的选项列表。 问题结果页——展示某个投票的结果。 投票处理器——用于响应用户为某个问题的特定选项投票的操作。 使用模板系统，更加灵活 建立polls/templates文件夹 在建立polls文件夹，形成polls/templates/polls，将html文件放此目录下 在polls/views.py下编写视图，使用通用视图，结合request和response from django.shortcuts import render, get_object_or_404 # Create your views here. from django.http import HttpResponse, HttpResponseRedirect from django.template import loader from .models import Question, Choice from django.http import Http404 from django.urls import reverse from django.views import generic from django.utils import timezone # def index(request): # latest_question_list = Question.objects.order_by('-pub_date')[:5] # context = { # 'latest_question_list' : latest_question_list # } # return render(request, 'polls/index.html', context) class IndexView(generic.ListView): #model = Question template_name = 'polls/index.html' context_object_name = 'latest_question_list' ''' Question.objects.filter(pub_date__lte=timezone.now()) returns a queryset containing Questions whose pub_date is less than or equal to - that is, earlier than or equal to - timezone.now. ''' def get_queryset(self): return Question.objects.filter( pub_date__lte = timezone.now() ).order_by('-pub_date')[:5] class DetailView(generic.DetailView): model = Question template_name = 'polls/detail.html' def get_queryset(self): return Question.objects.filter(pub_date__lte = timezone.now()) class ResultsView(generic.DetailView): model = Question template_name = 'polls/results.html' # Leave the rest of the views (detail, results, vote) unchanged # def detail(request, question_id): # question = get_object_or_404(Question, pk = question_id) # return render(request, 'polls/detail.html', {'question': question}) # # def results(request, question_id): # question = get_object_or_404(Question, pk=question_id) # return render(request, 'polls/results.html', {'question': question}) def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST['choice']) except (KeyError, Choice.DoesNotExist): # Redisplay the question voting form. return render(request, 'polls/detail.html', { 'question': question, 'error_message': \"You didn't select a choice.\", }) else: selected_choice.votes += 1 selected_choice.save() # Always return an HttpResponseRedirect after successfully dealing # with POST data. This prevents data from being posted twice if a # user hits the Back button. return HttpResponseRedirect(reverse('polls:results', args=(question.id,))) # 使用reverse将返回 '/polls/3/results/' 设置路由 在polls/urls.py中设置路由，并为应用加上命名空间 from django.urls import path from . import views app_name = 'polls' #命名空间，防止重名 urlpatterns = [ path('' , views.IndexView.as_view() , name = 'index'), path('\u003cint:pk\u003e/' , views.DetailView.as_view() , name = 'detail'), path('\u003cint:pk\u003e/results/' , views.ResultsView.as_view() , name = 'results'), path('\u003cint:question_id\u003e/vote/' , views.vote , name = 'vote'), ] 编写模板 使用软编码url，在polls/templates/polls中编写 index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e {% load static %} \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'polls/style.css' %}\"\u003e \u003c/head\u003e \u003cbody\u003e {% if latest_question_list %} \u003cul\u003e {% for question in latest_question_list %} \u003cli\u003e\u003ca href=\"{% url 'polls:detail' question.id %}\"\u003e{{ question.question_text }}\u003c/a\u003e\u003c/li\u003e {% endfor %} \u003c/ul\u003e {% else %} \u003cp\u003eNo polls are available.\u003c/p\u003e {% endif %} \u003c/body\u003e \u003c/html\u003e detail.html 表单验证 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e{{ question.question_text }}\u003c/h1\u003e {% if error_message %}\u003cp\u003e\u003cstrong\u003e{{ error_message }}\u003c/strong\u003e\u003c/p\u003e{% endif %} \u003cform action=\"{% url 'polls:vote' question.id %}\" method=\"post\"\u003e {% csrf_token %} {% for choice in question.choice_set.all %} \u003cinput type=\"radio\" name=\"choice\" id=\"choice{{ forloop.counter }}\" value=\"{{ choice.id }}\"\u003e \u003clabel for=\"choice{{ forloop.counter }}\"\u003e{{ choice.choice_text }}\u003c/label\u003e\u003cbr","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:10:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"自定义管理员界面 在polls/admin.py中编写 from django.contrib import admin # Register your models here. from .models import Question, Choice #admin.site.register(Question) # class QuestionAdmin(admin.ModelAdmin): # #fields = ['pub_date' , 'question_text'] # fieldsets = [ # (None, {'fields': ['question_text']}), # ('Date information', {'fields': ['pub_date']}), # ] #class ChoiceInline(admin.StackedInline): class ChoiceInline(admin.TabularInline): model = Choice extra = 3 class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, {'fields' : ['question_text']}), ('Date information' , {'fields' : ['pub_date'], 'classes' : ['collapse']}), ] inlines = [ChoiceInline] list_display = ('question_text', 'pub_date', 'was_published_recently') list_filter = ['pub_date'] search_fields = ['question_text'] admin.site.register(Question, QuestionAdmin) #admin.site.register(Choice) ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:11:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"问题记录 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:12:0","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"问题描述 把sqlite数据库导入到mysql 参考 ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:12:1","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"解决方法 安装mysqldb驱动 pip install --pre MySQLdb -i https://pypi.douban.com/simple 出错 安装可执行文件 链接 出错，因为python2才有 mysqldb Python3是pymysql 尝试 pip install pymysql py manage.py makemigrations 报错 与工程同名的文件夹下的__init__.py中这样写 import pymysql pymysql.version_info = (1, 3, 13, 'final', 0) pymysql.install_as_MySQLdb() 再执行 py manage.py makemigrations 找到对应的错误 定位到这样的代码段 query = getattr(cursor, '_executed', None) if query is not None: query = query.decode(errors='replace') return query 把decode改成encode ","date":"2020-06-20","objectID":"/django%E5%AD%A6%E4%B9%A0/:12:2","tags":["python"],"title":"Django学习","uri":"/django%E5%AD%A6%E4%B9%A0/"},{"categories":["linux"],"content":"install ubuntu in vmware","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装vmware 点击这里 需要注册账号 vmware的安装基本选择默认选项，一直next ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:1:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"准备一个ubuntu镜像文件 点击这里 选择对应版本的ubuntu文件 文件类似于 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:2:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装ubuntu 打开vmware 点击“创建新的虚拟机” 点击“自定义” 点击“下一步” 硬件兼容性选低一点能兼容的比较多 点击“下一步” 选择“稍后安装操作系统” 点击“下一步” 选择linux 选择 ubuntu64位 点击“下一步” 选择”虚拟机名称“和安装的路径 点击“下一步” 根据自身计算机性能来分配处理器数量 点击“下一步” 选择虚拟机内存，一般2G就行 点击“下一步” 选择“桥接网络” 点击“下一步” 选择推荐的那个 点击“下一步” 选择推荐的那个 点击“下一步” 选择“创建新的虚拟磁盘” 点击“下一步” 根据需求选择磁盘空间大小（一般20G以上） 点击“立即分配磁盘空间” 选择“将虚拟磁盘拆分成多个文件” 点击“下一步” 点击“下一步” 点击“完成”，开始创建（需要花很长的时间） 完成之后 先不要开启虚拟机 点击“编辑虚拟机设置” 点击”cd/dvd“ 选择“使用iso影像文件” 点击“浏览” 找到最开始装的iso文件 点击“确定 点击“开启虚拟机” 选择”中文“，点击“安装ubuntu” 点击“继续” 点击“继续” 点击“现在安装” 完成后 点击“继续” 点击“继续” 输入信息 点击“继续”，开始安装 完成后 点击“现在重启” 点击“小圆”，选择”ubuntu2d“ 输入密码，登录 完成 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:3:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"附加 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"鼠标滚轮无法使用的问题 应该只有罗技鼠标会出现这种情况吧 参考此处 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:1","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"chromium无法打开的问题 升级版本，据说chrome不支持ubuntu12及以下 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:2","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"中文输入法无法显示候选词框的问题 莫名其妙可以，如果fcitx不行，尝试安装搜狗输入法，要重启才能启用搜狗，但一般搜狗输入法也无法显示，可能与kde桌面有关，真正的原理未知 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:3","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"创建快捷方式（在启动器中） 在dash中输入，找到后直接拖到启动器中，可调整顺序 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:4","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装flatabulous主题 参考此处 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:5","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装clion 官网下载 tar.gz压缩包 然后 tar -zxvf XXX.tar.gz 解压缩 然后在bin目录下./clion.sh 安装gcc sudo apt-get update sudo apt-get install build-essential gcc --version 如果没有 sudo apt-get install gcc-对应的版本号 安装cmake 参考此处 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:6","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装pycharm 官网下载 tar.gz压缩包 然后 tar -zxvf XXX.tar.gz 解压缩 然后在bin目录下./pycharm.sh ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:7","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装anaconda 去官网下载 bash Anaconda3-2020.11-Linux-x86_64.sh 配置环境变量 vim ~/.bashrc 在最后一行输入 export PATH=\"~/anaconda3/bin:$PATH\" 然后在终端输入 source ~/.bashrc 查看anaconda版本 anaconda --version ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:8","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"安装ROS https://blog.csdn.net/u011832219/article/details/116799424 https://blog.csdn.net/qq_43626331/article/details/125855680 https://blog.csdn.net/czsnooker/article/details/120058151 ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:4:9","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["linux"],"content":"初步使用体验 初步使用ubuntu的感想 虽然ubuntu有图形界面，但它不像windows那样丰富，大多数的操作都可以通过点击可视化界面完成 ubuntu类似于万物皆文件，以抽象的形式存在，所以很多操作只能由命令行完成 ubuntu的很多操作都比windows直接，且安全性也比windows高，管理c++工程，比如安装库都要比windows方便，我觉得很大的原因在于windows要服务于大众，而linux更像自娱自乐的工具 使用linux只是使用它的特性，整体上windows还是大大优于linux ","date":"2020-06-19","objectID":"/install-ubuntu-in-vmware/:5:0","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"/install-ubuntu-in-vmware/"},{"categories":["database"],"content":"查询练习","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"数据准备 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:0","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"数据库 test3 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:1","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"建表 学生表 课程表 成绩表 教师表 Student Course Score Teacher 学号 课程号 学号 教师编号 姓名 课程名称 课程号 教师名字 性别 教师编号 成绩 教师性别 出生年月日 出生年月日 所在班级 职称 所在部门 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:2","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"学生表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:3","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"教师表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:4","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"课程表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:5","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"成绩表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:6","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"添加数据 课程表 分数 学生 教师表 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:1:7","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"10个基础查询练习 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:0","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询student中的所有记录 SELECT * FROM student; ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:1","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询其中几个字段 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:2","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询教师表中不重复的部门 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:3","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询30到50之间的成绩 或者 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:4","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询成绩是34 32 23 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:5","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询在9001班或者性别为女的同学 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:6","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"按班级降序查询 默认升序 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:7","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"在成绩表中按cnum升序优先，否则snum降序排列 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:8","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"在学生表中查找男有几个 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:9","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询最高分的学生学号和课程号 或者 上面limit第一个数字表示从哪开始，第二个数字表示查询几条 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:2:10","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"基础查询2 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:3:0","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"计算7-503课程号的平均成绩 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:3:1","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询所有的课程平均分 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:3:2","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"分组与模糊 查询在成绩表中cnum数量大于等于2且cnum以1-开头的成绩平均分（ 要用到模糊查询） ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:3:3","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"多表查询 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:0","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询学生名字、选课序号和成绩 首先可以查两个表观察一下 最后多表联查 注意是单个等号 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:1","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"三表查询 在1的基础上多一个课程名字 查询时起个别名 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:2","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询9001班学生平均分 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:3","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询选修1-797中成绩高于1004号的同学的所有成绩 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:4","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询与1001号和1002号学生同年出生的学生 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:5","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询李雷任课的学生成绩 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:6","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"查询选修某课程人数\u003e1的任课老师姓名 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:7","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"两表合并 union 先做到这边，还有很多以后再补充 ","date":"2020-06-16","objectID":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/:4:8","tags":["mysql"],"title":"mysql查询练习","uri":"/mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/"},{"categories":["database"],"content":"mysql基础","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"基本操作 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"进入数据库 mysql -uroot -p123456; ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看所有数据库 show databases； ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"使用某个数据库 use XXX; ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:3","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看某个数据库中的admin信息 select * from admin; ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:4","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"带条件的查询 select * from admin where id = 1; ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:5","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"mysql数据类型 链家 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:6","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看当前在哪个数据库 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:7","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看数据库中有哪些表 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:1:8","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"创建数据库 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"创建数据库 create database test2; ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看数据库中的表 show tables; ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"如何创建一个数据表 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:3","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看某个表的详情 或者 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:4","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"往某个表中添加新的记录 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:5","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"查看表中的记录 select * from person; ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:6","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"增加新字段 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:7","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"对字段的操作 链接 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:2:8","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"对某一条记录的crud ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:3:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"删除 delete from person where name = 'dyh'; ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:3:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"更新数据 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:3:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"创建表的约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"主键约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"联合主键 （是 与 逻辑）（不能为null） ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"自增约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:3","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"忘记添加主键约束，之后添加 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:4","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"删除主键约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:5","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"通过修改字段的方式来增加或删除主键约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:6","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"唯一约束（和主键约束的区别就是它可以为空） 失败 这样能成功（猜测和null有关） 还可以直接在创建的时候添加 当重复对一个字段添加unique是key会变成mul ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:7","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"删除唯一约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:8","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"非空约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:9","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"默认约束 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:10","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"外键约束 要两个表 主表和副表 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:4:11","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"数据表设计 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:5:0","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"1NF 字段不可拆分 链接 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:5:1","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"2NF 链接 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:5:2","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["database"],"content":"3NF 链接 ","date":"2020-06-16","objectID":"/mysql%E5%9F%BA%E7%A1%80/:5:3","tags":["mysql"],"title":"mysql基础","uri":"/mysql%E5%9F%BA%E7%A1%80/"},{"categories":["abc"],"content":"abc170","date":"2020-06-15","objectID":"/abc170/","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"A - Five Variables ","date":"2020-06-15","objectID":"/abc170/:0:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 找5个数中值为0的下标 ","date":"2020-06-15","objectID":"/abc170/:1:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 a = list(map(int , input().split())) print(a.index(0) + 1) B - Crane and Turtle ","date":"2020-06-15","objectID":"/abc170/:2:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 鸡兔同笼问题 ","date":"2020-06-15","objectID":"/abc170/:3:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 n , m = map(int , input().split()) print('Yes') if (m - 2 * n) % 2 == 0 and (m - 2 * n) \u003e= 0 and 4 * n - m \u003e= 0 and (4 * n - m) % 2 == 0 else print('No') C - Forbidden List ","date":"2020-06-15","objectID":"/abc170/:4:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一数x 和一数列，找不在数列中离x最近的数 ","date":"2020-06-15","objectID":"/abc170/:5:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 x , n = map(int , input().split()) b = [] if n!=0: b = list(map(int,input().split())) t = 0 ans = 0 while 1: if x-t not in b: ans = x - t break if x+t not in b: ans = x + t break t += 1 print(ans) D - Not Divisible ","date":"2020-06-15","objectID":"/abc170/:6:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一数列，对于数列中的每个数，如果都不能被其他数整除，计数器 + 1 求计数器的值 ","date":"2020-06-15","objectID":"/abc170/:7:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 暴力时间复杂度 O(n*√(V)) 好像会超时 可以排序，从小到大遍历，对于当前数，考虑 2*x 3*x 4*x 的值是否在数列里，如果在数列里（只会比当前数大）则移除 这样总共要算 (1/2 + 1/3 + 1/4 + 1/5 + 1/6 + … + 1/n) * V = (ln(n) + 0.578) * V 次 时间复杂度为 O(n*ln(n)) 注意当数列中有重复数，则都不能算 注意特判1个数 #include\u003cbits/stdc++.h\u003e using namespace std; int n; //int a[200005]; set\u003cint\u003e st; set\u003cint\u003e stt; multiset\u003cint\u003e ms; void did(int x){ for(int i=2;i*x\u003c=1000005;i++){ int tmp = i*x; if(st.find(tmp)!=st.end()){ st.erase(tmp); } } } int main(){ cin\u003e\u003en; //for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; for(int i=0;i\u003cn;i++){ int x; cin\u003e\u003ex; st.insert(x); stt.insert(x); ms.insert(x); } //for(int i:st) cout\u003c\u003ci\u003c\u003cendl; if(st.size()==1 and n\u003e1) { cout\u003c\u003c0\u003c\u003cendl; return 0; } if(n==1) { // WA!!! cout\u003c\u003c1\u003c\u003cendl; return 0; } for(int i:st){ did(i); } //for(int i:st) cout\u003c\u003ci\u003c\u003cendl; int ans = st.size(); // WA !!!! for(int i:st){ if(ms.count(i)\u003e1) ans--; } cout\u003c\u003cans\u003c\u003cendl; return 0; } E - Smart Infants ","date":"2020-06-15","objectID":"/abc170/:8:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 每个小朋友都有一个分数和初始的幼儿园 每次转学的操作是 将第 i 个小朋友转到第 j 个幼儿园 对于q次转学 每次输出每个幼儿园中分数最高的最小值 ","date":"2020-06-15","objectID":"/abc170/:9:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 一开始的思路是最小值的更新肯定在有变动的幼儿园和当前最小值之间选择 但这是错的，因为当前最小值被覆盖之后，更新后的最小值可能是之前的次小值（而次小值没有记录） 所以：用集合模拟幼儿园（目的在于log时间内排序） 对于每次操作都用集合模拟，用多重集维护所有的最大值 通过查看幼儿园最大值是否被更换来决定是否对多重集进行增删 一百万个数据错了3个，原因竟然是： 多重集的erase操作是全删而不是删一个 #include\u003cbits/stdc++.h\u003e using namespace std; int n,q; set\u003cpair\u003cint,int\u003e, greater\u003cpair\u003cint,int\u003e \u003e \u003e st[200005]; multiset\u003cint\u003e ms; int rat[200005]; int wh[200005]; //multiset\u003cint , greater\u003cint\u003e\u003e ts[200005]; int main(){ cin\u003e\u003en\u003e\u003eq; for(int i=0;i\u003cn;i++){ int a,b; cin\u003e\u003ea\u003e\u003eb; b--; rat[i] = a; wh[i] = b; st[b].insert({a,i}); //ts[b].insert(a); } for(int i=0;i\u003c200005;i++){ if(st[i].empty()) continue; //int num = ts[i].count(*ts[i].begin()); //for(int j=0;j\u003cnum;j++){ ms.insert(st[i].begin()-\u003efirst); //} } while(q--){ int a,b; cin\u003e\u003ea\u003e\u003eb; a--,b--; bool ismax = false; if(st[wh[a]].begin()-\u003esecond == a) ismax = true; if(ismax){ ms.erase(ms.find(rat[a])); st[wh[a]].erase({rat[a] , a}); if(st[wh[a]].empty()) ; else ms.insert(st[wh[a]].begin()-\u003efirst); wh[a] = b; if(st[b].empty()) ; else ms.erase(ms.find(st[b].begin()-\u003efirst)); st[b].insert({rat[a] , a}); ms.insert(st[b].begin()-\u003efirst); } else{ st[wh[a]].erase({rat[a] , a}); wh[a] = b; if(st[b].empty()) ; else ms.erase(ms.find(st[b].begin()-\u003efirst)); st[b].insert({rat[a] , a}); ms.insert(st[b].begin()-\u003efirst); } cout\u003c\u003c*ms.begin()\u003c\u003cendl; } return 0; } F - Pond Skater ","date":"2020-06-15","objectID":"/abc170/:10:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题意 给一个迷宫、起点、终点 对于走的方向，只能是上下左右 对于每一步，最多只能走k格且不能转弯 求是否能到达终点，如果能，最少走几步 ","date":"2020-06-15","objectID":"/abc170/:11:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["abc"],"content":"题解 bfs 每次沿一个方向，尽可能地走k步 #include\u003cbits/stdc++.h\u003e using namespace std; int h ,w ,k; int xs,ys,xt,yt; const int inf = 1e9; int dirx[] = {0,-1,1,0}; int diry[] = {1,0,0,-1}; int main(){ cin \u003e\u003e h \u003e\u003e w \u003e\u003e k; cin\u003e\u003exs\u003e\u003eys\u003e\u003ext\u003e\u003eyt; xs--,ys--,xt--,yt--; vector\u003cstring\u003e vt(h); for(int i=0;i\u003ch;i++) cin\u003e\u003evt[i]; vector\u003cvector\u003cint\u003e\u003e d(h , vector\u003cint\u003e(w,inf)); queue\u003cpair\u003cint,int\u003e\u003e q; q.push({xs,ys}); d[xs][ys] = 0; while(q.size()){ auto tmp = q.front(); q.pop(); int tmpx = tmp.first; int tmpy = tmp.second; for(int i=0;i\u003c4;i++){ // int tox = tmpx + dirx[i]; // int toy = tmpy + diry[i]; int ttmpx = tmpx; int ttmpy = tmpy; int j; for(j=0;j\u003ck;j++){ ttmpx += dirx[i]; ttmpy += diry[i]; if(ttmpx\u003e=0 and ttmpy\u003e=0 and ttmpx\u003ch and ttmpy\u003cw and vt[ttmpx][ttmpy]!='@' and d[ttmpx][ttmpy] \u003e d[tmpx][tmpy]){ if(d[ttmpx][ttmpy] \u003e d[tmpx][tmpy] + 1){ d[ttmpx][ttmpy] = d[tmpx][tmpy] + 1; q.push({ttmpx , ttmpy}); } }else break; } } } cout\u003c\u003c(d[xt][yt]==1e9 ? -1 : d[xt][yt])\u003c\u003cendl; return 0; } ","date":"2020-06-15","objectID":"/abc170/:12:0","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"/abc170/"},{"categories":["codeforces"],"content":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"A. Shovels and Swords ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:0:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 两个钻石和一个棍子可以造出A，两个棍子和一个钻石可以造出B 每个A或B都可以卖出一块钱，求 x个棍子和y个钻石最多可以卖多少钱 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:1:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 钻石和棍子是等价的，他们一共用了三个，只要贪心地将总数/3即可 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 998244353; int t; int main(){ cin\u003e\u003et; while(t--){ int a,b; cin\u003e\u003ea\u003e\u003eb; cout\u003c\u003cmin({a,b,(a+b)/3})\u003c\u003cendl; } return 0; } B. Shuffle ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:2:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 初始有n个数，第i个为1，其他为0，给若干个区间，对每个区间，可以选择区间内的数（两个或自身）交换数值 问有多少个数字能在合理选择后达到1 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:3:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 首先前面的区间是否覆盖1，没覆盖全部抛弃，否则从那个区间开始做以下事 判断接下来的区间和这个区间有没有交集，有则用并集刷新当前区间，否则抛弃 最后求集合包含了几个数 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 998244353; int n,x,m; int t; int l,r; int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003ex\u003e\u003em; int L=-1,R=-1; bool ok = false; while(m--){ cin\u003e\u003el\u003e\u003er; if(ok){ if(l\u003c=R and L\u003c=r){ L = min(L,l); R = max(R,r); } } else { if(x\u003cl or x\u003er ) continue; L = l,R = r; ok = true; } } if(L==-1 and R==-1) cout\u003c\u003c1\u003c\u003cendl; else cout\u003c\u003cR-L+1\u003c\u003cendl; } return 0; } C. Palindromic Paths ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:4:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一充满01的矩阵，从左上角走到右下角，只能向右走和向下走 改变矩阵中的若干元素，使得所有路径按序组成的字符串都是回文串 求最小改动数 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:5:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 由于题限，到每个点都走固定的步数，每个步数值与对称的步数值相同（同为0或1） bfs求每格步数，然后对于每一组求0多还是1多，以此决定全是0还是全是1 [WARNING] 以下代码，逻辑低效(懒得改) #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 998244353; int n,m; int t; int a[32][32]; int d[32][32]; vector\u003cint\u003e stp[62]; int used[32][32]; priority_queue\u003cpair\u003cint,int\u003e\u003e pq; void bfs(){ pq.push({0,0}); d[0][0] = 0; used[0][0] = 1; while(pq.size()){ pair\u003cint,int\u003e pii = pq.top(); pq.pop(); if(pii.first+1 \u003c n and used[pii.first+1][pii.second]==0) { pq.push(make_pair(pii.first+1,pii.second)); d[pii.first+1][pii.second] = d[pii.first][pii.second] + 1; used[pii.first+1][pii.second] = 1; } if(pii.second+1 \u003c m and used[pii.first][pii.second+1]==0){ pq.push(make_pair(pii.first,pii.second+1)); d[pii.first][pii.second+1] = d[pii.first][pii.second] + 1; used[pii.first][pii.second+1] = 1; } } for(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) stp[d[i][j]].push_back(a[i][j]); } int main(){ cin\u003e\u003et; while(t--){ int ans = 0; cin\u003e\u003en\u003e\u003em; for(int i=0;i\u003c62;i++) stp[i].clear(); memset(used,0,sizeof(used)); for(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) cin\u003e\u003ea[i][j]; bfs(); for(int i=0,j=n+m-2;i\u003cj;i++,j--){ if((n+m-2)%2==0 and i==j) continue; int zero = count(stp[i].begin(),stp[i].end(),0) + count(stp[j].begin(),stp[j].end(),0); int one = count(stp[i].begin(),stp[i].end(),1) + count(stp[j].begin(),stp[j].end(),1); ans += 2*stp[i].size() - max(zero,one); } cout\u003c\u003cans\u003c\u003cendl; } return 0; } D. Two Divisors ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:6:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一数n，判断n的所有因子中（1除外）是否存在 d1 d2使得 d1+d2与n互质 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:7:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 如果存在，则这组数可以是 d1*d2 = n d1 与d2一定互质 让n一直除以最小因子，除到最后不为1，则剩下的数与之前的除数互质，满足条件 最小因子可以筛法预处理 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 998244353; int n; int d1[500005]; int d2[500005]; int a[500005]; int f[10000005]; void preprocess(){ for(int i=2;i\u003c10000005;i++) if(f[i] == 0) { f[i] = i; for(int j=i+i;j\u003c10000005;j+=i) f[j] = i; } } void did(int x,int ind){ int foo = f[x]; int bar = x; while(x%foo==0) x /= foo; if(x==1) d1[ind]=-1,d2[ind]=-1; else d1[ind]=x,d2[ind]=bar/x; } int main(){ preprocess(); cin\u003e\u003en; for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; for(int i=0;i\u003cn;i++) did(a[i] , i); for(int i=0;i\u003cn;i++) cout\u003c\u003cd1[i]\u003c\u003c\" \"; cout\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003cd2[i]\u003c\u003c\" \"; cout\u003c\u003cendl; return 0; } E. Two Arrays ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:8:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给两个数组A B（B为递增），B的大小为m，将A分成m个区间，使得每个区间的最小值与B的每个数相同（按顺序对应），求方案数 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:9:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 隔板法，双指针锁定每个数之间隔板可以移动的范围，最后乘法原理 对于可移动范围，因为B是递增的，从右往左遍历 就是A B数组元素比大小，然后右边的指针贪心地选择可满足数中最右边的数，左指针贪心地选择可满足数中最左边的数 （即右指针左移过程中，碰到可满足数就停下来，左指针要一直移动直到不满足，这样得到最大的区间） 注意特判！！ #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 998244353; ll ans = 1; int a[200005]; int b[200005]; int n,m; int l[200005]; int r[200005]; int main(){ cin\u003e\u003en\u003e\u003em; for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; for(int i=0;i\u003cm;i++) cin\u003e\u003eb[i]; for(int i=0;i\u003cm;i++) l[i] = r[i] = -1; int ind = m-1; for(int i=n-1;i\u003e=0;i--){ while(ind\u003e=0 and b[ind] \u003e a[i]) ind--; if(ind\u003c0) { cout\u003c\u003c0\u003c\u003cendl; exit(0); } l[ind] = i; if(a[i] == b[ind] and r[ind]==-1){ //greedy r[ind] = i; } } if(l[0]==-1 or r[0]==-1) { cout\u003c\u003c0\u003c\u003cendl; exit(0); } for(int i=1;i\u003cm;i++){ if(l[i]==-1 or r[i]==-1) { cout\u003c\u003c0\u003c\u003cendl; exit(0); } ans *= (ll) (r[i] - l[i] + 1); ans %= mod; } cout\u003c\u003cans\u003c\u003cendl; return 0; } F. Jog Around The Graph ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:10:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:11:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 不会 G. Construct the String ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:12:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:13:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-06-13","objectID":"/educational-codeforces-round-89-rated-for-div.-2-a~e/:14:0","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"/educational-codeforces-round-89-rated-for-div.-2-a~e/"},{"categories":["Python web"],"content":"Flask-RESTful简单实例","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"Python web的框架有Django Flask Tornado Flask 是一个使用 Python 编写的轻量级 Web 应用程序框架，由werkzeug服务器和jinja2模板引擎组成 RESTful是一个与资源（resource）有关的架构理念 REST全称Representational State Transfer，详细信息参考下面的资料 ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:0","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"功能说明 接下来用Flask-RESTful扩展实现一个非常简单的实例，没有用到数据库，没有用到前端页面（模板），没有表单验证，没有复杂的业务逻辑 只用字典存储数据，实现crud（后期将增加数据库） ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:1","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"实现原理 安装 pip install flask-restful Flask-RESTful最基本的套路 实例化app api 实例化解析器，将待验证的参数加进解析器中 根据路由编写对应的类，在类下面编写需要的函数 将类和对应的路由集成到api中 代码如下 from flask import Flask from flask_restful import reqparse , abort , Api , Resource #实例化 app = Flask(__name__) api = Api(app) #创造初始数据 PERSONS = { 'p1' : {'name' : 'qaz' , 'num' : '15'} , 'p2' : {'name' : 'wsx' , 'num' : '16'} , 'p3' : {'name' : 'edc' , 'num' : '17'} , } def not_exist(ps_id): if ps_id not in PERSONS: abort(404 , message = 'person {} not exist'.format(ps_id)) #实例化解析器 #增加验证参数 parser = reqparse.RequestParser() parser.add_argument('name' , type=str , required=True , help='it is a string') #把它设为必填项 parser.add_argument('num' , type=int , required=True , help='it is a number') #把它设为必填项 #对单个人的操作 class Person(Resource): def get(self , ps_id): not_exist(ps_id) return PERSONS[ps_id] def delete(self , ps_id): not_exist(ps_id) del PERSONS[ps_id] return '' , 204 def put(self , ps_id): not_exist(ps_id) args = parser.parse_args() #开始数据验证 info = {'name' : args['name'] , 'num' : args['num']} PERSONS[ps_id] = info #更新 return info , 201 #对所有人的操作 class PersonList(Resource): def get(self): return PERSONS def post(self): global ps_id args = parser.parse_args() #暴力求缺失id lis = [] #求每个键，然后过滤出数字，加进列表中，遍历获得空位置 for i in PERSONS.keys(): tmp_filter = filter(str.isdigit , i) tmp_list = list(tmp_filter) tmp_str = ''.join(tmp_list) tmp_int = int(tmp_str) lis.append(tmp_int) lis.sort() flag = False for i,j in range(len(lis)),lis: if i+1 != j: ps_id = i+1 flag = True break if(not flag): ps_id = len(lis) + 1 ps_id = 'p%d' % (ps_id) PERSONS[ps_id] = {'name':args['name'] , 'num':args['num']} return PERSONS[ps_id] , 201 #增加对应的路由 api.add_resource(Person , '/persons/\u003cstring:ps_id\u003e') api.add_resource(PersonList , '/persons') if __name__ == '__main__': app.run() ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:2","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"测试 查询所有信息 根据ps_id查询单个人的信息 根据ps_id删除某个人的信息 再查看所有人的信息 增加某个人的信息 查看所有人的信息 由于之前删除了2号，所以它占据了2号的位置 改变某个人的信息 现在p3 的name是edc num是17 改成name是uuu，num是27 查看所有人的信息以验证 ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:3","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"参考资料（部分） ","date":"2020-06-13","objectID":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/:0:4","tags":["python"],"title":"Flask-RESTful简单实例","uri":"/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/"},{"categories":["Python web"],"content":"Flask学习","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"扩展的地址 flask扩展的地址 ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:1:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"requirement.txt 用来存项目的依赖和版本 ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:2:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"生成requirement.txt pip freeze \u003e requirement.txt ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:2:1","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"安装requirement.txt pip install -r requirement.txt ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:2:2","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"基本框架 from flask import Flask app = Flask(__name__) @app.route('/') def index(): return 'hello world' if __name__ == '__main__': app.run() Flask-RESTful from flask import Flask import flask_restful app = Flask(__name__) api = flask_restful.Api(app) class Hello(flask_restful.Resource): def get(self): return 'hello world' api.add_resource(Hello , '/') if __name__ == '__main__': app.run() ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:3:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"路由 ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:4:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"改变路由请求方式 @app.route('/', methods = ['GET', 'POST']) def index(): return 'hello world' ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:4:1","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"路由参数处理 @app.route('/order/\u003corder_id\u003e') def fun(order_id): return 'order id is %s' % order_id 格式限定 @app.route('/order/\u003cint:order_id\u003e') def fun(order_id): return 'order id is %s' % order_id ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:4:2","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"Jinja2模板 ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"Jinja2模板引擎渲染网页 from flask import Flask, render_template app = Flask(__name__) @app.route('/') def hello_world(): return render_template('index1.html') if __name__ == '__main__': app.run() ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:1","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"和模板链接更改数据 from flask import Flask, render_template app = Flask(__name__) @app.route('/') def hello_world(): tmp_url = 'https://dyhgo.fun' return render_template('index1.html', str_url=tmp_url) #此处模板中有str_url if __name__ == '__main__': app.run() ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:2","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"变量代码块 {{str_url}} ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:3","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"注释 {# 这是注释 #} ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:4","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"控制代码块 @app.route('/') def hello_world(): my_list = [1, 2, 3] return render_template('index.html', my_list=my_list) {% for i in my_list %} {% if i \u003e 1 %} {{i}} \u003cbr\u003e {% endif %} {% endfor %} ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:5","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"过滤器 @app.route('/') def hello_world(): _url = 'aaaB' return render_template('index.html', _url=_url) {{_url | upper}}\u003cbr\u003e {{_url | reverse}} \u003cbr\u003e {{_url | lower | reverse}}\u003cbr\u003e ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:5:6","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["Python web"],"content":"Flask表单 from flask import Flask, render_template, request, flash app = Flask(__name__) app.secret_key = 'csfdka' @app.route('/' , methods = ['POST','GET']) def fun(): if request.method == 'POST': username = request.form.get('username') psw = request.form.get('psw') psw2 = request.form.get('psw2') print(username,psw,psw2) if not all([username , psw , psw2]): flash('有待填项') elif psw2 != psw: flash('两次密码不一致') else: return 'success' return render_template('index1.html') # @app.route('/order/\u003cint:order_id\u003e') # def fun2(order_id): # return 'order id is %s' % order_id if __name__ == '__main__': app.run() index1.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform method=\"post\"\u003e \u003clabel\u003e用户名\u003c/label\u003e\u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e \u003clabel\u003e密码\u003c/label\u003e\u003cinput type=\"password\" name=\"psw\"\u003e\u003cbr\u003e \u003clabel\u003e确认密码\u003c/label\u003e\u003cinput type=\"password\" name=\"psw2\" \u003e\u003cbr\u003e \u003cinput type=\"submit\" value=\"提交\" \u003e\u003cbr\u003e {% for message in get_flashed_messages() %} {{message}}\u003cbr\u003e {% endfor %} \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-06-12","objectID":"/flask%E5%AD%A6%E4%B9%A0/:6:0","tags":["python"],"title":"Flask学习","uri":"/flask%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"Python学习","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"记录一下第n次学python。。。 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:0:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"打印 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:1:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"转义字符的打印 str = r\"D:\\now\" print(str) ------------------------------ D:\\now ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:1:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"数据类型 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:2:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"获得数据类型 print(type(3.14)) print(isinstance(15, int)) ----------------------------------- \u003cclass 'float'\u003e True ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:2:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"运算符 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:3:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"整数除法 幂次 大小关系表达式 print(3//2) print(-3**3) print(3\u003c4\u003c5) -------------------------- 1 -27 True ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:3:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"三目运算符 x = 6 if 2 \u003e 4 else 7 print(x) -------------------------------- 7 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:3:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"运算符的优先级 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:3:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"列表 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"普通列表 混合列表 空列表 a = [2,3,4] print(a) a = ['2',3,True] print(a) print(len(a)) a = [] print(a) ------------------------------ [2, 3, 4] ['2', 3, True] 3 [] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"append insert extend a = [1,\"2\",3] a.append(\"sss\") print(a) a.extend([\"eee\",6]) print(a) a.insert(1,\"one\") print(a) ------------------------------ [1, '2', 3, 'sss'] [1, '2', 3, 'sss', 'eee', 6] [1, 'one', '2', 3, 'sss', 'eee', 6] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"删除元素 a = [1,2,3,3] a.remove(1) print(a) a.remove(3) print(a) ----------------------- [2, 3, 3] [2, 3] a = [1,2,3] del a[0] print(a) del a print(a) ------------------------ [2, 3] Traceback (most recent call last): File \"D:/python/mysources/test2/test2.py\", line 38, in \u003cmodule\u003e print(a) NameError: name 'a' is not defined a = [1,2,3,4,5] a.pop() print(a) print(a.pop()) a.pop(1) print(a) ---------------------------- [1, 2, 3, 4] 4 [1, 3] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"slice a = [1,2,3,4] print(a[1:3]) print(a[:3]) print(a[1:]) print(a[:]) print(a[:-1]) print(a[-3:]) -------------------------- [2, 3] [1, 2, 3] [2, 3, 4] [1, 2, 3, 4] [1, 2, 3] [2, 3, 4] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:4","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"操作符 a = [3,3,1,1,2,4] print(a.count(3)) print(a.index(1)) print(a.index(3)) print(a.index(1,3)) print(a.index(1,1,2))#左闭右开 ------------------------------------ 2 2 0 3 Traceback (most recent call last): File \"D:/python/mysources/test2/test2.py\", line 60, in \u003cmodule\u003e print(a.index(1,1,2))#左闭右开 ValueError: 1 is not in list a = [3,5,7,1,2] b = a[:] c = a a.reverse() print(a) a.sort() print(a) a.sort(reverse=True) print(a) print(b) print(c) ------------------------------------ [2, 1, 7, 5, 3] [1, 2, 3, 5, 7] [7, 5, 3, 2, 1] [3, 5, 7, 1, 2] [7, 5, 3, 2, 1] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:4:5","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"元组 a = (1,2,'4') print(a) a = 1, print(type(a)) a = (1,) print(type(a)) ----------------------- (1, 2, '4') \u003cclass 'tuple'\u003e \u003cclass 'tuple'\u003e ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:5:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"格式化 s = '{0} {1} {2}'.format(\"aaa\",\"bb\",\"c\") print(s) s = '{0:.2f} {1}'.format(3.266,'ww') print(s) s = \"%s %c %6.2f\" % ('qqq',98,3.145) print(s) print('%#o' % 10) print('%010d' % 52) --------------------------------- aaa bb c 3.27 ww qqq b 3.15 0o12 0000000052 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:6:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"序列 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:7:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"一些函数 a = list('abc') print(a) a = list((2,3,4)) print(a) a = list((3,5,1,7,3)) print(sorted(a)) print(reversed(a)) #没有改变 a print(list(reversed(a))) print(sorted(a,reverse=True)) print(enumerate(a)) print(list(enumerate(a))) b = [4,2,6] print(zip(a,b)) print(list(zip(a,b))) -------------------------------------------- ['a', 'b', 'c'] [2, 3, 4] [1, 3, 3, 5, 7] \u003clist_reverseiterator object at 0x000001961A58C400\u003e [3, 7, 1, 5, 3] [7, 5, 3, 3, 1] \u003cenumerate object at 0x000001961A59DA68\u003e [(0, 3), (1, 5), (2, 1), (3, 7), (4, 3)] \u003czip object at 0x000001961A59E5C8\u003e [(3, 4), (5, 2), (1, 6)] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:7:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"函数 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"函数文档 def func(a): 'it is a doc' print(a) func(3) print(func.__doc__) help(func) ------------------------------ 3 it is a doc Help on function func in module __main__: func(a) it is a doc ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"函数参数 def func(*params , x = 5): print(x) print(params[1]) def fun(*param , x): print(x) func(2,3,1) fun(4,5,2,x=7) --------------------------- 5 3 7 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"全局变量 a = 5 def fun(): a = 10 print(a) def func(): global a a = 10 fun() print(a) func() print(a) 10 5 10 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"★闭包 def fun1(x): def fun2(y): return x*y return fun2 a = fun1(3) print(type(a)) b = a(5) print(b) print(fun1(4)(7)) ------------------------- \u003cclass 'function'\u003e 15 28 def fun1(): x = 3 def fun2(): x *= x return x return fun2() print(fun1()) ------------------------- Traceback (most recent call last): File \"D:/python/mysources/test2/test2.py\", line 155, in \u003cmodule\u003e print(fun1()) File \"D:/python/mysources/test2/test2.py\", line 154, in fun1 return fun2() File \"D:/python/mysources/test2/test2.py\", line 152, in fun2 x *= x UnboundLocalError: local variable 'x' referenced before assignment def fun1(): x = [3] def fun2(): x[0] *= x[0] #容器化 return x[0] return fun2() print(fun1()) ----------------------------------- 9 def fun1(): x = 3 def fun2(): nonlocal x x *= x return x return fun2() print(fun1()) --------------------------------------- 9 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:4","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"★lambda表达式 a = lambda x,y : x + y print(a) print(type(a)) print(a(3,6)) ------------------------ \u003cfunction \u003clambda\u003e at 0x000001418C837F28\u003e \u003cclass 'function'\u003e 9 print(list(filter(lambda x:x%2,[1,2,3,4,5]))) print(list(map(lambda x:x*2+1,[1,2,3,4,7]))) -------------------------------------------------------- [1, 3, 5] [3, 5, 7, 9, 15] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:8:5","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"字典 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:9:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"字典化 a = dict((('2','aaa') , (3,'vvv') , ('ss',7))) print(a) a = dict(a='222' , sss=99) #key是字符串 print(a) ---------------------------------------------- {'ss': 7, '2': 'aaa', 3: 'vvv'} {'a': '222', 'sss': 99} ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:9:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"字典的bif a = {} print(a.fromkeys((1,2,3),'num')) #产生新的但不改变a print(a) print(a.fromkeys((1,3,4),('a','b'))) print(a.fromkeys((1,3,4),('a','b','d'))) print(a.fromkeys(range(4),'s')) ------------------------------------------------- {1: 'num', 2: 'num', 3: 'num'} {} {1: ('a', 'b'), 3: ('a', 'b'), 4: ('a', 'b')} {1: ('a', 'b', 'd'), 3: ('a', 'b', 'd'), 4: ('a', 'b', 'd')} {0: 's', 1: 's', 2: 's', 3: 's'} a = {} b = a.fromkeys((1,3,4),'s') print(b.keys()) print(b.values()) print(dict(b.items())) print(b.get(7,'x')) print(b.get(3,'x')) ---------------------------- dict_keys([1, 3, 4]) dict_values(['s', 's', 's']) {1: 's', 3: 's', 4: 's'} x s a = {1:2} b = a a = {} print(a) print(b) b = a a.clear() print(b) ----------------------------- {} {1: 2} {} a = {1:'one' , 2:'to' , 3:'san'} b = a c = a.copy() print(id(a)) print(id(b)) print(id(c)) a.popitem() #随机返回并删除最后一组的键值对 print(a) a.setdefault(4,'for') print(a) d = {'5':'five' , 2:'two'} a.update(d) print(a) ---------------------- 2597077552072 2597077552072 2597077552200 {2: 'to', 3: 'san'} {2: 'to', 3: 'san', 4: 'for'} {2: 'two', 3: 'san', 4: 'for', '5': 'five'} ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:9:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"文件 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:10:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"输入输出重定向 import sys std_out = sys.stdout #备份 std_in = sys.stdin #备份 sys.stdout = open('out.txt','w') sys.stdin = open('in.txt','r') n,m = map(int,input().split()) print(n+m) sys.stdout.close() sys.stdin.close() ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:10:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"异常 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:11:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"捕获异常 try: print(2) print(1+'2') except (NameError , TypeError) as reason: print(reason) ------------------------------------------ 2 unsupported operand type(s) for +: 'int' and 'str' try: print(2) print(1+'2') except NameError as reason: print('not defined' + str(reason)) except TypeError as reason: print(reason) ----------------------------------------- 2 unsupported operand type(s) for +: 'int' and 'str' try: print(2) print(1+'2') except (NameError, TypeError) as reason: print(reason) finally: print('aaa') ------------------------------------ 2 unsupported operand type(s) for +: 'int' and 'str' aaa ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:11:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"异常中的else try: print(2) print(1+'2') except (NameError , TypeError) as reason: print(reason) else: print('no error') finally: print('aaa') ------------------- 2 unsupported operand type(s) for +: 'int' and 'str' aaa ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:11:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"类 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"继承（可以继承多个，但要小心） class Mylist(list): pass ml = Mylist() ml.append(1) ml.append(3) ml.append(2) ml.sort() print(ml) --------------------- [1, 2, 3] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"基本用法 class Person: name = None school = 'hhu' def fun1(self): print(self.name) def fun2(self): print(self.school) p = Person() p.name = 'qq' p.fun1() p.fun2() --------------------- qq hhu ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"构造函数 class Person: def __init__(self,name,gender): self.name = name self.gender = gender def doit(self): print(self.name,self.gender) p = Person('qq','female') p.doit() ----------------------------- qq female ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"私有变量 class Person: __name = 'aaa' def getName(self): return self.__name p = Person() print(p.getName()) print(p._Person__name) print(p.__name) print(p.name) ------------------ aaa aaa Traceback (most recent call last): File \"D:/python/mysources/test2/test2.py\", line 282, in \u003cmodule\u003e print(p.__name) AttributeError: 'Person' object has no attribute '__name' ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:4","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"类对象、实例对象 class A: f = 1 def x(self): print('xxx') a = A() b = A() c = A() c.f += 1 print(c.f) print(a.f) A.f += 100 print(a.f) print(b.f) print(c.f) d = A() print(d.x()) d.x = 1 print(d.x) print(d.x()) ------------------- Traceback (most recent call last): File \"D:/python/mysources/test2/test2.py\", line 305, in \u003cmodule\u003e print(d.x()) TypeError: 'int' object is not callable 2 1 101 101 2 xxx None 1 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:12:5","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"构造和析构 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:13:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"杂乱记录 ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:14:0","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"将输入数四舍五入显示 n = float(input()) print('%.2f' % (n + 0.001)) ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:14:1","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"多组输入直到文件结束 while True: try: pass except: break ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:14:2","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["note"],"content":"二维列表的定义 a = [[0] * 5 for i in range(10)] print(a) ------------------------------ [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] ","date":"2020-06-11","objectID":"/python%E5%AD%A6%E4%B9%A0/:14:3","tags":["python"],"title":"Python学习","uri":"/python%E5%AD%A6%E4%B9%A0/"},{"categories":["abc"],"content":"abc169","date":"2020-06-08","objectID":"/abc169/","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"由于事情太多，拖了这么久 A - Multiplication 1 ","date":"2020-06-08","objectID":"/abc169/:0:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入两个数，求积 ","date":"2020-06-08","objectID":"/abc169/:1:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 n,m = map(int,input().split()) print(n*m) B - Multiplication 2 ","date":"2020-06-08","objectID":"/abc169/:2:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入很多大数，求积是否超过1e18 ","date":"2020-06-08","objectID":"/abc169/:3:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 用 __int128 ， 样例有个情况是前面超过1e18但后面有0 所以遍历一遍数组判断是否有0 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using INT = __int128; ll a[100005]; int main(){ ll n; cin\u003e\u003en; INT ans = 1; bool flag = true; for(ll i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; if(!a[i]) flag = false; } if(!flag) { cout\u003c\u003c0\u003c\u003cendl; exit(0); } for(ll i=0;i\u003cn;i++){ ll x = a[i]; ans *= (INT) x; if(ans \u003e (INT) 1e18) { cout\u003c\u003c-1\u003c\u003cendl; exit(0); } } cout\u003c\u003c(ll)ans\u003c\u003cendl; return 0; } C - Multiplication 3 ","date":"2020-06-08","objectID":"/abc169/:4:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 输入两个数，求积 。一个数上限 1e15 ，一个数为小于10的正两位小数 ","date":"2020-06-08","objectID":"/abc169/:5:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 因为精度问题，先 *100 再 /100 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ ll a,b,c; scanf(\"%lld %lld.%lld\",\u0026a,\u0026b,\u0026c); ll ans = a*(b*100+c) ; ans /= 100LL; cout\u003c\u003cans\u003c\u003cendl; return 0; } D - Div Game ","date":"2020-06-08","objectID":"/abc169/:6:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-06-08","objectID":"/abc169/:7:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 根据唯一分解定理分解，得到质因子和每种质因子的个数 要求次数最多，对于每种质因子，取1次方，2次方，3次方。。。 有个WA点，当无法整除时，ans+1（本身的质数） #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; map\u003cll,ll\u003e mp; bool isprime(ll n){ if(n==1) return false; for(ll i=2;i*i\u003c=n;i++){ if(n%i==0){ return false; } } return true; } int main(){ ll n; cin\u003e\u003en; ll nn = n; for(ll i=2;i*i\u003c=nn;i++){ while(n%i==0){ n/=i; mp[i]++; } } //cout\u003c\u003cmp[2]\u003c\u003cmp[5]; ll ans = 0; for(auto i:mp){ //cout\u003c\u003ci.first\u003c\u003c\" \"\u003c\u003ci.second\u003c\u003cendl; ll tmp = i.second; ll cnt = 0; ll ct = 1; while(cnt\u003c=tmp){ cnt += ct++; } ct -= 2; ans += ct; } if(isprime(n)) ans++; //wa点 做不下去时要判断是不是质数 如果是质数那么z可以等于这个数 即答案+1 cout\u003c\u003cans\u003c\u003cendl; return 0; } E - Count Median ","date":"2020-06-08","objectID":"/abc169/:8:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 给 n 个区间，可以在每个区间中选一个数，这样就有 n 个数，对这n个数求中位数，问所有方案中，中位数有几种 ","date":"2020-06-08","objectID":"/abc169/:9:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 数学题 求最小的可能中位数和最大的可能中位数，在此之间的所有数都能取到 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll a[200005],b[200005]; int main(){ ll n; cin\u003e\u003en; for(ll i=0;i\u003cn;i++){ scanf(\"%lld%lld\",\u0026a[i],\u0026b[i]); } sort(a,a+n); sort(b,b+n); ll low ,hi; if(n\u00261){ low = a[(n-1)/2]; hi = b[(n-1)/2]; }else{ low = a[(n-2)/2] + a[(n-2)/2+1] ; hi = b[(n-2)/2] + b[(n-2)/2+1]; } cout\u003c\u003chi-low+1\u003c\u003cendl; return 0; } F - Knapsack for All Subsets ","date":"2020-06-08","objectID":"/abc169/:10:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题意 给一堆数，和一个数s 对于这堆数形成的集合，对于它的每个子集 如果该子集中有一个子集的数和为s，计数器加1 求计数器的值 ","date":"2020-06-08","objectID":"/abc169/:11:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["abc"],"content":"题解 计数dp题 可以考虑其中一种方案是 i 个数加起来等于 s 那么容纳它的所有集合都满足条件 所以计数器加 i*2^(n-i) 要求一堆数中，哪些数加起来能等于s就类似于背包问题 所以考虑dp dp[i][j] 表示前 i 个数和为 j 的答案 对于当前数，可以选择，也可以不选 转移方程 dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]] 根据上面的结论加上dp表示的是答案，所以每多选一个数，就会在前一个的基础上 /2 所以真正的转移方程为 dp[i][j] = dp[i-1][j] + ( dp[i-1][j-a[i]] ) / 2 这样初始条件就是 dp[0][0] = 2^n #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll dp[3005][3005]; ll n,s; ll a[3005]; const ll mod = 998244353; ll qpow(ll a, ll b, ll m){ if(b == 0) return 1; else if(b % 2 == 1) return a * qpow(a, b - 1, m) % m; else{ ll num = qpow(a, b/2, m) % m; return num * num % m; } } const ll inv2 = (mod+1) / 2; int main(){ cin\u003e\u003en; cin\u003e\u003es; for(ll i=1;i\u003c=n;i++) cin\u003e\u003ea[i]; dp[0][0] = qpow(2,n,mod); for(int i=1;i\u003c=n;i++){ for(int j=0;j\u003c=s;j++){ (dp[i][j] += dp[i-1][j]) %= mod; if(j\u003e=a[i]) { (dp[i][j] += dp[i-1][j-a[i]] * inv2) %= mod; } } } cout\u003c\u003cdp[n][s]%mod\u003c\u003cendl; return 0; } ","date":"2020-06-08","objectID":"/abc169/:12:0","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"/abc169/"},{"categories":["problemlist"],"content":"每日一题 (X)","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"堆 贪心 题目 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n; struct p{ ll v,s; }ps[100005]; bool cmp(p a,p b){return a.s\u003eb.s;} priority_queue\u003cll , vector\u003cll\u003e , greater\u003cll\u003e \u003e pq; int main(){ cin\u003e\u003en; for(ll i=0;i\u003cn;i++) cin\u003e\u003eps[i].v\u003e\u003eps[i].s; sort(ps,ps+n,cmp); ll temp=0,ans=0; for(ll i=0;i\u003cn;i++){ temp+=ps[i].v; pq.push(ps[i].v); while(pq.size()\u003eps[i].s){ temp-=pq.top(); pq.pop(); } ans=max(ans,temp); } cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:1:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"区间dp 题目 不会做，看了别人的题解写的 考虑到数据大小 区间dp dp[i][j][k][l] 表示在s1中取i到j区间，在s2中取k到l区间是否能组成回文串 这样它有四种状态转移（分别考虑边界） 对于每一种状态，只要有一种满足就行，用或运算实现 注意一些边界条件，长度从0开始、特判 先枚举长度，对于每一种长度，枚举区间 #include\u003cbits/stdc++.h\u003e using namespace std; int t; char s1[52]; char s2[52]; int dp[52][52][52][52]; int ans=0; int main(){ cin\u003e\u003et; while(t--){ ans=0; memset(dp,0,sizeof(dp)); //没有重置又WA了 scanf(\"%s\",s1+1); scanf(\"%s\",s2+1); int len1=strlen(s1+1); int len2=strlen(s2+1); for(int i=0;i\u003c=len1;i++) for(int j=0;j\u003c=len2;j++) for(int l1=1,r1=i+l1-1;r1\u003c=len1 ;l1++,r1++) for(int l2=1,r2=j+l2-1;r2\u003c=len2 ;l2++,r2++){ if(i+j\u003c=1) dp[l1][r1][l2][r2]=1; else{ if(s1[l1]==s1[r1] and r1\u003e0) dp[l1][r1][l2][r2] |= dp[l1+1][r1-1][l2][r2]; if(s1[l1]==s2[r2] and r2\u003e0) dp[l1][r1][l2][r2] |= dp[l1+1][r1][l2][r2-1]; if(s2[l2]==s1[r1] and r1\u003e0) dp[l1][r1][l2][r2] |= dp[l1][r1-1][l2+1][r2]; if(s2[l2]==s2[r2] and r2\u003e0) dp[l1][r1][l2][r2] |= dp[l1][r1][l2+1][r2-1]; } if(dp[l1][r1][l2][r2]) ans=max(ans,r2-l2+r1-l1+2); } cout\u003c\u003cans\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:2:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"前缀和 区间dp 题目 暴力时间复杂度 O(n^2) dp[i] 表示右区间的右边界为i时的最大值 maxv[i] 表示前 i+1个数区间长度为k的最大值（单区间） 那么 dp[i]=右区间的值+maxv[i] 求 maxv[i] 直接用前缀和预处理，时间复杂度 O(n) 依次遍历数组求答案 据说用st表也可以做，但我不会 思考问题的变形 一：不限制长度——在一个数列里找两个不相交区间使得他们权值和最大 二：区间数目变多——找 m个长度为 k 的不相交区间使得他们的权值和最大 (1≤n≤5000) 三：区间数目变多且不限制长度——找 m 个不相交长度不限的区间使得他们权值和最大(1≤n≤5000) #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll t; ll a[200005]; ll n,k; ll maxv[200005]; ll sum[200005]; ll ans=0; ll asn1=0; ll ans2=0; ll dp[200005]; int main(){ cin\u003e\u003et; while(t--){ //reset TODO ans=-1e15; //开1e9WA了一发 无语 cin\u003e\u003en\u003e\u003ek; for(ll i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; if(i\u003e0) sum[i]=sum[i-1]+a[i]; else sum[i]=a[i]; } //preprocess maxv[k-1]=sum[k-1]; for(ll i=k;i\u003cn-k;i++){ maxv[i]=max(maxv[i-1],sum[i]-sum[i-k]); } ll temp=0; for(ll i=k;i\u003c2*k;i++) temp+=a[i]; for(ll i=2*k-1;i\u003cn;i++){ dp[i]=temp+maxv[i-k]; ans=max(ans,dp[i]); if(i\u003cn-1){ temp+=a[i+1]; temp-=a[i+1-k]; } } cout\u003c\u003cans\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:3:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"位运算 题目 模拟位运算 暴力超时 可优化为 (a1+a2+a3...)*(a1+a2+a3...) a为每一位的1 这样只需要计算每一位1的数量 对于每一位，数量平方乘上二次幂系数 最后求和 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n; ll a[100005]; ll bin[100]; int main(){ cin\u003e\u003en; ll temp; for(ll i=0;i\u003cn;i++){ ll p=0; cin\u003e\u003etemp; while(temp!=0){ if(temp%2==1) bin[p]++; p++; temp/=2; } } ll ans=0; for(ll i=0;i\u003c100;i++){ ans+=(bin[i]*bin[i])*(1\u003c\u003ci); } cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:4:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"双端队列 （滑动窗口求最值） 题目 经典的滑动窗口求最大最小值问题 经典的做法就是利用双端队列 可以参考此处的讲解 #include\u003cbits/stdc++.h\u003e using namespace std; int n,k; int num[1000005]; deque\u003cint\u003e dq1; deque\u003cint\u003e dq2; vector\u003cint\u003e ans1; vector\u003cint\u003e ans2; int main(){ cin\u003e\u003en\u003e\u003ek; for(int i=0;i\u003cn;i++) cin\u003e\u003enum[i]; for(int i=0;i\u003cn;i++){ if(!dq2.empty() and dq2.front()\u003c=i-k){ dq2.pop_front(); } while(!dq2.empty() and num[dq2.back()]\u003c=num[i]){ dq2.pop_back(); } dq2.push_back(i); if(i\u003e=k-1){ ans2.push_back(num[dq2.front()]); } //-----------------华丽的分割线--------------------------- if(!dq1.empty() and dq1.front()\u003c=i-k){ dq1.pop_front(); } while(!dq1.empty() and num[dq1.back()]\u003e=num[i]){ dq1.pop_back(); } dq1.push_back(i); if(i\u003e=k-1){ ans1.push_back(num[dq1.front()]); } } for(int i:ans1) cout\u003c\u003ci\u003c\u003c\" \"; cout\u003c\u003cendl; for(int i:ans2) cout\u003c\u003ci\u003c\u003c\" \"; cout\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:5:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dp 题目 dp[i] 表示以i为节点的最小费用 则 dp[i]+=min(dp[ch],w) w表示当前i与ch的费用，即不断更新成最小值然后加上去 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n,m,s; vector\u003cpair\u003cll,ll\u003e \u003e G[100005]; ll dp[100005]; ll deg[100005]; const ll inf=0x3f3f3f3f3f3f; void dfs(ll s,ll p){ for(auto i:G[s]){ ll x=i.first; ll y=i.second; if(x!=p){ dfs(x,s); dp[s]+=min(dp[x],y); } } } int main(){ cin\u003e\u003en\u003e\u003em\u003e\u003es; while(m--){ ll u,v,w; cin\u003e\u003eu\u003e\u003ev\u003e\u003ew; G[u].emplace_back(v,w); G[v].emplace_back(u,w); deg[u]++; deg[v]++; } for(ll i=1;i\u003c=n;i++) if(deg[i]==1 and i!=s) dp[i]=inf; dfs(s,-1); cout\u003c\u003cdp[s]\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:6:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"二分查找 题目 和abc157-E很像 用集合存26个字母对应的下标 依次查找p中字符在s中的位置 每次对集合二分查找 有一个防止集合为空的小技巧 #include\u003cbits/stdc++.h\u003e using namespace std; char s[1000005]; int n; char p[1000005]; set\u003cint\u003e st[27]; int main(){ scanf(\"%s\",s+1); int len=strlen(s+1); //preprocess for(int i=0;i\u003c27;i++){ //防止为空 st[i].insert(len+1); } for(int i=1;i\u003c=len;i++){ st[s[i]-'a'].insert(i); } cin\u003e\u003en; while(n--){ bool ok=true; scanf(\"%s\",p+1); int lenp = strlen(p+1); int foo=1; for(int i=1;i\u003c=lenp;i++){ auto ind=st[p[i]-'a'].lower_bound(foo); if(*ind==len+1){ ok=false; break; } else{ foo=(*ind)+1; } } puts(ok?\"Yes\":\"No\"); } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:7:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dfs 题目 对于一个节点，如果以这个节点为根的树的节点（包含自己）是奇数，则这个节点必须与父节点相连，子节点内部自己配对 如果是偶数，则这个节点与子节点一起参与配对 以下代码的缺点是存储数据和求解不够高效 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll t,n; vector\u003cll\u003e G[10005]; ll cn[10005]; ll par[10005]; map\u003cll,ll\u003e W[10005]; void dfs_par(ll u,ll p){ par[u]=p; for(auto i:G[u]){ if(i!=p){ dfs_par(i,u); } } } void dfs_cn(ll u,ll p){ for(auto i:G[u]){ if(i!=p){ dfs_cn(i,u); cn[u]+=cn[i]; } } cn[u]++; } int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en; ll t1,t2,w; for(ll i=0;i\u003cn-1;i++){ cin\u003e\u003et1\u003e\u003et2\u003e\u003ew; G[t1].push_back(t2); G[t2].push_back(t1); W[t1].insert(make_pair(t2,w)); W[t2].insert(make_pair(t1,w)); } dfs_par(1,0); dfs_cn(1,0); ll ans=0; for(ll i=2;i\u003c=n;i++){ if(cn[i]\u00261){ ans+=W[i][par[i]]; } } cout\u003c\u003cans\u003c\u003cendl; //reset TODO memset(cn,0,sizeof(cn)); for(ll i=0;i\u003c=n;i++){ G[i].clear(); W[i].clear(); } } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:8:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"树形dp 贪心 dfs 题目 主要是树上dp 从子节点向根一直贪心地染色 这样就会出现一个问题，最优解需要染的顶点已经被染过了 所以要不断地更新两个值 dp[i] 现在在i，往根的方向还能染多少个 k[i] 每个点向根方向还能染多少个 那么 dp[i]=max(dp[i],dp[ch]-1) 如果最后 dp[i]==0 那么新的染色点开启 ans++ 否则处理完一个点后k要更新 k[par]=max(k[par],k[i]-1) #include\u003cbits/stdc++.h\u003e using namespace std; vector\u003cint\u003e c[100005]; int ans; int dp[100005]; int k[100005]; int n; void dfs(int u,int par){ for(auto i:c[u]){ dfs(i,u); dp[u]=max(dp[u],dp[i]-1); } if(dp[u]==0){ //can't reach next ans++; dp[u]=k[u]; } else{ //updata k k[par]=max(k[par],k[u]-1); } } int main(){ cin\u003e\u003en; int tmp; for(int i=2;i\u003c=n;i++){ cin\u003e\u003etmp; c[tmp].push_back(i); } for(int i=1;i\u003c=n;i++){ cin\u003e\u003ek[i]; } dfs(1,0); cout\u003c\u003cans\u003c\u003c\"\\n\"; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:9:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"堆 （对顶堆求实时中位数） 题目 经典的对顶堆求实时中位数问题 用两个堆存数据 大顶堆存小的一半 小顶堆存大的一半 这样中位数只在大顶堆或小顶堆的顶部 每次存数据需要将它与顶部（中间数）比较 确认放入哪一堆 每次放数后，需要平衡堆的大小，使大小相差不超过1 最后取堆大的顶部即可 plus：几个很坑的点，容易PE，要用快读才能过（还以为算法有问题。。。） #include\u003ciostream\u003e #include\u003cqueue\u003e using namespace std; int p,n,m; int t; int main(){ //ios::sync_with_stdio(0); cin\u003e\u003ep; while(p--){ priority_queue\u003cint\u003e q1; //大顶堆 priority_queue\u003cint,vector\u003cint\u003e,greater\u003cint\u003e\u003e q2; //小顶堆 scanf(\"%d%d\",\u0026n,\u0026m); if(n!=1) cout\u003c\u003cendl; cout\u003c\u003cn\u003c\u003c\" \"\u003c\u003c(m+1)/2\u003c\u003cendl; scanf(\"%d\",\u0026t); q1.push(t); if(m==1) cout\u003c\u003ct; else cout\u003c\u003ct\u003c\u003c\" \"; for(int i=2;i\u003c=m;i++){ scanf(\"%d\",\u0026t); if(t\u003eq1.top()) q2.push(t); //比大顶堆大，放入小顶堆 else q1.push(t); if(q1.size()\u003eq2.size()+1){ //平衡两个堆的大小 q2.push(q1.top()); q1.pop(); } if(q2.size()\u003eq1.size()+1){ q1.push(q2.top()); q2.pop(); } if(i\u00261){ int x; if(q1.size()\u003eq2.size()) x=q1.top(); //中位数在堆大的顶部 else x=q2.top(); if( ((i+1)/2)%10==0 and m-i\u003e1){ cout\u003c\u003cx\u003c\u003cendl; } else if(m-i\u003e1){ cout\u003c\u003cx\u003c\u003c\" \"; } else cout\u003c\u003cx; } } } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:10:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"在线区间预处理 前缀 题目 暴力枚举右区间的左右边界，这样时间复杂度就是 O(n^2) 前缀和预处理 对于每个右区间，O(1) 查询这个区间的异或值，然后找前面有几个区间的异或值等于这个区间 这时候只要计算以右区间左边界-1为右边界的区间中每一个的异或，然后与前面计算好的累加即可 最后直接累加到个数上 （注意区间的边界下标） #include\u003cbits/stdc++.h\u003e using namespace std; int n,a[1005],b[1000005]; //b要开大一点 否则数组越界 long long sum; //sum要用long long int main(){ cin\u003e\u003en; int tmp; a[0]=0; for(int i=1;i\u003c=n;i++) { cin\u003e\u003etmp; a[i]=a[i-1]^tmp; } for(int i=0;i\u003cn;i++){ for(int j=i-1;j\u003e=0;j--){ b[a[i]^a[j]]++; } for(int j=i+1;j\u003c=n;j++){ sum+=b[a[j]^a[i]]; } } cout\u003c\u003csum\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:11:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"图论 dfs 题目 奇数层的点到奇数层的点就是偶数路径 偶数同理 注意同一层也可达 还有long long 的转化 还可以树形dp #include\u003cbits/stdc++.h\u003e using namespace std; int n; vector\u003cint\u003e G[100005]; int dep[100005]; int ln[100005]; long long sum=0; //int deg[100005]; void dfs(int u,int v){ for(auto i:G[u]){ if(i!=v){ dep[i]=dep[u]+1; dfs(i,u); } } } int main(){ cin\u003e\u003en; int t1,t2; for(int i=0;i\u003cn-1;i++){ cin\u003e\u003et1\u003e\u003et2; G[t1].push_back(t2); G[t2].push_back(t1); } dep[1]=0; dfs(1,0); for(int i=1;i\u003c=n;i++){ ln[dep[i]]++; } int maxd=*max_element(dep+1,dep+n+1); for(int i=0;i\u003cmaxd+1;i++){ for(int j=i;j\u003cmaxd+1;j+=2){ if(j==i){ sum+=(long long)ln[i]*(ln[i]-1)/2; } else{ sum+=(long long)ln[i]*ln[j]; } } } cout\u003c\u003csum\u003c\u003cendl; //cout\u003c\u003cmaxd\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:12:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"排列组合 题目 对于一个长度为n的二进制串 随便选两个数前面放1后面放0 其他随便放 总共有 C(n,2)*2^(n-2) 种 注意对 n 取模 还有一个卡我的点是“特判”！！！ #include\u003cbits/stdc++.h\u003e using namespace std; using ll = unsigned long long; ll n; const ll mod = 1e9+7; ll qpow(ll x,ll t){ ll res=1; while(t\u003e0){ if(t\u00261) res=res*x%mod; x=x*x%mod; t\u003e\u003e=1; } return res; } int main(){ cin\u003e\u003en; if(n==1) cout\u003c\u003c0\u003c\u003cendl; else if(n==2) cout\u003c\u003c1\u003c\u003cendl; else{ cout\u003c\u003cqpow(2,n-3)%mod*(n%mod)%mod*((n-1)%mod)%mod\u003c\u003cendl; //记得给n取模 } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:13:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"二分法 尺取 题目 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll t; ll n,a[100005]; ll m,k; ll k_th(ll x){ ll num=0; ll sum=0; ll l=0,r=0; if(a[0]\u003ex) num++; while(r\u003cn and l\u003cn){ if(num\u003ck){ r++; if( r\u003cn and a[r]\u003ex) num++; } else{ sum += n-r; //不小心+1 就错了 l++; if(l\u003cn and a[l-1]\u003ex ) num--; } } return sum; } bool check(ll x){ return k_th(x) \u003e m-1 ? true : false; } int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003ek\u003e\u003em; for(ll i=0;i\u003cn;i++) cin\u003e\u003ea[i]; ll l = 1,r=1e10,mid; while(l\u003cr){ mid = (l+r)\u003e\u003e1; if(check(mid)) l = mid+1; else r=mid; } cout\u003c\u003cl\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:14:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"计数dp 题目 不会做，参考了别人的代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 1e9+7; ll a[100005]; ll dp[100005][12]; ll ls[100005]; ll n,m,k; int main(){ while(cin\u003e\u003en\u003e\u003em\u003e\u003ek){ //TODO reset memset(dp,0,sizeof(dp)); memset(ls,-1,sizeof(ls)); for(ll i=1;i\u003c=n;i++){ cin\u003e\u003ea[i]; } // TODO init 极端情况 for(ll i=0;i\u003c=n;i++) dp[i][0] = 1; for(ll i=0;i\u003c=11;i++) dp[i][i] = 1; for(ll i=1;i\u003c=n;i++){ for(ll j=1;j\u003c=min(i-1 , m);j++){ dp[i][j] = (dp[i-1][j] + dp[i-1][j-1])%mod; ll rm = ls[a[i]] - i +j; ll part = dp[ls[a[i]] - 1][rm]; if(ls[a[i]]!=-1 and rm\u003e=0) dp[i][j] = (dp[i][j] - part + mod)%mod; //这里也要模 } //update ls[a[i]] = i; } cout\u003c\u003cdp[n][m]%mod\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:15:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"贪心 堆 题目 贪心 按截至时间从小到大排序 如果按这个顺序选择，则有可能因为当前建筑耗费的时间比别的长，而错过最优解（即选择耗费时间短的，即使它的截至时间更久） 所以我们可以选择耗费时间更短的（相当于有一次反悔的机会），这样ans都加1，但是有更多的选择空间 用一个大顶堆维护当前选中的建筑的耗费时间 遍历所有建筑，如果能在截至时间内完成，就入堆 否则与堆顶比较（耗费时间最长的） 如果堆顶大，则用当前建筑替换堆顶的建筑，使耗费时间尽可能小 #include\u003cbits/stdc++.h\u003e using namespace std; vector\u003cpair\u003cint,int\u003e\u003e vt; int main(){ int n; cin\u003e\u003en; for(int i=0;i\u003cn;i++){ int x,y; cin\u003e\u003ex\u003e\u003ey; vt.emplace_back(x,y); } sort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return pii1.second\u003cpii2.second;}); priority_queue\u003cint\u003e pq; int sum = 0; for(auto i:vt){ if(sum+i.first\u003c=i.second){ sum+=i.first; pq.push(i.first); }else if(pq.top()\u003ei.first){ sum-=pq.top(); pq.pop(); sum+=i.first; pq.push(i.first); } } cout\u003c\u003cpq.size()\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:16:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"完全背包问题 题目 目标货币系统是子集，所以对于当前数，判断前面的数能否组合到这个数 这就变成完全背包问题，a[i] 表示体积，背包的最大体积是25000，价值就是是否可达到 (dp[i]=0 or 1) #include\u003cbits/stdc++.h\u003e using namespace std; int a[25005]; int dp[25005]; int ans; int main(){ int t; cin\u003e\u003et; while(t--){ memset(dp,0,sizeof(dp)); ans=0; int n; cin\u003e\u003en; dp[0]=1; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ea[i]; } sort(a+1,a+1+n); for(int i=1;i\u003c=n;i++){ if(!dp[a[i]]) ans++; for(int j=a[i];j\u003c=25000;j++){ dp[j] = dp[j] |= dp[j-a[i]]; } } cout\u003c\u003cans\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:17:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"贪心 题目 贪心，只要定排序规则就行 #include\u003cbits/stdc++.h\u003e using namespace std; vector\u003cpair\u003cint,int\u003e\u003e vt; int main(){ int n; cin\u003e\u003en; for(int i=0;i\u003cn;i++){ int x,y; cin\u003e\u003ex\u003e\u003ey; vt.emplace_back(x,y); } sort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return pii1.first*pii2.second \u003c pii1.second*pii2.first;}); long long ans = 0; long long tm = 0; for(auto i:vt){ ans += i.second*tm; tm += 2LL*i.first; } cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:18:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"dp 思维 题目 dp 第一次做真的很难想到 首先题目这么设计肯定是要把式子转换成物理意义 那就是“有两个装置，同时取到相同的排列的方案数，再求和” 设 dp[k][i][j] 表示两个装置都取出k个，第一个装置的上管道取出i个，第二个装置的上管道取出j个 那么第一个装置的下管道取出k-i个，第二个装置的下管道取出 k-j 个 dp 表示进行到此时的 ans 所以 dp 在传导的过程中用 += 最后的结果就是 dp[n+m][n][n] dp 的初始条件是 dp[0][0][0] = 1 dp 的转移方程考虑四种情况 (a[i]==a[j]) dp[k][i][j] += dp[k-1][i-1][j-1] 即两个装置的上管道 各加一个球结果相同 (a[i]==b[k-j]) dp[k][i][j] += dp[k-1][i-1][j] 即第一个装置的上下两个管道各加一个球结果相同 (b[k-i]==a[j]) dp[k][i][j] += dp[k-1][i][j-1] 同上 (b[k-i]==b[k-j]) dp[k][i][j] += dp[k-1][i][j] 同上 由于数据规模，需要用01滚动数组 注意 assert 注意continue 否则超时 #include\u003cbits/stdc++.h\u003e using namespace std; const int mod = 1024523; int n,m; int dp[2][505][505]; char u[505]; char d[505]; int main(){ cin\u003e\u003en\u003e\u003em; cin\u003e\u003e(u+1)\u003e\u003e(d+1); dp[0][0][0] = 1; for(int k=1;k\u003c=n+m;k++){ memset(dp[k\u00261],0,sizeof(dp[k\u00261])); for(int i=0;i\u003c=n;i++){ if(k-i\u003c0 or k-i\u003em) continue; //不加这个超时 for(int j=0;j\u003c=n;j++){ if(k-j\u003c0 or k-j\u003em) continue; //不加这个超时 if(u[i]==u[j] and i and j) { dp[k\u00261][i][j] += dp[(k-1)\u00261][i-1][j-1]; dp[k\u00261][i][j] %= mod; } if(u[i]==d[k-j] and i and k-j and k-j\u003c=m){ dp[k\u00261][i][j] += dp[(k-1)\u00261][i-1][j]; dp[k\u00261][i][j] %= mod; } if(u[j]==d[k-i] and j and k-i and k-i\u003c=m){ dp[k\u00261][i][j] += dp[(k-1)\u00261][i][j-1]; dp[k\u00261][i][j] %= mod; } if(d[k-i]==d[k-j] and k-i and k-j and k-i\u003c=m and k-j\u003c=m){ dp[k\u00261][i][j] += dp[(k-1)\u00261][i][j]; dp[k\u00261][i][j] %= mod; } } } } cout\u003c\u003cdp[(n+m)\u00261][n][n]%mod\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:19:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"差分 规律 题目 暴力差分 最重要的是所有的点在 log(n) 时间内都会变成 n 此时停机就不会超时 #include\u003cbits/stdc++.h\u003e using namespace std; int n,k; int dat[200005]; int dif[200005]; bool check(){ for(int i=1;i\u003c=n;i++){ if(dat[i]\u003cn){ return false; } } return true; } void did(int x){ int L = max(1,x-dat[x]); int R = min(n , x+dat[x]); dif[L]++; dif[R+1]--; } void update(){ for(int i=1;i\u003c=n;i++){ dat[i] = dat[i-1] + dif[i]; } } int main(){ cin\u003e\u003en\u003e\u003ek; for(int i=1;i\u003c=n;i++) cin\u003e\u003edat[i]; while(1 and k\u003e0){ for(int i=1;i\u003c=n;i++) did(i); k--; if(check()) break; update(); memset(dif,0,sizeof(dif)); } if(k\u003e0) { for(int i=0;i\u003cn;i++) cout\u003c\u003cn\u003c\u003c\" \"; } else for(int i=1;i\u003c=n;i++) cout\u003c\u003cdat[i]\u003c\u003c\" \"; cout\u003c\u003c'\\n'; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:20:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"分治（01背包问题 + 枚举） 题目 第一次做分治，太妙了 暴力超时 如果在树上用dp预处理，内存超限 解决方法就是分治 完全二叉树有18层，前9层dp预处理所有的点 后9层枚举，然后将两个结果相加。这样将时间复杂度也分开了 #include\u003cbits/stdc++.h\u003e using namespace std; vector\u003cint\u003e vt; int n,q; vector\u003cpair\u003cint,int\u003e\u003e info((1\u003c\u003c18) + 3); vector\u003cpair\u003cint,int\u003e\u003e res; #define fi first #define se second const int MAX = 100001; int dp[515][MAX]; int main(){ ios::sync_with_stdio(false); cin.tie(0); cin\u003e\u003en; for(int i=0;i\u003cn;i++){ int v,w; cin\u003e\u003ev\u003e\u003ew; info[i] = make_pair(v,w); } //preprocess const int MAX = 100001; int lim = min(512,n); for(int j=0;j\u003cMAX;j++){ dp[0][j] = (j\u003e=info[0].se ? info[0].fi : 0); } for(int i=1;i\u003clim;i++){ int p = (i-1)/2; for(int j=0;j\u003cMAX;j++){ if(j\u003cinfo[i].se){ dp[i][j] = dp[p][j]; }else{ dp[i][j] = max(dp[p][j] , dp[p][j - info[i].se] + info[i].fi); } } } cin\u003e\u003eq; while(q--){ int V,L; cin\u003e\u003eV\u003e\u003eL; V--; vector\u003cint\u003e rem; while(V\u003e=lim){ rem.push_back(V); V = (V-1)/2; } int ans = 0; int sz = rem.size(); for(int i=0;i\u003c(1\u003c\u003csz);i++){ int sv = 0; int sw = 0; for(int j=0;j\u003csz;j++){ if(i\u003e\u003ej\u00261){ sv += info[rem[j]].fi; sw += info[rem[j]].se; } } if(sw \u003c= L){ ans = max(ans , dp[V][L-sw] + sv); } } cout\u003c\u003cans\u003c\u003cendl; } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:21:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"博弈 题目 如果只有一个串，1的个数是奇数，alice必赢 所以只要有1个串1的个数是奇数，alice就对此操作，占据先机 接下来bob怎么操作，alice只要跟着操作就行 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int t; cin\u003e\u003et; while(t--){ int n; cin\u003e\u003en; bool ok=false; for(int i=0;i\u003cn;i++){ string s; cin\u003e\u003es; bitset\u003c1005\u003e bs(s); if(bs.count()\u00261) ok=true; } if(ok) puts(\"sdzNB\");else puts(\"kgNB\"); } return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:22:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"递推 构造 题目 第一个数有两种情况0,1，根据第二例的信息不断往后递推，中途判断格子是否是0或1 #include\u003cbits/stdc++.h\u003e using namespace std; int n; int a[10005]; int b[10005]; int sol(int x){ memset(b,0,sizeof(b)); b[0] = 0; b[1] = x; for(int i=2;i\u003c=n;i++){ int tmp = a[i-1] - (b[i-1] + b[i-2]); if(tmp == 0 or tmp==1) { b[i] = tmp; } else{ return 0; } if(i==n){ if(a[n] == b[n-1] + b[n]){ return 1; } else{ return 0; } } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cin\u003e\u003en; for(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i]; int ans = sol(0) + sol(1); cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:23:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"筛法 题目 筛法，注意从 i * i 开始，否则会超时 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll maxn = 30000005; ll a[maxn]; ll b[maxn]; int main(){ ll n; cin\u003e\u003en; // b[1] = 0; // for(ll i = 2; i \u003c maxn;i++){ // if(a[i] == 0){ // ll q = i; // while(q \u003c maxn){ // if(a[q] == 0){ // a[q] = i; // }q += i; // } // } // b[i] = a[i] + b[i-1]; // } ll ans = 0; for(ll i = 2;i \u003c n+1;i++){ if(a[i] == 0){ ans += i; ll q = i * i; //从i*i开始，否则会超时 while(q \u003c n+1){ if(a[q] == 0){ a[q] = 1; ans += i; }q += i; } } } cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:24:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["problemlist"],"content":"背包问题 dp 题目 由于N=30所以求出所有的方案 类似于完全背包问题 dp[i][k] 表示选 i 个，价值达到 k 的方案数 dp[i][k] = sum(dp[i-1][k-j]) 其中j是每张彩票的面值 最后求 k在 3n 到 4n 之间的方案数 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll dp[35][150]; int main(){ int n; cin\u003e\u003en; dp[0][0] = 1; for(int i=1;i\u003c=n;i++){ for(int j=1;j\u003c=4;j++){ for(int k=j;k\u003c=4*n;k++){ dp[i][k] += dp[i-1][k-j]; } } } ll ans = 0; for(int i=3*n;i\u003c=4*n;i++){ ans += dp[n][i]; } //cout\u003c\u003cans\u003c\u003cendl; ll tol = pow(4,n); ll x = __gcd(tol, ans); ans /= x; tol /= x; cout\u003c\u003cans\u003c\u003c\"/\"\u003c\u003ctol\u003c\u003cendl; return 0; } ","date":"2020-06-08","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/:25:0","tags":["problemlist"],"title":"每日一题 (X)","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/"},{"categories":["codeforces"],"content":"Codeforces Round #644 (Div. 3)","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"可能是最简单的div3（不考dp dfs？） A. Minimal Square ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:0:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给俩相同的长方形，求面积最小的正方形使得容纳两个长方形，且长方形之间不重合 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:1:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 两倍宽或两倍长 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using pii = pair\u003cint,int\u003e; using pll = pair\u003cll,ll\u003e; int main(){ int t; cin\u003e\u003et; while(t--){ int a,b; cin\u003e\u003ea\u003e\u003eb; if(a\u003eb) swap(a,b); if(2*a\u003c=b) cout\u003c\u003cb*b\u003c\u003cendl; else cout\u003c\u003c4*a*a\u003c\u003cendl; } return 0; } B. Honest Coach ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:2:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 把一堆数分成两堆，求第一堆最大值和第二堆最小值的差的最小值 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:3:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 排序，求相邻两数差的最小值，以此为分界 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using pii = pair\u003cint,int\u003e; using pll = pair\u003cll,ll\u003e; int main(){ int t; cin\u003e\u003et; while(t--){ int n; cin\u003e\u003en; int a[55]; for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; sort(a,a+n); int ans = 1000000000; for(int i=0;i\u003cn-1;i++){ ans = min(ans,a[i+1]-a[i]); } cout\u003c\u003cans\u003c\u003cendl; } return 0; } C. Similar Pairs ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:4:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 定义好数对 (a,b) a,b具有相同的奇偶性或者a,b差为1 给一堆数（偶数个），问是否能被划分成若干个好数对 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:5:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 如果奇数的个数有偶数个就一定可以 否则检测是否有差为1的数对 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using pii = pair\u003cint,int\u003e; using pll = pair\u003cll,ll\u003e; int main(){ int t; cin\u003e\u003et; while(t--){ int n; cin\u003e\u003en; vector\u003cint\u003e vt1; vector\u003cint\u003e vt2; for(int i=0;i\u003cn;i++){ int x; cin\u003e\u003ex; if(x\u00261) vt1.push_back(x);else vt2.push_back(x); } if(vt1.size()%2==0) puts(\"yes\"); else{ bool flag=false; for(int i:vt1){ if(find(vt2.begin(),vt2.end(),i+1)!=vt2.end() || find(vt2.begin(),vt2.end(),i-1)!=vt2.end()){ flag=true; break; } } if(flag) puts(\"yes\"); else puts(\"no\"); } } return 0; } D. Buying Shovels ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:6:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 第i种包里有i个铁铲，总共有k种，只能选择一种包，可以买无数个，求最小需要买几包才能获得恰好n个铁铲 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:7:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 k\u003e=n时特判 其他只要遍历到开方，一一检测是否能被整除，不断min #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using pii = pair\u003cint,int\u003e; using pll = pair\u003cll,ll\u003e; int main(){ ll t; cin\u003e\u003et; while(t--){ ll n,k; cin\u003e\u003en\u003e\u003ek; if(n\u003c=k) cout\u003c\u003c1\u003c\u003cendl; else{ bool flag = false; ll ans = 1e10; for(ll i=2;i\u003c=(ll)(sqrt(n));i++){ if(n%i==0 and i\u003c=k){ ans = min(ans , n/i); if(n/i\u003c=k) ans = min(ans , i); flag=true; //break; } } if(!flag) cout\u003c\u003cn\u003c\u003cendl; else cout\u003c\u003cans\u003c\u003cendl; } } return 0; } E. Polygon ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:8:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 判断一个矩阵是否是polygon游戏的产物 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:9:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 对于每一个元素，如果是1就判断右边和下面是否有1 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using pii = pair\u003cint,int\u003e; using pll = pair\u003cll,ll\u003e; int main(){ int t; cin\u003e\u003et; while(t--){ int n; cin\u003e\u003en; char mat[55][55]; for(int i=0;i\u003cn;i++) { cin\u003e\u003emat[i]; } bool ok = true; for(int i=0;i\u003cn;i++)for(int j=0;j\u003cn;j++){ if(mat[i][j]=='1'){ if(i==n-1 or j==n-1) continue; else{ if(mat[i+1][j]=='1' or mat[i][j+1]=='1') continue; else { ok = false; break; } } } } if(ok) puts(\"yes\"); else puts(\"no\"); } return 0; } F. Spy-string ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:10:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给一堆长度都是m的字符串，问是否存在一个长度也为m的字符串使得它对每个字符串都有“相同或不同的个数为1” ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:11:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 数据小，暴力枚举 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using pii = pair\u003cint,int\u003e; using pll = pair\u003cll,ll\u003e; vector\u003cstring\u003e vt; int n,m; bool ck(string q1,string q2){ int dif = 0; for(int i=0;i\u003cm;i++){ if(q1[i]!=q2[i]) dif++; } return dif\u003c=1 ? true : false; } bool check(string ss){ bool ok = true; for(auto i : vt){ if(!ck(ss,i)){ ok = false; break; } } return ok; } int main(){ int t; cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003em; string s; cin\u003e\u003es; vt.clear(); for(int i=0;i\u003cn-1;i++) { string s1; cin\u003e\u003es1; vt.push_back(s1); } bool ok = false; string s3; for(int i=0;i\u003cm;i++){ for(int j=0;j\u003c26;j++){ string s2 = s; s2[i] = 'a' + j; if(check(s2)){ ok = true; s3 = s2; break; } } } if(ok) cout\u003c\u003cs3\u003c\u003cendl; else{ cout\u003c\u003c-1\u003c\u003cendl; } } return 0; } G. A/B Matrix ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:12:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 是否存在一个n*m的矩阵使得每一行有a个1，每一列有b个1，其他都是0 ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:13:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 第一行开头先填a个1，第二行在这个之后填1，然后回到第一个，直到填满a个 第三行以此类推 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using pii = pair\u003cint,int\u003e; using pll = pair\u003cll,ll\u003e; int main(){ int t; cin\u003e\u003et; while(t--){ int n,m,a,b; cin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb; if(n*a!=m*b) puts(\"no\"); else{ int mat[55][55] = {0}; int one = 0; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003ca;j++){ mat[i][one] = 1; one++; one%=m; } } puts(\"yes\"); for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ cout\u003c\u003cmat[i][j]; }puts(\"\"); } } } return 0; } H. Binary Median ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:14:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题意 给几个长度为m的01串，求对于所有长度为m的01串形成的集合的补集中的中位数（字典序） ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:15:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["codeforces"],"content":"题解 将01串转成十进制，最后再转回来 由于数据规模是 2^60 所以不能枚举 以每个给定的数为节点，求补集内比它小的数有几个 求中位数是补集内的第几个 假设是第 i 个，求 i 落在以节点划分的哪个区间内 （几个WA点 要用1LL iota和strtol函数做进制转化时精度太低，是int ） #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using pii = pair\u003cint,int\u003e; using pll = pair\u003cll,ll\u003e; ll tot; ll ans; int main(){ int t; cin\u003e\u003et; while(t--){ ll n,m; cin\u003e\u003en\u003e\u003em; tot = (1LL\u003c\u003cm); // use 1LL ll rem = tot - n; rem--; ll ind = rem / 2; vector\u003cpll\u003e vt; vector\u003cstring\u003e vts; for(ll i=0;i\u003cn;i++) { string s; cin\u003e\u003es; vts.push_back(s); } sort(vts.begin(),vts.end()); //sort first for(ll i = 0;i\u003cvts.size();i++){ string st = vts[i]; ll res=0; for(ll j=0;j\u003cm;j++){ res+=(st[j]=='1' ? (1LL\u003c\u003c(m-j-1)) : 0); } vt.emplace_back(res,res-i-1LL); } //sort(vt.begin(),vt.end()); vt.emplace_back((1LL\u003c\u003cm),(1LL\u003c\u003cm) - n-1LL); for(ll i=0;i\u003cvt.size();i++){ if(vt[i].second==ind){ ans = vt[i].first - 1;break; }else if(vt[i].second\u003eind){ if(vt.size()==1 or i==0){ ans = ind;break; }else{ ans = vt[i-1].first + (ind - vt[i-1].second);break; } } } for(ll i=m-1;i\u003e=0;i--){ cout\u003c\u003c(ans\u003e\u003ei\u00261); }puts(\"\"); } return 0; } ","date":"2020-05-25","objectID":"/codeforces-round-644-div.-3/:16:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"/codeforces-round-644-div.-3/"},{"categories":["abc"],"content":"abc168","date":"2020-05-19","objectID":"/abc168/","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"A - ∴ (Therefore) ","date":"2020-05-19","objectID":"/abc168/:0:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-19","objectID":"/abc168/:1:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ string s; cin\u003e\u003es; char c=s[s.length()-1]; switch(c){ case '2' :case '4': case '5': case '7': case '9': cout\u003c\u003c\"hon\\n\"; break; case '3': cout\u003c\u003c\"bon\\n\"; break; default :cout\u003c\u003c\"pon\\n\"; } return 0; } B - … (Triple Dots) ","date":"2020-05-19","objectID":"/abc168/:2:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-19","objectID":"/abc168/:3:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int k; cin\u003e\u003ek; string s; cin\u003e\u003es; if(s.length()\u003c=k)cout\u003c\u003cs\u003c\u003cendl; else{ for(int i=0;i\u003ck;i++){ cout\u003c\u003cs[i]; }cout\u003c\u003c\"...\"\u003c\u003cendl; } return 0; } C - : (Colon) ","date":"2020-05-19","objectID":"/abc168/:4:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 给定时针和分针的长度，起始为12点，问经过h小时m分钟后，时针和分针不连接的端点的距离 ","date":"2020-05-19","objectID":"/abc168/:5:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 用比例求夹角，然后余弦定理 #include\u003cbits/stdc++.h\u003e using namespace std; const double pi = acos(-1); using db = double; double toRad(double x){ return x/180*pi; } db COS(db x,db y,db d){ return sqrt(x*x+y*y-2*x*y*cos(d)); } db a,b,m,h; int main(){ cin\u003e\u003ea\u003e\u003eb\u003e\u003eh\u003e\u003em; db ma = ((int)(h*60+m)%60)*(db)6; db ha = ((int)(h*60+m)%720)/(db)2; db delta = fabs(ma-ha); db Rdel = toRad(delta); db ans = COS(a,b,Rdel); printf(\"%.10lf\\n\",ans); return 0; } D - .. (Double Dots) ","date":"2020-05-19","objectID":"/abc168/:6:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 由n个点组成的边权为1的双向图，每个点一个标志，从这个点开始沿着标志所指向的点（要有边连接）一直走，就可以到达1号点，且是最短路。问对于所有的点是否都存在这样的标志，存在则输出每个标志。 ","date":"2020-05-19","objectID":"/abc168/:7:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 bfs 求前趋 最无脑的做法应该是单源最短路求前趋 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const int inf = 0x3f3f3f3f; const int ninf = 0xc0c0c0c0; const double pi = acos(-1); using db = double; const int max_v = 200005; int n,m; int prevv[max_v]; struct edge { int to,cost; edge(int to,int cost){ this-\u003eto = to; this-\u003ecost = cost; } }; typedef pair\u003cint,int\u003e pii; int V; vector\u003cedge\u003e G[max_v]; int d[max_v]; void dijkstra(int s) { priority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V,inf); fill(prevv,prevv+V,-1); d[s]=0; q.push(pii(0,s)); while(!q.empty()) { pii p=q.top(); q.pop(); int v=p.second; if(d[v]\u003cp.first) continue; for(int i=0;i\u003cG[v].size();i++) { edge e=G[v][i]; if(d[e.to]\u003ed[v]+e.cost) { d[e.to]=d[v]+e.cost; prevv[e.to]=v; q.push(pii(d[e.to],e.to)); } } } } int main(){ cin\u003e\u003en\u003e\u003em; V=n+1; for(int i=0;i\u003cm;i++){ int t1,t2; cin\u003e\u003et1\u003e\u003et2; G[t1].push_back(edge(t2,1)); G[t2].push_back(edge(t1,1)); } dijkstra(1); bool ok=true; for(int i=2;i\u003c=n;i++){ if(prevv[i]==-1) { ok=false;break; } } if(ok){ puts(\"Yes\"); for(int i=2;i\u003c=n;i++){ cout\u003c\u003cprevv[i]\u003c\u003cendl; } }else{ puts(\"No\"); } //cout\u003c\u003cd[1]\u003c\u003c\" \"\u003c\u003cd[2]\u003c\u003c\" \"\u003c\u003cd[3]\u003c\u003cd[4]; return 0; } E - ∙ (Bullet) ","date":"2020-05-19","objectID":"/abc168/:8:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题意 给n个数对 (ai,bi) 求满足下列条件的集合个数 集合由数对组成，集合中任意两个数对满足 ai*aj + bi*bj != 0 ","date":"2020-05-19","objectID":"/abc168/:9:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 以上的公式是内积形式，把问题转化成给n个向量，找满足任意两个向量不垂直的集合数 由于零向量和任意向量垂直，所以它只能单独在一个集合内 遍历数对，记录每个斜率（用map存出现的次数） 斜率为0和斜率不存在可以特殊处理 遍历每个斜率（出现次数为num），如果没有和它垂直的（找是否有 -1/k） 那么这个斜率的全集就是num个相同的数 子集有 2^num 个 如果有和它垂直的（个数分别为num1,num2），这两种斜率就不能放在一个集合 内，所以要把它们看成一个整体 从两个集合分开选子集，再合并，总的子集个数为 2^num1 -1+ 2^num2 -1 + 1 减去各自的空集加上总体的空集 然后把每个子集数乘起来（乘法原理）（包括斜率为0和不存在） 最后再加上零向量的个数，减去1（除去空集） 照这个方法做是错的 debug半天一直错6个点，看了下数据，都是大数，看了下程序，觉得自己逻辑一点也没有漏洞，模数也没有溢出 直到看到这句话 1E18 long double 精度不够！！所以只能存原始的数对 (ai,bi) 用gcd处理倍数关系 由于 (-a,b) 和 (a,-b) 是一致的，所以让第一个数始终大于0 想想 long double 确实精度不够，但那时真的没想到 发现一个提供atcoder测试数据的网站 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long ; ll n,x,y; using ld = long double; map\u003cpair\u003cll,ll\u003e,ll\u003e mp; const ll mod = 1000000007; ll zero; ll h; ll v; ll ans = 1; ll qpow(ll x,ll n) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } int main(){ cin\u003e\u003en; for(ll i=0;i\u003cn;i++){ cin\u003e\u003ex\u003e\u003ey; if(x==0 and y==0) zero++; else if(x==0) v++; else if(y==0) h++; else { ll g = __gcd(x,y); x/=g; y/=g; if(x\u003c0) x=-x,y=-y; mp[{x,y}]++; } } for(auto i:mp){ ll a = i.first.first; ll b = i.first.second; ll c = i.second; if(c==0) continue; ll cnt; if(-b\u003c0) b=-b,a=-a; pair\u003cll,ll\u003e pll = {-b,a}; if(!mp.count(pll)){ cnt = qpow(2,c); ans=(ans*cnt)%mod; }else{ cnt = qpow(2,c)-1LL+qpow(2,mp[pll]); cnt %= mod; ans=(ans*cnt)%mod; mp[pll]=0; } } if(h!=0 and v!=0){ ll foo = qpow(2,h)-1LL+qpow(2,v); foo %= mod; ans = (ans*foo)%mod; }else if(h==0 and v!=0){ ll foo = qpow(2,v); ans = (ans*foo)%mod; }else if(h!=0 and v==0){ ll foo = qpow(2,h); ans = (ans*foo)%mod; } ans = (ans+zero)%mod; ans-=1LL; ans+=mod; ans%=mod; cout\u003c\u003cans\u003c\u003cendl; return 0; } F - . (Single Dot) ","date":"2020-05-19","objectID":"/abc168/:10:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["abc"],"content":"题解 待补 好像是细节很多的离散化bfs ","date":"2020-05-19","objectID":"/abc168/:11:0","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"/abc168/"},{"categories":["codeforces"],"content":"Codeforces Round #643 (Div. 2) A~D","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Sequence with Digits ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:0:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 看题目 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:1:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 模拟，minDigit(x) 等于0 时打断 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const int inf = 0x3f3f3f3f; const int ninf = 0xc0c0c0c0; ll t; ll a,k; ll maxD(ll n) { ll res=n%10; while(n) { res=max(res,n%10); n/=10; } return res; } ll minD(ll n) { ll res=n%10; while(n) { res=min(res,n%10); n/=10; } return res; } ll cal(ll n) { return n+maxD(n)*minD(n); } int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003ea\u003e\u003ek; for(ll i=1;i\u003ck;i++) { //cout\u003c\u003ca\u003c\u003c\" \"\u003c\u003ci\u003c\u003c\" \"\u003c\u003cmaxD(a)\u003c\u003c\" \"\u003c\u003cminD(a)\u003c\u003c\" \"\u003c\u003cendl; a=cal(a); if(minD(a)==0) break; } cout\u003c\u003ca\u003c\u003cendl; } return 0; } B. Young Explorers ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:2:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 有一个数组，将它们划分成n组（不用每一个数字都被划分），保证每一组的每个数字都\u003c=这组数字的个数，求最多划分成几组 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:3:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 贪心 方法有很多，其中之一是 排序，对当前数字x，从它开始选x个，如果有不满足的就继续选，直到满足条件 最后一个区间如果不能满足条件则并到前一个区间内 （之前一直以为只要从头到尾或从尾到头贪心地选择数字对应的区间即可） #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const int inf = 0x3f3f3f3f; const int ninf = 0xc0c0c0c0; int t; int n; int a[200005]; int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003en; for(ll i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; } sort(a,a+n); int ans=0; for(int i=0;i\u003cn;){ int t=a[i]; int x=i+t-1; while(t\u003ca[x] and t\u003c=n and x\u003c=n){ t++; x++; } if(x\u003cn) ans++; i+=t; } cout\u003c\u003cans\u003c\u003cendl; } return 0; } C. Count Triangles ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:4:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给四个数 abcd （从小到大），划分成三个区间，分别从三个区间中选三个数组成三条边，求组成三角形的个数 ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:5:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 由于顺序的特殊性，只要检查前两个区间选出来的数之和有没有大于第三个区间选出来的数 对于前两个区间选出来的数之和落在 [a+b , b+c] 然后再判断第三个区间有几个数满足条件 记录一下每个数出现的次数（找规律） #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll a,b,c,d; ll ran[1000005]; int main(){ cin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed; ll low=a+b; ll hi=b+c; ll num=min(b-a,c-b); num++; for(ll i=1;i\u003c=num;i++){ ran[low]=i; low++; } for(ll i=a+b+num;i\u003c=hi-num;i++){ ran[i] = num; } for(ll i=hi-num+1;i\u003c=hi;i++){ ran[i] = num; num--; } //for(ll i=3;i\u003c=5;i++) cout\u003c\u003cran[i]\u003c\u003c\" \"; ll ans=0; for(ll i=a+b;i\u003c=b+c;i++){ ll mul = ran[i]; if(i-c-1\u003e=0) { if(i-1\u003ed){ ans+=(d-c+1)*mul; }else{ ans+=mul*(i-c); } } //cout\u003c\u003cans\u003c\u003cendl; } cout\u003c\u003cans\u003c\u003cendl; return 0; } D. Game With Array ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:6:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给俩数 n s (n\u003c=s) 问是否存在满足下列条件的数组 数组的长度为 n 元素和为 s 存在k使得任何一个子数组的和都不等于 k或s-k ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:7:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 构造 由于 k 或 s-k 所以当 s/2\u003cn 时不存在 由于数的奇偶性，可以构造全是偶数的数组(2) 这样随便选一个奇数就满足条件 但对于s是奇数时，最后一个元素是奇数，如果把前面全部构造成2，且s/2\u003cn 这样最后一个一定\u003e=3 所以k选择1 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,s; cin\u003e\u003en\u003e\u003es; if(s/2\u003cn){ puts(\"no\"); } else{ puts(\"yes\"); for(int i=0;i\u003cn-1;i++){ cout\u003c\u003c2\u003c\u003c\" \"; } cout\u003c\u003cs-2*n+2\u003c\u003cendl; cout\u003c\u003c1\u003c\u003cendl; } return 0; } ","date":"2020-05-16","objectID":"/codeforces-round-643-div.-2-a~d/:8:0","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"/codeforces-round-643-div.-2-a~d/"},{"categories":["codeforces"],"content":"Codeforces Round #641 (Div. 2) A~D","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Orac and Factors ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:0:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数，每一次操作加上他的最小因子（除1外） 问k次操作后，这个数是多少 ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:1:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 奇数找最小因子加一下就变成偶数，偶数最小因子是2 #include\u003cbits/stdc++.h\u003e using namespace std; int n,k,t; int ans; int f(int x){ for(int i=2;i*i\u003c=x;i++){ if(x%i==0){ return i; } } return x; } int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003ek; if(n\u00261){ n+=f(n); ans = n+(k-1)*2; } else{ ans = n+k*2; } cout\u003c\u003cans\u003c\u003cendl; } return 0; } B. Orac and Models ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:2:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数组，从中选几个数出来，满足严格递增，且对任意相邻下标a,b满足a|b，输出最长子序列的个数 ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:3:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 对于每个数都可以选择x2 x3 x4 x5… 所以对于每个数依次判断x2 x3 x4 x5…是否满足严格递增，由于越大的数越稀疏，所以不会超时 即 if( a[j] \u003e a[i] ) dp[j] = max(dp[j] , dp[i] + 1) #include\u003cbits/stdc++.h\u003e using namespace std; int t,n; int dat[100005]; int dp[100005]; int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++) cin\u003e\u003edat[i],dp[i]=1; for(int i=1;i\u003c=n;i++)for(int j=i+i;j\u003c=n;j+=i){ if(dat[j]\u003edat[i]) dp[j]=max(dp[j],dp[i]+1); } int ans=-1; for(int i=1;i\u003c=n;i++){ ans=max(ans,dp[i]); } cout\u003c\u003cans\u003c\u003cendl; } return 0; } C. Orac and LCM ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:4:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数组，每两个元素求lcm，把结果放到multi_set中，对multiset求gcd ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:5:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 从a[1]开始依次对后面的数求lcm，然后对结果求gcd gcd(lcm(a1,a2) , lcm(a1,a3) , ... , lcm(a1,an)) = lcm(a1 , gcd(a2,a3, ... , an) 这样就可以利用后缀 最后对所有lcm求gcd #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n; ll dat[100005]; vector\u003cll\u003e vt; ll suf[100005]; ll lcm(ll a,ll b){ return a*b/__gcd(a,b); } int main(){ cin\u003e\u003en; for(ll i=1;i\u003c=n;i++) cin\u003e\u003edat[i]; suf[n]=dat[n]; for(ll i=n-1;i\u003e=2;i--){ suf[i]=__gcd(dat[i],suf[i+1]); } for(ll i=1;i\u003c=n-2;i++){ vt.push_back(lcm(dat[i],suf[i+1])); } vt.push_back(lcm(dat[n-1],dat[n])); ll gcd=vt[0]; for(ll i=1;i\u003cvt.size();i++){ gcd=__gcd(gcd,vt[i]); } cout\u003c\u003cgcd\u003c\u003cendl; return 0; } D. Orac and Medians ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:6:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 对于一个数组，可以选择一个区间，将区间内的数变成这个区间的中位数，如果有两个，则选较小，问是否能在若干次操作后把所有数字变成k ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:7:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 特判数组是否有k 对于有k的情况 如果数组中\u003e=k 的个数大于 \u003ck的个数，就可以通过不断选2个数，其中一个是K 同化另一个数，达到同化所有 其他情况如果存在相邻的三个数，满足2个数\u003e=k 就可以实现同化并不断同化 #include\u003cbits/stdc++.h\u003e using namespace std; int t,n,k; int dat[100005]; int main(){ cin\u003e\u003et; while(t--){ bool ok=false; int low=0,hi=0; cin\u003e\u003en\u003e\u003ek; for(int i=0;i\u003cn;i++){ cin\u003e\u003edat[i]; if(dat[i]==k) ok=true; if(dat[i]\u003ck) low++; else hi++; } if(!ok){ puts(\"no\"); } else if(hi\u003elow) puts(\"yes\"); else{ bool okk = false; for(int i=0;i\u003cn-2;i++){ int l=0,h=0; if(dat[i]\u003ck) l++;else h++; if(dat[i+1]\u003ck) l++;else h++; if(dat[i+2]\u003ck) l++;else h++; if(h\u003el) okk=true; } if(okk) puts(\"yes\"); else puts(\"no\"); } } return 0; } ","date":"2020-05-13","objectID":"/codeforces-round-641-div.-2-a~d/:8:0","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"/codeforces-round-641-div.-2-a~d/"},{"categories":["abc"],"content":"abc167","date":"2020-05-11","objectID":"/abc167/","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"这个比赛尽犯些sb错🙃，先是把 j 写成 i ，然后把2E5写成1E5 A - Registration ","date":"2020-05-11","objectID":"/abc167/:0:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 判断字符串T是不是S后加一个字符 ","date":"2020-05-11","objectID":"/abc167/:1:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ string s1,s2; cin\u003e\u003es1\u003e\u003es2; if(s2.substr(0,s2.length()-1)==s1) puts(\"Yes\"); else puts(\"No\"); return 0; } 不知道strstr为啥就不行 B - Easy Linear Programming ","date":"2020-05-11","objectID":"/abc167/:2:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 有三种卡片，分别写上数字1，0，-1，选择k张，让数字和最大 ","date":"2020-05-11","objectID":"/abc167/:3:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 贪心 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ int a,b,c,k; cin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ek; int ans=0; if(a\u003c=k){ ans+=a; k-=a; if(b\u003c=k){ k-=b; if(c\u003c=k){ ans-=c; }else ans-=k; } else{ ans+=k; } } else{ ans+=k; } cout\u003c\u003cans\u003c\u003cendl; return 0; } C - Skill Up ","date":"2020-05-11","objectID":"/abc167/:4:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 高桥想学m个算法，有n本书，每本书有价格，和对每个算法的提升程度 问高桥想要每个算法都达到X，最少需要花多少钱 ","date":"2020-05-11","objectID":"/abc167/:5:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 数据不是很大，可以暴力模拟，数据大，可以考虑dp #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const long long inf = 0x3f3f3f3f; int main(){ //freopen(\"in.txt\",\"r\",stdin); int n,m,x; cin\u003e\u003en\u003e\u003em\u003e\u003ex; int ans=inf; int dat[n+1][m+1+1]; for(int i=0;i\u003cn;i++){ cin\u003e\u003edat[i][0]; for(int j=1;j\u003c=m;j++) cin\u003e\u003edat[i][j]; } for(int i=0;i\u003c=(1\u003c\u003cn)-1;i++){ int e[m+1+1]={0}; int foo=0; for(int j=0;j\u003cn;j++){ if(i\u003e\u003ej\u00261){ for(int k=1;k\u003c=m;k++){ e[k]+=dat[j][k]; } foo+=dat[j][0]; } } bool ok=true; for(int i=1;i\u003c=m;i++) if(e[i]\u003cx) ok=false; if(ok) ans=min(ans,foo); //for(int i=1;i\u003c=m;i++) cout\u003c\u003ce[i]\u003c\u003c\" \"; cout\u003c\u003cendl; } cout\u003c\u003c(ans==inf?-1:ans)\u003c\u003cendl; return 0; } D - Teleporter ","date":"2020-05-11","objectID":"/abc167/:6:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 有一个数组（长度最大为2E5），当你在下标为 i 时，可以tp到下标为 a[i] 问 N(N\u003c=1E18) 次tp后在哪里 ","date":"2020-05-11","objectID":"/abc167/:7:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 由于数据很大不能直接算 考虑到数组最大为2E5，所以有最大为2E5的循环节 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; bool vis[200005]; ll tim[200005]; ll ind[2000005]; ll loop=0; ll a[200005]; int main(){ //freopen(\"in.txt\",\"r\",stdin); ll n,k; cin\u003e\u003en\u003e\u003ek; for(ll i=1;i\u003c=n;i++){ cin\u003e\u003ea[i]; } ll ans=1; vis[1]=true; tim[1] = 1; ind[1] = 1; for(int i=2;i\u003c=k;i++){ ans = a[ans]; if(vis[ans]){ loop=i-tim[ans];break; }else{ vis[ans]=true; tim[ans]=i; ind[i]=ans; } } if(loop==0){ cout\u003c\u003ca[ans]\u003c\u003cendl; } else{ k-=tim[ans]; k%=loop; cout\u003c\u003ca[ind[k+tim[ans]]]\u003c\u003cendl; } //cout\u003c\u003cloop\u003c\u003cendl; return 0; } E - Colorful Blocks ","date":"2020-05-11","objectID":"/abc167/:8:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 给一排方块涂色，方块有n个，至多m种颜色，要求至多有k对相邻的块涂相同的颜色 求方案数 ","date":"2020-05-11","objectID":"/abc167/:9:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 高中排列组合 $$ ans = \\sum\\limits_{i=0} ^ {k} {m * C_{n-1}^{i} * (m-1)^{n-1-i}} $$ #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const ll mod = 998244353; ll n,m,k; ll fac[200005]; ll ans = 0; ll qpow(ll x,ll n){ ll res = 1; while(n\u003e0){ if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } ll C(int n,int m){ return fac[n]%mod*qpow(fac[m],mod-2)%mod*qpow(fac[n-m],mod-2)%mod; } int main(){ cin\u003e\u003en\u003e\u003em\u003e\u003ek; for(ll i=0;i\u003cn+2;i++) fac[i] = 1; for(ll i=1;i\u003cn+2;i++) fac[i] = i*fac[i-1]%mod; for(ll i=0;i\u003c=k;i++){ ans = ans + m*C(n-1,i)%mod*qpow(m-1,n-1-i)%mod; } cout\u003c\u003c(ans+mod)%mod\u003c\u003cendl; return 0; } F - Bracket Sequencing ","date":"2020-05-11","objectID":"/abc167/:10:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题意 给n个由 ‘(’ 和 ‘)’ 组成的字符串，将n个字符串连接，问是否存在一种方案使得连接后的字符串是合法括号序列 ","date":"2020-05-11","objectID":"/abc167/:11:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["abc"],"content":"题解 很好玩的一道题 一开始想用栈，太麻烦 用计数器，每读入一个open +1 否则 -1 ，这样就得到每个字符串的计数 把计数大的放前面，并且检查计数和是否为0 这样做是错的，样例2不给过 那就对连接后的备选字符串遍历，重新计数，查看中途不能有负数且最后为0 但这样也是错的，因为有可能正确的答案不是按从大到小的顺序排的 这种错误是因为（对于每个字符串）前面有几个close，后面一堆open导致计数变大，但其实是不合法的，因为前面几个close没得匹配 所以应该记录由close影响的“计数的最小值” 合理的排序应该是 对于两个字符串a,b 考虑两种情况 a+b b+a 对于每种连接考虑两种情况 遍历到a时，a的计数最小值 遍历到a+b时，a+b的计数最小值 #include\u003cbits/stdc++.h\u003e using namespace std; int n; string s; vector\u003cpair\u003cint,int\u003e\u003e vt; int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en; int sum=0; for(int i=0;i\u003cn;i++){ cin\u003e\u003es; int cnt=0;int low=0; //int cnt,low=0 WA T_T for(char c:s){ if(c=='('){ cnt++; }else cnt--; low=min(low,cnt); } vt.emplace_back(cnt,low); sum+=cnt; } if(sum!=0) { puts(\"No\");return 0; } sort(vt.begin(),vt.end(),[](pair\u003cint,int\u003e pii1,pair\u003cint,int\u003e pii2){return min(pii1.second,pii1.first+pii2.second) \u003e min(pii2.second,pii2.first+pii1.second);}); int foo=0; for(pair\u003cint,int\u003e pii:vt){ if(foo\u003c-pii.second){ puts(\"No\"); return 0; }foo+=pii.first; } puts(\"Yes\"); return 0; } ","date":"2020-05-11","objectID":"/abc167/:12:0","tags":["cpp","greedy","counting"],"title":"abc167","uri":"/abc167/"},{"categories":["nowcoder"],"content":"牛客算法周周练5(部分)","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"C - 序列最小化 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:0:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 贪心，每次选择的长度为k的区间首尾重叠 #include\u003cbits/stdc++.h\u003e using namespace std; using Int = long long; int main(){ Int n,k; cin\u003e\u003en\u003e\u003ek; n-=k; Int ans = ceil((double)n/(k-1)); cout\u003c\u003cans+1\u003c\u003cendl; return 0; } E - 简单瞎搞题 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:1:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 位dp，dp[i] 表示前i个数能达到的数字集合 加上第 i 个区间的数，遍历一遍这个区间对于其中一个数 j 集合的结果变成 dp[i-1]\u003c\u003c(j*j) 所以 dp[i] |= dp[i-1] \u003c\u003c (j*j) #include\u003cbits/stdc++.h\u003e using namespace std; bitset\u003c1000005\u003e dp[105]; int n; int l[105]; int r[105]; int main(){ cin\u003e\u003en; for(int i=1;i\u003c=n;i++) dp[i].reset(); //init dp[0][0]=1; for(int i=1;i\u003c=n;i++){ cin\u003e\u003el[i]\u003e\u003er[i]; } for(int i=1;i\u003c=n;i++){ for(int j=l[i];j\u003c=r[i];j++){ dp[i] |= (dp[i-1]\u003c\u003c(j*j)); } } cout\u003c\u003cdp[n].count(); return 0; } D - 小雨坐地铁 ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:2:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 经典图论题 丁老师说过如果由直线构成的图中，转弯需要花费时间，则可以构造虚点 对于本身耗费的金钱a，可以构造虚点，对应于每个点，从实点到虚点有权为0的边，从虚点到实点有权为a的边 把每条地铁线的点独立，这样就有(m+1)*n个点 对于每条地铁线上的点，在对应的图层上连线，而图层之间由虚点连接 最后跑一遍最短路 #include\u003cbits/stdc++.h\u003e using namespace std; int n,m,s,t; int a,b,c; int t1,t2; const int inf = 0x3f3f3f3f; const int max_v = 501505; struct edge { int to,cost; edge(int to,int cost){ this-\u003ecost = cost; this-\u003eto = to; } }; typedef pair\u003cint,int\u003e pii; int V; vector\u003cedge\u003e G[max_v]; int d[max_v]; inline void add_edge(int a,int b,int c){ G[a].push_back(edge(b,c)); } void dijkstra(int s) { priority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V,inf); d[s]=0; q.push(pii(0,s)); while(!q.empty()) { pii p=q.top(); q.pop(); int v=p.second; if(d[v]\u003cp.first) continue; for(int i=0;i\u003cG[v].size();i++) { edge e=G[v][i]; if(d[e.to]\u003ed[v]+e.cost) { d[e.to]=d[v]+e.cost; q.push(pii(d[e.to],e.to)); } } } } int main(){ cin\u003e\u003en\u003e\u003em\u003e\u003es\u003e\u003et; V=(m+1)*n+1; s=n*m+s; t=n*m+t; for(int i=0;i\u003cm;i++){ cin\u003e\u003ea\u003e\u003eb\u003e\u003ec; for(int j=0;j\u003cc;j++){ cin\u003e\u003et1; if(j\u003e0){ add_edge(i*n+t2,i*n+t1,b); add_edge(i*n+t1,i*n+t2,b); } add_edge(i*n+t1,m*n+t1,0); add_edge(m*n+t1,i*n+t1,a); t2=t1; } } dijkstra(s); cout\u003c\u003c(d[t]==inf ? -1 : d[t])\u003c\u003cendl; return 0; } ","date":"2020-05-06","objectID":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/:3:0","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/"},{"categories":["note"],"content":"git","date":"2020-05-05","objectID":"/git/","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"git安装 ","date":"2020-05-05","objectID":"/git/:0:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"用户名和邮箱 初始化或切换用户名和邮箱 git config --global user.name \"XXX\" git config --global user.email \"XXX\" 查看当前用户名和邮箱 git config --global user.name git config --global user.email 查看用户名和邮箱列表 git config --list 删除用户名和邮箱 git config --global --unset user.name \"XXX\" git config --global --unset user.email \"XXX\" ","date":"2020-05-05","objectID":"/git/:1:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"git工作原理 ","date":"2020-05-05","objectID":"/git/:2:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"三种状态 modified staged committed ","date":"2020-05-05","objectID":"/git/:3:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"本地操作 ","date":"2020-05-05","objectID":"/git/:4:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"基本操作 从工作目录移动到暂存区 git add XXX 全部移动 git add . 从暂存区移动到本地仓库 git commit -m \"XXX\" 修改提交信息 git commit --amend 打开vim编辑器 只读状态下的保存退出 [esc] :wq! vim使用 查看状态 git status 查看日志 git log 查看更完全的日志并压缩排版 git reflog --oneline ","date":"2020-05-05","objectID":"/git/:4:1","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"版本回退 从暂存区回退到工作目录 git reset XXX 从本地仓库回退到暂存区(后面带数字可以选择回退几个版本) git reset --soft HEAD~ 从本地仓库回退到工作目录 git reset HEAD~ 从本地仓库回退到工作目录，并撤销在工作目录的操作（可能导致删除文件） git reset --hard HEAD~ 对因回退删除掉的文件还原 git reset --hard \u003cfilename\u003e (这时候已经commit) ","date":"2020-05-05","objectID":"/git/:4:2","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"恢复文件 在工作目录中删除，要恢复(把暂存区的恢复过来) git checkout XXX ","date":"2020-05-05","objectID":"/git/:4:3","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"删除文件 删除工作目录和暂存区的文件，取消跟踪，不纳入版本管理（两个区文件要相同） git rm XXX 此时本地仓库还有该文件 通过回退实现彻底删除 git reset --soft HEAD~ 如果两个区文件不同 全都删除 git rm -f XXX 只删除暂存区 git rm --cached XXX ","date":"2020-05-05","objectID":"/git/:4:4","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"重命名 git mv \u003cbefore\u003e \u003cafter\u003e 然后再添加，提交 ","date":"2020-05-05","objectID":"/git/:4:5","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"文件比较 比较两个历史快照 git diff XXX XXX 比较工作目录和暂存区 git diff XXX 比较工作目录和仓库 git diff XXX 比较暂存区和仓库 git diff --cached XXX ","date":"2020-05-05","objectID":"/git/:4:6","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"分支 创建分支 git branch XXX 进入分支 git checkout XXX 创建并进入分支 git checkout -b XXX 列出所有分支 git branch -a 查看当前分支 git branch 图化所有分支 git log --decorate --oneline --graph --all 与当前分支合并 git merge XXX 合并冲突 打开文件，修改文件，重新添加提交 删除分支 git branch -d XXX 分支名删除，文件仍然存在 ","date":"2020-05-05","objectID":"/git/:4:7","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"远程操作 远程项目拷贝到本地 git clone XXX ","date":"2020-05-05","objectID":"/git/:5:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"push/pull 推到远程分支上 git push 需要输入github账号密码 把远程分支更新的内容拉到本地 git pull 连续两次 git push 内容不一样产生冲突 git pull 文件会自动更新，改文件内容，重新添加提交 ","date":"2020-05-05","objectID":"/git/:5:1","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"其他 git push \u003c远程主机名\u003e \u003c远程分支名\u003e git pull \u003c远程主机名\u003e \u003c远程分支名\u003e e.g git push origin master git pull origin master push需要创建upstream连接本地分支和远程分支 git branch --set-upstreamXXX 更常用的是(建立upstream并push)(本地与远程同名) git push -u origin XXX ","date":"2020-05-05","objectID":"/git/:5:2","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"fetch git pull 类似于 git fetch + git merge 和commitId的改动有关 git fetch 更安全 具体参考 这篇文章 ","date":"2020-05-05","objectID":"/git/:5:3","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"remote 远程添加仓库 git remote add \u003cname\u003e \u003curl\u003e 远程删除仓库 git remote remove XXX 查看远程仓库 git remote 查看有关联的远程仓库 git remote -v ","date":"2020-05-05","objectID":"/git/:5:4","tags":["git"],"title":"git","uri":"/git/"},{"categories":["note"],"content":"问题 git remote set-url origin xxx.git 来设置你要提交的仓库，不是使用git remote add origin 在ubuntu16.04 git push时出现 fatal: unable to access \"xxx.git\": gnutls_handshake() failed: Handshake failed 解决方法： https://stackoverflow.com/questions/60262230/fatal-unable-to-access-gnutls-handshake-failed-handshake-failed第一个回答 ","date":"2020-05-05","objectID":"/git/:6:0","tags":["git"],"title":"git","uri":"/git/"},{"categories":["abc"],"content":"abc166","date":"2020-05-04","objectID":"/abc166/","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"A - A?C ","date":"2020-05-04","objectID":"/abc166/:0:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 abc输出arc反之亦然 ","date":"2020-05-04","objectID":"/abc166/:1:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ string s; cin\u003e\u003es; s[1]=s[1]=='B'? 'R': 'B'; cout\u003c\u003cs\u003c\u003cendl; return 0; } B - Trick or Treat ","date":"2020-05-04","objectID":"/abc166/:2:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 snack_i被snuke_1,snuke_2..拥有 问有多少个snuke没有snack ","date":"2020-05-04","objectID":"/abc166/:3:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 #include\u003cbits/stdc++.h\u003e using namespace std; set\u003cint\u003e st; int main(){ int n,k; cin\u003e\u003en\u003e\u003ek; for(int i=1;i\u003c=k;i++){ int x; cin\u003e\u003ex; while(x--){ int y; cin\u003e\u003ey; st.insert(y); } } cout\u003c\u003cn-st.size()\u003c\u003cendl; return 0; } C - Peaks ","date":"2020-05-04","objectID":"/abc166/:4:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 山上有n个观景台，有一些路连接两个观景台，一个观景台是好的当且仅当从它出发走一条路能到达的观景台海拔都比它低，没有路也算 问有多少个好观景台 ","date":"2020-05-04","objectID":"/abc166/:5:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 用二叉树排序 #include\u003cbits/stdc++.h\u003e using namespace std; priority_queue\u003cint\u003e p[100005]; int a[100005]; int main(){ int n,m; cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++) p[i].push(0); for(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i]; while(m--){ int t1,t2; cin\u003e\u003et1\u003e\u003et2; p[t1].push(a[t2]); p[t2].push(a[t1]); } int ans=0; for(int i=1;i\u003c=n;i++){ if(p[i].top()\u003ca[i]) ans++; } cout\u003c\u003cans\u003c\u003cendl; return 0; } D - I hate Factorization ","date":"2020-05-04","objectID":"/abc166/:6:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 给定一个数X，求A，B使得A^5 - B^5 = X,A，B是整数 ","date":"2020-05-04","objectID":"/abc166/:7:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 bf #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll x,a,b; bool check(ll a,ll b){ if(a*a*a*a*a - b*b*b*b*b == x) return true; return false; } int main(){ cin\u003e\u003ex; for(ll i = -500;i\u003c=500;i++) for(ll j=-500;j\u003c=500;j++){ if(check(i,j)){ a = i,b = j; break; } } cout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003cendl; return 0; } E - This Message Will Self-Destruct in 5s ","date":"2020-05-04","objectID":"/abc166/:8:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 有一个数列，一对数字是好数对，当且仅当下标差等于数值和，求好数对个数 ","date":"2020-05-04","objectID":"/abc166/:9:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 等式移项 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n; map\u003cll,ll\u003e mp; ll ans; int main(){ cin\u003e\u003en; for(ll i=0;i\u003cn;i++){ ll x; cin\u003e\u003ex; ans+=mp[i-x]; mp[i+x]++; } cout\u003c\u003cans\u003c\u003cendl; return 0; } F - Three Variables Game ","date":"2020-05-04","objectID":"/abc166/:10:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题意 有三个数a,b,c，有n轮抉择，每一轮抉择会给出一个字符串\"ab\" “bc” ,“ac” 选择其中一个数加，另一个数减，问是否存在一种方案使得所有数最后都不是负数 ","date":"2020-05-04","objectID":"/abc166/:11:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"题解 这题做错了，因为思维局限在dfs找两个数字相同情况下该选哪个，然后不是WA就是TLE，理论上可以，没写好 其实可以全搜索，然后找到一组解就exit(0) 一定要退出，不能返回，因为真的搜索完全就超时 #include\u003cbits/stdc++.h\u003e using namespace std; int n,a,b,c; string s[100005]; char ans[100005]; bool ok; void dfs(int ind,int a,int b,int c){ if(a\u003c0 || b\u003c0 || c\u003c0) return; if(ind==n){ puts(\"Yes\"); for(int i = 0;i \u003c n;i++){ cout\u003c\u003cans[i]\u003c\u003cendl; } exit(0); } else{ if(s[ind]==\"AB\"){ ans[ind]='A'; dfs(ind+1,a+1,b-1,c); ans[ind]='B'; dfs(ind+1,a-1,b+1,c); } else if(s[ind]==\"AC\"){ ans[ind]='A'; dfs(ind+1,a+1,b,c-1); ans[ind]='C'; dfs(ind+1,a-1,b,c+1); } else{ ans[ind]='B'; dfs(ind+1,a,b+1,c-1); ans[ind]='C'; dfs(ind+1,a,b-1,c+1); } } } int main(){ cin\u003e\u003en\u003e\u003ea\u003e\u003eb\u003e\u003ec; for(int i = 0;i\u003cn;i++) cin\u003e\u003es[i]; dfs(0,a,b,c); puts(\"No\"); return 0; } ","date":"2020-05-04","objectID":"/abc166/:12:0","tags":["cpp","dfs"],"title":"abc166","uri":"/abc166/"},{"categories":["abc"],"content":"abc165","date":"2020-05-03","objectID":"/abc165/","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"A - We Love Golf ","date":"2020-05-03","objectID":"/abc165/:0:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 询问在A到B之间是否有C的倍数 ","date":"2020-05-03","objectID":"/abc165/:1:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 特判边界是否满足条件，否则判断左右边界除以C的值是否大于等于1 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ int a,b,c; cin\u003e\u003ea\u003e\u003eb\u003e\u003ec; if(b/(double)a == b/a) puts(\"OK\"); else if(c/(double)a == c/a) puts(\"OK\"); else if(c/a \u003e b/a){ puts(\"OK\"); } else puts(\"NG\"); return 0; } B - 1% ","date":"2020-05-03","objectID":"/abc165/:2:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 初始有100円，每年利息1%，每年结算时将小数部分抛弃，问多久能达到A円 ","date":"2020-05-03","objectID":"/abc165/:3:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 计数器模拟 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ ll a; cin\u003e\u003ea; ll dy = 0; double bs = 100; while(bs\u003ca){ bs*=1.01; bs = floor(bs); dy++; } cout\u003c\u003cdy\u003c\u003cendl; return 0; } C - Many Requirements ","date":"2020-05-03","objectID":"/abc165/:4:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 构造一个数列A每个数不大于10，数列长度不大于M，且递增 有q个四元组 a b c d 如果Ab - Aa == c，则v+=d 求v的最大值 ","date":"2020-05-03","objectID":"/abc165/:5:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 最开始有两种思路，暴力构造（超时），对q个四元组贪心（会错过最优解） 所以dfs，dfs到最后一个数时求v并更新v 传入下标作为参数，不需要回溯 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int a[55],b[55],c[55],d[55]; int n,m,q; int ans; int dat[12]; void dfs(int ind , int pre){ if(ind == n){ int cnt = 0; for(int i=0;i\u003cq;i++){ if(dat[b[i] - 1] - dat[a[i] - 1] == c[i]) cnt+=d[i]; } ans = max(ans , cnt); } else{ for(int i = pre;i\u003c=m;i++){ dat[ind] = i; dfs(ind + 1 , i); } } } int main(){ cin\u003e\u003en\u003e\u003em\u003e\u003eq; for(int i=0;i\u003cq;i++) cin\u003e\u003ea[i]\u003e\u003eb[i]\u003e\u003ec[i]\u003e\u003ed[i]; dfs(0,1); cout\u003c\u003cans\u003c\u003cendl; return 0; } D - Floor Function ","date":"2020-05-03","objectID":"/abc165/:6:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-05-03","objectID":"/abc165/:7:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 问题转化成在0~N中找一个数x，使得x/B的小数部分最接近0.99999 x = B-1 如果N不允许，找最大N ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main(){ double a,b,n; cin\u003e\u003ea\u003e\u003eb\u003e\u003en; double x; if(n\u003e=b-1) x =b-1; else x=n; cout\u003c\u003cfloor(a*x/b) - a*floor(x/b)\u003c\u003cendl; return 0; } E - Rotation Matching ","date":"2020-05-03","objectID":"/abc165/:8:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 有N个玩家，M个竞技场（M*2+1\u003c=N） 每个玩家都有一个数字 每个竞技场安排两个数字，不能重复 共有N轮决斗 对于每一轮，每个竞技场中数字对应的两个玩家进行battle 每一轮决斗后，所有玩家的数字都+1 求安排方案使得所有的人都不会和同一个人battle两次 ","date":"2020-05-03","objectID":"/abc165/:9:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 应该是本次比赛最难的题 由于M*2+1\u003c=N 所以合理安排，在进行N轮之后，一定会刚好满足条件 其实就是号码的两两配对 在纸上列出所有的情况，一直尝试、排除 最后会发现，前半段要隔一个对称配对，后半段直接对称配对，这样就能完美错开 ac代码 #include\u003cbits/stdc++.h\u003e int dat1[100005],dat2[100005]; using namespace std; int main(){ int n,m; cin\u003e\u003en\u003e\u003em; if(!(n\u00261)) n--; int mm = (n-1)/2; if(mm\u00261){ for(int i=1;i\u003c=mm/2;i++){ dat1[i] = i; dat2[i] = (n+1)/2 - i; } for(int j=(n+1)/2,i = mm/2+1,k=0;i\u003c=mm;i++,j++,k++){ dat1[i] = j; dat2[i] = n - k; } } else{ for(int i=1;i\u003c=mm/2;i++){ dat1[i] = i; dat2[i] = (n+3)/2 - i; } for(int i=(n+3)/2,j=n,k=mm/2+1;k\u003c=mm;i++,j--,k++){ dat1[k] = i; dat2[k] = j; } } //for(int i=1;i\u003c=6;i++) cout\u003c\u003cdat1[i]\u003c\u003c\" \"\u003c\u003cdat2[i]\u003c\u003cendl; for(int i=1;i\u003c=m;i++) cout\u003c\u003cdat1[i]\u003c\u003c\" \"\u003c\u003cdat2[i]\u003c\u003cendl; return 0; } F - LIS on Tree ","date":"2020-05-03","objectID":"/abc165/:10:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题意 给一棵树，每个点有一个数字属性，求1到X的最短路径中，按1到X的顺序排列数字属性得到的序列中的最长上升子序列（LIS） 对所有的X ","date":"2020-05-03","objectID":"/abc165/:11:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"题解 dfs + lis 注意回溯 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int dp[200005]; vector\u003cint\u003e G[200005]; int n; int a[200005]; int ans[200005]; const int inf = 0x3f3f3f3f; void dfs(int u,int p){ int ind = (int)(lower_bound(dp,dp+n,a[u]) - dp); int cnt = dp[ind]; dp[ind] = a[u]; ans[u] = (int)(lower_bound(dp,dp+n,inf) - dp); for(int i:G[u]){ if(i!=p){ dfs(i,u); } } //undo dp[ind] = cnt; } int main(){ cin\u003e\u003en; for(int i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; } for(int i=0;i\u003cn-1;i++){ int t1,t2; cin\u003e\u003et1\u003e\u003et2; t1--,t2--; G[t1].push_back(t2); G[t2].push_back(t1); } fill(dp,dp+n+2,inf); dfs(0,-1); for(int i=0;i\u003cn;i++) cout\u003c\u003cans[i]\u003c\u003cendl; return 0; } ","date":"2020-05-03","objectID":"/abc165/:12:0","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"/abc165/"},{"categories":["abc"],"content":"abc164","date":"2020-05-02","objectID":"/abc164/","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"A - Sheep and Wolves ","date":"2020-05-02","objectID":"/abc164/:0:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 判断两个数的大小 ","date":"2020-05-02","objectID":"/abc164/:1:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 ac代码 n,m = map(int,input().split()) if n\u003em: print('safe') else : print('unsafe') B - Battle ","date":"2020-05-02","objectID":"/abc164/:2:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给定两个人的生命值和攻击力，两个人回合制battle，谁的生命值先小于等于0 ","date":"2020-05-02","objectID":"/abc164/:3:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 模拟 ac代码 a,b,c,d = map(int,input().split()) while a\u003e0 and c\u003e0: c=c-b if c\u003c=0: break a=a-d if a\u003c=0: break if a\u003c=0: print('No') else: print('Yes') C - gacha ","date":"2020-05-02","objectID":"/abc164/:4:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给一堆字符串，求有多少种 ","date":"2020-05-02","objectID":"/abc164/:5:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; set\u003cstring\u003e st; cin\u003e\u003en; string s; while(n--){ cin\u003e\u003es; st.insert(s); } cout\u003c\u003cst.size()\u003c\u003cendl; return 0; } D - Multiple of 2019 ","date":"2020-05-02","objectID":"/abc164/:6:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 给一数字串，求多少个连续子串组成的数字是2019的倍数 ","date":"2020-05-02","objectID":"/abc164/:7:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 后缀，和abc158E几乎一致 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ string s; int a[2020]={0}; cin\u003e\u003es; int ans = 0; int t = 1; int cnt = 0; a[0]++; for(int i=s.length()-1;~i;i--){ cnt = (cnt+t*(s[i]-'0'))%2019; ans+=(a[cnt]++); t=(t*10)%2019; } cout\u003c\u003cans\u003c\u003cendl; return 0; } E - Two Currencies ","date":"2020-05-02","objectID":"/abc164/:8:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题意 有n个城市，m条路（无向），每条路有两个属性（通过这条路要花费的时间和金 钱），每个城市有两个属性（可以花费时间购买金钱），给初始的金钱数量，求 从1城市到每个城市花费的最少时间 ","date":"2020-05-02","objectID":"/abc164/:9:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["abc"],"content":"题解 dijkstra算法的变形 把时间当做最短路 当金钱超过最大值时，就不需要考虑是否在每个城市购买金钱 套一个dijkstra算法板子，加上对每个城市是否购买金币的判断 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; using tp = tuple\u003cll,ll,ll\u003e; ll n,m,s; ll a,b; ll c[55],d[55]; //存获得的银币和消耗的时间 ll dp[55][2505]; //到达i时还有j银币的最小时间 vector\u003ctp\u003e G[55]; //目标点 a b tp info; //时间 目标点 当前的钱 const ll inf = 0x3f3f3f3f3f3f3f3f; int main(){ cin\u003e\u003en\u003e\u003em\u003e\u003es; s = min(s,2504LL); for(ll i=0;i\u003cm;i++){ ll ta,tb,tc,td; cin\u003e\u003eta\u003e\u003etb\u003e\u003etc\u003e\u003etd; G[ta].push_back(tp(tb,tc,td)); G[tb].push_back(tp(ta,tc,td)); } for(ll i=1;i\u003c=n;i++){ ll tc,td; cin\u003e\u003etc\u003e\u003etd; c[i] = tc; d[i] = td; } fill(dp[0] , dp[0] + 54*2504 , inf); dp[1][s] = 0; priority_queue\u003ctp,vector\u003ctp\u003e,greater\u003ctp\u003e\u003e pq; pq.push(tp(0,1,s)); while(!pq.empty()){ info = pq.top(); pq.pop(); ll t = get\u003c0\u003e(info) , u = get\u003c1\u003e(info) , w = get\u003c2\u003e(info); if(dp[u][w] \u003e t) continue; for(auto i:G[u]){ ll v = get\u003c0\u003e(i) , aa = get\u003c1\u003e(i) , bb = get\u003c2\u003e(i); if(w\u003e=aa and dp[v][w-aa] \u003e t + bb){ dp[v][w-aa] = t + bb; pq.push(tp(t+bb , v , w-aa)); } } if(dp[u][min(w + c[u] , 2504LL)] \u003e t + d[u]){ dp[u][min(w + c[u] , 2504LL)] = t + d[u]; pq.push(tp(t + d[u] , u , min(w + c[u] , 2504LL))); } } for(ll i=2;i\u003c=n;i++){ ll ans = inf; for(ll j=0;j\u003c2504;j++){ ans = min(ans , dp[i][j]); } cout\u003c\u003cans\u003c\u003cendl; } return 0; } F - I hate Matrix Construction 似乎是位运算的构造。。。🤔 ","date":"2020-05-02","objectID":"/abc164/:10:0","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"/abc164/"},{"categories":["nowcoder"],"content":"NC17134","date":"2020-05-02","objectID":"/nc17134/","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"Symmetric Matrix ","date":"2020-05-02","objectID":"/nc17134/:0:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"题目描述 Count the number of n x n matrices A satisfying the following condition modulo m. Ai, j ∈ {0, 1, 2} for all 1 ≤ i, j ≤ n. Ai, j = Aj, i for all 1 ≤ i, j ≤ n. Ai, 1 + Ai, 2 + … + Ai, n = 2 for all 1 ≤ i ≤ n. A1, 1 = A2, 2 = … = An, n = 0. ","date":"2020-05-02","objectID":"/nc17134/:1:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"输入描述 The input consists of several test cases and is terminated by end-of-file. Each test case contains two integers n and m. ","date":"2020-05-02","objectID":"/nc17134/:2:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"输出描述 For each test case, print an integer which denotes the result. ","date":"2020-05-02","objectID":"/nc17134/:3:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"样例输入 3 1000000000 100000 1000000000 ","date":"2020-05-02","objectID":"/nc17134/:4:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"样例输出 1 507109376 ","date":"2020-05-02","objectID":"/nc17134/:5:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"限制 1 ≤ n ≤ 105 1 ≤ m ≤ 109 The sum of n does not exceed 107. ","date":"2020-05-02","objectID":"/nc17134/:6:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["nowcoder"],"content":"题解 挺好一道题目 这个题分三个步骤 1.根据题意转化成图的邻接矩阵 2.使用dp，找dp递推式 3.化简递推式 1.把题目转化成求n个点的无向图个数满足，没有自环，如果组成圈则边权为1 如果是两个点相连则权值为2（参考下面的图片） 2.f[n] 表示 n 个点时的方案数 那么第 n 个点依赖于前 n-1 个点 考虑两种情况 ① 将 n-1 个点中的一个点拉出来与第 n 个点组成边权为2的点对，对于每一种方 案都有 n-1 个点可选，剩下的 n-2 个点方案数为 f[n-2] 所以 f[n] += (n-1)*f[n-2] ② 把第 n 个点与前 n-1 个点组成圈 考虑选 k 个点出来，那么就有 $$ C_{n-1}^{k} $$ 种选法 对于选出来的 k 个点全排列，有 $$ A_{k}^{k} $$ 种，剩下的情况有 f[n-1-k] 种 由于圈的首位相连，所以 /2 那么所有的方案是 $$ \\frac{1}{2} \\sum\\limits_{k=2} ^ {n-1} {C_{n-1}^{k}A_{k}^{k}f[n-1-k]} $$ 这样并不会重复，因为每次参与形成圈的点数是不同的，这一定互异 3.化简 最终式 f[n] = (n-1) * (f[n-1] + f[n-2]) - 1/2 * (n-1) * (n-2) * f[n-3] ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll ans[100005]; int main(){ ll n,m; ans[0] = 1; ans[1] = 0; ans[2] = 1; ans[3] = 1; while(cin\u003e\u003en\u003e\u003em){ for(ll i=4;i\u003c=n;i++){ ans[i] = 0; } for(ll i = 4;i\u003c=n;i++){ ans[i] += ((i-1)*((ans[i-1]+ans[i-2])%m)%m); ans[i] -= (((i-1)*(i-2)/2%m)*ans[i-3])%m; ans[i] += m; ans[i] %= m; } cout\u003c\u003cans[n]%m\u003c\u003cendl; } return 0; } ","date":"2020-05-02","objectID":"/nc17134/:7:0","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"/nc17134/"},{"categories":["codeforces"],"content":"Codeforces Round #636 (Div. 3) A~E","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"A. Candies ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:0:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一个数n，找一个数x，满足 x+2x+4x+8x+… = n ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:1:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 等比数列求和，变成2^m 然后枚举，看哪个能整除 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; long long n,t; int main(){ cin\u003e\u003et; long long a[32]; for(long long i=1;i\u003c=30;i++){ a[i] = (1\u003c\u003ci) - 1; } while(t--){ cin\u003e\u003en; for(long long i=2;i\u003c=30;i++){ if((double)n/a[i] == n/a[i]){ cout\u003c\u003cn/a[i]\u003c\u003cendl; break; } } } return 0; } B. Balanced Array ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:2:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一数n，问是否可以构造一个数列 数列的个数是偶数 前半部分都是偶数，后半部分都是奇数 前半部分的和等于后半部分 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:3:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 按照样例那样有规律地构造 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n,t; int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003en; if((n/2) \u0026 1) puts(\"NO\"); else { puts(\"YES\"); for(int i=1;i\u003c=n/2;i++){ cout\u003c\u003ci*2\u003c\u003c\" \"; } for(int i=1;i\u003c=n/4;i++){ cout\u003c\u003ci*2-1\u003c\u003c\" \"; } for(int i=n/4+1;i\u003c=n/2;i++){ cout\u003c\u003ci*2+1\u003c\u003c\" \"; } cout\u003c\u003c\"\\n\"; } } return 0; } C. Alternating Subsequence ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:4:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 在一个数列中找一个子序列（可以不连续）满足奇偶穿插 对于满足这个条件的最长子序列中，求元素和最大值 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:5:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 将数列按奇偶性分割，每一部分取最大值 可以用双指针锁定区间 我的写法需要再最后添一个相反数，否则加不到最后一块区域 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n,t,a[200005]; const ll inf = 0x3f3f3f3f3f3f3f3f; const ll ninf = 0xc0c0c0c0c0c0c0c0; int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en; vector\u003cll\u003e ans; for(ll i=0;i\u003cn;i++) cin\u003e\u003ea[i]; if(a[n-1]\u003e0) a[n]=-1; else a[n]=1; bool pos; if(a[0]\u003e0){ pos=true; }else pos=false; ll l = 0; ll r = 0; for(int i=0;i\u003c=n;i++){ if(pos){ if(a[i]\u003e0) r++; else { pos^=1; ll cnt = *max_element(a+l , a+r); ans.push_back(cnt); l = r; r++; } } else{ if(a[i]\u003c0) r++; else{ pos^=1; ll cnt = *max_element(a+l , a+r); ans.push_back(cnt); l = r; r++; } } } ll foo = 0; for(ll i:ans){ //cout\u003c\u003ci\u003c\u003cendl; foo+=i; } cout\u003c\u003cfoo\u003c\u003cendl; } return 0; } D. Constant Palindrome Sum ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:6:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 对于一个长度为n的数列（n为偶数） 对于数列中的每个数可以进行替换，使得所有的对称的一组数字和相等 且所有数字不超过k 求最小替换数 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:7:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 对于每组数，可以替换1次，2次0次 由于数字不超过k，所以和的范围为[2,2*k] 因为k的数据较小，所以可以枚举，对于每个x 求替换数，然后一直min 如果两个数和为x，则替换数为0 如果替换一个数，则替换之后和的范围是[min(x1,x2)+1 , max(x1,x2)+k] 所以检查x是否落在这个范围内 除此之外要替换2个 所以用一个容器存数字和的个数（目的是求0个） 存左右区间的个数（目的是不断迭代求1个）（如果用这种方法1个的个数会覆盖0个） 剩下就是2个 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t,n,k; int a[200005]; int eq[2*200005]; int l[2*200005]; int r[2*200005]; int one[2*200005]; //只替换一个 int ans; int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003ek; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ea[i]; } for(int i=1;i\u003c=n/2;i++){ eq[a[i]+a[n-i+1]]++; l[min(a[i],a[n-i+1])+1]++; r[max(a[i],a[n-i+1])+k]++; } for(int i=1;i\u003c=2*k+3;i++){ one[i] = one[i-1]+l[i]-r[i-1]; } ans = n+2; for(int i=1;i\u003c=2*k+3;i++){ ans = min(ans , n - one[i] - eq[i]); //不能用2*eq，因为one会重复计算一个eq所以要再加上一个eq } cout\u003c\u003cans\u003c\u003cendl; //TODO reset for(int i=0;i\u003c2*k+2;i++) { //这里用memeset就会超时 eq[i]=l[i]=r[i]=0; } } return 0; } E. Weights Distributing ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:8:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 给一没有权值的无向图和权值序列 问怎样给边赋值（一一对应）使得从a到b再到c的权值和最小 ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:9:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 由于行走路径会重复的问题 所以可以把问题转化成从a到 i ，从i到b，从b到 I ，从 i 到c 遍历所有的点 i 保证 i 到 b ，a 到 i ， i 到 c 都是最短路径（路径数最少） 将权值最小的部分赋给 b到 i 的路径上，再将较小的权值赋给 a到 i 和 i 到 c 要让路径数最少，直接bfs预处理 然后给权值排序，因为要不断选一段有序的权值，所以前缀和预处理 最后要特判 如果在样例1中，i 在 a 上，那么 i 到 b 和 i 到 c 路径重复，这种情况是绝对不可 能最优的（总能找到反例） ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll t,n,m,a,b,c; ll mm[200005]; ll d[3][200005]; ll spre[200005]; vector\u003cll\u003e G[200005]; const ll inf = 0x3f3f3f3f3f3f3f3f; void bfs(ll st,ll r){ queue\u003cll\u003e q; q.push(st); while(!q.empty()){ ll cnt = q.front(); q.pop(); for(auto i : G[cnt]){ if(d[r][i] == -1){ d[r][i] = d[r][cnt]+1; q.push(i); } } } } int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb\u003e\u003ec; //TODO reset for(ll i=0;i\u003c3;i++)for(ll j=0;j\u003c=n;j++) d[i][j]=-1; for(ll i=0;i\u003c=n;i++) G[i].clear(); for(ll i=1;i\u003c=m;i++){ cin\u003e\u003emm[i]; } sort(mm+1,mm+m+1); spre[1] = mm[1]; for(ll i=2;i\u003c=m;i++){ spre[i]=spre[i-1]+mm[i]; } ll t1,t2; for(ll i=1;i\u003c=m;i++){ cin\u003e\u003et1\u003e\u003et2; G[t1].push_back(t2); G[t2].push_back(t1); } d[0][a]=0;d[1][b]=0,d[2][c]=0; bfs(a,0); bfs(b,1); bfs(c,2); ll ans = inf; for(ll i=1;i\u003c=n;i++){ if(d[0][i] + d[1][i] + d[2][i] \u003e m) continue; ans = min(ans , spre[ d[1][i] ] + spre[ d[0][i] + d[1][i] + d[2][i] ]); } cout\u003c\u003cans\u003c\u003cendl; } // for(ll i=1;i\u003c=7;i++){ //cout\u003c\u003cd[2][2]\u003c\u003c\" \"; // } //for(ll i=1;i\u003c=8;i++) cout\u003c\u003cspre[i]\u003c\u003c\" \"; //cout\u003c\u003cd[1][1]\u003c\u003cendl; //cout\u003c\u003ca\u003c\u003cb\u003c\u003cc; return 0; } ","date":"2020-04-23","objectID":"/codeforces-round-636-div.-3-a~e/:10:0","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"/codeforces-round-636-div.-3-a~e/"},{"categories":["abc"],"content":"abc163","date":"2020-04-22","objectID":"/abc163/","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"A - Circle Pond ","date":"2020-04-22","objectID":"/abc163/:0:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 求圆周长 ","date":"2020-04-22","objectID":"/abc163/:1:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 print(int(input())*2*3.14159265) B - Homework ","date":"2020-04-22","objectID":"/abc163/:2:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 给定假期的时间和每一项作业完成的时间，求这个假期能玩几天 ","date":"2020-04-22","objectID":"/abc163/:3:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 n,m = map(int , input().split()) a = list(map(int , input().split())) s = sum(a) if n\u003e=s: print(n-s) else: print(-1) C - management ","date":"2020-04-22","objectID":"/abc163/:4:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 告诉每个员工的老板，询问每个老板有多少个员工 ","date":"2020-04-22","objectID":"/abc163/:5:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 ac代码 n=int(input()) a=input().split() w=[0]*n for i in a: w[int(i)-1]+=1 for i in w: print(i) D - Sum of Large Numbers ","date":"2020-04-22","objectID":"/abc163/:6:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-22","objectID":"/abc163/:7:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 由于10^100次方的作用，这个题目就转化成求从中选n个数，有几种求和的结果 种数就是最大的n个减最小的n个 再遍历所有的n ac代码 n , k = map(int , input().split()) sum = 0 mod = 1e9+7 def func(x): return (2 * n - x + 1) * x / 2 - (x - 1) * x / 2 + 1 for i in range(k , n+2): sum = (sum + func(i)) % mod print(int(sum)) E - Active Infants ","date":"2020-04-22","objectID":"/abc163/:8:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-22","objectID":"/abc163/:9:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 贪心策略，尽可能地把值最大的点放到边边上,所以可以按降序排，然后从左到右 遍历 dp[i][j] 表示区间 [ i , j ] 确定的最大值 cnt\u003cvalue,index\u003e 表示当前点，即比它大的点都已安置过 那么 dp[i[[j] = max(dp[i+1][j] + cnt.first * | cnt.second - i| , dp[i][j-1] + cnt.first * |cnt.second - j| ) 对于 dp[i+1][j] 和 dp[i][j-1] 都需要用函数进行计算，就形成dfs ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; #define fi first #define se second using pll = pair\u003cll,ll\u003e; ll n; ll ans=0; vector\u003cpll\u003e vt; //存value和index ll dp[2005][2005]; ll cal(ll a,ll b,ll cnt){ if(a\u003eb) return 0; if(dp[a][b]!=-1) return dp[a][b]; return dp[a][b] = max(cal(a+1 , b , cnt+1) + vt[cnt].fi*abs(vt[cnt].se-a) , cal(a,b-1,cnt+1) + vt[cnt].fi*abs(vt[cnt].se -b)); } int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en; ll t; for(ll i=0;i\u003cn;i++){ cin\u003e\u003et; vt.emplace_back(t,i) ; } sort(vt.begin() , vt.end() , [](pll x,pll y){if(x.fi != y.fi) return x.fi\u003ey.fi; return x.se\u003ey.se;}); //可以直接用greater memset(dp,-1,sizeof(dp)); cout\u003c\u003ccal(0,n-1,0)\u003c\u003cendl; return 0; } F - path pass i ","date":"2020-04-22","objectID":"/abc163/:10:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题意 一个n个节点的树，每个节点都有一种颜色，可能重复 对于每种颜色，输出包含这种颜色的简单路径数量 ","date":"2020-04-22","objectID":"/abc163/:11:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["abc"],"content":"题解 挺好一道树上dfs求路径的题 把问题转化成所有路径 - 不包含这种颜色的路径数 所有路径数为 C(2,n)+n 不包含这种颜色 i 的路径可以分成两部分 以颜色 i 作为父节点的子树，任意一条都是满足的（注意子树可能有颜色 i ） 将 i 节点作为父节点的子树切去的剩余部分 如果暴力求连通块的话会超时，所以要dfs（回溯思想） 因为分成两个部分，所以维护两种信息 path_num[i] 以i为颜色的点作为父节点中子树里面不包含此颜色的路径数量 ch_num[i] 以 i 为颜色的点作为父节点中子树的大小，包含 i 颜色 最后 k = n - cn_num[i] ans = all - path_num[i] - k(k+1)/2 对于dfs的细节在代码中标注 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int c[200005]; vector\u003clong long\u003e G[200005]; long long path_num[200005]; //以i为颜色的点作为父节点中子树里面不包含此颜色的路径数量 long long ch_num[200005]; //以i为颜色的点作为父节点中子树的大小，包含i颜色 long long n; long long ans; long long dfs(long long u,long long v){ long long pre = ch_num[c[u]]; //dfs到u时，ch_num[i]的大小 long long cnt_ch_num = 1; //记录以u为父节点，子树的大小，包含自己所以起始为1 long long update = ch_num[c[u]]; //每次访问一个子节点就更新，目的是实时地计算路径数（需要用到残差） for(auto i:G[u]){ if(i!=v){ long long cntt = dfs(i,u); //返回的是以这个点为父节点的子节点数 cnt_ch_num += cntt; //扩充新的子节点数 long long delta = ch_num[c[u]] - update; //计算下一个子节点对于上一个子节点该颜色子树点的数量差 long long k = cntt - delta; //对于每个点都要更新路径数，路径数就是多出来的剩余部分(切去该颜色的点为父节点的所有子树，因为之前算过一部分 //所以这里算残差) path_num[c[u]] += (k+1)*k/2; update = ch_num[c[u]]; //为了残差，需要更新 } } ch_num[c[u]] = pre + cnt_ch_num; //子树大小为之前的部分 + 以u为父节点子树的部分 return cnt_ch_num; } int main(){ cin\u003e\u003en; for(long long i=0;i\u003cn;i++) { cin\u003e\u003ec[i]; c[i]--; } long long t1,t2; for(long long i=0;i\u003cn-1;i++){ cin\u003e\u003et1\u003e\u003et2; t1--;t2--; G[t1].push_back(t2); G[t2].push_back(t1); } dfs(0,-1); for(long long i=0;i\u003cn;i++){ long long k=n-ch_num[i]; ans = (n+1)*n/2 - path_num[i] - (k+1)*k/2; //所有路径 - 子树部分 - 剩余部分 cout\u003c\u003cans\u003c\u003cendl; } return 0; } 吃了一发爆long long debug很久发现，“简单路径”居然可以是自己到自己 一直在做android作业，debug快疯掉 debug一天多，发现recyclerview里面没有呈现cardview居然是getItemCount(){return 0;} ","date":"2020-04-22","objectID":"/abc163/:12:0","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"/abc163/"},{"categories":["codeforces"],"content":"Codeforces Round #634 (Div. 3) A~E","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"A. Candies and Two Sisters ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:0:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 将一堆糖果分给两个女孩，其中一个要比另一个多，问有几种分法 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:1:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 可以看出规律 ac代码 t=int(input()) for i in range(t): n=int(input()) print((int)((n-1)/2)) B. Construct the String ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:2:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 输入a,b,c 构造字符串，使字符串的长度为a，任意b个字符有c个不同字符 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:3:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 如果b=6,c=4就构造类似于aaabcdaaabcd.. 其他同理 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t,n,a,b; char s[2005]; int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003ea\u003e\u003eb; for(int i=0;i\u003ca-b+1;i++){ s[i]='a'; } char x; for(int i=a-b+1, x='b';i\u003ca;i++,x++){ s[i]=x; } for(int j=0,i=0;j\u003cn;j++){ if(i==a) i=0; cout\u003c\u003cs[i++]; } cout\u003c\u003cendl; } return 0; } C. Two Teams Composing ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:4:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 从一个数列中，选一些数组成两个数列，使这两个数列长度相等，一个数列数字 全部相同，一个数列数字全部不同，求最长长度 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:5:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 求数列中出现次数最多的个数和总共有多少种数字，瞎比较一下即可 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; map\u003cint,int\u003e mp; int t,n; int num; int m; int dat[200005]; int ans; int main(){ cin\u003e\u003et; while(t--){ set\u003cint\u003e st;mp.clear(); m=-1; cin\u003e\u003en; for(int i=0;i\u003cn;i++){ cin\u003e\u003edat[i]; mp[dat[i]]++; if(mp[dat[i]]\u003em){ m=mp[dat[i]]; num=dat[i]; } st.insert(dat[i]); } int rem=n-m; if(m\u003c=st.size()-1) ans=m; else if(m==st.size()) ans=m-1; else ans=st.size(); cout\u003c\u003cans\u003c\u003cendl; } return 0; } D. Anti-Sudoku ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:6:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 输入一个数独 每行每列每宫格只能改变一个数，使每行每列每宫格有两个数相同 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:7:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 思维题 把所有的1改成2 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t; char s[9][10]; int main(){ cin\u003e\u003et; while(t--){ for(int i=0;i\u003c9;i++){ cin\u003e\u003es[i]; } for(int i=0;i\u003c9;i++){ for(int j=0;j\u003c9;j++){ if(s[i][j]=='1') s[i][j]='2'; } } for(int i=0;i\u003c9;i++){ puts(s[i]); } } return 0; } E. Three Blocks Palindrome (hard version) ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:8:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 求一个字符串的子串（可以不连续）使得这个子串是三块回文串 三块回文串：字符串被分成三块（长度可以为0），第一块和第三块必须相同 第二块可以和第一块相同也可以不同 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:9:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 简单版的可以暴力枚举中间块的左边界和右边界 然后前缀存每个数字出现的次数 设长度为n，数字最大为m 则时间复杂度O(n*n*m*m) 困难版时间复杂度必须降到O(k*n) 这时候不再遍历两个边界 而是固定一个边界，遍历一个边界，这样时间复杂度为O(k*n) 如此只能遍历第一块的右边界（对应第三块的左边界） 对于一个特定的数 i 假设共有 x 个 第一块含有这个数的个数从1遍历到 x/2 个 这就需要一个容器存储数字 i 出现 j 次对应的下标 确定第一块和第三块后就要找第二块哪种数字出现得最多 这和简单版的一样，用前缀存数字 i 在下标为 j 时出现的次数 遍历一遍所有数字 再总体遍历一遍所有数字 时间复杂度O(m*m*n*lgn) 看起来会超时，但实际不会 (跑了400ms) 本来在存储下标pos时开二维静态数组，MLE(266K) 改成动态map (166K) 对于时间复杂度和空间复杂度都可以再优化 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t; int n; int num[205][200005]; //num[i][j]存数字i在下标为j时出现的次数 map\u003cint,int\u003e pos[205]; //map\u003cj,index\u003e存数字i出现第j次的下标 int main(){ //freopen(\"in.txt\",\"r\",stdin); scanf(\"%d\",\u0026t); while(t--){ //TODO reset /*for(int i=0;i\u003c202;i++) { num[i][0]=0; pos[i][0]=0; }*/ for (int i=0;i\u003c205;i++) pos[i].clear(); scanf(\"%d\",\u0026n); int tmp; for(int i=1;i\u003c=n;i++){ scanf(\"%d\",\u0026tmp); for(int j=1;j\u003c=200;j++){ if(j==tmp){ num[j][i]=num[j][i-1]+1; } else{ num[j][i]=num[j][i-1]; } } pos[tmp].insert(make_pair(num[tmp][i],i)); } int ans=1; for(int i=1;i\u003c=200;i++){ for(int j=1;j\u003c=num[i][n]/2;j++){ int l=pos[i][j]+1; int r=pos[i][num[i][n]-j+1]-1; for(int k=1;k\u003c=200;k++){ ans=max(ans,num[k][r]-num[k][l-1]+2*j); } } } cout\u003c\u003cans\u003c\u003cendl; //for(int i=1;i\u003c=4;i++) cout\u003c\u003cnum[i][8]\u003c\u003c\" \"; //for(int i=1;i\u003c=4;i++) cout\u003c\u003cpos[3][i]\u003c\u003c\" \"; } return 0; } F. Robots on a Grid ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:10:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:11:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-04-14","objectID":"/codeforces-round-634-div.-3-a~e/:12:0","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"/codeforces-round-634-div.-3-a~e/"},{"categories":["abc"],"content":"abc162","date":"2020-04-13","objectID":"/abc162/","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"A - Lucky 7 ","date":"2020-04-13","objectID":"/abc162/:0:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 问一个整数中是否含有数字7！ ","date":"2020-04-13","objectID":"/abc162/:1:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 ac代码 s = input() if '7' in list(s): print('Yes') else: print('No') B - FizzBuzz Sum ","date":"2020-04-13","objectID":"/abc162/:2:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 找出不大于n的自然数中不能被3和5整除的数的和 ","date":"2020-04-13","objectID":"/abc162/:3:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 模拟或者集成成公式O(1) ac代码 n = int(input()) ans=0 for i in range(1,n+1): if i%3==0 or i%5==0: continue else: ans+=i print(ans) C - Sum of gcd of Tuples (Easy) ","date":"2020-04-13","objectID":"/abc162/:4:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:5:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 ac代码 from math import gcd k=int(input()) ans=0 for i in range(1,k+1): for j in range(1,k+1): for m in range(1,k+1): ans+=gcd(i,gcd(j,m)) print(ans) D - RGB Triplets ","date":"2020-04-13","objectID":"/abc162/:6:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:7:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 存rgb对应的下标 每次for循环两个颜色，在第三种颜色的下标中二分查找 时间复杂度O(n^2lgn) 这种方法不是很高效，跑了1600ms 利用乘法原理，跑一遍字符串应该可以O(n) ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n; char s[4005]; vector\u003cint\u003e c[3]; long long ans=0; void sol(int q,int w,int e){ for(int i:c[q]) for(int j:c[w]){ if(j\u003ei){ vector\u003cint\u003e::iterator it = upper_bound(c[e].begin(),c[e].end(),j); if(it!=c[e].end()){ ans+=(int)(c[e].end()-it); int tgt=j+j-i; if(find(c[e].begin(),c[e].end(),tgt)!=c[e].end()) ans--; }else break; } } } int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en; for(int i=0;i\u003cn;i++){ cin\u003e\u003es[i]; switch(s[i]){ case 'R':c[0].push_back(i);break; case 'G':c[1].push_back(i);break; case 'B':c[2].push_back(i);break; } } sol(0,1,2); sol(0,2,1); sol(1,2,0); sol(1,0,2); sol(2,1,0); sol(2,0,1); cout\u003c\u003cans\u003c\u003cendl; //cout\u003c\u003cs+1\u003c\u003cendl; return 0; } E - Sum of gcd of Tuples (Hard) ","date":"2020-04-13","objectID":"/abc162/:8:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 C题的升级版，个人觉得出得很好 官方题解，巧妙易懂 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll =long long; ll n,k; ll ans; ll dp[1\u003c\u003c17]; const ll mod = 1e9+7; ll qpow(ll x,ll n) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } int main(){ cin\u003e\u003en\u003e\u003ek; for(ll i=k;i\u003e0;i--){ dp[i]=qpow(k/i , n); for(ll j=i+i;j\u003c=k;j+=i){ dp[i]-=dp[j]; //+mod%mod防溢出 } } for(ll i=1;i\u003c=k;i++) ans=(ans+dp[i]*i)%mod; cout\u003c\u003cans%mod\u003c\u003cendl; return 0; } F - Select Half ","date":"2020-04-13","objectID":"/abc162/:9:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题意 看题目 ","date":"2020-04-13","objectID":"/abc162/:10:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["abc"],"content":"题解 贪心dp 对于当前数，有两种情况，选和不选 如果前一个数选了，这个数就不能选 如果前一个数不选，这个数可选可不选，取决于选了是否会贡献 对于下标的奇偶性需要分开判断 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; ll dat[1\u003c\u003c18]; ll sum[1\u003c\u003c18]; ll dp[1\u003c\u003c18]; ll n; int main(){ cin\u003e\u003en; for(ll i=0;i\u003cn;i++) { cin\u003e\u003edat[i]; if(i\u003e=2 and i%2==0) sum[i]=dat[i]+sum[i-2]; else if(i==0) sum[i]=dat[i]; } for(ll i=0;i\u003cn;i++){ if(i\u00261){ dp[i]=max(dp[i-2]+dat[i] , sum[i-1]); } else{ dp[i]=max(dp[i-2]+dat[i] , dp[i-1]); } } cout\u003c\u003cdp[n-1]\u003c\u003cendl; return 0; } ","date":"2020-04-13","objectID":"/abc162/:11:0","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"/abc162/"},{"categories":["algorithm","hduoj"],"content":"hduoj1796","date":"2020-04-11","objectID":"/hduoj1796/","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"How many integers can you find ","date":"2020-04-11","objectID":"/hduoj1796/:0:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Problem Description Now you get a number N, and a M-integers set, you should find out how many integers which are small than N, that they can divided exactly by any integers in the set. For example, N=12, and M-integer set is {2,3}, so there is another set {2,3,4,6,8,9,10}, all the integers of the set can be divided exactly by 2 or 3. As a result, you just output the number 7. ","date":"2020-04-11","objectID":"/hduoj1796/:1:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Input There are a lot of cases. For each case, the first line contains two integers N and M. The follow line contains the M integers, and all of them are different from each other. 0\u003cN\u003c2^31,0\u003cM\u003c=10, and the M integer are non-negative and won’t exceed 20. ","date":"2020-04-11","objectID":"/hduoj1796/:2:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Output For each case, output the number. ","date":"2020-04-11","objectID":"/hduoj1796/:3:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Sample Input 12 2 2 3 ","date":"2020-04-11","objectID":"/hduoj1796/:4:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Sample Output 7 ","date":"2020-04-11","objectID":"/hduoj1796/:5:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["algorithm","hduoj"],"content":"Solution 容斥原理 ac代码 几个注意点 data可能为0(这时候可以忽略) 要开long long(一直没想到) #include\u003cbits/stdc++.h\u003e using namespace std; long long n,m; long long dat[11]; long long ans=0; vector\u003clong long\u003e vt; long long mm; main(){ while(~scanf(\"%d%d\",\u0026n,\u0026mm)){ ans=0; vt.clear(); n--; long long temp; for(long long i=0;i\u003cmm;i++) { cin\u003e\u003etemp; if(temp!=0) vt.push_back(temp); } m=vt.size(); long long x=0; for(auto i:vt){ dat[x++]=i; } for(long long i=1;i\u003c(1\u003c\u003cm);i++){ //i从1开始 long long lcm=1; for(long long j=0;j\u003cm;j++){ if(i\u003e\u003ej\u00261){ lcm=(lcm*dat[j])/__gcd(lcm,dat[j]); } if(lcm\u003en) break; } if(__builtin_popcount(i)\u00261) ans+=n/lcm; else ans-=n/lcm; } cout\u003c\u003cans\u003c\u003cendl; } } ","date":"2020-04-11","objectID":"/hduoj1796/:6:0","tags":["cpp","counting"],"title":"hduoj1796","uri":"/hduoj1796/"},{"categories":["nowcoder"],"content":"牛客练习赛61(部分)","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"A . 打怪 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:0:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ //freopen(\"in.txt\",\"r\",stdin); int t,a,b,c,d; cin\u003e\u003et; while(t--){ cin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed; if(b\u003e=c || d\u003c=0) cout\u003c\u003c-1\u003c\u003cendl; else{ int num=0; int cx=c; bool me=true; while(a\u003e0){ if(me){ cx-=b; me^=1; } else{ a-=d;me^=1; } if(cx\u003c=0) { cx=c;num++;me=true; } } if(num\u003e10000) cout\u003c\u003c-1\u003c\u003cendl;else cout\u003c\u003cnum\u003c\u003cendl; } } return 0; } B . 吃水果 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:1:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 贪心 其实就是找一些操作使两数相等，如果小的数*2比大的数小就*2，否则随着数的 递减，y/x增大，需要乘很多次2才能相等 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int t; cin\u003e\u003et; while(t--){ int n,m; cin\u003e\u003en\u003e\u003em; int c=0; while(n!=m){ if(n\u003em) swap(n,m); if(2*n\u003c=m) { n*=2;c++; } else{ n--;m--;c++; } } cout\u003c\u003cc+n\u003c\u003cendl; } return 0; } C . 四个选项 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:2:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 z[12]用来存12道题的选项，每次停留在一道题时，根据剩余选项数进行dfs 每次搜索到末尾时判断是否满足第i题和第j题答案相同，都相同则方案数+1 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int num[5]; int z[13]; vector\u003cpair\u003cint,int\u003e\u003e vt; int ans=0; int m; void dfs(int ind){ if(ind==13){ bool flag=true; for(auto i:vt){ if(z[i.first]!=z[i.second]) { flag=false;break; } } if(flag) { ans++;return; } } for(int i=1;i\u003c=4;i++){ z[ind]=i; if(num[i]){ num[i]--; dfs(ind+1); num[i]++; } } } int main(){ cin\u003e\u003enum[1]\u003e\u003enum[2]\u003e\u003enum[3]\u003e\u003enum[4]\u003e\u003em; int t1,t2; while(m--) { cin\u003e\u003et1\u003e\u003et2; vt.emplace_back(t1,t2); } dfs(1); cout\u003c\u003cans\u003c\u003cendl; return 0; } D . 最短路变短了 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:3:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["nowcoder"],"content":"题解 设d1[x]是1到x的最短距离 d2[x]是x到n的最短距离 则每次反向一条边（u-\u003ev,w） 如果变短，那么一定是 1-\u003ev-\u003eu-\u003en 所以只需要判断 d1[v]+w+d2[u] \u003c d1[n] 反向边的改变可能会影响d1,d2原始的数值 但不影响结果 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; const long long max_v=100005; const long long max_q=200005; const long long max_e=200005; const long long inf=0x3f3f3f3f3f3f3f3f; struct edge { long long to,cost; edge(long long to,long long cost){ this-\u003eto=to; this-\u003ecost=cost; } }; typedef pair\u003clong long,long long\u003e pii; vector\u003cedge\u003e G1[max_v]; vector\u003cedge\u003e rG[max_v]; long long V; long long d1[max_v]; long long d2[max_v]; long long n,m,q; long long t1,t2,t3; long long x; long long dat[max_e][3]; void dijkstra(long long s,long long d[],vector\u003cedge\u003e G[]) { priority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; fill(d,d+V+2,inf); d[s]=0; q.push(pii(0,s)); while(!q.empty()) { pii p=q.top(); q.pop(); long long v=p.second; if(d[v]\u003cp.first) continue; for(long long i=0;i\u003cG[v].size();i++) { edge e=G[v][i]; if(d[e.to]\u003ed[v]+e.cost) { d[e.to]=d[v]+e.cost; q.push(pii(d[e.to],e.to)); } } } } main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003em; V=n; for(long long i=1;i\u003c=m;i++){ cin\u003e\u003et1\u003e\u003et2\u003e\u003et3; edge e(t2,t3); G1[t1].push_back(e); edge e1(t1,t3); rG[t2].push_back(e1); dat[i][0]=t1,dat[i][1]=t2,dat[i][2]=t3; } dijkstra(1,d1,G1); dijkstra(n,d2,rG); cin\u003e\u003eq; while(q--){ cin\u003e\u003ex; long long u=dat[x][0],v=dat[x][1],w=dat[x][2]; if(d1[v]+d2[u]+w\u003cd1[n]) puts(\"YES\"); else puts(\"NO\"); } // for(long long i=1;i\u003c4;i++) cerr\u003c\u003cd1[i]\u003c\u003c\" \"; cerr\u003c\u003c\"\\n\"; // for(long long i=1;i\u003c4;i++) cerr\u003c\u003cd2[i]\u003c\u003c\" \"; cerr\u003c\u003c\"\\n\"; } E . 相似的子串 F . 苹果树 ","date":"2020-04-11","objectID":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/:4:0","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/"},{"categories":["codeforces"],"content":"Codeforces Round #632 (Div. 2) A~C","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"A. Little Artem ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:0:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 给一网格染色，黑或白。要求满足以下条件的黑方块比白方块少1 如果是黑方块，则至少与一白方块边相邻，否则不计数 反之亦然 ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:1:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 左上角染白，其他全黑 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int t; cin\u003e\u003et; while(t--){ int n,m; cin\u003e\u003en\u003e\u003em; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ if(i==0 and j==0){ cout\u003c\u003c'W'; } else cout\u003c\u003c'B'; } cout\u003c\u003cendl; } } return 0; } B. Kind Anton ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:2:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 两数组a,b a初始时只由{0,-1,1}的子集组成 操作方式：将一个数前面的某一个数加到这个数上 问能否经过一些操作后得到数组b ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:3:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 由于一个数只会被前面的数影响，且前面的数不受影响 再加上0,-1,1的特殊性，只需要考虑b[i]\u003ea[i]时，前面是否有1 或b[i]\u003ca[i]时前面是否有-1 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t; int n; int a[100005]; int b[100005]; int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ bool one=false; bool none=false; cin\u003e\u003en; for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; for(int i=0;i\u003cn;i++) cin\u003e\u003eb[i]; if(a[0]!=b[0]) { cout\u003c\u003c\"NO\\n\"; continue; } if(a[0]==1) one=true; if(a[0]==-1) none=true; bool ok=true; for(int i=1;i\u003cn;i++){ if(b[i]\u003ea[i] and !one) { ok =false;break; } if(b[i]\u003ca[i] and !none){ ok=false;break; } if(a[i]==1) one=true; if(a[i]==-1) none=true; } if(ok) cout\u003c\u003c\"YES\\n\"; else cout\u003c\u003c\"NO\\n\"; } return 0; } C. Eugene and an array ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:4:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题意 给一数组，问有多少个“好子数组“ 定义，好子数组：这个数组是原数组的子集，元素之和不等于0，其子集都是好子 数组 ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:5:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["codeforces"],"content":"题解 类似于依赖前缀和动态规划 从左向右遍历，查看是否有和为0的区间，其中区间的右边界为当前数 查看是否有和为0的区间只需要查看是否有前缀和为当前数的区间 如果有则取最右端（因为好子数组的子集也是好子数组） ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; ll n;ll x;ll sum=0;map\u003cll,ll\u003e pos;ll cp=-1;ll ans=0; int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en; pos[0]=0; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ex; sum+=x; if(pos.count(sum)) cp=max(cp,pos[sum]); ans+=i-cp-1; pos[sum]=i; } cout\u003c\u003cans\u003c\u003cendl; return 0; } D. Challenges in school №41 E. Road to 1600 F. Kate and imperfection ","date":"2020-04-09","objectID":"/codeforces-round-632-div.-2-a~c/:6:0","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"/codeforces-round-632-div.-2-a~c/"},{"categories":["nowcoder"],"content":"NC13611","date":"2020-04-06","objectID":"/nc13611/","tags":["cpp","number_theory","dp"],"title":"NC13611","uri":"/nc13611/"},{"categories":["nowcoder"],"content":"题目描述 shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。 输入描述: 第一行两个整数n，k代表点数和颜色数； 接下来n-1行，每行两个整数x,y表示x与y之间存在一条边； 输出描述: 输出一个整数表示方案数（mod 1e9+7）。 sample input 4 3 1 2 2 3 2 4 sample output 39 solution 动态规划 dp[i][j] 表示现在在第 i 个点，用 j 中颜色染色的方案数 那么对于下一个点有两种情况 1.染同一种颜色 dp[i][j]=dp[i-1][j] 2.染不同颜色 dp[i][j]+=dp[i-1][j-1]*(k-j+1) 最后对所有的 dp[n][i] 1\u003c=i\u003c=k 求和 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; ll n,k; ll dp[305][305]; const ll mod = 1e9+7; int main(){ cin\u003e\u003en\u003e\u003ek; dp[0][0]=1; for(int i=1;i\u003c=n;i++) for(int j=1;j\u003c=k;j++){ dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-j+1))%mod; } ll ans=0; for(int i=1;i\u003c=k;i++){ ans=(ans+dp[n][i])%mod; } cout\u003c\u003cans%mod\u003c\u003cendl; return 0; } 排列组合 把问题转化成将树分解成不大于 k 个连通块的方案数 将树分解成 i 个连通块，就要删掉 i-1 条边 总共有 $$\\ C_{n-1}^{i-1}$$ 种方案 对于每一种方案，染 i 中颜色 就有 $$\\ A_{k}^{i}$$ 种方案 所以一共有 $$ \\sum\\limits_{i=1} ^ {min(n,k)} {\\ C_{n-1}^{i-1}\\ A_{k}^{i}} $$ 然后模拟 逆元法 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; ll n,k; const ll mod = 1e9+7; ll inv[305]; ll fac[305]; inline ll C(ll m,ll n){ return fac[n]*inv[m]%mod*inv[n-m]%mod; } inline ll A(ll m,ll n){ return fac[n]*inv[n-m]%mod; } int main(){ cin\u003e\u003en\u003e\u003ek; for(ll i=0;i\u003c=n;i++){ fac[i]=1; } for(ll i=2;i\u003c=n;i++){ fac[i]=(fac[i-1]*i)%mod; } //for(int i=1;i\u003c=9;i++) cout\u003c\u003cfac[i]\u003c\u003cendl; inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){ inv[i]=(mod-mod/i)*inv[mod%i]%mod; } for(ll i=2;i\u003c=n;i++){ inv[i]=(inv[i]*inv[i-1])%mod; } ll ans=0; for(ll i=1;i\u003c=min(n,k);i++){ ans=(ans+C(i-1,n-1)*A(i,k)%mod)%mod; } cout\u003c\u003cans%mod; return 0; } 快速幂法 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; ll n,k; const ll mod = 1e9+7; ll fac[305]; ll qpow(ll x,ll n) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } inline ll cal(ll i){ return fac[n-1]*fac[k]%mod*qpow(fac[i-1],mod-2)%mod*qpow(fac[n-i],mod-2)%mod*qpow(fac[k-i],mod-2)%mod; } int main(){ cin\u003e\u003en\u003e\u003ek; for(ll i=0;i\u003c=n;i++){ //fac[0]=1!!! fac[i]=1; } for(ll i=2;i\u003c=n;i++){ fac[i]=(fac[i-1]*i)%mod; } ll ans=0; for(ll i=1;i\u003c=min(k,n);i++){ ans=(ans+cal(i))%mod; } cout\u003c\u003cans%mod; return 0; } ","date":"2020-04-06","objectID":"/nc13611/:0:0","tags":["cpp","number_theory","dp"],"title":"NC13611","uri":"/nc13611/"},{"categories":["abc"],"content":"abc161","date":"2020-04-05","objectID":"/abc161/","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"A - ABC Swap ","date":"2020-04-05","objectID":"/abc161/:0:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给三个数a,b,c，交换ab的值，交换ac的值，输出 ","date":"2020-04-05","objectID":"/abc161/:1:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a,b,c; cin\u003e\u003ea\u003e\u003eb\u003e\u003ec; swap(a,b); swap(a,c); cout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003c\" \"\u003c\u003cc\u003c\u003cendl; return 0; } B - Popular Vote ","date":"2020-04-05","objectID":"/abc161/:2:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 有n件商品，每种商品有一价格，给一数m 求能否从中选出m件商品使得它们的价格都不小于商品总价格（n件）/(4*m) ","date":"2020-04-05","objectID":"/abc161/:3:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 对价格求和，求出界限，对商品价格排序，检查前m件商品价格是否都满足这个限 制 ac代码 #include\u003ciostream\u003e #include\u003cbits/stdc++.h\u003e using namespace std; //using ll = long long; int n,m; int a[1005]; bool cmp(int a,int b){ return a\u003eb; } int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003em; for(int i=0;i\u003cn;i++)cin\u003e\u003ea[i]; int sum=0; for(int i=0;i\u003cn;i++) sum+=a[i]; int b=ceil((double)sum/(4*m)); //cout\u003c\u003csum; //cout\u003c\u003cb; bool ok=true; sort(a,a+n,cmp); //int ans=0; for(int i=0;i\u003cm;i++){ //ans+=a[i]; if(a[i]\u003cb){ ok=false; break; } } puts(ok? \"Yes\":\"No\"); return 0; } C - Replacing Integer ","date":"2020-04-05","objectID":"/abc161/:4:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给俩数n,k 一直做如右操作，将n替换成|n-k| 求这个过程中n能达到的最小值 ","date":"2020-04-05","objectID":"/abc161/:5:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 找规律，不断地去迎合所有的情况，就会莫名其妙ac 或者用数学方法做 ac代码 #include\u003ciostream\u003e using namespace std; using ll = long long; ll n,k; int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003ek; if(n==k){ cout\u003c\u003c0\u003c\u003cendl; } else{ if(n\u003ck) n=k+(k-n); cout\u003c\u003cmin((k-n%k)%k,n-k)\u003c\u003cendl; } return 0; } D - Lunlun Number ","date":"2020-04-05","objectID":"/abc161/:6:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 定义“lunlun数”：对于一个数，相邻两个位数的数字差不大于1 给一数n，求第n个“lunlun数” ","date":"2020-04-05","objectID":"/abc161/:7:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 预处理最大的情况 dfs，dp都行 数字，字符串都行 此处用bfs做 对于一个数，在它的末尾增加新的数字，9和0有两种情况，其他有三种情况 先处理一位数，再处理两位数。。。 用bfs经典方法队列实现 用maxn进行循环退出判断 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; vector\u003cstring\u003e vt; int num=0; queue\u003cstring\u003e q; bool cmp(string s1,string s2){ if(s1.length()==s2.length()){ return s1\u003cs2; } else return s1.length()\u003cs2.length(); } int main(){ q.push(\"1\"); q.push(\"2\"); q.push(\"3\"); q.push(\"4\"); q.push(\"5\"); q.push(\"6\"); q.push(\"7\"); q.push(\"8\"); q.push(\"9\"); while(!q.empty() and num\u003c100005){ string s=q.front(); q.pop(); vt.push_back(s); num++; int len=s.length(); char ch=s[len-1]; if(ch=='9'){ q.push(s+'8'); q.push(s+'9'); } else if(ch=='0'){ q.push(s+'0'); q.push(s+'1'); } else{ char ch1= ch-1,ch2=ch,ch3=ch+1; string s1=s,s2=s,s3=s; s1.insert(s1.end(),ch1); s2.insert(s2.end(),ch2); s3.insert(s3.end(),ch3); q.push(s1); q.push(s2); q.push(s3); } } sort(vt.begin(),vt.end(),cmp); int n;cin\u003e\u003en; n--; cout\u003c\u003cvt[n]\u003c\u003cendl; return 0; } cmp可以用lambda表达式写 E - Yutori ","date":"2020-04-05","objectID":"/abc161/:8:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给两个数k,c和一串由ox组成的字符串，表示每一天 从中选k天上班 限制条件：x不能上班，上完一天班后要连续休息c天 求所有可能的上班方案中，哪一天是必须上班的 ","date":"2020-04-05","objectID":"/abc161/:9:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 枚举必超时 其实只要贪心地从第一个开始选k个，从最后开始贪心地往前选k个 查看是否有交集就可 小证明 如果交集为空集，则不存在，因为这两种情况是所有情况的子集 如果存在（数量不大于k，下证），则对于所有中间取的情况一定会和左右两种情 况重叠，左右取产生的交集是最苛刻的满足条件 有几个细节 1.可以特判n==2 2.当从最左边开始选可以选到k+1个，则不存在必须上班的那一天 小证明 如果有k+1天，则随便从中选一天不上班，其余的天数都上班 对于所有的情况，它们的交集为空集，与右边的交集为空集（空集与任何集合 的交集都为空集） 3.同理右边也不能选到k+1个 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n,k,c; char s[200005]; set\u003cint\u003e st; set\u003cint\u003e st2; set\u003cint\u003e st3; int main(){ //freopen(\"in.txt\",\"r\",stdin); scanf(\"%d%d%d%s\",\u0026n,\u0026k,\u0026c,s); int cnt=0; for(int i=0;i\u003cn;i++){ if(s[i]=='o') { st.insert(i+1); cnt++; i+=c; } if(cnt\u003ek) return 0; //一定不存在必须工作的一天 } cnt=0; for(int i=n-1;i\u003e=0;i--){ if(s[i]=='o'){ st2.insert(i+1); cnt++; i-=c; } if(cnt\u003ek) return 0; //一定不存在必须工作的一天 } set_intersection(st.begin(),st.end(),st2.begin(),st2.end(),ostream_iterator\u003cint\u003e(cout,\"\\n\")); return 0; } F - Division or Substraction ","date":"2020-04-05","objectID":"/abc161/:10:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题意 给俩数n,k（2\u003c=k\u003c=n） 不断进行如下操作 如果k能整除n，则n/=k 否则n-=k 当n\u003ck时停机 问满足最后n==1的k的个数 ","date":"2020-04-05","objectID":"/abc161/:11:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["abc"],"content":"题解 设置一个计数器，遍历所有的k进行判断 这样会T，所以进行优化 首先只需遍历到√n（下证） 对于每个k 分两种情况 如果n%k==1，则满足条件 且(n-1)/k也满足条件 如果n%k==0则不断进行n/=k 最后判断是否n%k==1 这种情况下只有k满足条件，计数器计数 注意k*k=n-1只能计一个数 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main(){ //freopen(\"in.txt\",\"r\",stdin); ll n; cin\u003e\u003en; if(n==2) { cout\u003c\u003c1\u003c\u003cendl;return 0; } ll ans=2; //n和n-1 for(ll i=2;i*i\u003c=n;i++){ if(n%i==1){ if(i*i==n-1) ans++; else ans+=2; } else if (n%i==0){ ll t=n; while(t%i==0) t/=i; if(t%i==1) ans++; } } cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-04-05","objectID":"/abc161/:12:0","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"/abc161/"},{"categories":["codeforces"],"content":"Codeforces Round #631 (Div. 2) A~D","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. Dreamoon and Ranking Collection ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:0:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给n个数和数字k，你可以对数列进行扩充k个数，使得扩充后的数列出现1~m的 数字至少一次，求m的最大值 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:1:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 用计数器对原始数列计数，如果不连续，则k递减，直到k耗光，最后还要判断 原始数列能否再连续下去，直到断开 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n,x; int a[105]; int t; set\u003cint\u003e s; int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ //reset s.clear(); cin\u003e\u003en\u003e\u003ex; for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; //sort(a,a+n); for(int i=0;i\u003cn;i++){ s.insert(a[i]); } int cnt=1;set\u003cint\u003e::iterator it; for(it =s.begin();it!=s.end();){ if((*it)!=cnt){ x--;cnt++; } else { it++; cnt++; } if(x==0) break; } if(it==s.end() and x!=0){ cnt+=x; } while(*it==cnt){ it++;cnt++; } cout\u003c\u003ccnt-1\u003c\u003cendl; } return 0; } B. Dreamoon Likes Permutations ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:2:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 定义“排列”为一个长度为n的数列，数列中1~n的数字必须且只能出现一次 给一数列，对数列进行切割，将数列分成两部分，使得两部分都是“排列” 求分割方案数 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:3:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 用两个集合存左右两部分 如果两个集合的最大值都等于数量，则这种分割可以得到排列 遍历数组，同时对俩集合进行增删操作 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t; int n; int a[200005]; set\u003cint\u003e s1; set\u003cint\u003e s2; vector\u003cint\u003e ans; int num[200005]; int main(){ ios::sync_with_stdio(0);cin.tie(0); // freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ //TODO reset s1.clear(); s2.clear(); ans.clear(); memset(num,0,sizeof(num)); cin\u003e\u003en; for(int i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; } //preprocess s1.insert(a[0]); for(int i=1;i\u003cn;i++){ s2.insert(a[i]); num[a[i]]++; } for(int i=1;i\u003cn;i++){ if(s1.size()==i and s2.size()==n-i and *(--s1.end())==i and *(--s2.end())==n-i){ ans.push_back(i); } s1.insert(a[i]); if(num[a[i]]==1){ s2.erase(a[i]); } num[a[i]]--; } if(ans.size()!=0) { cout\u003c\u003cans.size()\u003c\u003cendl; for(auto i:ans){ cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cn-i\u003c\u003cendl; } } else cout\u003c\u003c0\u003c\u003cendl; } return 0; } C. Dreamoon Likes Coloring ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:4:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数列，每次可以对其中连续的li个元素进行染色，每次染的颜色都不相同，问 所有染色结束后，能否使所有数字都染色，且每种颜色都存在 ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:5:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 首先特判 如果区间的长度和小于数列长度，则不存在 如果对于第i个长度，区间的起始位置小于i，则不存在 贪心法 让第一个区间从第一个数开始，第二个区间从第二个数开始。。。 这样就能保证至少有一个数染这种颜色 但这样会出现一个问题 当所有区间都用完之后，右边的数可能不会染色 这时候就要将某些区间右移（不能在放在第i个） 判断条件就是，对于这个区间，是否存在右边为空的情况（即n-sum\u003ei） 其中sum为剩余部分长度和 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n,m; ll l[100005]; ll sum=0; ll ans[100005]; int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003em; bool ok=true; for(int i=0;i\u003cm;i++) { cin\u003e\u003el[i]; //l[i]; sum+=l[i]; if(n-l[i]+1\u003c=i){ ok=false; } } if(!ok or sum\u003cn) { cout\u003c\u003c-1\u003c\u003cendl; return 0; } else{ for(int i=0;i\u003cm;i++){ if(n-sum\u003ei){ ans[i]=n-sum; } else ans[i]=i; sum-=l[i]; } for(int i=0;i\u003cm;i++) cout\u003c\u003cans[i]+1\u003c\u003c\" \"; cout\u003c\u003cendl;return 0; } } D. Dreamoon Likes Sequences ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:6:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给俩数d,m 求满足下列条件的数列的个数%m 1\u003c= a1 \u003c a2 \u003c… \u003c an \u003c=d a1 XOR a2 \u003e a1 a1 XOR a2 XOR a3 \u003e a1 XOR a2 a1 XOR a2 XOR a3 XOR a4 \u003e a1 XOR a2 XOR a3 ……. ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:7:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 二进制构造 + 动态规划 对于一个数a，构造一个数b，使得b\u003ea ，且 b XOR a \u003e a a的二进制首位为0（可以添加0，没影响） b的二进制首位为1 那么b XOR a 的首位一定为1，满足条件 b的首位为1，其他位随便填 所以dp[i]表示长度为i的个数 那么dp[i] = (2^i) * dp[i-1] + dp[i-1] （加上之前的个数） 但这样一直做可能会超过d 所以要判断条件2^i\u003c=d 剩余的部分不再有2^i种 而是d-2^i+1种 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll d,m,t; ll dp[30]; ll init=2; int main(){ // freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003ed\u003e\u003em; if(d==1){ cout\u003c\u003c1%m\u003c\u003cendl; } else{ dp[0]=init; int i; for( i=1;(1\u003c\u003ci)\u003c=d;i++){ dp[i]=(1\u003c\u003ci)*dp[i-1]%m+dp[i-1]%m; } i--; dp[i]=(d-(1\u003c\u003ci)+1)*dp[i-1]%m+dp[i-1]%m; cout\u003c\u003c(dp[i]-1+m)%m\u003c\u003cendl; //加m防止溢出 } } return 0; } ","date":"2020-04-05","objectID":"/codeforces-round-631-div.-2-a~d/:8:0","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"/codeforces-round-631-div.-2-a~d/"},{"categories":["note","courses"],"content":"浮点数加减法","date":"2020-04-03","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/","tags":["cs"],"title":"浮点数加减法","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/"},{"categories":["note","courses"],"content":"#0 0操作数检查 如果有一个数为0，则可以直接得出结果 #1 用补码表示阶码，尾数 阶码的符号位为两位 尾数的个位为符号位 #2 对阶 小阶向大阶对齐（看原码），被对阶的数尾数右移阶差个 #3 尾数加 将两个尾数相加得到新的尾数 #4 溢出处理 太复杂，不作考虑 #4 规格化处理 先检查是否规格化，如果尾数符号位与最高位相同则非规格化 尾数左移直到规格化为止，阶码减少左移的位数（不含符号位） #5 舍入处理 最低有效位为0舍去，为1则尾数+1 #6 还原 将补码还原成原码 E.G. 1.设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y] x= 2^(-011) * (0.100101) y = 2^(-010) * (-0.011110) 解： 第一步，补码表示 x :11 101 , 0.100101 y : 11 110 , 1.100010 第二步 对阶，x阶小，y阶大，x向y对阶，阶差为1，所以x尾数右移一个 x阶码变成与y相同，阶码为 11 110 尾数0.010010(1) 第三步 尾数加 0. 0 1 0 0 1 0 (1)\r1. 1 0 0 0 1 0\r-------------------------\r1. 1 1 0 1 0 0 (1) 结果为 1.110110(1) 符号位与最高位都是1，非规格化 第四步 规格化 尾数左移两位变成 1.010010 阶码减2（符号位不变），变成 11 100 第五步 舍入处理 没得舍入 第六步 还原 x+y = 2^(-4) * (-0.101110) 对于[x-y] 根据[x-y]补码 = [x]补码 + [-y]补码 在第三步尾数加时 0. 0 1 0 0 1 0 (1)\r0. 0 1 1 1 1 0\r-------------------------\r0. 1 1 0 0 0 0 (1) 结果为 0.110000(1) 最高有效位和符号位不同，是规格化 最低有效位为1 尾数+1变成 0.110001 还原 x-y = 2^(-2) * (0.110001) ========================================================= 设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y] x=2^(-101) × （-0.010110） y=2^(-100) × （0.010110） 解： 第一步 补码表示 x : 11 011 , 1.101010 y : 11 100 , 0.010110 第二步 对阶，x阶小，y阶大 x阶码变成y，阶差1，x尾数右移1位 x : 11100 , 1.110101(0) 第三步 尾数加 1. 1 1 0 1 0 1 (0)\r0. 0 1 0 1 1 0\r-------------------------\r0. 0 0 1 0 1 1 (0) 结果为 0.001011(0) 符号位与最高有效位相同，非规格化 第四步 规格化 尾数左移两位，阶码减2 尾数 0.101100 阶码 11 010 第五步 舍入处理 无需舍入 第六步 还原 x+y = 2^(-6) * (0.101100) 同理x-y的尾数加为 1. 1 1 0 1 0 1 (0)\r1. 1 0 1 0 1 0\r-------------------------\r1. 0 1 1 1 1 1 (0) 结果为 1.011111(0) 符号位和最高有效位不同，为规格化 最低有效位为0，全舍弃 还原 x-y = 2^(-4) * (-0.100001) （有缺漏，待改正） ","date":"2020-04-03","objectID":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/:0:0","tags":["cs"],"title":"浮点数加减法","uri":"/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/"},{"categories":["codeforces"],"content":"Codeforces Round #630 (Div. 2) A~E","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"A. Exercising Walk ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:0:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一坐标范围，初始位置，和左右上下移动的步数，问是否会出界 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:1:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 加各种条件判断即可 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t; int a,b,c,d,x,y,x1,y1,x2,y2; bool ok; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ ok=true; cin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed\u003e\u003ex\u003e\u003ey\u003e\u003ex1\u003e\u003ey1\u003e\u003ex2\u003e\u003ey2; if( (a-b\u003e=0 and x-x1\u003ca-b) or (b-a\u003e0 and x2-x\u003cb-a) or (c-d\u003e0 and y-y1\u003cc-d) or (d-c\u003e0 and y2-y\u003cd-c) or (a==b and a!=0 and x1==x and x2==x) or (c==d and c!=0 and y1==y and y2==y) ) ok = false; if(ok) puts(\"yes\"); else puts(\"no\"); } return 0; } B. Composite Coloring ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:2:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给n个合数上色，要求相同颜色的数字必须不互质，求最小着色数和着色方案 （题目保证着色数不大于11，且值不大于1000） ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:3:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 两个合数不互质，即最小质因子相同 对每个数求最小质因子 相同则染同一种颜色（贪心） ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t,n; int a[1005]; int c[1005]; int p[]={1,2,3,5,7,11,13,17,19,23,29,31}; set\u003cint\u003e st; bool vi[1005]; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003en; //reset memset(c,0,sizeof(c)); st.clear(); memset(vi,0,sizeof(vi)); for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; for(int i=0;i\u003cn;i++){ for(int j=1;j\u003c=12;j++){ if(a[i]%p[j]==0){ c[i]=j; st.insert(j); break; } } } int num=st.size(); int index=0; int cnt; for(int i=0;i\u003cn;i++){ if(!vi[i]){ cnt=c[i]; vi[i]=true; index++; c[i]=index; for(int j=i+1;j\u003cn;j++){ if(!vi[j] and c[j]==cnt){ c[j]=index; vi[j]=true; } } } } cout\u003c\u003cnum\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003cc[i]\u003c\u003c\" \"; cout\u003c\u003cendl; } return 0; } C. K-Complete Word ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:4:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一字符串和k，要求改其中一些字符，使字符串是回文串且周期为k，求最小改 动数 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:5:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 把字符串分成k个部分，每个部分都是回文串 字符串中的一些字符是相互捆绑的（即要相同），与其他字符相互独立 对于相互捆绑的字符，查询出现次数最多的字符，然后都替换成它 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t,n,k; string s; int kp; int z[27]; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003ek; cin\u003e\u003es; //reset //memset(z,0,sizeof(z)); kp=0; for(int i=0;i\u003c=k-i-1;i++){ memset(z,0,sizeof(z)); for(int j=i;j\u003cn;j+=k){ z[s[j]-'a']++; } if(i\u003ck-i-1) { for(int j=k-i-1;j\u003cn;j+=k){ z[s[j]-'a']++; } } kp+=*max_element(z,z+27); //cout\u003c\u003c*max_element(z,z+27)\u003c\u003cendl; } cout\u003c\u003cn-kp\u003c\u003cendl; } } D. Walk on Matrix ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:6:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一矩阵，从矩阵的左上角走到右下角，只能往右和往下走 走到一个元素上，则自身的值变为当前自身的值\u0026元素上的值 存在一种走法使得最后得到的值最大 给一dp算法和k，求满足经dp算法算出的值和最大值差k的矩阵 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:7:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 构造矩阵 让最大值为k 经dp算法输出的值为0 根据(m+k)\u0026k=k , (m+k)\u0026m=m , m\u0026k=0 其中m的二进制位1000… 进行构造（不唯一） ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int m=(1\u003c\u003c17); int k; int main(){ cin\u003e\u003ek; cout\u003c\u003c2\u003c\u003c\" \"\u003c\u003c3\u003c\u003cendl; cout\u003c\u003cm+k\u003c\u003c\" \"\u003c\u003cm\u003c\u003c\" \"\u003c\u003c0\u003c\u003cendl\u003c\u003ck\u003c\u003c\" \"\u003c\u003cm+k\u003c\u003c\" \"\u003c\u003ck\u003c\u003cendl; return 0; } E. Height All the Same ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:8:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题意 给一n*m的网格，和L，R 在网格上进行初始化放方块，要求每一格的方块数在L到R之间 有两种操作 1.在两（边相邻）相邻网格上各增加一块 2.在一个网格上增加两块 求能够使所有网格高度相等的初始化方案数 ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:9:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["codeforces"],"content":"题解 dif=R-L+1 当网格数量为奇数时，随便放，有dif^(n*m)种 当网格数量为偶数时，如果dif为偶数，则有一半情况不满足（每个满足的都对应 一个不满足的），有dif^(n*m)/2 当dif为奇数时，则中间会多出一个没有对应的方案，有(dif^(n*m)+1)/2 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; const ll mod = 998244353; ll qpow(ll x,ll n) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } int main(){ //freopen(\"input.txt\",\"r\",stdin); ll n,m,l,r; cin\u003e\u003en\u003e\u003em\u003e\u003el\u003e\u003er; ll ans; ll dif=r-l+1; if((n*m)\u00261) ans=qpow(dif,n*m)%mod; else if(dif%2==0) { ans=qpow(dif,n*m)%mod*qpow(2,mod-2)%mod; } else{ ans=(qpow(dif,n*m)+1)%mod*qpow(2,mod-2)%mod; } cout\u003c\u003cans\u003c\u003cendl; } ","date":"2020-04-01","objectID":"/codeforces-round-630-div.-2-a~e/:10:0","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"/codeforces-round-630-div.-2-a~e/"},{"categories":["abc"],"content":"abc160","date":"2020-03-29","objectID":"/abc160/","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"A - Coffee ","date":"2020-03-29","objectID":"/abc160/:0:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 判断一个长度为6的字符串，第3位和第4位是否相等，第5位和第6位是否相等 ","date":"2020-03-29","objectID":"/abc160/:1:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 模拟 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ string s; cin\u003e\u003es; if(s[2]==s[3] and s[4]==s[5]) cout\u003c\u003c\"Yes\"; else cout\u003c\u003c\"No\"; return 0; } B - Golden Coins ","date":"2020-03-29","objectID":"/abc160/:2:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 高桥有许多钱，可以兑换成各种硬币，每获得一枚500円的硬币，就能获得1000 点快乐值，每获得一枚5円的硬币，就能获得5点快乐值，问最多能获得多少快乐 值 ","date":"2020-03-29","objectID":"/abc160/:3:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 贪心地兑换成500円的硬币，然后再兑换成5円的 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll x; ll ans=0; int main(){ cin\u003e\u003ex; ans+=x/500; ans*=1000; x%=500; ans+=(x/5)*5; cout\u003c\u003cans\u003c\u003cendl; return 0; } C - Traveling Salesman around Lake ","date":"2020-03-29","objectID":"/abc160/:4:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 在一个圆上有n个点，给定每个点的位置，问沿圆周访问所有点的最短长度 ","date":"2020-03-29","objectID":"/abc160/:5:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 访问所有点的路径就是圆周长减去一段隔阂 求隔阂的最大值，依次遍历即可 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n,k; int dist[200005]; int c; int ans=-1; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003ek\u003e\u003en; c=k; for(int i=1;i\u003c=n;i++) cin\u003e\u003edist[i]; sort(dist+1,dist+n+1); for(int i=1;i\u003c=n-1;i++){ ans=max(ans,dist[i+1]-dist[i]); } ans=max(ans,c-dist[n]+dist[1]); //n是double不能当作index cout\u003c\u003cc-ans\u003c\u003cendl; return 0; } D - Line++ ","date":"2020-03-29","objectID":"/abc160/:6:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 有n个点，依次连线，再把其中两个未连线的点连线 求最短路径长度等于k的路径条数（对于所有的k=1,2,3..） ","date":"2020-03-29","objectID":"/abc160/:7:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 看似是图论题，其实只需要考虑两种情况 枚举所有点对的最短距离 1.直接按顺序走 2.走过特殊的连线 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n,x,y; map\u003cint,int\u003e mp; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003ex\u003e\u003ey; for(int i=1;i\u003c=n;i++) for(int j=i+1;j\u003c=n;j++) mp[min(j-i,abs(i-x)+abs(j-y)+1)]++; for(int i=1;i\u003cn;i++) cout\u003c\u003cmp[i]\u003c\u003cendl; return 0; } E - Red and Green Apples ","date":"2020-03-29","objectID":"/abc160/:8:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 DIO有a个红苹果（X）红面包（√）和b片绿面包，c片白面包 每片面包都有时停时间，聪明的DIO可以将白面包涂成红色或者绿色 现在DIO要吃x片红面包和y片绿面包（！DIO居然记得吃几片面包） DIO的最终目的就是无限时停，问DIO最多能时停几秒 ","date":"2020-03-29","objectID":"/abc160/:9:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 贪心地选取时停时间最多的面包 但是有限制条件就是x和y（白色是不受限制的） 所以从红色中选前x个，绿色中选前y个，与白色混合排序 最后选前x+y个 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll x,y,aa,bb,cc; vector\u003cll\u003e a,b,c; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003ex\u003e\u003ey\u003e\u003eaa\u003e\u003ebb\u003e\u003ecc; ll temp; for(ll i=0;i\u003caa;i++) { cin\u003e\u003etemp; a.push_back(temp); } for(ll i=0;i\u003cbb;i++) { cin\u003e\u003etemp; b.push_back(temp); } sort(a.rbegin(),a.rend()); sort(b.rbegin(),b.rend()); for(ll i=0;i\u003cx;i++) c.push_back(a[i]); for(ll i=0;i\u003cy;i++) c.push_back(b[i]); for(ll i=0;i\u003ccc;i++) { cin\u003e\u003etemp; c.push_back(temp); } sort(c.rbegin(),c.rend()); ll sum=0; for(ll i=0;i\u003cx+y;i++) sum+=c[i]; cout\u003c\u003csum\u003c\u003cendl; return 0; } F - Distributing Integers ","date":"2020-03-29","objectID":"/abc160/:10:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题意 给一棵树，对于树上的一个顶点，赋值为1，然后对于已赋值顶点的相邻顶点依次 赋值2,3,4..，求有多少种赋值方案，对于所有的顶点 ","date":"2020-03-29","objectID":"/abc160/:11:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["abc"],"content":"题解 又是不会做的一题 树的拓扑序计数 + 换根 （感谢出题人和这道题让我认识了“树的拓扑序计数”，然后第二次遇见了“换根”） 对于某个顶点，方案数就是以这个点为根的“树的拓扑序的个数” 树的拓扑序的个数为 $$ {\\frac{n!}{\\prod\\limits_{} ^ {} {num}}} $$ num为每个节点的子节点数（含自己） 小证明： 如果没有限制，则排列组合有n!种 由于子节点要排在父节点的的后面 以根节点为例，它要排在第一个 由于排序是随机的，所以排在第一个的概率为1/num 同理所有的节点作为父节点时都与子节点等概率排序，所以每个都是1/num 全部就是product(num) n!可以直接求 现在要求product(num) 为避免超时，可以用类似于记忆化搜索的思想 先选取一个点为根（以1为例）求每个节点的子节点个数 直接dfs 然后求product(num[1]) 最后换根求不同节点的product(num) 直接dfs 此处换根product(num[i])=product(num[par])*(n-child[i])/child[i] ac代码 //#include\"bits/stdc++.h\" #include\u003ciostream\u003e #include\u003cvector\u003e using namespace std; typedef long long ll; // using pAr = product_as_root; const ll mod = 1e9+7; ll n; ll sn[200005]; ll pAr[200005]; vector\u003cll\u003e G[200005]; ll qpow(ll x,ll n,ll mod) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } void dfs_sn(ll u,ll v){ for(auto i:G[u]){ if(i!=v){ dfs_sn(i,u); sn[u]+=sn[i]; } } sn[u]++; } void dfs_cr(ll u,ll v){ for(auto i:G[u]){ if(i!=v){ pAr[i]=pAr[u]*qpow(sn[i],mod-2,mod)%mod*(n-sn[i])%mod; dfs_cr(i,u); } } } int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en; ll t1,t2; for(ll i=0;i\u003cn-1;i++) { cin\u003e\u003et1\u003e\u003et2; G[t1].push_back(t2); G[t2].push_back(t1); } dfs_sn(1,0); //init pAr[1]=1; for(ll i=1;i\u003c=n;i++) pAr[1]=pAr[1]*sn[i]%mod; dfs_cr(1,0); //factorial ll fac=1; for(ll i=2;i\u003c=n;i++) fac=fac*i%mod; for(ll i=1;i\u003c=n;i++){ cout\u003c\u003cfac*qpow(pAr[i],mod-2,mod)%mod\u003c\u003cendl; } //for(int i=1;i\u003c=8;i++) cout\u003c\u003cpAr[i]\u003c\u003c\" \"; return 0; } have a good day ^_^ ","date":"2020-03-29","objectID":"/abc160/:12:0","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"/abc160/"},{"categories":["anime"],"content":"星际牛仔","date":"2020-03-29","objectID":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/","tags":[],"title":"星际牛仔","uri":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/"},{"categories":["anime"],"content":"《星际牛仔》（カウボーイビバップ；Cowboy Bebop），是日本SUNRISE动画 公司制作的原创电视动画，于1998年10月23日-1999年4月23日在东京电视台和 WOWOW播出，同年夺得第三回神户动画奖的年度最佳电视动画奖，并于2000年 获得日本科幻大会星云奖。 –百度百科 故事背景设定在2071 年。随着超光速航行技术的实现，人类得以在太阳系范围 内方便的自由移动，但是由于设计上的失误，这一技术引发了月球的爆炸，无数 月球碎片被吸引向地球，造成了空前绝后的大灾难。存活下来的人类逃离地球， 并开始在太阳系各地建立家园。 由于这次灾难，国家、政府等权力机构都极为不稳定，治安问题也成为了大难 题。 为了在人力资源不足的情况下抓捕罪犯，有些组织开始允许个人抓捕通缉的罪犯 并换取奖金，“赏金猎人”这个职业也就由此诞生了。–百度百科 ","date":"2020-03-29","objectID":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/:0:0","tags":[],"title":"星际牛仔","uri":"/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/"},{"categories":["codeforces"],"content":"Codeforces Round #629 (Div. 3)","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"A. Divisibility Problem ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:0:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 求一个数加上多少能被另一个数整除 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:1:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果b|(a+k) 则k=b-a%b注意k=0特判 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t,a,b; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003ea\u003e\u003eb; cout\u003c\u003c(b-(a%b)==b?0:b-(a%b))\u003c\u003cendl; } return 0; } B. K-th Beautiful String ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:2:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 一个长度为n的字符串，由n-2个a组成和2个b组成 求所有按字典序排列组合的第k个 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:3:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 只要定位b的位置就行 b的位置是有规律的，模拟这个规律 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; long long t,n,k; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003ek; long long fi=ceil((sqrt(1+8*k)-1)/2); long long se=fi*(fi-1)/2; se=k-se; se=n-se; fi=n-1-fi; for(long long i=0;i\u003cn;i++) if(i==fi or i==se) cout\u003c\u003c'b'; else cout\u003c\u003c'a'; cout\u003c\u003cendl; } } 没开long long WA掉一发 C. Ternary XOR ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:4:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 定义一种异或运算 ai XOR bi = (ai+bi)%3 给一数c，求a,b使得(a XOR b)=c，使得max(a,b)尽可能小 c由0,1，2组成，且首位为2 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:5:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 从左到右遍历 以是否出现过1作为判断条件 第一次出现1时，一边为0，一边为1 之后把大的数填到之前填0的那一边 就能保证max最小 如果没有出现1则2分成1和1 出现后2分成0和2 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int t; int n; short up[50005]; short down[50005]; bool one; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ one = false; cin\u003e\u003en; char temp1; int temp2; for(int i=0;i\u003cn;i++){ cin\u003e\u003etemp1; temp2=temp1-'0'; if(one){ if(temp2==1){ up[i]=1;down[i]=0; } if(temp2==2){ up[i]=2;down[i]=0; } if(temp2==0){ up[i]=0;down[i]=0; } } else{ if(temp2==1) { one=true;up[i]=0;down[i]=1; } if(temp2==2){ up[i]=1;down[i]=1; } if(temp2==0) { up[i]=0;down[i]=0; } } } for(int i=0;i\u003cn;i++) cout\u003c\u003cup[i]; cout\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003cdown[i]; cout\u003c\u003cendl; } return 0; } D. Carousel ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:6:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 旋转木马的马上有很多图案，给它们涂色，要求相邻不同图案要涂不同的颜色 问最少需要几种颜色，并求涂色方案（注意旋转木马是个环） ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:7:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果所有的图案都相同，只需要一种 如果图案不同则有可能需要2种或3种，但不超过3种 如果必须3种，则涂色可以为1,2,3,1,2,3…（注意最后一个不能与第一个相同）（不一定） 现在验证是否只需要2种 因为不同的图案必须涂不同的颜色 所以以不同的图案为点，用边连起来 判定是否为二分图就行（同种图案涂色不受限，所以不需要考虑同种图案） 还可以通过木马的奇偶性分类讨论 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int q; int n; int a[200005]; int color[200005]; vector\u003cint\u003e G[200005]; bool dfs(int v,int c) { color[v]=c; for(int i=0;i\u003cG[v].size();i++) { if(color[G[v][i]]==c) return false; if(color[G[v][i]]==0 \u0026\u0026 !dfs(G[v][i],3-c)) return false; } return true; } bool bipartite_graph() { for(int i=1;i\u003c=n;i++) { if(color[i]==0) if(!dfs(i,1)) return false; } return true; } int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003eq; while(q--){ //reset TODO memset(color,0,sizeof(color)); for(int i=0;i\u003c=n;i++) G[i].clear(); cin\u003e\u003en; for(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i]; //特判 bool flag=true; for(int i=1;i\u003cn;i++) if(a[i]!=a[i+1]) flag=false; if(a[n]!=a[1]) flag=false; if(flag) { cout\u003c\u003c1\u003c\u003cendl; for(int i=0;i\u003cn;i++) cout\u003c\u003c1\u003c\u003c\" \"; cout\u003c\u003cendl; } else{ //preprocess for(int i=1;i\u003cn;i++){ if(a[i]!=a[i+1]) { G[i].push_back(i+1);G[i+1].push_back(i); } } if(a[n]!=a[1]) { G[n].push_back(1);G[1].push_back(n); } if(bipartite_graph()){ cout\u003c\u003c2\u003c\u003cendl; for(int i=1;i\u003c=n;i++) cout\u003c\u003ccolor[i]\u003c\u003c\" \"; cout\u003c\u003cendl; } else{ cout\u003c\u003c3\u003c\u003cendl; if((n-1)%3==0) { for(int i=1;i\u003cn;i++) cout\u003c\u003c(i%3==0? 3 : i%3 )\u003c\u003c\" \"; cout\u003c\u003c2\u003c\u003cendl; } else{ for(int i=1;i\u003c=n;i++) cout\u003c\u003c(i%3==0? 3 : i%3 )\u003c\u003c\" \"; cout\u003c\u003cendl; } } } } return 0; } E. Tree Queries ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:8:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 给一棵树和几个树上的顶点 问是否存在从根出发的一条简单路径 使得所有的点都在这条路径上或离路径的距离为1 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:9:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 如果存在，这条路径一定是从根到深度最大的顶点 接下来依次判断这些点是否满足这些条件 对于某个点 求这个点和最深的点的LCA 判断这个点是否是LCA或LCA的子节点 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int V; int m; const int maxv=200005; const int max_logv=20; int data[maxv]; int n; vector\u003cint\u003e G[maxv]; int root=0; int parent[max_logv][maxv]; int depth[maxv]; void dfs(int v,int p,int d){ parent[0][v]=p; depth[v]=d; for(int i=0;i\u003cG[v].size();i++){ if(G[v][i]!=p) dfs(G[v][i],v,d+1); } } void init(int V){ dfs(root,-1,0); for(int k=0;k+1\u003cmax_logv;k++){ for(int v=0;v\u003cV;v++){ if(parent[k][v]\u003c0) parent[k+1][v]=-1; else parent[k+1][v]=parent[k][parent[k][v]]; } } } int lca(int u,int v){ if(depth[u]\u003edepth[v]) swap(u,v); for(int k=0;k\u003cmax_logv;k++){ if((depth[v]-depth[u])\u003e\u003ek\u00261) v=parent[k][v]; } if(u==v) return u; for(int k=max_logv-1;k\u003e=0;k--){ if(parent[k][u]!=parent[k][v]){ u=parent[k][u]; v=parent[k][v]; } } return parent[0][u]; } int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003eV\u003e\u003em; int temp1,temp2; for(int i=0;i\u003cV-1;i++){ cin\u003e\u003etemp1\u003e\u003etemp2; G[temp1-1].push_back(temp2-1); G[temp2-1].push_back(temp1-1); } init(V); while(m--){ cin\u003e\u003en; int maxdi; int maxd=-1e9; int temp; for(int i=0;i\u003cn;i++){ cin\u003e\u003etemp; data[i]=temp-1; if(depth[data[i]]\u003e=maxd) { maxd=depth[data[i]]; maxdi=data[i]; } } //cout\u003c\u003cmaxdi\u003c\u003cendl; bool flag=true; for(int i=0;i\u003cn;i++){ if(data[i]!=maxdi) { int foo=lca(maxdi,data[i]); if(!(data[i]==foo || foo==parent[0][data[i]])) { flag=false;break; } } } if(flag) cout\u003c\u003c\"YES\"\u003c\u003cendl; else cout\u003c\u003c\"NO\"\u003c\u003cendl; } //cout\u003c\u003clca(2,4)\u003c\u003cendl; //for(int i=1;i\u003c=4;i++) cout\u003c\u003cdepth[i]\u003c\u003cendl; return 0; } 因为max_logv开太小，WA了7次，一直停留在第80个测试点（我记得明明还往多了开的，难道是计算失误，还是记忆丧失） F. Make k Equal ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:10:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题意 给一数列 每次可进行这样的操作 1.把最小的数+1 2.把最大的数-1 求最少需要多少次操作使数列中有k个相等的数 ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:11:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["codeforces"],"content":"题解 一开始想的是，这个数应该是中位数，然后从它往两边扩散，把两边的数往里压 结果这应该不是最优解 太困了（X）太菜了（√），直接看了别人的题解恍然大悟 最后得到的这k个相同的数一定在数列中（由于两边往里压，中间的数可看成不变，最后的结果一定是压向不变的数） 首先排序 过一遍数列 每次针对一片相同数字域 求以此为目标需要进行的操作数 不断min更新 对于某块相同数字域 遍历过程中维护数字域左边的数量lnum 左边的和lsum 右边的数量rnum 右边的和rsum 这样是便于计算操作数，降低时间复杂度 考虑三种情况 左边压到中间 右边压到中间 两边压到中间 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n,k; ll a[200005]; map\u003cll,ll\u003e mp; ll lsum=0; ll rsum=0; ll lnum=0; ll rnum; ll re; ll ans=1e15; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003ek; for(ll i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; mp[a[i]]++; rsum+=a[i]; } //特判 for(auto i:mp) if(i.second\u003e=k) {cout\u003c\u003c0\u003c\u003cendl;return 0;} rnum=n; for(auto i:mp) { rnum-=i.second; rsum-=(i.first*i.second); re=k-i.second; if(lnum\u003e=re){ ans=min(ans,(i.first-1)*lnum-lsum+re); } if(rnum\u003e=re){ ans=min(ans,rsum-(i.first+1)*rnum+re); } if(re\u003e=2){ ans=min(ans,(i.first-1)*lnum-lsum+re+rsum-(i.first+1)*rnum); } lsum+=(i.first*i.second); lnum+=i.second; } cout\u003c\u003cans\u003c\u003cendl; return 0; } hava a good day ^_^ ","date":"2020-03-28","objectID":"/codeforces-round-629-div.-3/:12:0","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"/codeforces-round-629-div.-3/"},{"categories":["GAME"],"content":"杀手2","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["GAME"],"content":"杀手2由IO Interactive开发，2018年发行的潜行刺杀游戏，与羞辱不同的是这是第三人称 杀手2最大的特点是刺杀方法的丰富性 游玩过程中会发现特别多的可能性 里面有一个适合手残党的玩法，就是被敌人盯上时，可以一直藏着，只要等的下去，危险就会解除 剧情很丰富，延续了杀手1 但是剧情太短了 玩一会就完了（指不开辟新的刺杀方式） 地图是分区的，每一块地图也太小了 风景做的很好，但是与NPC的互动太少了 换装式的伪装也是一大特色 通过这种伪装可以派生很多的玩法 吐槽一下一种线下的狙击模式，非常的sb，简直就是4399小游戏搬过来的 ","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/:0:0","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["GAME"],"content":"剧情 游戏剧情衔接《杀手》的剧情，戴安娜为了得到神意秘会的代理人“永恒常量”手中有关47出身来历的一切信息，说服了ICA董事会接受了来自神意秘会的契约：消灭“影子客户”并瓦解他的民兵组织。 根据47曾经在科罗纳多获取的情报，ICA找到了关于民兵组织成员的线索：阿尔玛·雷纳德，肖恩·罗斯的前女友，当过生态恐怖分子并且是一名很有才华的外勤潜入者，目前与她的新搭档奥森·米尔斯躲 藏在新西兰霍克斯湾的一处海滨别墅。 47为搜寻情报而前往调查关于“影子客户”与民兵的线索。 –百度百科 ","date":"2020-03-28","objectID":"/%E6%9D%80%E6%89%8B2/:1:0","tags":[],"title":"杀手2","uri":"/%E6%9D%80%E6%89%8B2/"},{"categories":["android"],"content":"Android Fragment","date":"2020-03-24","objectID":"/android-fragment/","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"生命周期 在containerActivity的布局中放入一个fragment，然后点击按钮，切换成另一个fragment containerActivity的布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".fragment.containerActivity\"\u003e \u003cButton android:id=\"@+id/ctnbtn1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"change_fragment\" android:textSize=\"25sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.1\" /\u003e \u003cFrameLayout android:id=\"@+id/ctn1\" android:layout_width=\"match_parent\" app:layout_constraintTop_toBottomOf=\"@+id/ctnbtn1\" app:layout_constraintBottom_toBottomOf=\"parent\" android:layout_height=\"0dp\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e containerActivity.java package com.example.test.fragment; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import com.example.test.R; public class containerActivity extends AppCompatActivity { private Afragment afragment; private Bfragment bfragment; private Button ctnbtn1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_container); ctnbtn1 = findViewById(R.id.ctnbtn1); ctnbtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(bfragment==null) bfragment = new Bfragment(); getSupportFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).commitAllowingStateLoss(); } }); afragment = new Afragment(); getSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment).commitAllowingStateLoss(); } } Afragment.java package com.example.test.fragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import com.example.test.R; public class Afragment extends Fragment { private TextView fatv1; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_a,container,false); return view; } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); fatv1 = view.findViewById(R.id.fatv1); } } fragment_a.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/fatv1\" android:text=\"fragment_a\" android:textSize=\"25sp\" android:gravity=\"center\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintVertical_bias=\"0.4\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e Bfragment.java和fragment_b.xml与A类似 ","date":"2020-03-24","objectID":"/android-fragment/:1:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"传数据给fragment Afragment.java package com.example.test.fragment; import android.content.Context; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import com.example.test.R; public class Afragment extends Fragment { private TextView fatv1; public static Afragment newInstance(String title){ Afragment afragment = new Afragment(); Bundle bundle = new Bundle(); bundle.putString(\"tk\",title); afragment.setArguments(bundle); return afragment; } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_a,container,false); return view; } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); fatv1 = view.findViewById(R.id.fatv1); if(getArguments()!=null) { fatv1.setText(getArguments().getString(\"tk\")); } } @Override public void onAttach(Context context) { super.onAttach(context); } @Override public void onDetach() { super.onDetach(); } } 通过这种方法实例化 afragment = Afragment.newInstance(\"hello world\"); ","date":"2020-03-24","objectID":"/android-fragment/:2:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"fragment的回退栈 fragment_a.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cButton android:id=\"@+id/fabtn1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"change_to_Bfragment\" android:textSize=\"25sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.1\" /\u003e \u003cButton android:id=\"@+id/fabtn2\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"updata_text\" android:textSize=\"25sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.2\" /\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/fatv1\" android:text=\"fragment_a\" android:textSize=\"25sp\" android:gravity=\"center\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintVertical_bias=\"0.4\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e Afragment.java package com.example.test.fragment; import android.content.Context; import android.os.Bundle; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.Button; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import com.example.test.R; public class Afragment extends Fragment { private TextView fatv1; private Button fabtn1,fabtn2; private Bfragment bfragment; public static Afragment newInstance(String title){ Afragment afragment = new Afragment(); Bundle bundle = new Bundle(); bundle.putString(\"tk\",title); afragment.setArguments(bundle); return afragment; } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_a,container,false); Log.d(\"Afragment\",\"----------onCreateView--------\"); return view; } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); fatv1 = view.findViewById(R.id.fatv1); fabtn1 = view.findViewById(R.id.fabtn1); fabtn2 = view.findViewById(R.id.fabtn2); fabtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(bfragment==null) bfragment = new Bfragment(); if (getFragmentManager() != null) { getFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss(); } } }); fabtn2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { fatv1.setText(\"updated\"); } }); if(getArguments()!=null) { fatv1.setText(getArguments().getString(\"tk\")); } } } fragment_b.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/fbtv1\" android:text=\"fragment_b\" android:textSize=\"25sp\" android:gravity=\"center\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintVertical_bias=\"0.4\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e Bfragment.java package com.example.test.fragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; impor","date":"2020-03-24","objectID":"/android-fragment/:3:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"传递数据给activity 通过接口回调 Afragment.java package com.example.test.fragment; import android.content.Context; import android.os.Bundle; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.Button; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import com.example.test.R; public class Afragment extends Fragment { private msgclick listener; public interface msgclick{ void onclick(String s); } private TextView fatv1; private Button fabtn1,fabtn2,fabtn3; private Bfragment bfragment; public static Afragment newInstance(String title){ Afragment afragment = new Afragment(); Bundle bundle = new Bundle(); bundle.putString(\"tk\",title); afragment.setArguments(bundle); return afragment; } @Override public void onAttach(Context context) { super.onAttach(context); listener = (msgclick) context; } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.fragment_a,container,false); Log.d(\"Afragment\",\"----------onCreateView--------\"); return view; } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); fatv1 = view.findViewById(R.id.fatv1); fabtn1 = view.findViewById(R.id.fabtn1); fabtn2 = view.findViewById(R.id.fabtn2); fabtn3 = view.findViewById(R.id.fabtn3); fabtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(bfragment==null) bfragment = new Bfragment(); Fragment fragment = null; if (getFragmentManager() != null) { fragment = getFragmentManager().findFragmentByTag(\"a\"); } if(fragment!=null) { getFragmentManager().beginTransaction().hide(fragment).add(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss(); } else{ if (getFragmentManager() != null) { getFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss(); } } } }); fabtn2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { fatv1.setText(\"updated\"); } }); fabtn3.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { listener.onclick(\"dedsec\"); } }); if(getArguments()!=null) { fatv1.setText(getArguments().getString(\"tk\")); } } } containerActivity.java package com.example.test.fragment; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import com.example.test.R; public class containerActivity extends AppCompatActivity implements Afragment.msgclick { private Afragment afragment; //private Bfragment bfragment; private TextView ctntv1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_container); afragment = Afragment.newInstance(\"hello world\"); getSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment,\"a\").commitAllowingStateLoss(); ctntv1 = findViewById(R.id.ctntv1); } @Override public void onclick(String s) { ctntv1.setText(s); } } ","date":"2020-03-24","objectID":"/android-fragment/:4:0","tags":["java","xml"],"title":"Android Fragment","uri":"/android-fragment/"},{"categories":["android"],"content":"Android 属性动画","date":"2020-03-24","objectID":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","tags":["java","xml"],"title":"Android 属性动画","uri":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"},{"categories":["android"],"content":"简单演示 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".anim2Activity\"\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"70dp\" android:id=\"@+id/a2tv1\" android:textSize=\"30sp\" android:text=\"animation_test\" android:gravity=\"center\" android:textColor=\"#FFFFFF\" android:background=\"#AAAAAA\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; public class anim2Activity extends AppCompatActivity { private TextView a2tv1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_anim2); a2tv1 = findViewById(R.id.a2tv1); a2tv1.animate().translationYBy(500).setDuration(2000).start(); } } package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.animation.ObjectAnimator; import android.animation.ValueAnimator; import android.os.Bundle; import android.util.Log; import android.widget.TextView; public class anim2Activity extends AppCompatActivity { private TextView a2tv1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_anim2); a2tv1 = findViewById(R.id.a2tv1); //a2tv1.animate().translationYBy(500).setDuration(2000).start(); //a2tv1.animate().alpha(0).setDuration(2000).start(); // ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100); // valueAnimator.setDuration(2000); // valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { // @Override // public void onAnimationUpdate(ValueAnimator animation) { // Log.d(\"test\",animation.getAnimatedValue()+\"\"); // Log.d(\"test\",animation.getAnimatedFraction()+\"\"); // } // }); // valueAnimator.start(); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(a2tv1,\"translationY\",1500,200,500,300,1000); objectAnimator.setDuration(5000); objectAnimator.start(); } } ","date":"2020-03-24","objectID":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/:0:0","tags":["java","xml"],"title":"Android 属性动画","uri":"/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/"},{"categories":["GAME"],"content":"看门狗2","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["GAME"],"content":"Watch_dogs2是ubisoft于2016年11月发行的角色扮演游戏 骇入系统是其游戏特色 玩了130+小时 看门狗2的这个特色很新颖，但是剧情很平淡，后面的玩法基本与前面重复 难度也不是很高，很快就能通关，dlc就是支线剧情的复制。但是旧金山的风景还是 很不错的，就是地图太小了。线上模式的hack玩的最多，开始被虐，后来找到技巧，虐别人就索然无味了 线上赛车自从玩了GTA5之后真的就无趣了，经常有人莫名其妙退出 经常受到土豆服务器的制约 现在是真的没空玩看门狗3了 ","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/:0:0","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["GAME"],"content":"剧情 《看门狗2》将游戏设定在距离《看门狗》故事发生之后，ctOS由1.0升级成为2.0，同时也获得了许多功能。然而，ctOS并不是像宣传的那样单纯只是为市民服务，它被不法公司，团体和个人用来监视市民，收集并出售他们个人的数据，操纵选举和扰乱社会秩序等等。游戏需要玩家跟随主人公一点一点进入《看门狗2》的庞大电子世界，揭开并粉碎敌人的阴谋。 《看门狗2》的总监表示，游戏开发团队想在这一作上尝试一些新的点子，比如位于旧金山的游戏场景，整体色调更鲜活明亮，再搭配故事的主题、建筑风格、网络世界以及先进科技。在这样的架构中，故事风格不适合艾登‧皮尔斯，因此让马可仕担任主角来叙述故事是很合适的。 –百度百科 ","date":"2020-03-24","objectID":"/%E7%9C%8B%E9%97%A8%E7%8B%972/:0:1","tags":[],"title":"看门狗2","uri":"/%E7%9C%8B%E9%97%A8%E7%8B%972/"},{"categories":["abc"],"content":"abc159","date":"2020-03-23","objectID":"/abc159/","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"A - The Number of Even Pairs ","date":"2020-03-23","objectID":"/abc159/:0:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (awk语言) $0=$1*--$1/2+$2*--$2/2_ B - String Palindrome ","date":"2020-03-23","objectID":"/abc159/:1:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) print\u003c\u003e=~/^(.+).\\1$/?Yes:No C - Maximum Volume ","date":"2020-03-23","objectID":"/abc159/:2:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) print\u003c\u003e**3/27 D - Banned K ","date":"2020-03-23","objectID":"/abc159/:3:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ac代码 (perl语言) \u003c\u003e;print$.-@$_,$/for grep$.+=++$#$_,glob`dd` E - Dividing Chocolate ","date":"2020-03-23","objectID":"/abc159/:4:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题意 一块巧克力由h行w列的方块组成，每个方块为白或黑 你可以对巧克力进行切割，切割只能沿着方块边缘横切或竖切切到底 问最少需要切几刀，使每个独立块都有不多于k个白巧克力方块 ","date":"2020-03-23","objectID":"/abc159/:5:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ","date":"2020-03-23","objectID":"/abc159/:6:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"贪心 枚举 和牛客小白月赛26的A题很像 由于h的数据不大，枚举行的所有可能情况，先考虑横切，横切不够再竖切 考虑竖切时，如果最大的块大于k，就实施竖切 遍历所有情况求最小值 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int h,w,k; string s[12]; int main(){ //freopen(\"input.txt\",\"r\",stdin); int coun=0; cin\u003e\u003eh\u003e\u003ew\u003e\u003ek; for(int i=0;i\u003ch;i++){ cin\u003e\u003es[i]; } //特判 //没有特判，用u=0代替 WA for(int i=0;i\u003ch;i++) for(int j=0;j\u003cw;j++) if(s[i][j]=='1') coun++; if(coun\u003c=k) cout\u003c\u003c0\u003c\u003cendl; else{ int ans=1e9; for(int u=1;u\u003c(1\u003c\u003c(h-1));u++){ int x=__builtin_popcount(u); int cut_num=x; int block[x+1]={0}; int p=0; int mx=0; bool flag=true; //没有设置flag WA for(int j=0;j\u003cw;j++){ for(int i=0;i\u003ch;i++){ block[p]+=s[i][j]-'0'; mx=max(mx,block[p]); if(u\u003e\u003ei\u00261) p++; } //mx=max(mx,block[p]); if(mx\u003ek) { if(j==0) { flag=false;break; } cut_num++; mx=0; memset(block,0,sizeof(block)); p=0; //没有重置p WA for(int i=0;i\u003ch;i++){ //没有记忆（重新计算） WA block[p]+=s[i][j]-'0'; mx=max(mx,block[p]); if(u\u003e\u003ei\u00261) p++; } } p=0; //没有重置p WA } if(flag) ans=min(ans,cut_num); } cout\u003c\u003cans\u003c\u003cendl; } return 0; } 这道题做了快一个小时，WA了特别多次，每次都WA两三个测试点，主要是细节，WA点在代码中已标注 F - Knapsack for All Segments ","date":"2020-03-23","objectID":"/abc159/:6:1","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题意 给一数列，求对每一可能区间，其子区间内的数和等于s的子区间个数 对所有可能区间求和 ","date":"2020-03-23","objectID":"/abc159/:7:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"题解 ","date":"2020-03-23","objectID":"/abc159/:8:0","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["abc"],"content":"动态规划 奇妙的动态规划 dp[i][j] = sum(f(left,i)) 当和为 j 时 可以的得到递推式 dp[i][j]=dp[i-1][j] dp[i][j]+=dp[i-1][j-data[i]] 有一个很重要的点在代码中标出 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; ll n,s; ll data[3005]; ll dp[3005][3005]; const ll mod=998244353; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003es; for(ll i=1;i\u003c=n;i++) cin\u003e\u003edata[i]; dp[0][0]=1; for(ll i=1;i\u003c=n;i++) for(ll j=0;j\u003c=s;j++) { dp[i][j]=dp[i-1][j]; if(j-data[i]\u003e=0) dp[i][j]+=dp[i-1][j-data[i]]; if(j==0) dp[i][j]++; //当j-data[i]==0时，a[i]这一个也要算上 dp[i][j]%=mod; } ll ans=0; for(ll i=1;i\u003c=n;i++) ans=(ans+dp[i][s])%mod; cout\u003c\u003cans%mod\u003c\u003cendl; return 0; } 一遍过，芜湖~ have a good day ^_^ ","date":"2020-03-23","objectID":"/abc159/:8:1","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"/abc159/"},{"categories":["android"],"content":"Android 数据存储","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["android"],"content":"SharedPreferences sharedpreferences的布局 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".datastorage.sharedPreferencesActivity\"\u003e \u003cEditText android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/spet1\" android:hint=\"input\" android:textSize=\"25sp\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintVertical_bias=\"0.1\" /\u003e \u003cButton android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:text=\"sava\" app:layout_constraintTop_toBottomOf=\"@+id/spet1\" android:layout_marginTop=\"20dp\" android:id=\"@+id/spbtn1\"/\u003e \u003cButton android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25sp\" android:text=\"show\" app:layout_constraintTop_toBottomOf=\"@+id/spbtn1\" android:layout_marginTop=\"20dp\" android:id=\"@+id/spbtn2\"/\u003e \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/sptv1\" android:textSize=\"25sp\" app:layout_constraintTop_toBottomOf=\"@+id/spbtn2\" android:layout_marginTop=\"20dp\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e 输入内容，存储到sharedpreferences,并呈现 package com.example.test.datastorage; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.content.SharedPreferences; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; import com.example.test.R; public class sharedPreferencesActivity extends AppCompatActivity { private Button spbtn1,spbtn2; private EditText spet1; private TextView sptv1; private SharedPreferences mysp; private SharedPreferences.Editor myspe; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_shared_preferences); spbtn1 = findViewById(R.id.spbtn1); spbtn2 = findViewById(R.id.spbtn2); spet1 = findViewById(R.id.spet1); sptv1 = findViewById(R.id.sptv1); //实例化 mysp = getSharedPreferences(\"data\",MODE_PRIVATE); myspe = mysp.edit(); spbtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { myspe.putString(\"name\",spet1.getText().toString()); myspe.apply(); //相当于提交 } }); spbtn2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { sptv1.setText(mysp.getString(\"name\",\"\")); } }); } } sharedpreferences把数据存在xml文件中 在路径 data\\data\\\u003capplicationId\u003e\\shared_prefs下有一个xml文件 真机要root查看 模拟器直接在终端打开monitor 要查看这个文件可以点击右上角的 pull a file from the device 下载下来 打开之后 File 内部存储 布局和功能几乎与sharedpreferences相同 java文件 package com.example.test.datastorage; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; import com.example.test.R; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class fileActivity extends AppCompatActivity { private Button fibtn1,fibtn2; private EditText fiet1; private TextView fitv1; private final String filename = \"test.txt\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_file); fibtn1 = findViewById(R.id.fibtn1); fibtn2 = findViewById(R.id.fibtn2); fiet1 = findViewById(R.id.fiet1); fitv1 = findViewById(R.id.fitv1); fibtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { save(fiet1.getText().toString()); } }); fibtn2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { fitv1.setText(read()); } }); } public ","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:0","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["android"],"content":"权限申请 \u003cuses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/\u003e \u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/\u003e ","date":"2020-03-22","objectID":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/:0:1","tags":["java","xml"],"title":"Android 数据存储","uri":"/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"categories":["nowcoder"],"content":"牛客小白月赛23(部分题解)","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"A 膜法记录 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:0","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 贪心 枚举 集合的整数表示 由于n的数据较小，直接枚举n的所有情况，有2^n种 对于每种情况判断剩下的点列blast能否用完 其实就是贪心思想（把行blast用完，再用列blast） ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; char s[23][100005]; ll t; ll n,m,a,b; ll cl[1\u003c\u003c21]; int main(){ cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003em\u003e\u003ea\u003e\u003eb; for(ll i=0;i\u003c(1\u003c\u003cn);i++) cl[i]=0; for(ll i=1;i\u003c=n;i++) scanf(\"%s\",s[i]+1); //memset(cl,0,sizeof(cl)); for(ll j=1;j\u003c=m;j++) { ll temp=0; for(ll i=1;i\u003c=n;i++) if(s[i][j]=='*') temp|=(1\u003c\u003ci-1); cl[temp]++; } for(ll i=1;i\u003c=n;i++) for(ll j=0;j\u003c(1\u003c\u003cn);j++){ if((j\u0026(1\u003c\u003ci-1))==0) cl[j|1\u003c\u003ci-1]+=cl[j]; } bool ok=false; for(ll i=0;i\u003c(1\u003c\u003cn);i++){ if(__builtin_popcount(i)\u003c=a and m-cl[i]\u003c=b){ ok=true;break; } } if(ok) puts(\"yes\"); else puts(\"no\"); } return 0; } 这里用memset会迷之超时，要用for循环 一个神奇的函数 __builtin_popcount(int x) 返回x的二进制1的个数 B 阶乘 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:1","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二分 数论 用二分法获得最小值 检测一个数n的阶乘是否能被p整除 对p进行质因数分解 遍历p的质因数 如果对于所有的质因数 n！被这个质因数整除的个数都不小于p中的个数 那么n！就能被p整除 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; ll t; ll p; ll fac[1000005]; ll num[1000005]; ll tt; void decompose(ll p){ tt=0; for(ll i=2;i*i\u003c=p;i++){ if(p%i==0){ fac[tt]=i; num[tt]=0; while(p%i==0) p/=i,num[tt]++; tt++; } } if(p\u003e1) { fac[tt]=p;num[tt]=1;tt++; } } bool check(ll x){ for(ll i=0;i\u003ctt;i++){ ll cnt=0,t=x; while(t) { cnt+=t/fac[i]; t/=fac[i]; } if(cnt\u003cnum[i]) return false; } return true; } int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003ep; decompose(p); ll l=1,r=1e10; //开1e6会wa while(l\u003cr){ ll mid=l+r\u003e\u003e1; if(check(mid)) r=mid; else l=mid+1; } cout\u003c\u003cr\u003c\u003cendl; } return 0; } C 完全图 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:2","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二分 图论 规律 很容易能找到规律 要分裂出 x 个连通块，就要拆掉 x*n-(x+1)*x/2 条边 然后用二分找到 x 注意 r 的初始值不大于 n 据说解一元二次方程也可以，我随便写了个，失败了 用python可以防溢出，但是我出现了2.9999999！=3的情况 用c++就要用__int128防止爆long long 不过__int128不能用标准输入输出 一种解决方法是自己写输入输出 但是这题只需要在特定的地方转成__int128就行 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using Int = __int128; using ll = long long; ll t,n,m; int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003em; ll l=0,r=n; ll mid; for(int i=0;i\u003c10000;i++){ mid=(l+r)/2; if(((Int)mid*n-(1+mid)*(Int)mid/2)\u003c=(Int)m) l=mid; else r=mid; } cout\u003c\u003cr\u003c\u003cendl; } return 0; } D 病毒传染 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:3","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 不会 E A+B问题 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:4","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 总共能表示的数有2^32个，每一个数都能找到另一个数与之相加等于答案 ac代码 用PHP写的（求比这更短的代码）（再一次证明了PHP是世界上最好的语言） 4294967296 F 美丽的序列I 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:5","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 不会 G 树上求和 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:6","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 图论 DFS 求出每条边对于所有的简单路径经过了几次 然后按次数从大到小排序，依次赋值1,2,3… 求遍历次数就是求这条边的左右各有几个点，然后相乘 对于每个点再递归求它的子节点 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; ll n; vector\u003cll\u003e p[100005]; ll ch[100005]; bool visit[100005]; using pll=pair\u003cll,ll\u003e; vector\u003cpll\u003e vt; vector\u003cll\u003e w; map\u003cpll,ll\u003e mp; bool cmp(ll a,ll b){return a\u003eb;} ll dfs(ll k){ visit[k]=true; ll ans=1; for(auto it:p[k]){ if(!visit[it]){ ans+=dfs(it); } } w.push_back(ans*(n-ans)); return ans; } int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en; ll t1,t2; for(ll i=0;i\u003cn-1;i++){ cin\u003e\u003et1\u003e\u003et2; p[t1].push_back(t2); ch[t1]++; p[t2].push_back(t1); ch[t2]++; } for(ll i=1;i\u003c=n;i++) ch[i]--; dfs(1); sort(w.begin(),w.end(),cmp); ll i=1; ll ans2=0; for(auto it:w){ ans2+=it*i++; //cout\u003c\u003cit\u003c\u003cendl; } cout\u003c\u003cans2\u003c\u003cendl; return 0; } 用另外一种传入父节点的方法就超时，记忆化搜索也超时 这是TLE/RE代码，不知道为什么错了（对80%），等有空或实力更强一点再看 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; ll n; vector\u003cll\u003e p[100005]; ll ch[100005]; using pll=pair\u003cll,ll\u003e; vector\u003cpll\u003e vt; vector\u003cll\u003e w; map\u003cpll,ll\u003e mp; bool cmp(ll a,ll b){return a\u003eb;} ll dfs(ll k,ll par){ if(mp[make_pair(k,par)]!=0) return mp[make_pair(k,par)]; if(ch[k]==0) {mp[make_pair(k,par)]=0;return 0;} ll ans=0; ans+=ch[k]; for(auto it:p[k]){ if(it!=par){ ans+=dfs(it,k); } } mp[make_pair(k,par)]=ans; return ans; } ll cal(ll x,ll y){ ll resx=dfs(x,y); ll resy=dfs(y,x); return resx+resy+resx*resy+1; } int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en; ll t1,t2; for(int i=0;i\u003cn-1;i++){ cin\u003e\u003et1\u003e\u003et2; p[t1].push_back(t2); ch[t1]++; p[t2].push_back(t1); ch[t2]++; vt.emplace_back(t1,t2); } for(int i=1;i\u003c=n;i++) ch[i]--; for(int i=0;i\u003cn-1;i++){ w.push_back(cal(vt[i].first,vt[i].second)); } sort(w.begin(),w.end(),cmp); ll i=1; ll ans2=0; for(auto it:w){ ans2+=it*i++; } cout\u003c\u003cans2\u003c\u003cendl; return 0; } H 奇怪的背包问题增加了 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:7","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 二进制 由二进制01串的性质可以发现 如果物品总重量没有2^30就输出impossible 否则从大到小排序，依次增加就可以 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll =long long; ll t; ll n; ll num[100005]; using pll=pair\u003cll,ll\u003e; int check[100005]; int main(){ cin\u003e\u003et; while(t--){ vector\u003cpll\u003e vt; //因为这个wa了好久 cin\u003e\u003en; ll ans=0; ll temp; for(ll i=0;i\u003cn;i++){ cin\u003e\u003etemp; num[i]=(1\u003c\u003ctemp); vt.emplace_back(num[i],i); ans+=num[i]; } if(ans\u003c(1\u003c\u003c30)) puts(\"impossible\"); else{ sort(vt.begin(),vt.end(),greater\u003cpll\u003e()); ll ans=0; ll i=0; ll rr=(1\u003c\u003c30); for(ll i=0;i\u003cn;i++) check[i]=0; while(ans!=rr){ ans+=vt[i].first; check[vt[i].second]=1; i++; } //for(ll i=0;i\u003cn;i++) cout\u003c\u003cvt[i].first\u003c\u003c\" \"; for(ll i=0;i\u003cn;i++) cout\u003c\u003ccheck[i]; cout\u003c\u003cendl; } } return 0; } 有个wa点，就是没有清空容器 T_T I 寻找字串 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:8","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 枚举后缀，比较即可 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; vector\u003cstring\u003e vt; string s; bool cmp(string s1,string s2){ return s1\u003es2; } int main(){ cin\u003e\u003es; int len=s.length(); for(int i=0;i\u003clen;i++){ vt.push_back(s.substr(i,len-i)); } sort(vt.begin(),vt.end(),cmp); cout\u003c\u003cvt[0]\u003c\u003cendl; return 0; } J 最大的差 题目链接 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:9","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["nowcoder"],"content":"题解 最大值减最小值 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; int mi=100005; int ma=-1; cin\u003e\u003en; int t; for(int i=0;i\u003cn;i++){ cin\u003e\u003et; mi=min(t,mi); ma=max(t,ma); } cout\u003c\u003cma-mi\u003c\u003cendl; return 0; } 本次比赛官方说难度对标cf div2 a~c，可是根据大家的做题情况除签到题至少应该d吧 不知道为什么有好多题都迷之超时 总体来说，题目还行 ","date":"2020-03-22","objectID":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/:0:10","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"categories":["android"],"content":"Android 事件处理机制","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"事件处理 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:0:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"基于监听的事件处理机制 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"匿名内部类 mbt1.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(\"listener\",\"touch\"); break; } return false; } }); ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:1","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"事件源所在类（activity类） public class eventActivity extends AppCompatActivity implements View.OnClickListener ebt1 = findViewById(R.id.ebt1); ebt1.setOnClickListener(eventActivity.this); @Override public void onClick(View v) { switch (v.getId()){ case R.id.ebt1: Toast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show(); break; } } ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:2","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"在布局文件中设置 \u003cButton android:id=\"@+id/ebt1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"click\" android:textSize=\"20sp\" app:layout_constraintTop_toTopOf=\"parent\" android:layout_marginTop=\"50dp\" android:onClick=\"show\" /\u003e public void show(View view){ //一定是public void switch (view.getId()){ case R.id.ebt1: Toast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show(); break; } } ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:1:3","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"基于回调的事件处理机制 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".eventActivity\"\u003e \u003cButton android:id=\"@+id/ebt1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"click\" android:textSize=\"20sp\" app:layout_constraintTop_toTopOf=\"parent\" android:layout_marginTop=\"50dp\" /\u003e \u003ccom.example.test.Mybotton android:id=\"@+id/mbt1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"20sp\" android:text=\"Mybotton\" android:textAllCaps=\"false\" app:layout_constraintTop_toBottomOf=\"@+id/ebt1\" android:layout_marginTop=\"20dp\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e Mybotton类 package com.example.test; import android.content.Context; import android.util.AttributeSet; import android.util.Log; import android.view.MotionEvent; import android.widget.Button; import androidx.appcompat.widget.AppCompatButton; public class Mybotton extends AppCompatButton { public Mybotton(Context context) { super(context); } public Mybotton(Context context, AttributeSet attrs) { super(context, attrs); } public Mybotton(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override public boolean onTouchEvent(MotionEvent event) { super.onTouchEvent(event); switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(\"Mybotton\",\"touch\"); break; } return false; //return true即onTouchEvent到此终止 } } eventactivity.java package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.view.MotionEvent; import android.view.View; import android.widget.Button; import android.widget.Toast; public class eventActivity extends AppCompatActivity { private Button ebt1; private Mybotton mbt1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_event); mbt1 = findViewById(R.id.mbt1); mbt1.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(\"listener\",\"touch\"); break; } return false; } }); // ebt1 = findViewById(R.id.ebt1); // ebt1.setOnClickListener(eventActivity.this); } // @Override // public void onClick(View v) { // switch (v.getId()){ // case R.id.ebt1: // Toast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show(); // break; // } // } // public void show(View view){ //一定是public void // switch (view.getId()){ // case R.id.ebt1: // Toast.makeText(eventActivity.this , \"click...\",Toast.LENGTH_LONG).show(); // break; // } // } @Override public boolean onTouchEvent(MotionEvent event) { super.onTouchEvent(event); switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(\"activity\",\"touch\"); break; } return false; } } 触摸Mybotton触发事件 ","date":"2020-03-19","objectID":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/:2:0","tags":["java","xml"],"title":"Android 事件处理机制","uri":"/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"categories":["android"],"content":"Android 四大组件之Activity","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"Activity ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:0:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity的生命周期 运行以下代码可以看到activity经历的生命周期 package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; public class lifeCircleActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_life_circle); Log.d(\"lifecircle\",\"-----onCreate----\"); } @Override protected void onStart() { super.onStart(); Log.d(\"lifecircle\",\"-----onStart----\"); } @Override protected void onResume() { super.onResume(); Log.d(\"lifecircle\",\"-----onResume----\"); } @Override protected void onPause() { super.onPause(); Log.d(\"lifecircle\",\"-----onPause----\"); } @Override protected void onStop() { super.onStop(); Log.d(\"lifecircle\",\"-----onStop----\"); } @Override protected void onRestart() { super.onRestart(); Log.d(\"lifecircle\",\"-----onRestart----\"); } @Override protected void onDestroy() { super.onDestroy(); Log.d(\"lifecircle\",\"-----onDestroy----\"); } } 启动这个activity之后 按返回键退出activity 再启动activity,并按主页键或者菜单键 在cache中重新进入activity ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:1:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity之间的跳转 方法有很多 以下是设置点击事件来跳转 private Button bt11; bt11 = findViewById(R.id.bt11); bt11.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this , broadActivity.class); startActivity(intent); } }); ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:2:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"隐式intent 目标activity在manifest文件中应这样注册 \u003cactivity android:name=\".implicitIntentActivity\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"com.example.test.124\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e 点击事件的设置 bt14 = findViewById(R.id.bt14); bt14.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(); intent.setAction(\"com.example.test.124\"); startActivity(intent); } }); ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:3:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"activity之间的数据传输 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:4:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"将activity的数据传输到目标activity 发送数据 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_jump); jumpbt1 = findViewById(R.id.jumpbt1); jumpbt1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(jumpActivity.this , jump2Activity.class); Bundle bundle = new Bundle(); bundle.putString(\"name\",\"henry\"); bundle.putInt(\"number\",11); intent.putExtras(bundle); startActivity(intent); //startActivityForResult(intent,0); //写在点击事件里 } }); } 接收数据并呈现 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_jump2); jump2tv1 = findViewById(R.id.jump2tv1); Bundle bundle = new Bundle(); bundle = getIntent().getExtras(); String name = bundle.getString(\"name\"); int number = bundle.getInt(\"number\"); jump2tv1.setText(name+\",\"+number);} ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:4:1","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"启动一个activity,结束后返回结果 jump界面 jump2界面 点击back返回结果（一个toast） jumpactivity package com.example.test; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; public class jumpActivity extends AppCompatActivity { private Button jumpbt1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_jump); jumpbt1 = findViewById(R.id.jumpbt1); jumpbt1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(jumpActivity.this , jump2Activity.class); Bundle bundle = new Bundle(); bundle.putString(\"name\",\"henry\"); bundle.putInt(\"number\",11); intent.putExtras(bundle); //startActivity(intent); startActivityForResult(intent,0); //写在点击事件里 } }); } @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); Toast.makeText(jumpActivity.this,data.getExtras().getString(\"msg\"),Toast.LENGTH_LONG).show() ; } } jump2activity package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; public class jump2Activity extends AppCompatActivity { private TextView jump2tv1; private Button jump2bt1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_jump2); jump2tv1 = findViewById(R.id.jump2tv1); Bundle bundle = new Bundle(); bundle = getIntent().getExtras(); String name = bundle.getString(\"name\"); int number = bundle.getInt(\"number\"); jump2tv1.setText(name+\",\"+number); jump2bt1 = findViewById(R.id.jump2bt1); jump2bt1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(); Bundle bundle1 = new Bundle(); bundle1.putString(\"msg\",\"i'm back\"); intent.putExtras(bundle1); setResult(Activity.RESULT_OK,intent); finish(); } }); } } ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/:5:0","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/"},{"categories":["android"],"content":"Android 四大组件之Broadcast Receiver","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"Broadcast Receiver ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:0:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"通过LoaclBroadcastManager发送广播并接收广播 点击broadactivity的click,跳转到broad2activity 点击broad2activity的clickme,发送广播 broadactivity接收广播，将abc改成123 broadactivity broad2activity 点击clickme后返回到broadactivity 代码 broadactivity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".broad.broadActivity\"\u003e \u003cButton android:id=\"@+id/bcbt1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_constraintTop_toTopOf=\"parent\" android:layout_marginTop=\"40dp\" android:textSize=\"30sp\" android:text=\"click\"/\u003e \u003cTextView android:id=\"@+id/bctv1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"abc\" android:textSize=\"60sp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/bcbt1\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintVertical_bias=\"0.3\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e broadactivity_java package com.example.test.broad; import androidx.appcompat.app.AppCompatActivity; import androidx.localbroadcastmanager.content.LocalBroadcastManager; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import com.example.test.R; public class broadActivity extends AppCompatActivity { private Button bcbt1; private TextView bctv1; private Mybroad mybroad; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_broad); bcbt1 = findViewById(R.id.bcbt1); bctv1 = findViewById(R.id.bctv1); bcbt1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(broadActivity.this , broad2Activity.class); startActivity(intent); } }); mybroad = new Mybroad(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(\"sss\"); LocalBroadcastManager.getInstance(broadActivity.this).registerReceiver(mybroad,intentFilter); } private class Mybroad extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { //接收到广播要处理的事 switch(intent.getAction()){ case \"sss\": bctv1.setText(\"123\"); break; } } } @Override protected void onDestroy() { super.onDestroy(); LocalBroadcastManager.getInstance(broadActivity.this).unregisterReceiver(mybroad); } } broad2activity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".broad.broad2Activity\"\u003e \u003cButton android:id=\"@+id/bc2bt1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_constraintTop_toTopOf=\"parent\" android:layout_marginTop=\"30dp\" android:textSize=\"30sp\" android:text=\"click me\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e broad2activity_java package com.example.test.broad; import androidx.appcompat.app.AppCompatActivity; import androidx.localbroadcastmanager.content.LocalBroadcastManager; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Button; import com.example.test.R; public class broad2Activity extends AppCompatActivity { private Button bc2bt1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_broad2); bc2bt1 = findViewById(R.id.bc2bt1); bc2bt1.setOnClick","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:1:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"一些系统操作对应的action ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/:2:0","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/"},{"categories":["android"],"content":"Android 四大组件之Content Provider","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"Content Provider ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:0:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"获取外部应用的信息 以获取通讯录为例 布局文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".contentProviderActivity\"\u003e \u003cButton android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/cpbtn1\" android:textSize=\"25sp\" android:text=\"get_contacts\"/\u003e \u003cButton android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/cpbtn2\" android:text=\"getdata\" android:textSize=\"25dp\" app:layout_constraintTop_toBottomOf=\"@+id/cpbtn1\" android:layout_marginTop=\"20dp\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e 点击get_contacts获取联系人信息 手机里存储的联系人信息 在manifest里获取权限 \u003cuses-permission android:name=\"android.permission.READ_CONTACTS\" /\u003e 利用content resolver获取 package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.content.ContentResolver; import android.database.Cursor; import android.net.Uri; import android.os.Bundle; import android.provider.ContactsContract; import android.util.Log; import android.view.View; import android.widget.Button; import java.util.HashSet; import java.util.List; public class contentProviderActivity extends AppCompatActivity { private Button cpbtn1,cpbtn2; //private List\u003cString\u003e contactlist=null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_content_provider); cpbtn1 = findViewById(R.id.cpbtn1); cpbtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { ContentResolver contentResolver = getContentResolver(); Cursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null); while(cursor.moveToNext()){ String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); Log.d(\"tag\",name+\" \"+number); //contactlist.add(name+\" \"+number); } cursor.close(); //System.out.println(contactlist.toString()); } }); // } } 获取到的信息 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:1:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"获取系统权限指令大全 点击此处 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:1:1","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"提供自己的应用信息 在sqlite数据库中创建表 package com.example.test; import android.content.Context; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import androidx.annotation.Nullable; public class Myopenhelper extends SQLiteOpenHelper { private static final String CREATE_TABLE_PERSON = \"create table person (id integer primary key autoincrement,name text,age integer)\"; public Myopenhelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(CREATE_TABLE_PERSON); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } 插入数据，提供content provider package com.example.test; import android.content.ContentProvider; import android.content.ContentValues; import android.content.UriMatcher; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.net.Uri; import androidx.annotation.NonNull; import androidx.annotation.Nullable; public class Myprovider extends ContentProvider { private static final String PACKAGE_NAME = \"com.example.test\"; private static UriMatcher uriMatcher; private Myopenhelper myopenhelper; private SQLiteDatabase sqLiteDatabase; static { uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(PACKAGE_NAME,\"person\",0); } @Override public boolean onCreate() { myopenhelper = new Myopenhelper(getContext(),\"database\",null,1); sqLiteDatabase = myopenhelper.getWritableDatabase(); ContentValues contentValues = new ContentValues(); contentValues.put(\"name\",\"jingjing\"); contentValues.put(\"age\",15); sqLiteDatabase.insert(\"person\",null,contentValues); contentValues.put(\"name\",\"kakulukia\"); contentValues.put(\"age\",15); sqLiteDatabase.insert(\"person\",null,contentValues); return true; } @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) { int code = uriMatcher.match(uri); switch (code){ case 0: Cursor cursor = sqLiteDatabase.query(\"person\",null,null,null,null,null,null); return cursor; } return null; } @Nullable @Override public String getType(@NonNull Uri uri) { return null; } @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) { return null; } @Override public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) { return 0; } @Override public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) { return 0; } } 在manifest注册 \u003cprovider android:name=\".Myprovider\" android:authorities=\"com.example.test\" android:exported=\"true\" /\u003e 到此已经提供了自己的应用信息 现在通过点击“get_data”来查询（利用content resolver） package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.content.ContentResolver; import android.database.Cursor; import android.net.Uri; import android.os.Bundle; import android.provider.ContactsContract; import android.util.Log; import android.view.View; import android.widget.Button; import java.util.HashSet; import java.util.List; public class contentProviderActivity extends AppCompatActivity { private Button cpbtn1,cpbtn2; //private List\u003cString\u003e contactlist=null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_content_provider); cpbtn1 = findViewById(R.id.cpbtn1); cpbtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { ContentResolver contentResolver = getContentResolver(); Cursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null); while(cursor.moveToNext()){ String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/:2:0","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/"},{"categories":["android"],"content":"Android 四大组件之Service","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"Service ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:0:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"Service的生命周期 ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:1:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"通过启动Service传递数据 在serviceactivity的输入框中输入数据，启动Myservice并传递数据，打印到日志 serviceactivity_xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".serviceActivity\"\u003e \u003cButton android:id=\"@+id/sbtn1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"startservice\" android:textSize=\"25sp\"/\u003e \u003cButton android:id=\"@+id/sbtn2\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25dp\" android:text=\"stopservice\" app:layout_constraintTop_toBottomOf=\"@+id/sbtn1\" android:layout_marginTop=\"20dp\"/\u003e \u003cButton android:id=\"@+id/sbtn3\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25dp\" android:text=\"bindservice\" app:layout_constraintTop_toBottomOf=\"@+id/sbtn2\" android:layout_marginTop=\"20dp\"/\u003e \u003cButton android:id=\"@+id/sbtn4\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25dp\" android:text=\"unbindservice\" app:layout_constraintTop_toBottomOf=\"@+id/sbtn3\" android:layout_marginTop=\"20dp\"/\u003e \u003cEditText android:id=\"@+id/set1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_constraintTop_toBottomOf=\"@+id/sbtn4\" android:textSize=\"20sp\" android:layout_marginTop=\"20dp\"/\u003e \u003cButton android:id=\"@+id/sbtn5\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"25dp\" android:text=\"syncdata\" app:layout_constraintTop_toBottomOf=\"@+id/set1\" android:layout_marginTop=\"30dp\"/\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e serviceactivity.java sbtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(serviceActivity.this , MyService.class); intent.putExtra(\"data\",set1.getText().toString()); startService(intent); } }); Myservice.java private String data=\"cat\"; private boolean running=false; @Override public int onStartCommand(Intent intent, int flags, int startId) { data = intent.getStringExtra(\"data\"); //Log.d(\"tag\",data); return super.onStartCommand(intent, flags, startId); } @Override public void onCreate() { super.onCreate(); //Log.d(\"tag\",data); running=true; new Thread(){ @Override public void run() { super.run(); while (running){ System.out.println(data); try { sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); } ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:2:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"通过绑定来同步数据 点击bindservice 输入数据，点击syncdata service.java package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.os.Bundle; import android.os.IBinder; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.EditText; public class serviceActivity extends AppCompatActivity implements ServiceConnection { private Button sbtn1,sbtn2,sbtn3,sbtn4; private EditText set1; private Button sbtn5; private MyService.mybinder binder; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_service); sbtn1 = findViewById(R.id.sbtn1); sbtn2 = findViewById(R.id.sbtn2); sbtn3 = findViewById(R.id.sbtn3); sbtn4 = findViewById(R.id.sbtn4); set1 = findViewById(R.id.set1); sbtn5 = findViewById(R.id.sbtn5); sbtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(serviceActivity.this , MyService.class); intent.putExtra(\"data\",set1.getText().toString()); startService(intent); } }); sbtn2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(serviceActivity.this , MyService.class); stopService(intent); } }); sbtn3.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(serviceActivity.this , MyService.class); bindService(intent,serviceActivity.this, Context.BIND_AUTO_CREATE); } }); sbtn4.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //Intent intent = new Intent(serviceActivity.this,MyService.class); unbindService(serviceActivity.this); } }); sbtn5.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(binder!=null){ binder.setdata(set1.getText().toString()); //System.out.println(MyService.data); } } }); } @Override public void onServiceConnected(ComponentName name, IBinder service) { Log.d(\"service123\",\"connected123\"); binder = (MyService.mybinder) service; } @Override public void onServiceDisconnected(ComponentName name) { } } Myservive.java package com.example.test; import android.app.Service; import android.content.Intent; import android.os.Binder; import android.os.IBinder; import android.util.Log; public class MyService extends Service { private String data=\"cat\"; private boolean running=false; public MyService() { } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. //throw new UnsupportedOperationException(\"Not yet implemented\"); //return new Binder(); return new mybinder(); } public class mybinder extends Binder{ //是binder不是 ibinder public void setdata(String data){ MyService.this.data = data; } } @Override public int onStartCommand(Intent intent, int flags, int startId) { //data = intent.getStringExtra(\"data\"); //Log.d(\"tag\",data); return super.onStartCommand(intent, flags, startId); } @Override public boolean onUnbind(Intent intent) { return super.onUnbind(intent); } @Override public void onCreate() { super.onCreate(); //Log.d(\"tag\",data); running=true; new Thread(){ @Override public void run() { super.run(); while (running){ System.out.println(data); try { sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); } @Override public void onDestroy() { super.onDestroy(); Log.d(\"tag\",\"dog\"); running=false; } } ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:3:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["android"],"content":"在manifest里的注册 \u003cactivity android:name=\".serviceActivity\" android:exported=\"true\" /\u003e \u003cservice android:name=\".MyService\" android:enabled=\"true\" android:exported=\"true\" /\u003e ","date":"2020-03-19","objectID":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/:4:0","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/"},{"categories":["algorithm","hduoj"],"content":"hduoj1711(kmp)","date":"2020-03-17","objectID":"/hduoj1711kmp/","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Number Sequence ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:0","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Problem Description Given two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 \u003c= M \u003c= 10000, 1 \u003c= N \u003c= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:1","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Input The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 \u003c= M \u003c= 10000, 1 \u003c= N \u003c= 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000]. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:2","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Output For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead. ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:3","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Sample Input 2 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 1 3 13 5 1 2 1 2 3 1 2 3 1 3 2 1 2 1 2 3 2 1 ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:4","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Sample Output 6 -1 ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:5","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["algorithm","hduoj"],"content":"Solution 测一下kmp板子 ac代码 #include\u003ciostream\u003e using namespace std; int n,m,t; int s[1000005]; int p[10005]; int nextt[10005]; void get_next(){ int i=0,j=-1; nextt[0]=-1; while(i\u003cm){ if(j==-1 || p[i]==p[j]) nextt[++i]=++j; else j=nextt[j]; //!!! } } int kmp(){ int i=0,j=0; while(1){ if(s[i]==p[j]) i++,j++; else{ int t=nextt[j]; if(t==-1) i++,j=0; else j=t; } if(j\u003e=m) return i-m+1; //根据题目要求返回 if(i\u003e=n) return -1; } } int main(){ //freopen(\"input.txt\",\"r\",stdin); ios::sync_with_stdio(0);cin.tie(0); cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003em; for(int i=0;i\u003cn;i++) cin\u003e\u003es[i]; for(int i=0;i\u003cm;i++) cin\u003e\u003ep[i]; get_next(); cout\u003c\u003ckmp()\u003c\u003cendl; } return 0; } ","date":"2020-03-17","objectID":"/hduoj1711kmp/:0:6","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"/hduoj1711kmp/"},{"categories":["codeforces"],"content":"Codeforces Round #628 (Div. 2) A~D","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"A. EhAb AnD gCd ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:0","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一正整数x，求正整数a,b满足gcd(a,b)+lcm(a,b)=x ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:1","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 数论思维题，a=1，b=x-1满足条件 ac代码 #include\u003ciostream\u003e using namespace std; int main(){ int t; cin\u003e\u003et; while(t--) { int k; cin\u003e\u003ek; cout\u003c\u003c1\u003c\u003c\" \"\u003c\u003ck-1\u003c\u003cendl; } return 0; } B. CopyCopyCopyCopyCopy ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:2","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一数列，将数列无限复制，求最长严格单调子序列的个数 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:3","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 计算数列有多少种数字就行 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll =long long; ll t; ll n; set\u003cll\u003e st; ll tmp; inline ll read(){ ll x=0;ll f=1;char s=getchar(); while(s\u003c'0' or s\u003e'9') { if(s=='-') f-=1; s=getchar(); } while(s\u003e='0' and s\u003c='9') { x=x*10+s-'0'; s=getchar(); } return x*f; } int main(){ //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--){ st.clear(); cin\u003e\u003en; for(int i=0;i\u003cn;i++){ tmp=read(); st.insert(tmp); } cout\u003c\u003cst.size()\u003c\u003cendl; } return 0; } C. Ehab and Path-etic MEXs ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:4","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 给一棵n个节点的树，求边权重的赋值方案（权重为0~n-2互异） 使得max(mex(u,v))最小 其中mex(u,v)为连接顶点u,v的简单路径中“不”包含边权重的最小值 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:5","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 当树为一条链时，随便赋值 否则，树必然有一个顶点的度数为3 所有简单路径中必然经过0和1的边 要让最大值最小，就要让所有简单路径不同时存在0，1，2的边（这样max(mex)=2） 只需要把0，1，2分散在三度顶点的三条边上 其他随便赋值 以第2个样例为例 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n; int deg[100005]; using pii=pair\u003cint,int\u003e; vector\u003cpii\u003e vt; bool lis; //bool lef; int p; int main(){ //freopen(\"input.txt\",\"r\",stdin); ios::sync_with_stdio(0);cin.tie(0); lis=true; cin\u003e\u003en; for(int i=0,t1,t2;i\u003cn-1;i++){ cin\u003e\u003et1\u003e\u003et2; //if(t1\u003et2) swap(t1,t2); deg[t1]++; deg[t2]++; vt.emplace_back(t1,t2); } for(int i=1;i\u003c=n;i++) { if(deg[i]\u003e2){ lis=false; p=i; break; } } if(lis){ for(int i=0;i\u003cn-1;i++) cout\u003c\u003ci\u003c\u003cendl; } else{ int a=0,b=3; for(int i=0;i\u003cn-1;i++){ if((vt[i].first==p or vt[i].second==p ) and (a\u003c3)){ cout\u003c\u003ca++\u003c\u003cendl; } else cout\u003c\u003cb++\u003c\u003cendl; } } return 0; } D. Ehab the Xorcist ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:6","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 Given 2 integers u and v, find the shortest array such that bitwise-xor of its elements is u, and the sum of its elements is v. ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:7","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 如果是3个数，则这3个数可以是u , (v-u)/2 , (v-u)/2 (利用异或性质) 如果是2个数，p，q 则考虑p+q和p^q的关系 利用以下性质可求得p,q 注意题目说的正整数和样例，进行特判 ac代码 #include\u003cbits/stdc++.h\u003e using ll = long long; using namespace std; ll u,v; int main(){ cin\u003e\u003eu\u003e\u003ev; if((v-u)\u00261 || v-u\u003c0) puts(\"-1\"); else if(v==0 \u0026\u0026 u==0) puts(\"0\"); else if(v==u) cout\u003c\u003c1\u003c\u003cendl\u003c\u003cu; else{ ll p=(v-u)/2; ll q=u^p; if(p+q==v) cout\u003c\u003c2\u003c\u003cendl\u003c\u003cp\u003c\u003c\" \"\u003c\u003cq\u003c\u003cendl; else cout\u003c\u003c3\u003c\u003cendl\u003c\u003cu\u003c\u003c\" \"\u003c\u003cp\u003c\u003c\" \"\u003c\u003cp\u003c\u003cendl; } return 0; } E. Ehab’s REAL Number Theory Problem ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:8","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:9","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 不会 F. Ehab’s Last Theorem ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:10","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题意 不懂 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:11","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["codeforces"],"content":"题解 不会 ","date":"2020-03-16","objectID":"/codeforces-round-628-div.-2-a~d/:0:12","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"/codeforces-round-628-div.-2-a~d/"},{"categories":["note","courses"],"content":"二进制编码","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"二进制转十进制 除2取余 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:0","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"十进制转二进制 乘2次幂 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:1","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"小数进制转换 e.g. 3.59375 整数部分3的二进制位11 小数部分0.59375 0.59375*2=1.1875 ———————— 1 0.1875*2=0.375 —————————0 0.375*2=0.75 ——————————0 0.75*2=1.5 ——————————–1 0.5*2=1 ———————————–1 二进制位0.10011 所以3.59375的二进制表示为11.10011 有些小数不能测出现循环 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:2","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"IEEE754标准的浮点数与十进制数的转换 32位和64位标准 通过全1和全0来划定它的表示范围 E.G. ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:3","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"原码 即正常的二进制码（带符号位） ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:4","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码 正数（包括+0）的补码和原码一样 负数（包括-0）的补码在原码的基础上“按位取反，末尾加1” 补码转原码的一种方法 还可以用逆过程法，即减1取反 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:5","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"反码 正数（包括+0）的补码和原码一样 负数（包括-0）的补码在原码的基础上“按位取反” ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:6","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码的加法运算 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:7","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["note","courses"],"content":"补码的减法运算 ","date":"2020-03-15","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/:0:8","tags":["binary","cs"],"title":"二进制编码","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"},{"categories":["codeforces"],"content":"Codeforces Round #627 (Div. 3)","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"A. Yet Another Tetris Problem link B. Yet Another Palindrome Problem link C. Frog Jumps link D. Pair of Topics link E. Sleeping Schedule link ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:0","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题意 假设一天有h个小时，DIO一共要睡n次，每次睡ai个小时（按顺序睡觉），每次刚睡醒，就要继续睡觉，一直睡下去，直至睡眠次数耗光。 给定一个一天中的区间[l,r]，如果有一次睡醒时刻在区间内，则这次睡眠为“好睡眠” 对于每次睡眠时间ai,可以选择睡ai小时或ai-1小时 问一开始就进行睡眠的情况下，“好睡眠”的次数最多有几次 ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:1","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题解 动态规划 dp[i][j] i表示已经进行了i次睡眠 j表示现在在时刻j dp表示最大“好睡眠”次数 初始化 ：dp[i][j]=-inf , dp[0][0]=0 分别讨论下面两种情况 to=(j+a[i])%h to=(j+a[i]-1)%h 状态转移方程 ：dp[i+1][to] = max(dp[i+1][to] , dp[i][j] + flag) flag当to在区间内为1，否则为0 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n,h,l,r; int dp[2005][2005]; int data[2005]; int main() { //freopen(\"input.txt\",\"r\",stdin); ios::sync_with_stdio(0);cin.tie(0); cin\u003e\u003en\u003e\u003eh\u003e\u003el\u003e\u003er; for(int i=0;i\u003cn;i++) cin\u003e\u003edata[i]; //preprocess memset(dp,0xc0,sizeof(dp)); //0xc0c0c0c0 0x3f3f3f3f dp[0][0]=0; for(int i=0;i\u003cn;i++) for(int j=0;j\u003ch;j++) // \u003c即可 { int to=(j+data[i])%h; dp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u003c=to and to\u003c=r)); to =(j+data[i]-1)%h; dp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u003c=to and to\u003c=r)); } int ans=-1; for(int i=0;i\u003ch;i++) ans=max(ans,dp[n][i]); cout\u003c\u003cans\u003c\u003cendl; return 0; } 小技巧 inf = 0x3f3f3f3f memset可以用0x3f ninf=0xc0c0c0c0 memset可以用0xc0 F. Maximum White Subtree link ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:2","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题意 给一棵树（比赛当天是植树节！！） 节点有黑的，白的 对于这棵树的某一子图 定义这个子图所有节点的dif=白色节点数-黑色节点数 求每一个节点的最大dif值 ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:3","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["codeforces"],"content":"题解 深度优先搜索+动态规划 首先考虑以每个节点为父节点的子图的最大dif 然后每个节点的的最大dif=作为父节点的最大dif+作为子节点的最大dif 如何求以每个节点为父节点的子图的最大dif？ 遍历子节点 判断每个子节点以下（作为父节点）是否白色比黑色多，多则累加对应的数值，否则不累加 这样就形成和了dfs 如何求最终的dif？ 作为子节点的部分的dif，可以用该节点的父节点的dif（最终）- 作为父节点的dif 需要判断是否有必要增加“额外部分” 要让该节点的父节点的dif为最终值，需要从根开始，一层层遍历子节点 这样又形成了dfs ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int n; int dif_orig[200005]; vector\u003cint\u003e adj[200005]; int dif_par[200005]; int ans[200005]; void dfs_par(int u,int par) { dif_par[u]=dif_orig[u]; for(auto v:adj[u]) { if(v!=par) { dfs_par(v,u); dif_par[u]+=max(dif_par[v],0); //如果黑色比白色多，则丢弃 } } } void dfs_final(int u,int par,int el) { ans[u]=dif_par[u]+el; for(auto v:adj[u]) { if(v!=par) { dfs_final(v,u,max(0,ans[u]-max(dif_par[v],0))); //里面的max和上面一样，外面的max判断是否有必要增加其他部分（作为子节点的部分） } } } int main() { //freopen(\"input.txt\",\"r\",stdin); ios::sync_with_stdio(0);cin.tie(0); cin\u003e\u003en; for(int i=0;i\u003cn;i++) { cin\u003e\u003edif_orig[i]; if(!dif_orig[i]) dif_orig[i]=-1; //如果是黑色，则白色-黑色=-1 } for(int i=1,u,v;i\u003cn;i++) { cin\u003e\u003eu\u003e\u003ev; u--,v--; adj[u].emplace_back(v); adj[v].emplace_back(u); } dfs_par(0,-1); dfs_final(0,-1,0); for(int i=0;i\u003cn;i++) cout\u003c\u003cans[i]\u003c\u003c\" \"; return 0; } ","date":"2020-03-13","objectID":"/codeforces-round-627-div.-3/:0:4","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"/codeforces-round-627-div.-3/"},{"categories":["anime"],"content":"ef - a tale of melodies","date":"2020-03-09","objectID":"/ef-a-tale-of-melodies/","tags":[],"title":"ef - a tale of melodies","uri":"/ef-a-tale-of-melodies/"},{"categories":["anime"],"content":"《ef - a tale of melodies.》由日本动画公司SHAFT制作电视动画，并于2008年10月6日开始播放，是动画《悠久之翼》系列的第二季。故事内容由原作游戏《ef - the latter tale.》的第四章及终章改篇而成，终章的修改幅度比较大，加入了一些原创的情节。共12话。 剧情 圣诞节，雨宫优子与火村夕两人在教会里重逢。两人怀缅过去，由雨宫优子开始说过去发生过的种种事情。 广野纮是个高中生兼少女漫画家，每一天度过忙碌的生活。在圣诞节的夜晚，遇到追逐小偷的宫村宫子。两人再次在学校见面后，宫村宫子对广野纮开始产生兴趣，而开始纠缠在广野纮身边。 身为青梅竹马的新藤景看到这种场景而感到焦虑。几个月后的夏天。喜欢电影制作的堤京介，在体育馆看到新藤景的射篮的动作时，想要拍摄以她为主的电影。因为失恋与郁闷而退出社团的新藤景，受到热爱电影的堤京介的影响，慢慢走出阴霾。–百度百科 ","date":"2020-03-09","objectID":"/ef-a-tale-of-melodies/:0:0","tags":[],"title":"ef - a tale of melodies","uri":"/ef-a-tale-of-melodies/"},{"categories":["abc"],"content":"abc158","date":"2020-03-08","objectID":"/abc158/","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"A - Station and Bus ","date":"2020-03-08","objectID":"/abc158/:0:0","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:1","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给一长度为3的，只含AB的字符串，问是否存在相邻两个字符不同的情况 ","date":"2020-03-08","objectID":"/abc158/:0:2","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 签到题 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { string s; cin\u003e\u003es; if((s[0]=='A' and s[1]=='A' and s[2]=='A') or(s[0]=='B' and s[1]=='B' and s[2]=='B')) cout\u003c\u003c\"No\"\u003c\u003cendl; else cout\u003c\u003c\"Yes\"\u003c\u003cendl; return 0; } B - Count Balls ","date":"2020-03-08","objectID":"/abc158/:0:3","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:4","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 有蓝球和红球若干，将他们排成一排，不断通过以下操作排列，在尾部加a个蓝球，在尾部加b个红球，问前n个球有多少个蓝球 ","date":"2020-03-08","objectID":"/abc158/:0:5","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 签到题 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; int main() { //freopen(\"input.txt\",\"r\",stdin); ll a,b,n; cin\u003e\u003en\u003e\u003ea\u003e\u003eb; ll m=n/(a+b); ll ans; if(n\u003e0) ans=m*a; else ans=0; n-=m*(a+b); if(n\u003ea) ans+=a; else ans+=n; cout\u003c\u003cans\u003c\u003cendl; return 0; } C - Tax Increase ","date":"2020-03-08","objectID":"/abc158/:0:6","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:7","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给俩数a,b，问是否存在整数x使得，floor(x0.08)=a \u0026\u0026 floor(x0.1)=b，若存在，输出满足这种条件的最小数，否则输出-1 ","date":"2020-03-08","objectID":"/abc158/:0:8","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 由于数据不大，遍历x，判断是否满足条件 或者求满足条件的两个区间，判断是否有交集 ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { //freopen(\"input.txt\",\"r\",stdin); int l1,r1,l2,r2; int a,b; cin\u003e\u003ea\u003e\u003eb; l1=ceil(a/0.08); double t; t=(a+1)/0.08; if(t*0.08==a+1) r1=t-1; else r1=floor((a+1)/0.08); l2=ceil(b/0.1); t=(b+1)/0.1; if(t*0.1==b+1) r2=t-1; else r2=floor((b+1)/0.1); bool flag=true; int ans; if(r1\u003cl2 or r2\u003cl1) flag=false; else if(l2\u003e=l1 and r2\u003c=r1) ans=l2; else if(l1\u003e=l2 and r1\u003c=r2) ans=l1; else ans=max(l1,l2); if(flag) cout\u003c\u003cans\u003c\u003cendl; else cout\u003c\u003c-1\u003c\u003cendl; //cout\u003c\u003cl1\u003c\u003c\" \"\u003c\u003cr1\u003c\u003c\" \"\u003c\u003cl2\u003c\u003c\" \"\u003c\u003cr2; return 0; } D - String Formation ","date":"2020-03-08","objectID":"/abc158/:0:9","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:10","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 对于一个字符串，有三种操作，倒置，在头部添加字符，在尾部添加字符，求最后得到的字符串 ","date":"2020-03-08","objectID":"/abc158/:0:11","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 分别存储前缀和后缀，用一个bool来判断顺序，倒置操作给bool取反。 在头部加，如果是顺序的就加在前缀，其他情况同理。 最后通过bool量来控制输出顺序 （直接模拟也可以） ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; string s; int q; char c; int f; int t; string pre,suf; bool order; int main() { //freopen(\"input.txt\",\"r\",stdin); order=true; cin\u003e\u003es; cin\u003e\u003eq; while(q--) { cin\u003e\u003et; if(t==1) order^=1; //!! else { cin\u003e\u003ef; if(f==1) { cin\u003e\u003ec; if(order) pre+=c; else suf+=c; } else { cin\u003e\u003ec; if(order) suf+=c; else pre+=c; } } } if(order) { reverse(pre.begin(),pre.end()); cout\u003c\u003cpre\u003c\u003cs\u003c\u003csuf\u003c\u003cendl; } else { reverse(suf.begin(),suf.end()); reverse(s.begin(),s.end()); cout\u003c\u003csuf\u003c\u003cs\u003c\u003cpre\u003c\u003cendl; } return 0; } 知识点 1.bool的取反不能flag=-flag，可以用flag^=1 2.string 在的插入函数 e.g. s.insert(s.begin(),c) or s.insert(s.end(),c) 3.string的拼接 s=(string)“aaa”+“bbb”; （一定要强制类型转换） s=‘a’+(string)“kkk”; （string要强制类型转换，char是不能转成string） E - Divisible Substring ","date":"2020-03-08","objectID":"/abc158/:0:12","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:13","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 给一个仅由数字组成的字符串和质数p，问有几个子串（连续字符组成的）能够被p整除 ","date":"2020-03-08","objectID":"/abc158/:0:14","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 个人感觉出的特别好的一道题 动态规划+后缀 从最后开始向前遍历每个数 ans+=（以当前数为开头，满足条件的个数） 要求以当前数开头，满足条件的个数，就是个区间问题 这个区间问题可以用后缀来求 当两个后缀模p的余数相等时，这个区间内的数能被p整除（2和5除外） 所以问题转化成求此时的后缀（余数），查询之前和这个余数相等的个数 然后ans+=个数 注意特殊处理一下2和5 以下是对上面结论的证明（实际并不需要严格证明） ac代码 #include\u003cbits/stdc++.h\u003e using namespace std; using ll=long long; int n,p; string s; map\u003cint,int\u003e mp; //存余数和对应的个数 ll ans=0; int main() { ios::sync_with_stdio(false); cin.tie(0); //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003ep\u003e\u003es; if(p==2 or p==5) { int pt=p; for(int i=0;i\u003cn;i++) if((s[i]-'0')%pt==0) ans+=i+1; } else { mp[0]++; int num=0; int m=1; for(int i=n-1;~i;i--) { num=(num+(s[i]-'0')*m)%p; ans+=mp[num]; mp[num]++; m=(m*10)%p; } } cout\u003c\u003cans\u003c\u003cendl; return 0; } F - Removing Robots ","date":"2020-03-08","objectID":"/abc158/:0:15","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题目链接 ","date":"2020-03-08","objectID":"/abc158/:0:16","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题意 数轴上有n个点，每个点有两个属性（坐标和能够向右移动的距离），随意地激活其中几个点，激活的点必须向右移动该距离，若移动过程中碰到点则那个点被激活，求对于所有的激活情况，最后的结果有多少种 ","date":"2020-03-08","objectID":"/abc158/:0:17","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["abc"],"content":"题解 动态规划+栈优化 从右往左遍历每个点 给每个点设置一个数值，表示遍历到该点的集合数量（即答案） 判断这个点是否可以覆盖右边的点，可以覆盖，则这个点的数值乘上覆盖点的数值 用栈维护每个遍历的点，如果栈顶没有被覆盖，则栈里面都无需遍历 被覆盖的点就出栈 新的点入栈（因为旧的点被新的点覆盖，集合数已经被新的点记录） 最后遍历一遍栈，累乘数值 ac代码 #include \"bits/stdc++.h\" using namespace std; using ll = long long; ll n; const ll mod=998244353; vector\u003cpair\u003cint,int\u003e\u003e vt; //存输入 stack\u003cpair\u003cint,int\u003e\u003e stk; //将不覆盖的点入栈 ，用栈优化（对于正在检测的点，如果栈顶不满足，则栈里面的都不满足） //存点的坐标（identifier）和扫描到这个点时，它满足的集合数量 int t1,t2; int main() { //freopen(\"input.txt\",\"r\",stdin); ios::sync_with_stdio(false);cin.tie(0); cin\u003e\u003en; for(int i=0;i\u003cn;i++) { cin\u003e\u003et1\u003e\u003et2; t2+=t1; vt.emplace_back(t1,t2); } sort(vt.rbegin(),vt.rend()); //这种题目几乎都要sort 此处逆序遍历 for(int i=0;i\u003cn;i++) { ll t=1; //cout\u003c\u003cstk.empty()\u003c\u003cendl; while(!stk.empty() \u0026\u0026 vt[i].second\u003estk.top().first) //遍历栈 注意开区间 { t=(t*stk.top().second)%mod; stk.pop(); } //cout\u003c\u003ct\u003c\u003cendl; stk.push(make_pair(vt[i].first,t+1)); //!!!!! 一定要加1，因为枚举集合数的时候，对于每个点分两种情况（激活和不激活） } ll ans=1; while(!stk.empty()) { ans=(ans*stk.top().second)%mod; stk.pop(); //cout\u003c\u003cans\u003c\u003cendl; } cout\u003c\u003cans%mod\u003c\u003cendl; return 0; } debug了一小时 发现自己手贱，在声明vector的时候给它分配了空间，然后就出现迷之错误 （我一定是有病才会这么做） 感觉自己的思维和英语都退步了 oh shake it 又没有学习android ","date":"2020-03-08","objectID":"/abc158/:0:18","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"/abc158/"},{"categories":["GAME"],"content":"波斯王子","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["GAME"],"content":"波斯王子 prince of persia是ubisoft于1989年发行的一款单机游戏 波斯王子有好多部，前3部是一个完整的故事，后面则是一些衍生 这是我2010年玩的游戏，pop1通关了4遍 作为上个世纪的游戏，画质不能与现在的3A大作比 但是，有一说一画质也不差 环境的渲染也特别棒，很符合故事背景，有很多细节 游玩的时候不禁会让人驻足联想 剧情真的很不错，以时间倒流作为主要技能是很大的创新 也增加了游玩的乐趣 值得一提的是，据官方称，这个游戏有六百多种动作 按键的组合确实可以打出很多不同的动作，但前期在战斗的时候基本只需要靠几个动作 pop2应该是最难的一部，小boss血量巨厚 如果我没记错的话，pop3应该是加入了刺杀系统，在当时是一个很大的创新，而且感觉还不错 对于boss来讲，要一遍过还挺难 黑暗王子的20倍攻击力用的太爽了 pop的跑酷系统在当时做的着实优秀 ","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/:0:0","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["GAME"],"content":"游戏剧情 很多人都认为，时间就像一条河流，永远朝着一个方向不断的前进。 印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，并带走了时间女皇的遗物——时之沙漏和时之匕首。 后来，为了将这两件宝物据为己有，以达到长生不老的目的，维瑟尔背叛了穆罕默德。他怂恿波斯国王沙拉曼攻打印度，并承诺作为内应会打开印度的城门。战争结束，沙拉曼得到了时之沙漏，并且俘虏了印度国的公主法拉。而波斯王子由于在战争中的杰出表现，得到了他的第一件战利品——时之匕首。 波斯大军凯旋在阿扎德苏丹皇宫暂时停留时，心怀怨恨的维瑟尔诱惑波斯王子用匕首打开时之沙漏，释放的时之砂瞬间吞噬了整个皇宫，并且将沙拉曼变成了砂之怪物。 王子不得已杀死了自己的父亲，在悲痛欲绝中，逃脱的印度公主法拉告诉王子，只要将时之匕首重新插进时之沙漏，那么时间就会倒退，回到一切的开始。于是王子和法拉开始了他们的冒险。 随着冒险的不断深入，王子和法拉的情感也在发生微妙的变化。最后，法拉悄悄的带着时之匕首离开了王子。王子找到了法拉，但却眼睁睁的看着法拉坠楼身亡。哀伤的王子夺回了匕首并将其插进了沙漏里。 伴随着维瑟尔绝望的呼叫，时间倒退到了波斯军队进攻印度之前。保留着记忆的王子在进攻的前夜悄悄的潜进了公主法拉的卧室，告诉了她一切，包括维瑟尔的背叛。被揭穿的维瑟尔恼羞成怒，想要杀掉法拉嫁祸给王子，但被王子消灭了。后来，王子劝说他的父亲沙拉曼撤走了军队，一切好像都恢复了平静。但是谁也没有料到的是，王子的命运已经被诅咒：任何使用过时之匕首的人，只有死路一条。 “因为王子使用了时之匕首破坏了时间的平衡。而达哈卡就是为了恢复时间的平衡而诞生的，他就像时间一样是不可战胜的。达哈卡会像影子一样追杀着王子，直到王子的生命走到尽头。” 王子是从一位盲眼老人那里得到了自己的命运被诅咒这个消息的。为了改变自己悲惨的命运，王子打算去时之岛，回到过去，回到时间女皇制造时之沙的那一刻，去阻止时之沙的诞生。 历经艰难的王子终于到达了时之岛，并且通过岛上的时间传送点回到了过去。在那里，王子遇到了一位名叫凯琳娜的红衣少女。凯琳娜帮助了王子，她告诉了王子如何去打开时间女皇所在房间的门的机关。 在冒险的过程中，一个神秘的黑衣人不时在王子周围出现，不知是敌是友。更让人感到诡异的是，最后时间的守护者达哈卡突然在王子和黑衣人的面前出现，但是达哈卡却杀掉那个黑衣人，然后没有理会王子就走了！纳闷的王子按照凯琳娜的帮助打开了时间女皇房间的大门，却又愕然发现原来凯琳娜就是时间女皇！怨愤的凯琳娜告诉王子，她之所以帮助王子，就是想让王子在打开大门的过程中被那些机关杀死，或者被时间守护者达哈卡杀死。原来凯琳娜也通过时间线预知到了自己的命运：她将会被波斯王子亲手杀死！同样为了改变自己悲惨的命运，时间女皇和王子展开了一场生死战，最后王子逼不得已只好杀掉了凯琳娜！ 凯琳娜在临死之前告诉王子：没有人能改变自己的命运，你也会像我一样去奋力，但你也会像我一样死去！随后，凯琳娜的尸体迸发出了金色的光芒。 王子通过时间传送点回到了杀死父亲之前。本以为一切都结束的王子突然发现时间的守护者达哈卡仍然在追杀他。这时王子才想起来，凯琳娜死后那些金色的光芒就是时之沙！（王子本以为时之沙是时之女皇凯琳娜制造的，杀死凯琳娜就可以阻止时之沙的诞生，但事实是时之沙的诞生正是因为王子杀死了凯琳娜，时之沙就是凯琳娜死后尸体变成的）绝望的王子被达哈卡困在了一个地下墓穴里。就在万念俱灰之时，墙壁上的文字吸引了王子的注意。 根据文字记载：当年印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，在夺取时之沙漏的过程中，穆罕默德不幸被时之守卫杀死，但幸运的是，一件黑色的面具让他有了第二次机会…… 就像在黑暗中看到了一丝曙光一样，王子暂时摆脱了达哈卡的追杀，去寻找那件黑色面具。终于在时之岛的尽头，王子找到了黑色面具。戴上了面具的王子回到了他刚到时之岛的那一刻，并且变成了一个黑衣人——原来在他冒险的过程中时隐时现的黑衣人其实就是他自己。 又经过一番努力，王子最后阻止了自己被达哈卡杀掉（本来达哈卡杀掉了黑衣人，但王子没有让这件事情发生，达哈卡转而杀掉了原来的王子），王子又变回了原来的样子。由于知道了接下来将要发生的事情，王子决定利用时间传送点把时间女皇凯琳娜带到之前。这样即使凯琳娜死了时之沙也不会威胁到自己。变身回来的王子成功的把凯琳娜带到了之前，但是时间的守护者达哈卡再度现身，只不过这次他的目标换成了凯琳娜。这是理所当然的，凯琳娜本来不属于这个时代，为了维护时间的平衡，达哈卡自然把矛头对准了她。因为不忍心凯琳娜就这样被达哈卡杀死，王子利用从过去带回来的一把水之刃（此刀可以伤害到达哈卡），与达哈卡展开了一场肉搏战。 最后在凯琳娜和王子的配合下，达哈卡居然奇迹般的被消灭了。胜利的王子打算带着凯琳娜一起回到他的故乡——波斯的巴比伦城，想从此过着平静的生活。但此时的巴比伦城正被战火所蹂躏……盲眼老人的声音仍在萦绕在王子心头：你不可能改变自己的命运，没有任何人可以。 几个星期后，王子带着凯琳娜离开了时之岛回到了他故乡巴比伦城，却发现整个巴比伦城陷入一片火海中。震惊和愤怒的王子不敢相信眼前的一切，但随后他的船就被飞来的火球打翻，并且和凯琳娜失散。 昏迷的凯琳娜被侵略军带到了巴比伦皇宫里。王子紧随其后想要去救她。在皇宫中，愤怒的王子不幸被敌人擒住，但他却愕然发现侵略军的首领居然是那个“已经被自己杀死的”邪恶法师维瑟尔！而维瑟尔居然又不认识自己？原来，当王子把时间女皇凯琳娜带到之前的一霎那，历史就已经发生了改变：由于没有时之沙，维瑟尔也就不会去背叛穆罕默德，也就没有了波斯进攻印度的历史，维瑟尔也就不会认识王子，当然也不会被王子杀死了。 历史已经改变，但依然改变不了维瑟尔邪恶的欲望。 多年以前，印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，与原先的历史不同，他们只找到了一把时之匕首，至于传说中的时间女皇和时之沙则没有任何存在过的痕迹。已经对时之沙快要放弃的维瑟尔却突然发现时之匕首在最近几个星期变得活跃了起来，维瑟尔很快明白了究竟发生了什么事情：时间女皇来到了之前！被长生欲望熏昏了头脑的维瑟尔杀死了穆罕默德，囚禁了印度公主法拉，控制了印度的军队来进攻巴比伦城！企图寻找时间女皇！时间女皇凯琳娜终于落在了维瑟尔手中！残忍的维瑟尔用时之匕首杀死了凯琳娜，释放出了时之砂，他又将匕首插进自己的身体里，随后变成了一个金黄色的怪物——维瑟尔终于达到了他长生不老的愿望。整个巴比伦城被时之沙吞没，那些侵略军全部被感染到了时之砂，变成了沙之怪物，就连王子自己的手臂也被时之砂侵入。危急时刻，王子挣脱了束缚，抢走了时之匕首，离开了巴比伦皇宫。时之沙唤起了王子最大的敌人…… 被时之沙感染的王子感觉到体内产生另一个邪恶的人格——黑暗王子。黑暗王子狡猾，残忍，对弱者没有同情心，但在冒险的时候王子却需要变身成黑暗王子来渡过难关。 在这种奇怪的组合下，王子又遇到了自己爱慕的印度公主法拉。法拉被维瑟尔囚禁后也被带到了巴比伦城。后来法拉在时之沙的混乱中逃脱，遇到了游荡在巴比伦城的王子。起初法拉对波斯王子的双重身份深感怀疑，但在随后的冒险中逐渐与王子重新建立了信任和友情（法拉再次遇见王子的时候也和维瑟尔一样不认识他了）。但在冒险的过程中，黑暗王子的感染变得越来越严重，这让王子本身深感不安。不幸的是，冒失的法拉又被维瑟尔抓住，而王子被打入了一个黑暗的深洞里。 最后，在巴比伦城黑暗的地下宫殿里，王子找到了他父亲波斯王沙拉曼的尸体。悲痛的王子拿起父亲的宝剑，抑制住了邪恶的黑暗王子的意识，决心找维瑟尔复仇。 在巴比伦的空中花园，左手持波斯帝王宝剑，右手持时之匕首的王子与维瑟尔展开了一场决战！胜利的王子将时之匕首插进了维瑟尔的心脏，彻底的终结了这个邪恶的灵魂。 已经变成时之沙的凯琳娜再度幻化成人形来跟王子告别：这个世界本不属于我，自有我所归属的世界……王子将时之匕首交给凯琳娜，凯琳娜化做时之砂，向远方飘散而去。 凯琳娜消失之后，黑暗王子从王子的内心世界中分裂出来，企图夺走王子的一切，但王子走出内心的阴霾，最终在虚幻的世界中消灭了黑暗王子。 时之砂消逝，邪恶力量破灭，波斯帝国的子民为王子所拯救，一切都结束了。 在巴比伦的空中花园，王子再次向法拉讲起了那个时间的故事。–百度百科 ","date":"2020-03-08","objectID":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/:0:1","tags":[],"title":"波斯王子","uri":"/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/"},{"categories":["GAME"],"content":"刺客信条2","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"ac2由育碧蒙特利尔工作室开发 十年前玩的游戏，环境渲染和剧情真的超棒 背景音乐选的十分用心 后来主角ezio也成为了刺客信条系列的标志 刺客信条系列基本延续着刺客和圣殿骑士（现在的abstergo）的斗争，进入animus为追求祖先记忆，寻找金苹果讯息。。。 续作兄弟会的剧情显得有些乏味，不过以组建兄弟会为主线的游戏安排还是很可以的 线上有更丰富的内容 ","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/:0:0","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"剧情 刺客信条2： Desmond在刺客信条1之后本来是准备要处死的，但是Lucy帮他逃了出来，和另外两个现代刺客会合。为了找到伊甸园圣器的下落，Desmond不得不再次进入刺客兄弟会的机器Animus 2.0，这一次他成为了中世纪佛罗伦萨的贵族Ezio Auditore(艾奇奥)。Ezio的父亲和两个兄弟被陷害以后，他在自己的叔叔Mario Auditore(马里奥)的帮助下脱离险境，并且知道自己的家族是刺客家族。于是他开始自己的复仇之路。在复仇的过程中，Ezio慢慢知道了伊甸园圣器的事，并且自己也在慢慢成长，直到有一次圣殿骑士从外地运回威尼斯一件很重要的物品，被Ezio夺到，原来就是金苹果。 于是Ezio发现一个事实，就是在罗马有一件伊甸园圣器“教皇权杖”，它和“金苹果”结合就能打开一些秘密。于是刺客们就前往罗马，一来为了杀死陷害Ezio一家的罗马教皇Rodrigo Borgia(罗德里格·波奇亚)，二来为了抢夺教皇权杖。谁知Rodrigo早有准备，反刺伤了Ezio，抢了他的金苹果。但是Rodrigo没有刺客的血统，结合了教皇权杖和金苹果，但却无法激活。而后Ezio赶来，两人赤手空拳搏斗，Ezio最终胜利，但心一软没有杀死这位陷害自己一家的幕后主使。Rodrigo逃脱。Ezio身为正统刺客，发现自己的血统使两件伊甸园圣器合体激活，打开了罗马教堂地下的一间密室，而密室中出现的影像却是给后来人，也就是给现代正统刺客Desmond的信息。然而回到现代，正在此时，圣殿骑士出现，Lucy和Desmond不得不展开战斗，Desmond通过Animus的血统效应已经学会了Ezio的一些技能，击退了圣殿骑士以后逃离。 刺客信条兄弟会： Desmond和Lucy一行人一直逃到蒙特奥吉欧尼，也就是中世纪Ezio叔叔Mario的庄园。他们开始继续搜索金苹果的下落。回到Animus中，Ezio打败Rodrigo之后载誉归来，回到Mario的庄园，但不想第二天凌晨，Rodrigo的儿子Cesare Borgia带兵攻打庄园，并最终抢夺了金苹果，还杀死了Mario。Ezio也只能带伤逃离。逃离了以后，他孤身一人来到罗马，再次踏上了复仇之路。在Machiavelli(马基雅维利)、Da Vinci(达芬奇)和罗马当地的佣兵、交际花和盗贼的帮助下，Ezio解放了罗马，拿回了金苹果，并最终杀死了Cesare。夺回金苹果后，Ezio把它埋在了罗马大剧场地下的一间密室里。回到现代，Desmond等人立即赶往罗马大剧场遗址，并进入密室，拿到了金苹果。但Desmond一碰到金苹果之后就被控制，不由自主走向Lucy，刺杀了她，随后陷入了昏迷。 刺客信条启示录： Desmond昏迷之后，其他刺客急忙将他放回了Animus，希望通过Animus能让他苏醒。在Animus中，Desmond的意识和肉体已经分离，他的意识遇见了另一位在Animus中游荡的“16号”意识，来自一位现代已经遇害的刺客。16号告诉他只有在Altair(阿泰尔，刺客信条1主角)、Ezio和Desmond完全同步的时候才能让Desmond找回自我。于是Desmond第三次进入了Ezio的记忆。 Ezio为了寻找古老刺客的知识，来到了Altair所在的马西亚夫城堡，发现一间Altair建造的密室。为了打开密室，Ezio必须找到五把Altair留下的钥匙，而这些钥匙已经被当时马可波罗的父亲带去君士坦丁堡埋藏。到了君士坦丁堡之后Ezio卷入了宫廷斗争，还认识了一位有魅力的女人Sofia(索菲亚)。找到五个钥匙之后，Ezio和Sofia一起回到了马西亚夫城堡，打开了密室，见到了Altair的遗体和Altair留下的另一个力量更强大的金苹果。这时金苹果又被激活，Altair、Ezio和Desmond的意识完全同步，Desmond聆听了人类诞生前的文明留下的信息，需要Desmond拯救世界。在那之后，Ezio扔下了身上的武器，把它们和金苹果放在一起留在了密室，结束了自己的刺客生涯。回到现代，Desmond从Animus中苏醒了过来。 刺客信条-余烬：Ezio老年和Sofia生活在佛罗伦萨郊外的一片农庄里，他们有两个孩子。有一天来了一个中国女刺客，为了刺杀残暴的嘉靖皇帝来向Ezio求教。帮助了女刺客之后，有一天Ezio在和Sofia逛街的时候疾病突发，安详仙去。 当我还年轻时，我身怀自由，但我并未看出它的存在，我有大把的时间，可我不懂得珍惜，我还拥有爱，但是从未真实地感受过它，我花了好几十年才明白这三者的真正意义，但现在，在我生命中的黄昏，这些认知逐渐转变成了幸福。爱，自由，时间,曾经随意丢弃的这些，原来正是驱使我前行的动力，而在这三者中，爱尤其宝贵。以此献给你和我们的孩子，以及我们的兄弟姐妹，还有这个赋予我们生命与好奇的广袤世界。索菲亚，我对你的爱永无止境——无论何时都属于你的——艾吉奥·奥迪托雷 Ezio写给Sofia Sorto的遗书 —来自网络 ","date":"2020-03-08","objectID":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/:0:1","tags":[],"title":"刺客信条2","uri":"/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/"},{"categories":["GAME"],"content":"光环1","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"halo1是微软于2001年发行的第一人称射击游戏 halo是一个很注重武器选择的游戏，合适的武器会非常高效 ","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/:0:0","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"剧情 2160-2200：早期冲突 这一时期的人类历史充斥着太阳系中各大政府和派别之间的一系列血腥冲突。具有重大历史意义的冲突包括：木卫战役（Jovian Moons Campaign）、雨林争霸（The Rain Forest Wars）和一系列的火星遭遇战。 随着地球上人口过剩和政局动荡的愈演愈烈，许多新的政治运动兴起了。这一时期最值得注意的政治异端运动是“科思洛维克”（“Koslovics”)和 “福里登”（“Frieden”)运动。“科思洛维克”是指新共产主义者的强权领袖福拉德米亚·科思洛夫(Vladimir Koslov）的拥护者，他们致力于回到共产主义的光荣岁月，要消灭公司和资本家的流毒，特别是要肃清近地轨道和地外殖民地。 “福里登”运动是法西斯主义的复兴，该运动起源于反“科思洛维克”情绪，扎根木星殖民地为据点（很大程度上受到了统一德意志共和国企业的支持，这些企业常常成为科思洛维克“工人起义”的对象）。“福里登”的字面意思是“和平”－－这就是说，他们相信只有消灭了“人类的暴君”（oppressors on Terra Firma），才可能达成和平。 2160 三月－六月：木卫战役开始 木星分裂主义者袭击了位于木卫一爱莪（Io）的联合国殖民地总署（United Nations Colonial Advisors），导致了地球军与木星“福里登”部队之间展开了长达三个月的激战。虽然这并非我们太阳系中的第一起武装冲突，但此役成了最为血腥的战斗之一，也被普遍认为是引发接下来的摩擦和军国主义大潮的导火索。 木卫战役也升级了地球各国政府间的紧张关系－－许多国家在太阳系中都建立了殖民地，开始为各自在地外的利益而开战。殖民地战争的持续，使得地球上的紧张关系一触即发，引发了地球本土的数起武装冲突。 2162：雨林争霸 武装冲突横扫南美大陆，科思洛维克、福里登和联合国军之间因为不同的意识形态而开战。而这又加剧了地外冲突。 2163 十二月：在火星的战斗 地球三股主要派别将雨林争霸中燃起的战火烧到了火星上。一系列在火星Argyre Planitia附近对科思洛维克军的闪电战，是第一次非地军队的部署。战斗取得了决定性胜利。作为结果，后来的军事指导战略，惯用大编制的地面部队突袭配合舰船登陆行动。 2164：星际大战 联合国军开始形成大规模集结的格局，终于迎来了第一次真正的星际大战。继火星的军队部署告捷后，大规模的征兵行动和宣传策略极大地鼓舞了UNSC (United Nations Space Command，联合国太空司令部）军队的士气。联合国军挫败了地球上的科思洛维克和福里登军队，接着开始系统地专注于驱逐其在太阳系内其他行星上建立起来的残存势力。在这些局部战争后，福里登和科思洛维克军队被庞大、统一而强大的联合国军悉数剿灭。 2170：膨胀 2160年代的战乱促使人们建立了统一的地球政府。现在，胜利者必须处理不太引人注目却同样严重的威胁：人口过剩和无仗可打的庞大军队。 战后的岁月里，大量人口急剧膨胀；雨林争霸遗留的资源破坏和饥荒更是雪上加霜，世界经济岌岌可危。 2291：超越光速 一支由研究人员、物理学家和数学家组成的团队正在秘密研发“肖恩·藤川”超光速引擎（Shaw-Fujikawa Translight Engine，SFTE），一种驱动太空船穿越辽远星际的特殊手段。 这种新型引擎允许飞船钻入“跃迁空间”（“the Slipstream\"或\"Slipspace”，又称为“迁跃断层空间”）。“断层”一个变通的物理法则下的空间，允许超光速旅行而避免相对论的副作用。超光速旅行并不是瞬间完成的；“短程”的跳跃一般要花两个月，而“长程”的跳跃则能持续六个月甚至更久。 SFTE能生成一个共振场，当与迁跃空间的物理特性结合时，就能大大缩短跨越星际的时间；然而，科学家们也注意到在迁跃空间内部会有暂时的涌流这一奇怪的“变数”。尽管人类科学家都无法确定为何星际旅行所需的时间不是一个常量，但有理论指出在迁跃空间内部存在“漩涡”或“涌动” －－正是这造成了星际旅行所需的时间会有百分之五到十的出入。这一暂时的不一致性使军事战术家和战略家颇为恼火－－这会妨碍许多协同作战的进行。 2310：初潮 地球政府向公众公布了一系列殖民船中的第一艘－－应征者相当踊跃。地球上的状况因为人口过剩而不断恶化，搭乘飞船去外星殖民自然成了诱人的选择。 每艘殖民船都配备了军队人员和护卫舰，这样有助于更好地利用现有的庞大舰队。在异端武装瓦解后，军队正消耗着庞大的军费和物资。 因为超光速旅行在此阶段还十分新鲜而又昂贵，殖民地居民和军队人员都要通过生理和心理的严格测试。原则上，只有最优秀的公民和士兵才能获准去“邻近”的世界殖民。这就是近地殖民地（Inner Colonies）的诞生。 2362：远征号 远征号（The Odyssey）于2362年1月1日发射。作为浩浩荡荡的殖民舰队的领头舰船，远征号满载着部队和地貌改造装置，殖民的矛头直指新世界。人类超越太阳系的边界向外扩展的初潮由此拉开帷幕。 2390：近地殖民地 到了2390年，近地殖民地的殖民化运动正如火如荼。总计有210个人类占据的世界在进行不同程度的地貌改造，而在人类掌控的太空里，人口负担得到了巨大的缓解。 2490：远地殖民地的诞生 扩张仍在马不停蹄地进行，到2490年已经有800多个人类世界遍布银河系猎户座星臂了（这些世界形形色色，既有高度开化的星际要塞，也有偏僻的小定居点）。随着向外扩张的继续，近地殖民地成了政治和经济重镇，虽然他们极其仰赖远地殖民地提供的原材料。 在这一时期，致远星（planet Reach，围绕波江座第五恒星（Epsilon Eridani）运转，正当地球的咽喉要道）成为了UNSC的主要舰船制造厂和训练营地。致远星是战舰和殖民船的主要制造地，也是训练秘密特工和特种部队的所在地。 2525：星盟战争开始 2525年4月20日，与远地殖民地丰饶星（Harvest）的联络中断了。在试图重新建立联络的努力失败后，殖民军总参谋部 (the Colonial Military Administration，CMA）派遣了一艘侦查舰，金羊毛号（the Argo）前去调查。可是金羊毛号一到达丰饶星系，与飞船的联络也突然中断了。 CMA火速派遣了一支三艘战舰组成的战列舰队前往丰饶星。只有战列舰队领航的旗舰大力神号（the Heracles）返回了致远星，战痕累累，伤亡惨重。战舰的指挥官报告说，出现了一艘配备了强大武器的外星战舰，已经践踏了丰饶星，血洗了殖民地（很可能也已摧毁了金羊毛号）。 战列编队很快遭遇了外星战舰，并被紧密跟踪。在两艘战舰被击毁后，大力神号迅速跳出了星系，但因为受损严重，几周之后大力神号才回到了致远星。 地球军立即提升了警报级别，开始积极准备收复丰饶星的作战计划。当年12月，由普雷斯顿·科尔（Preston Cole）中将率领的地球军舰队浩浩荡荡地出发了，如此快地派出如此庞大的远征军，在人类历史上实数罕见。 2525：丰饶星战役 科尔率领的舰队誓报殖民星沦陷之仇，在与外星战舰的遭遇战中告捷－－尽管胜利的代价是损失了科尔军三分之二的有生力量。扭转战局的，只是科尔在最后几分钟，战术上的灵光乍现罢了。 军队回师地球之后，晋升为上将的科尔才获悉：许多外围殖民地已经沦陷，无人生还。科尔开始排兵布阵，准备对入侵者展开截击。地面战和舰船战相当惨烈，战火绵延到了整个远地殖民地。在一次地面遭遇中，人类部队俘虏了一个外星入侵者。在负伤过重死亡之前，人类得知这些外星人自称为“星盟” (the Covenant）。 远地殖民地大屠杀 在接下来的几年中，科尔部遭到了重创，他个人出色的领导力和战略才华也无济于事。这完全是一场实力悬殊的较量，星盟在舰船战中的胜率甚至接近四比一。 到了2535年11月，事实上所有的远地殖民地都已经惨遭星盟屠戮。“科尔协议”（Cole Protocol）作为军事命令确立了如下原则：所有的地球舰船必须确保星盟军不会发现地球。当地球舰船被迫撤退时，必须远离环地航线，甚至不做计算就进行超时空跳跃也在所不惜。 如果存在被星盟俘虏的危险，连“盲跳”都不可行时，船长必须下令船只自毁。此外，强大的舰船人工智能（AI）核心数据也切不可落入敌军之手。所以，科尔条款的部分内容也指出：在紧急状态下，必须转移或销毁舰船人工智能。 2536-2552：近地殖民地之围 星盟的铁蹄已经踏入近地殖民地。多年来的战事渐成定局：人类只是以极其高昂的代价赢得局部战斗的胜利，尤其是在地面行动中。而在太空对战中，人类的失利猝不及防，殖民地就这样接二连三地沦陷了。 2552：致远星的沦陷 星盟军终于到达了致远星－－这个离地球最近的重大军事要塞覆灭了。秋风之墩号（the Pillar of Autumn）巡洋舰，载着最后一个二期 (SPARTAN）斯巴达战士士官长逃出生天，幸免于难。所谓“斯巴达战士”指的是超级特种兵的一种精英作战单位，装备了令人望而生畏的雷神锤装甲。他们是人造的终极兵种。 现在，仅存一个斯巴达战士能与敌对决了。秋风之墩号的舰长雅各布·凯斯（Jacob Keyes）为了遵守“科尔条款”下令进行目的地未知的长程跳跃，希冀着能让星盟追兵始终远离地球。 引擎熄火后，秋风之墩发现自己落入了一个辽远未知的星系。星系中也有一支星盟舰队，他们附近有一个行星般大小的环状结构－－“光晕”。 2552-2553：地球战役 解决了“光晕”的问题之后，秋风之敦号一小部分幸存者和致远星上的部分幸存者合流，经过一系列艰辛的征战回到了地球。然而，此时星盟舰队也大举入侵。人类不得不为自己最后","date":"2020-03-08","objectID":"/%E5%85%89%E7%8E%AF1/:0:1","tags":[],"title":"光环1","uri":"/%E5%85%89%E7%8E%AF1/"},{"categories":["GAME"],"content":"刻痕","date":"2020-03-08","objectID":"/%E5%88%BB%E7%97%95/","tags":[],"title":"刻痕","uri":"/%E5%88%BB%E7%97%95/"},{"categories":["GAME"],"content":"《刻痕》是由蓝天使制作组制作的2D动画游戏，于2008年发行，是一款恐怖推理解谜游戏 《刻痕》是国内原创推理悬疑解谜（猎奇）游戏的始祖，国内第一个以R15作为GALGAME正式标准的游戏，也是国内第一个R15类型的推理悬疑解谜（猎奇）类游戏，刻痕系列首次在国内提出了带有悬疑、血腥、恐怖或者猎奇要素的游戏，要以R15作为分类标准的概念，此分类概念在后来在国内整个GALGAME行业业界被得以广泛认可，并被普遍流传使用。 ","date":"2020-03-08","objectID":"/%E5%88%BB%E7%97%95/:0:0","tags":[],"title":"刻痕","uri":"/%E5%88%BB%E7%97%95/"},{"categories":["abc"],"content":"abc157","date":"2020-03-02","objectID":"/abc157/","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"A - Duplex Printing 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:0","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 每一页正反两面可以分别写一个数，问有n个不同的数可以写几页 ","date":"2020-03-02","objectID":"/abc157/:0:1","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 简单模拟 ac代码如下 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a; cin\u003e\u003ea; if(a\u00261) cout\u003c\u003ca/2+1\u003c\u003cendl; else cout\u003c\u003ca/2; return 0; } B - Bingo 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:2","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 有一个3*3的网格填满数字，接下来给出一些数字，如果网格中有，就标记。 问是否存在一行或一列或对角线满足它们都被标记 ","date":"2020-03-02","objectID":"/abc157/:0:3","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 由于数据不是很大，所以暴力模拟 ac代码如下 #include\u003ciostream\u003e using namespace std; bool b[3][3]; int main() { int d[3][3]; int n; for(int i=0;i\u003c3;i++) for(int j=0;j\u003c3;j++) cin\u003e\u003ed[i][j]; cin\u003e\u003en; int t; while(n--) { cin\u003e\u003et; for(int i=0;i\u003c3;i++) for(int j=0;j\u003c3;j++) { if(d[i][j]==t) { b[i][j]=true; break; } } } bool flag=false; for(int i=0;i\u003c3;i++) { if(b[0][i]== true and b[1][i]==true and b[2][i]==true) { flag=true; break; } } for(int i=0;i\u003c3;i++) { if(b[i][0]== true and b[i][1]==true and b[i][2]==true) { flag=true; break; } } if(b[0][0]==true and b[1][1]==true and b[2][2]==true) { flag=true; } if(b[0][2]==true and b[1][1]==true and b[2][0]==true) { flag=true; } if(flag) cout\u003c\u003c\"Yes\"\u003c\u003cendl; else cout\u003c\u003c\"No\"\u003c\u003cendl; return 0; } C - Guess The Number 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:4","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 给一个数位n，和若干个条件，条件类型为ai位必须是数字bi，求满足这些条件的最小n 位数，不满足输出-1 ","date":"2020-03-02","objectID":"/abc157/:0:5","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 数据很小，简单模拟，有很多的细节，注意一位数、前导0等特殊情况 由于边打代码边想，所以代码很乱 ac代码如下 #include\u003cbits/stdc++.h\u003e using namespace std; bool use[3]; int main() { int d[3]; int n,m; cin\u003e\u003en\u003e\u003em; int s,c; bool flag=true; for(int i=0;i\u003cm;i++) { cin\u003e\u003es\u003e\u003ec; s--; if(n!=1 and s==0 and c==0) { flag=false; break; } else if(s\u003en) { flag=false; break; } else if(use[s] and c!=d[s]) { flag=false; break; } else { d[s]=c; use[s]=true; } } if(n!=1 and !use[0]) { d[0]=1; for(int i=1;i\u003cn;i++) { if(!use[i]) d[i]=0; } } else { for(int i=0;i\u003cn;i++) { if(!use[i]) d[i]=0; } } if(!flag) cout\u003c\u003c-1\u003c\u003cendl; else { for(int i=0;i\u003cn;i++) { cout\u003c\u003cd[i]; } cout\u003c\u003cendl; } //cout\u003c\u003cuse[2]\u003c\u003cendl; return 0; } D - Friend Suggestions 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:6","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 有n个人和两种关系（双向的）friendship 和 blockship 定义：一个人为另一个人的friend candidate 当且仅当满足他们没有这两种关系且他们之间存在着friendship的传导链 问每个人的friend candidate数量 ","date":"2020-03-02","objectID":"/abc157/:0:7","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 由于需要friendship传导链，又存在friendship的双向关系，所以考虑并查集 再遍历一遍信息，如果是直接的friendship和blockship关系就减掉这个人（数量减1） （需要计算集合元素个数） ac代码如下 #include\u003cbits/stdc++.h\u003e using namespace std; int n,m,k; //union find int par[100005]; int rankk[100005]; int sizz[100005]; int ans[100005]; int a[100005]; int b[100005]; int c[100005]; int d[100005]; void init(int n) { for(int i=0;i\u003cn;i++) { par[i]=i; rankk[i]=0; } } int find(int x) { if(par[x]==x) return x; else return par[x]=find(par[x]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return ; if(rankk[x]\u003crankk[y]) par[x]=y,sizz[y]+=sizz[x]; else { par[y]=x; sizz[x]+=sizz[y]; if(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y) { return find(x)==find(y); } int main() { ios::sync_with_stdio(0);cin.tie(0); //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003em\u003e\u003ek; init(n); fill(sizz,sizz+n,1); for(int i=0;i\u003cm;i++) { cin\u003e\u003ea[i]\u003e\u003eb[i]; } for(int i=0;i\u003ck;i++) { cin\u003e\u003ec[i]\u003e\u003ed[i]; } for(int i=0;i\u003cm;i++) { unite(a[i],b[i]); } for(int i=1;i\u003c=n;i++) { ans[i]=sizz[find(i)]; } for(int i=0;i\u003cm;i++) { if(same(a[i],b[i])) { ans[a[i]]--; ans[b[i]]--; } } for(int i=0;i\u003ck;i++) { if(same(c[i],d[i])) { ans[c[i]]--; ans[d[i]]--; } } cout\u003c\u003cans[1]-1; for(int i=2;i\u003c=n;i++) { cout\u003c\u003c\" \"\u003c\u003cans[i]-1; } cout\u003c\u003cendl; return 0; } E - Simple String Queries 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:8","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 给一个只有小写字母的字符串s，和两种操作 将ai下标的字符替换成bi 查询l到r区间内有多少个不同的字母，输出结果 ","date":"2020-03-02","objectID":"/abc157/:0:9","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 数据太大，不能简单模拟 用合理的数据结构 用26个集合存储有这个字母对应的下标 对于查询区间，遍历26个集合，查询这个区间是否存在该字母（如果存在 ans++） 只需要对每个集合二分搜索左边界的标号，如果这个标号在右边界内，即存在 ac代码如下 #include\u003cbits/stdc++.h\u003e using namespace std; int n,q; string s; set\u003cint\u003e st[27]; int main() { ios::sync_with_stdio(false);cin.tie(false); //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en; cin\u003e\u003es; cin\u003e\u003eq; for(int i=0;i\u003c26;i++) { st[i].insert(n); //防止使用lower_bound时集合为空 } for(int i=0;i\u003cn;i++) { st[s[i]-'a'].insert(i); } int t; for(int i=0;i\u003cq;i++) { cin\u003e\u003et; if(t==1) { int a;char b; cin\u003e\u003ea\u003e\u003eb; st[s[a-1]-'a'].erase(a-1); st[b-'a'].insert(a-1); s[a-1]=b; } else { int l,r; cin\u003e\u003el\u003e\u003er; int ans=0; for(int i=0;i\u003c26;i++) { auto it=st[i].lower_bound(l-1); if(*it\u003c=r-1) ans++; } cout\u003c\u003cans\u003c\u003cendl; } } return 0; } F - Yakiniku Optimization Problem 题目链接 ","date":"2020-03-02","objectID":"/abc157/:0:10","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"题意 平面上有n个点，每个点有一个属性ci，坐标上至少存在一个点使得这个点到其中k个点 的距离*ci（只对k个点中的一点）的值的最大值最小 输出最小值 ","date":"2020-03-02","objectID":"/abc157/:0:11","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["abc"],"content":"思路 有趣的计算几何 很难通过找到点来求最小值 很常见的做法是用二分法 区间的值为“最大值“ 每一次检查满足“最大值”的点是否超过k个 超过则将最大值减小 否则将最大值增大（理论上直到满足k个点） 通过精度来停机 怎样检查？ 每个点的属性=当前“最大值” / ci 以点为圆心，每个点的属性为半径，每两个圆可能存在交点 遍历每个点，如果交点在某个点的属性范围内，这个点也满足条件 遍历所有情况，求最多有多少个点满足条件 以此来检查是否超过k 注意点 1.只有一个点的特判 2.要有eps，而且eps不能太大也不能太小 3.为避免重复计算，j从i开始，但不能从i+1开始，因为有可能目标点就在某一点上 从i+1开始会wa掉1个测试点 ac代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; int n, k; double x[65], y[65], c[65], r[65]; double eps = 1e-8; //!!! double dist(pair\u003cdouble, double\u003e p, pair\u003cdouble, double\u003e q) { double xx = (p.first - q.first)*(p.first - q.first); double yy = (p.second - q.second)*(p.second - q.second); return sqrt(xx + yy); } vector\u003cpair\u003cdouble, double\u003e\u003e circle_circle_intersection(double x1, double y1, double r1, double x2, double y2, double r2) { vector\u003cpair\u003cdouble, double\u003e \u003e ans; double d = dist(make_pair(x1, y1), make_pair(x2, y2)); if (d \u003e r1 + r2) { return ans; } if (x1 == x2 \u0026\u0026 y1 == y2) { ans.push_back(make_pair(x1, y1)); return ans; } if (d \u003c abs(r1 - r2)) { ans.push_back(make_pair(x1, y1)); return ans; } double a = (r1*r1 - r2*r2 + d*d)/(2*d); double h = sqrt(r1*r1 - a*a); double x3 = (x2 - x1)*(a/d) + x1; double y3 = (y2 - y1)*(a/d) + y1; ans.emplace_back(x3 + h*(y2 - y1)/d, y3 - h*(x2 - x1)/d); ans.emplace_back(x3 - h*(y2 - y1)/d, y3 + h*(x2 - x1)/d); return ans; } int check(double t) { int ans = 0; for (int i = 0; i \u003c n; i++) { r[i] = t/c[i]; } for (int i = 0; i \u003c n; i++) { for (int j = i; j \u003c n; j++) { //!!! vector\u003cpair\u003cdouble, double\u003e \u003e pts = circle_circle_intersection(x[i], y[i], r[i], x[j], y[j], r[j]); for (auto p: pts) { int cnt = 0; for (int k = 0; k \u003c n; k++) { if (dist(p, make_pair(x[k], y[k])) \u003c= r[k] +eps) cnt++; } ans = max(ans, cnt); } } } return ans; } int main() { ios::sync_with_stdio(0); cin.tie(0); cin \u003e\u003e n \u003e\u003e k; if (k == 1) { cout \u003c\u003c \"0\\n\"; exit(0); } for (int i = 0; i \u003c n; i++) { cin \u003e\u003e x[i] \u003e\u003e y[i] \u003e\u003e c[i]; } double l = 0, r = 100000000; while(r-l\u003e=1e-8) { double mid = (l + r)/2; if (check(mid) \u003e= k) { r = mid; } else { l = mid; } } cout \u003c\u003c fixed \u003c\u003c setprecision(9) \u003c\u003c r \u003c\u003c '\\n'; return 0; } 个人感觉abc很考验思维和对数据结构的熟练度 ","date":"2020-03-02","objectID":"/abc157/:0:12","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"/abc157/"},{"categories":["test"],"content":"test for music and video","date":"2020-03-02","objectID":"/test-for-music-and-video/","tags":["test"],"title":"test for music and video","uri":"/test-for-music-and-video/"},{"categories":["test"],"content":"paste a music below [video(video-HXuIKyFl-1583157343324)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=93185992)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/393b26d243ae8f1c7b3cf4d1ba0bea2fd4015d85.jpg)(title-【暴走大事件】致 杠 精)] [video(video-QTmoAEnp-1585132330863)(type-undefined)(url-undefined)(image-https://img-blog.csdnimg.cn/editor-video.png)(title-undefined)] ","date":"2020-03-02","objectID":"/test-for-music-and-video/:0:0","tags":["test"],"title":"test for music and video","uri":"/test-for-music-and-video/"},{"categories":["test"],"content":"test","date":"2020-02-27","objectID":"/test/","tags":["test"],"title":"test","uri":"/test/"},{"categories":["test"],"content":"\rButton\rTry Element ","date":"2020-02-27","objectID":"/test/:0:0","tags":["test"],"title":"test","uri":"/test/"},{"categories":["note"],"content":"用hugo搭建个人博客网站","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"效果展示 在hugo官网也有说明如何搭建个人网站 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:0","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"注册github账号 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:1","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"创建github仓库 仓库的名字必须是 用户名.github.io 建议全小写 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:2","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"安装git bash（非必须，但建议） 点击此处 选择计算机对应的规格 一步一步安装 在使用前要进行初始化用户名和邮箱 打开终端（以powershell为例） 输入git命令，没有异常就可以 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:3","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"安装hugo 点击此处 选择计算机对应的规格 下载zip压缩包 解压后会得到 hugo.exe（这个是主要的） ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:4","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"创建博客 打开powershell 转到存放hugo.exe的文件夹下（hugo指令只能在这个目录下执行） 如果hugo指令识别不出来，可以配置环境变量 如果还是不行，那就用绝对路径，一直到hugo.exe 要启动hugo.exe就要用 .\\hugo 在存放hugo.exe的文件夹下，执行以下代码 \u003ehugo new site myblog myblog是自己起的名字，是一个identifier 之后会生成myblog文件夹 里面已经有一些东西了（大部分都是建立网站必须的） ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:5","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"下载主题 点击此处 选一个主题下载 下载有两种方式 1.点击download，转到作者github，下载zip 把zip转到myblog/theme下，需要改文件夹一些名字 2.在主题下面有git clone(推荐使用这种) 直接在powershell下面输入（一定要 cd 到myblog） 个别主题下载的慢，可以在不同时间不同地点多试试 下载完，myblog/theme 就会多出一个主题对应的文件夹（很重要） 以下是无论哪一种都要进行的操作 根据作者在hugo网页中写的文档进行初始化配置（就是把主题文件夹中的东西搬出来，替换什么的）（很重要，没有这一步，可能本地都打不开，疯狂报错）（但有些主题没有此过程） 尝试在本地打开 输入以下代码(以pure主题为例）(这个主题名字是theme下对应文件夹的名字) myblog\u003ehugo server -t pure 会得到一个本地网址 用浏览器打开这个网址 就可以在本地看到自己的网页 局域网内的用户也可以看到你的网页 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:6","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"部署到服务器上（github pages） 建议先在本地查看，确认无误之后再推到服务器 输入以下代码 注意不要写错 myblog\u003ehugo --theme=pure --baseUrl=\"https://你的用户名.github.io\" --buildDrafts myblog下会生成public文件夹 输入以下代码 myblog\u003ecd public public\u003egit init public\u003egit add . public\u003egit commit -m \"输入你自己的提交信息\" public\u003egit remote add origin https://github.com/用户名/用户名.github.io.git public\u003egit push -u origin master public\u003e 此过程中有可能需要输入github的账号和密码 访问 用户名.github.io就可以看到你的网页 会有延迟，需要等一会 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:7","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"配置主题和增加内容 配置因主题而异 通法就是认真仔细地阅读作者的文档 hugo/theme上的或者README.md（可见文档有多重要） 增加的内容一般都放在content文件夹下，当然也可以删掉内容 一般是markdown格式 写markdown可以用markdownpad / visual studio code / csdn自带的等等 但是发现一个问题，不同的编辑器预览的效果不一样 比如markdownpad不能很好的识别latex公式 有可能主题自带的markdown也不能很好的呈现出效果 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:8","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":["note"],"content":"更新网站内容 ！！！文件名字不能有 # 建议首先在本地预览，确认无误再上传 然后执行以下代码（含本地预览） myblog\u003ehugo server -t pure myblog\u003ehugo --theme=pure --baseUrl=\"https://你的用户名.github.io\" --buildDrafts myblog\u003ecd public public\u003egit init public\u003egit add . public\u003egit commit -m \"输入你自己的提交信息\" public\u003egit remote add origin https://github.com/用户名/用户名.github.io.git public\u003egit pull origin master public\u003egit push -u origin master public\u003e 一定要写git pull origin master 有延迟 打开 用户名.github.io 可以看到内容已经更新 之后更新网站内容就一直重复上述操作 =================== 以下是自定义域名（附加内容）===================== 在阿里云上面注册账号 实名制 购买域名 域名实名制 购买SSL证书（有免费的） 确定SSL证书有效 配置DNS服务器 在域名解析中添加记录 记录类型为CNAME 记录值填写 用户名.github.io（或者记录类型为A，记录值填写IP地址） 打开github对应的仓库 在settings中找到custom domain 输入新域名 在github pages下显示绿色的√就可以 访问新域名就可以看到网页了 之后更新的内容，都可以通过访问新域名实现 以上操作都需要时间，需耐心等待 个人博客网站基本搭建完毕 ","date":"2020-02-27","objectID":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/:0:9","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"categories":null,"content":"about","date":"2020-02-26","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"this is da1yh a graduate student major in software engineering at Zhejiang University currently learning … use c++, golang, python love swimming, coding, poppin thanks to “dillonzq” offering me theme template i set up this site as a self blog and paste some study experience if u wanna leave a message, feel free to contact me you can reach me by qq “244882973” or email “daiyh.xyz@outlook.com” or github account etc hope to receive your advice and talk 2 u ^_^ 2020.02.26 end ","date":"2020-02-26","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"anime","date":"2020-02-26","objectID":"/anime/","tags":null,"title":"Anime","uri":"/anime/"},{"categories":null,"content":"\u003c!DOCTYPE html\u003e\r乒乓                 小林家的龙女仆 第二季        小林家的龙女仆\r鬼灭之刃               鬼灭之刃 无限列车篇         岸边露伴 一动也不动\r银魂                 银魂 第二季             银魂 第三季\rJOJO的奇妙冒险           JOJO的奇妙冒险 星尘远征军      JOJO 星尘远征军 埃及篇\rJOJO的奇妙冒险 不灭钻石       JOJO的奇妙冒险 黄金之风       JOJO的奇妙冒险 石之海\r碧蓝之海               舞动青春               白沙的水族馆\r星合之空               属性咖啡厅           青春猪头少年不会梦到兔女郎学姐\r总之就是非常可爱           玲音                 SSSS.电光机王\rSSSS.GRIDMAN           言叶之庭               蜂蜜与四叶草\r冰菓                 平家物语               名侦探柯南\r工作细胞                工作细胞 第二季          工作细胞BLACK\r知晓天空之蓝的人啊          流汗吧！健身少女           攻壳机动队\r我的青春恋爱物语果然有问题。     我们的存在              人形电脑天使心\r悠久之翼               悠久之翼2              很帅很可爱宣言\r悠久之翼               悠久之翼2              很帅很可爱宣言\r希德尼娅的骑士 第一季         轻音少女 第一季           星际牛仔 SP\r进击的巨人第一季           搞笑漫画日和             \r未闻花名\r关于前辈很烦人的事          辉夜大小姐想让我告白...        刀剑神域\r在下坂本，有何贵干？         天使降临到我身边           赛马娘 第二季\r游戏王GX              干物妹！小埋             重启咲良田\r甘城光辉游乐园            可塑性记忆              声之形\r你的名字。              天气之子               起风了\r","date":"2020-02-26","objectID":"/anime/:0:0","tags":null,"title":"Anime","uri":"/anime/"},{"categories":null,"content":"cloud","date":"2020-02-26","objectID":"/cloud/","tags":null,"title":"Cloud","uri":"/cloud/"},{"categories":null,"content":"\u003c!DOCTYPE html\u003e\rfail to load\rfail to load\rfail to load\rfail to load\rfail to load\rfail to load\r","date":"2020-02-26","objectID":"/cloud/:0:0","tags":null,"title":"Cloud","uri":"/cloud/"},{"categories":null,"content":"game","date":"2020-02-26","objectID":"/game/","tags":null,"title":"Game","uri":"/game/"},{"categories":null,"content":"\u003c!DOCTYPE html\u003e\rWatch_Dogs2           Watch Dogs: Legion       Forza Horizon 4\rForza Horizon 5          Dishonored           Dishonored 2\rAssassin's Creed 2         Assassin's Creed Brotherhood  Assassin's Creed Unity\rAssassin's Creed Origins      Assassin's Creed Odyssey      Assassin's Creed Valhalla\rMetro Exodus           PUBG              Dota 2\rCS:GO                Grand Theft Auto V         Riders Republic\rPoP: The Sands of Time      PoP: Warrior Within        PoP: The Two Thrones\rHITMAN 2            Human: Fall Flat          SCP: Secret Laboratory\rCyberpunk 2077          Sekiro: Shadows Die Twice    Battlefield 1\rSteep               Notch              Halo: Combat Evolved\rDARK SOULS III          Apex Legends          Overwatch\rIt Takes Two            NieR:Automata         Tomb Raider\rLife is Strange - Episode 1     Yakuza 0             The Witcher 3: Wild Hunt\rLeft 4 Dead            Subnautica            Devil May Cry 5\rFINAL FANTASY XV        ICEY               God of War\r","date":"2020-02-26","objectID":"/game/:0:0","tags":null,"title":"Game","uri":"/game/"},{"categories":null,"content":"life","date":"2020-02-26","objectID":"/life/","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"\u003c!DOCTYPE html\u003e\r研二已经过去一半了，毕业论文和找工作的事儿是一点进度都没有，然而自己还在疯狂玩耍，属于是间歇性焦虑持续性摆烂\r修复了图片无法正常显示的问题，问题是csdn图片的防盗链\r版本V2.2 更新了文章左上角的视频，现在视频为cs2 IEM 悉尼，G2 vs Ence\r好久没更新网站了，随便写点啥 不知不觉已经研二了，马上面临找工作和毕业论文的双重焦虑😫 所以说cs2什么时候能优化好 anyway, have a good day and enjoy life😀 下一次更新又会是什么时候\r网站复活🌶️，网站已经运行了1038天，域名到期了，再过一天就进入高价赎回期了 祝大家新年快乐，身体健康，皆得所愿🎉🎉 研一由于学业繁忙没怎么更新，寒假如果有时间会进行更新，这学期主要就是在学多传感器融合，搞项目，然而搞不出来很头疼😕 近期🐑了很难受，大家照顾好身体，注意休息 网站之后随缘更新\r更新歌单和播放器，更新文章内嵌的视频，增加网站运行时间，更改跑马灯信息，之后打算嵌一个和风天气 赶紧搞正事吧😨\r等有时间的时候，要对网站内容重新归档和整理。可是，什么时候能有时间呢\r文章markdown用katex有关转义的语法问题 1.在'\\'前加一个'\\' 2.在'_'前加'\\' 3.换行\"\\\\\"，上下两行在markdown里要写在同一行 4.在表格里用'|'，有时候直接用\"\\|\"，不需要用\"\\\\\\|\" 以上不是真正写katex要遵循的规则，只是在网站的解析器里要遵循\r鼠鼠我是真的要开始学习了🥶\r🥶\r国庆过后，要开始学习惹🥱\r开学了，开启新的生活\r要毕业🌶️\r新版的vue和目前的elementui不匹配，替换了新的vue的cdn（vue2），重新渲染出时间线\r考研加油！！\r更新了较多内容，暂且称它为V2.2\r增加了雪花效果\r找了好久的live2d模型，单击换装，双击换人\r修改了音乐分区，增加了番剧分区和游戏分区，并且合并，搞了特定的背景图\r删除之前的“语言选择”\r更改了导航栏选项的tooltip\r利用接口修改css和js，更高效地部署网站，感谢github上的老哥完美解决我的问题\r更新了网址，旧网址的重定向以后再搞\r“城镇手指”玩得是越来越烂了\r新出游戏：极限国度、地平线5。拿到奖学金就买，拿不到就算了\r接下来我该做什么\r行，我顺利回校了\r后天能顺利回校吗😟\r更新了tf-idf，属于是不知道要更新什么\r暂时不知道要更新什么，就每天做一道题吧\r更新了网站重启的公告\r更新了linux相关\r更新了一些好玩的游戏\r更新了相机模型和非线性优化\r更新了两个题\r更新了一个可以用状态压缩dp或dfs暴搜的题目，更新了hhucpc的部分代码，明天开始玩cyberpunk2077 复习编译原理\r更新了cf 688 div2 a~d\r好久没打牌了，不得不感叹六武众没连得起来还是别打了，剑斗兽也太离谱了，高攻防又能连锁，不能再玩了，要写汇编了\r记录一下网站的bug 1.footer不能正常显示。 2.顶部导航栏的走马灯会吞并右边的字。 3.代码块有一些合法的括号序列无法正常显示。 4.latex的转义字符通常不能很好地识别（写了个转换程序，目前没问题）。 5.移动端不能很好地适配。 6.云盘还没开发。 7.简体中文那边懒得写副本。 8.live2d模型没有渲染成功。 其实还有很多的bug，由于技术太弱以及没时间，这些bug和想法不知道要鸽到什么时候\r更新了abc184，很久才补完题，真的没时间，明天要考微机实验，害怕\r想整活又没技术，满脑子想法\r目前由于使用框架，夜间模式不会同步，以后再解决这个bug吧\r今天晚上又浪费了一晚上的时间，只做了微机实验报告，明明还有那么多事情要做啊，我学不完了\r蓝色图标是随便写写的，绿色图标是网站更新的内容\r这是一个随想分区，很早就想整活，但是没时间整，晚上因为不想学习，所以随意整了个界面，和自己真正想要做的还差很多，这个是在md中直接用elementui，等到有时间在认真搞吧（什么时候能有时间，elementui还是用的cdn\r这是一个随想分区，很早就想整活，但是没时间整，晚上因为不想学习，所以随意整了个界面，和自己真正想要做的还差很多，这个是在md中直接用elementui，等到有时间在认真搞吧（什么时候能有时间，elementui还是用的cdn\r","date":"2020-02-26","objectID":"/life/:0:0","tags":null,"title":"Life","uri":"/life/"},{"categories":null,"content":"music","date":"2020-02-26","objectID":"/music/","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"Funky =================================================================== =================================================================== ","date":"2020-02-26","objectID":"/music/:1:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"Anime =================================================================== ","date":"2020-02-26","objectID":"/music/:2:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"轻音乐 =================================================================== ","date":"2020-02-26","objectID":"/music/:3:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"热歌榜 =================================================================== ","date":"2020-02-26","objectID":"/music/:4:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"Billboard榜 =================================================================== ","date":"2020-02-26","objectID":"/music/:5:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"其他 ","date":"2020-02-26","objectID":"/music/:6:0","tags":null,"title":"Music","uri":"/music/"},{"categories":null,"content":"poppin","date":"2020-02-26","objectID":"/poppin/","tags":null,"title":"Poppin","uri":"/poppin/"},{"categories":null,"content":"\r=================================================================== =================================================================== =================================================================== =================================================================== =================================================================== =================================================================== =================================================================== ","date":"2020-02-26","objectID":"/poppin/:0:0","tags":null,"title":"Poppin","uri":"/poppin/"},{"categories":null,"content":"keshe","date":"2020-02-26","objectID":"/keshe/","tags":null,"title":"课设测试（临时）","uri":"/keshe/"},{"categories":null,"content":"\u003c!DOCTYPE html\u003e\r实验一\r实验二\r实验三\r实验四\r实验五\r清空\r例子\r","date":"2020-02-26","objectID":"/keshe/:0:0","tags":null,"title":"课设测试（临时）","uri":"/keshe/"},{"categories":["note"],"content":"二进制表示集合","date":"2020-02-24","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/","tags":["cpp","binary"],"title":"二进制表示集合","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/"},{"categories":["note"],"content":"以二进制的原理表示集合，以整数呈现 1表示在集合内，0表示不在集合内 一位运算优先于按位逻辑运算 空集 0 只含有第i个元素的集合{i} 1«i 含有全部n个元素的集合 {0,1,2,…n-1} (1«n) - 1 判断第i个元素是否属于集合S if ( s»i \u0026 1 ) 原来的集合变了 向集合中加入第i个元素 S∪{i} S|1«i 从集合中去除第i个元素 S{i} S\u0026~(1«i) 集合S和T的并集 S|T 集合S和T的交集 S\u0026T 按顺序枚举集合的子集 for(int S=0;S\u003c1\u003c\u003cn;S++) 枚举某个集合sup的子集 int sub=sup; do { sub=(sub-1)\u0026sup; }while(sub!=sup); //处理完0之后，会有-1\u0026sup=sup 枚举{0,1,2,…n-1}所包含的大小为k的子集 int comb=(1\u003c\u003ck)-1; while(comb\u003c1\u003c\u003cn) { int x=comb \u0026 -comb , y=comb+x; comb=((comb \u0026 ~y) / x\u003e\u003e1) | y; } ","date":"2020-02-24","objectID":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/:0:0","tags":["cpp","binary"],"title":"二进制表示集合","uri":"/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/"},{"categories":["algorithm"],"content":"Number Theory","date":"2020-02-22","objectID":"/number-theory/","tags":["cpp","number_theory"],"title":"Number Theory","uri":"/number-theory/"},{"categories":["algorithm"],"content":"求最大公约数和最小公倍数 辗转相除法 时间复杂度O(log(max(a,b))) int gcd(int a,int b) { if(b==0) return a; else return gcd(b,a%b); } int lcm(int a,int b) { return a*b/gcd(a,b); } 或直接调用algorithm库中的__gcd(int a,int b) 扩展欧几里得算法 求满足 ax+by=gcd(a,b) 的整数解 x ，y 时间复杂度O(log(max(a,b))) int ex_gcd(int a,int b,int\u0026 x,int\u0026 y) { int t,res; if(!b) { x=1;y=0;return a; } else { res=ex_gcd(b,a%b,x,y); t=x; x=y;y=t-a/b*y; return res; } } 埃氏筛质数 时间复杂度O(nloglogn) int prime[maxn]; //ith prime number bool isprime[maxn+1] //is i a prime number int e_sieve(int n) { int p=0; //position for(int i=0;i\u003c=n;i++) isprime[i]=true; //initialize isprime[0]=isprime[1]=false; for(int i=2;i\u003c=n;i++) { if(isprime[i]) { prime[p++]=i; for(int j=2*i;j\u003c=n;j+=i) isprime[j]=true; } } return p; } 欧拉筛质数 时间复杂度O(n) int prime[maxn]; bool isprime[maxm]; void get_prime(int n){ memset(isprime, 1, sizeof(isprime)); isprime[0] = false; isprime[1] = false; int cnt = 0; for(int i = 2; i \u003c n; ++i){ if(isprime[i]){ prime[++cnt] = i; } for(int j = 1; j \u003c= cnt and i * prime[j] \u003c n; ++j){ isprime[i * prime[j]] = false; if(i % prime[j] == 0) break; //最关键的一句 } } } 数论的一些性质 Premise: a≡c (mod m) and b≡d (mod m) Conclusion: a±b≡c±d (mod m) a*b≡c*d (mod m) d|a \u0026\u0026 d|b ⇒ d|gcd(a,b) gcd(an,bn) = n*gcd(a,b) 任意正整数n，n|ab \u0026\u0026 a,n互质 ⇒ n|b a,p 互质 ， b,p互质 ⇒ ab,p互质 任意一个合数都可以分解成唯一的质数幂积的形式，即 $$ a=\\prod\\limits_{i=1} ^ {n} {pi ^ ei} $$ 因子个数为 $$ \\sum\\limits_{i=1} ^ {n} {(1+e_i)} $$ 积性函数 f(ab) = f(a)f(b) 欧拉函数 莫比乌斯函数 gcd 狄利克雷函数 快速幂 时间复杂度O(logn) typedef long long ll; ll qpow(ll x,ll n,ll mod) { ll res =1; while(n\u003e0) { if(n\u00261) res=res*x%mod; x=x*x%mod; n\u003e\u003e=1; } return res; } 逆元 $$ 逆元\\quad y=a^{-1}\\quad满足\\quad ay≡1(mod\\ m) ~\\ y为a在模m下的逆元 $$ $$ 对于\\quad ax≡b(mod\\ m) ~\\ x=a^{-1}*b $$ 求逆元 $$ ax≡1(mod\\ m) ~\\ ax-mk=1 ~\\ ax+my=1 ~\\ ax+my=gcd(a,m) ~\\当a,m不互质的时候，逆元不存在 $$ int mod_inverse(int a,int m) { int x,y; ex_gcd(a,m,x,y); return (m+x%m)%m; } 线性时间内预处理逆元 inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u003c=n;i++){ inv[i]=(mod-mod/i)*inv[mod%i]%mod; } 欧拉函数 设 $$ \\quad n =\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} ~\\ $$ 则欧拉函数 $$ \\quad φ(n)=n*\\prod\\limits_{i=1} ^ {n} {\\frac{p_i-1}{p_i}} $$ 欧拉函数的数值等于不超过n且与n互质的数的个数 欧拉函数的数值等于不超过n且与n互质的数的个数 当n时质数时，φ(n)=n-1 如果n=p^k , φ(n)=p^k - p^(k-1) = (p-1)p^(k-1) 如果m,n互质，则φ(mn)=φ(m)φ(n) φ(n)的值都为偶数，φ(2)除外 质因子之和 (φ(n)*n)/2 欧拉定理 $$ 当a,m互质时 ~\\ a^{φ(m)}≡1(mod \\ m) $$ 费马小定理 $$ 当p是质数时， 对任意整数x 都有 ~\\ x^p≡x(mod \\ p) ~\\~\\ 当x,p互质时 ~\\ x^{p-1}≡1(mod \\ p) ~\\ 这就是欧拉定理的特殊形式 $$ 求欧拉函数 时间复杂度O(√(n)) 求欧拉函数值的表，类似于埃氏筛，时间复杂度O(n) int phi(int n) { int res=n; for(int i=2;i*i\u003c=n;i++) { if(n%i==0) { res=res/i*(i-1); while(n%i==0) n/=i; } } if(n!=1) res=res/n*(n-1); return res; } int euler_phi[maxn]; void phi_arr() { for(int i=0;i\u003cmaxn;i++) euler_phi[i]=i; for(int i=2;i\u003cmaxn;i++) { if(euler_phi[i]==i) { for(int j=i;j\u003cmaxn;j+=i) euler_phi[j]=euler_phi[j]/i*(i-1); } } } 线性同余方程组 $$ a_ix≡b_i(mod \\ m_i) $$ 如果方程组有解，一定有无穷多解 解的全集可以写成 x≡b(mod m) 所以将问题转化为求b,m 可以对如下方程组依次求解 $$ x≡b_1(mod \\ m_1) ~\\ ax≡b_2(mod\\ m_2) $$ $$ x≡b_1(mod \\ m_1) ~\\ x=b_1+m_1t ~\\a(b_1+m_1t)≡b_2(mod\\ m_2) ~\\am_1t≡b_2-ab_1(mod \\ m_2) ~\\a’t≡b’(mod \\ m_2) $$ 当gcd(m₂,am₁)与b₂-ab₁互质时，方程组无解 时间复杂度O(n) pair\u003cint,int\u003e linear_congruence(const vector\u003cint\u003e\u0026 A,const vector\u003cint\u003e\u0026 B,const vector\u003cint\u003e\u0026 M) { //最开始没有限制，把解设为所有整数 x ≡0(mod 1) int x=0,m=1; for(int i=0;i\u003cA.size();i++) { int a=A[i]*m , b=B[i]-A[i]*x , d=gcd(M[i],a); //d!!! if(b%d!=0) return make_pair(0,-1); //无解 int t=b / d * mod_inverse(a/d,M[i]/d) % (M[i]/d) ; x=x+m*t; m*=M[i]/d; //*= !!! } return make_pair(x%m,m); } 中国剩余定理(CRT) crt是线性同余方程组ai=0，mi互质的特殊形式 这时，x≡b(mod Πmi) crt的思想是余数的加性和模数的乘性，当模数为合数时，可以拆成质因数的积 crt定理如下 $$ 对于x≡b_i(mod \\ m_i) \\ \\ \\ \\ \\ \\ m_i互质 ~\\ ~\\令M=\\prod{m_i} ~\\M_i=\\frac{M}{m_i} ~\\M_i ^ {-1} 为M_i模m_i的逆元 ~\\ 则 \\ x≡(\\sum\\limits_{i=1} ^ {n} {b_iM_iM_i ^{-1}}) \\ (mod \\ M) $$ // x=x+(Πmi)*t //return minimum int crt(const vector\u003cint\u003e\u0026 b,const vector\u003cint\u003e \u0026m) { int M=1,x=0; for(int i=0;i\u003cm.size();i++) M*=m[i]; for(int i=0;i\u003cm.size();i++){ int Mprime=M/m[i]; int M_p_i=mod_inverse(Mprime,m[i]); x=(x + b[i] * Mprime * M_p_i)%M; } return (x+M)%M; } Lucas定理 ","date":"2020-02-22","objectID":"/number-theory/:0:0","tags":["cpp","number_theory"],"title":"Number Theory","uri":"/number-theory/"},{"categories":["algorithm","hduoj"],"content":"hduoj2089(数位dp + 记忆化搜索)","date":"2020-02-20","objectID":"/hduoj2089%E6%95%B0%E4%BD%8Ddp--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"/hduoj2089%E6%95%B0%E4%BD%8Ddp--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"categories":["algorithm","hduoj"],"content":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input 输入的都是整数对n、m（0\u003cn≤m\u003c1000000），如果遇到都是0的整数对，则输入结束。 Output 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input 1 100 0 0 Sample Output 80 Solution 与数位的组成有关，可以用数位dp。 利用前缀即 solve(m)-solve(n-1) dp[i][j] 表示 符合条件的个数[当前操作的数位(倒序排)][当前操作的数位的前一个数] $$ dp[pos][pre] = \\sum\\limits_{i=0} ^ {maxd} dp[pos-1][i] $$ maxd可以由一个boolean变量limit控制，是否是9还是dig[pos] 为了不重复计算（重复计算也可以），可以用记忆化搜索，也就是可以利用计算好的dp。为了使dp普适，dp必须是稳定，经全搜索得到的（即maxd=9）。所以通过limit控制dp的存储和dp的读取 通过dp递推式，可以用dfs实现（理论上来说可以不用dfs，但不能记忆化且dp可能要增加维度，且要特殊初始化。没有实践过，有时间可以去试试） int dfs(int pos,int pre,bool limit) 通过limit和返回值来使dp结果普适 AC代码如下 #include\u003ciostream\u003e #include\u003ccstring\u003e using namespace std; int n,m; int dp[10][10]; //dp[i][j] i:总共有i位 , j:前导数字为j , dp:满足条件（不含4和62）的个数 int dig[10]; int dfs(int pos,int pre,bool limit) //pos 当前位置 ， pre 当前位置的前一个数字 { if(pos==-1) return 1; //只有0（1个数字）满足 if(dp[pos][pre]!=-1 \u0026\u0026 !limit) return dp[pos][pre]; //已经搜索过则直接返回 //!!!! int ans=0; int maxd; if(limit) maxd=dig[pos]; else maxd=9; for(int i=0;i\u003c=maxd;i++) { if(i==4 || (pre==6 \u0026\u0026 i==2)) ; else ans+=dfs(pos-1,i,limit \u0026\u0026 i==dig[pos]); //这里需要传limit !!!!!!!!!! } if(!limit) //只有在全搜索的时候才能给dp赋值，这样可以保证dp适用于所有情况，从而实现记忆化搜素 dp[pos][pre]=ans; return ans; } int solve(int x) { int len=0; while(x) { dig[len++]=x%10; x/=10; } return dfs(len-1,0,1); } int main() { //freopen(\"input.txt\",\"r\",stdin); memset(dp,-1,sizeof(dp)); //不需要每次都初始化，因为要记忆化搜索 //不需要对dp特殊初始化，因为dfs中有return 1 while(scanf(\"%d%d\",\u0026n,\u0026m)==2 \u0026\u0026 (n || m)) { cout\u003c\u003csolve(m)-solve(n-1)\u003c\u003cendl; } return 0; } 第一次写数位dp，参考了别人的代码，也调试了很久，思考了很多，才弄懂其中的细节 ","date":"2020-02-20","objectID":"/hduoj2089%E6%95%B0%E4%BD%8Ddp--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/:0:0","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"/hduoj2089%E6%95%B0%E4%BD%8Ddp--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"categories":["algorithm","nowcoder"],"content":"Segment Tree","date":"2020-02-20","objectID":"/segment-tree/","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"/segment-tree/"},{"categories":["algorithm","nowcoder"],"content":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树 用一个例子来介绍线段树 RMQ（range minimum query） 实现功能 对于一个数列 1.给定s,t求[s,t)区间的最小值（最大值） 2.给定i和x,把ai改成x const int maxn = 1\u003c\u003c17; int n,dat[2*maxn+1]; void init(int n_) { //为了计算方便,把元素个数扩大到2的幂次方的个数 n=1; while(n\u003cn_) n*=2; fill(dat,dat+2*n-1,inf); } //将从0开始的第k个值，改成a void update(int k,int a) { k+=n-1; dat[k]=a; //向上更新 while(k\u003e0) { k=(k-1)/2; dat[k]=min(dat[2*k+1],dat[2*k+2]); } } //求[a,b)区间的最小值(从0开始数) //后面的参数是为了计算方便传入的 //k是节点编号，l，r是k节点对应的区间 //在外部调用是用query(a,b,0,0,n) int query(int a,int b,int k,int l,int r) { if(r\u003c=a || b\u003c=l) return inf; if(a\u003c=l \u0026\u0026 r\u003c=b) return dat[k]; else { int vl=query(a,b,2*k+1,l,(l+r)/2); int lr=query(a,b,2*k+2,(l+r)/2,r); return min(vl,vr); } } 初始化的时间复杂度O(n) 更新和查询的时间复杂度O(logn) 如果dat以1开头，则可以利用这些性质 \u003e\u003e1 : /2取整 «1 : 乘2 «1|1 : (*2+1) 以这题为例 给出一个长度为 n 的数列，a1,a2,…,an,求其长度为 k 的连续子段的乘积对 998244353 取模余数的最大值。 solution:这道题可以用尺取法、线段树、逆元 线段树的做法不需要update函数，最底层存每个数，父节点存子节点的乘积，最后query每一段区间 AC代码如下 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll mod = 998244353; ll n_,k; ll n; ll dat[4*200005+2]; //[a,b) ll query(ll a ,ll b,ll k,ll l,ll r) { if(r\u003c=a || b\u003c=l) return 1; if(a\u003c=l \u0026\u0026 r\u003c=b) return dat[k]; return (query(a,b,k*2+1,l,(l+r)/2) * query(a,b,k*2+2,(l+r)/2,r))%mod; } int main() { //freopen(\"input.txt\",\"r\",stdin); scanf(\"%lld%lld\",\u0026n_,\u0026k); n=1; while(n\u003cn_) n*=2; for(ll i=n-1;i\u003cn_-1+n;i++) { scanf(\"%lld\",\u0026dat[i]); } for(ll i=n-2;i\u003e=0;i--) { dat[i]=(dat[i*2+1]*dat[i*2+2]) % mod; } ll ans=-1; for(ll i=0;i+k\u003c=n_;i++) { ans=max(ans,query(i,i+k,0,0,n)); } cout\u003c\u003cans%mod\u003c\u003cendl; return 0; } 有几个点导致WA 1.要用long long 不能用int 2.dat的的大小要用4乘，否则会断错误，因为在query时，最底层的也有可能访问子节点 边界条件是线段树容易出错的地方，以上代码的区间是左闭右开，在判断条件里面用等号注意n_和n的使用 线段树的lazy思想 参考这里 =========================================================================================================== 在这里补一个线段树板子 支持区间加、区间乘、区间求和、区间求平方和 如果求最值可以用上面那个模板 这个模板还没有融合进去 其实线段树的基本操作就是区间查询和区间更新，其他的操作都可以通过两个基本的区间加（区间求最值）、区间求和操作转化 平方和就是通过等式转化、类似地还可以求立方和、不过四次方应该会很麻烦 测板子题 #include\u003cbits/stdc++.h\u003e using namespace std; using ll = long long; const int maxn = 10005; struct tnode{ ll w,l,r,siz,alazy; ll sq,mlazy=1; }tn[maxn\u003c\u003c2]; ll n,m; const ll mod = 0x3f3f3f3f3f3f3f3f; ll wt[maxn]; void pushup(ll u){ tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod; tn[u].sq = (tn[u\u003c\u003c1].sq + tn[u\u003c\u003c1|1].sq) % mod; } void build(ll u,ll l,ll r){ tn[u].l = l; tn[u].r = r; tn[u].siz = r - l + 1; if(l == r){ tn[u].w = wt[l]; tn[u].sq = wt[l] * wt[l]; return ; } ll mid = (l+r) \u003e\u003e 1; build(u\u003c\u003c1 , l , mid); build(u\u003c\u003c1|1 , mid+1 , r); pushup(u); } void pushdown(ll u){ if(tn[u].alazy != 0 or tn[u].mlazy != 1){ tn[u\u003c\u003c1].sq = ((tn[u\u003c\u003c1].sq + 2LL * tn[u\u003c\u003c1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1].siz % mod) % mod; tn[u\u003c\u003c1|1].sq = ((tn[u\u003c\u003c1|1].sq + 2LL * tn[u\u003c\u003c1|1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u003c\u003c1|1].siz % mod) % mod; tn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1].siz * tn[u].alazy % mod) % mod; tn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w * tn[u].mlazy % mod + tn[u\u003c\u003c1|1].siz * tn[u].alazy % mod) % mod; tn[u\u003c\u003c1].alazy = (tn[u\u003c\u003c1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u003c\u003c1|1].alazy = (tn[u\u003c\u003c1|1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u003c\u003c1].mlazy = (tn[u\u003c\u003c1].mlazy * tn[u].mlazy) % mod; tn[u\u003c\u003c1|1].mlazy = (tn[u\u003c\u003c1|1].mlazy * tn[u].mlazy) % mod; tn[u].alazy = 0; tn[u].mlazy = 1; } } ll query(ll u,ll l,ll r,ll t){ if(l\u003c=tn[u].l and r\u003e=tn[u].r) { if(t == 1) return tn[u].w; if(t == 2) return tn[u].sq; } ll ans = 0; pushdown(u); ll mid = (tn[u].l + tn[u].r) \u003e\u003e 1; if(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r , t)) % mod; if(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r , t)) % mod; return ans; } void update(ll u,ll l,ll r,ll wa,ll wm){ if(l\u003c=tn[u].l and r\u003e=tn[u].r){ tn[u].sq = ((tn[u].sq + 2LL * tn[u].w * wa % mod) % mod + wa * wa % mod * tn[u].siz % mod) % mod; tn[u].w = (tn[u].w * wm % mod + tn[u].siz * wa % mod) % mod; tn[u].alazy = (tn[u].alazy * wm % mod + wa) % mod; tn[u].mlazy = (tn[u].mlazy * wm) % mod; return ; } pushdown(u); ll ","date":"2020-02-20","objectID":"/segment-tree/:0:0","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"/segment-tree/"},{"categories":["nowcoder"],"content":"牛客基础训练营5B","date":"2020-02-14","objectID":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/"},{"categories":["nowcoder"],"content":"题目在这 这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快 三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2 求mid midmid与n个点的距离，然后依据较小值缩减区间 代码如下 //三分法 最快的应该是0.618法 #include\u003cbits/stdc++.h\u003e using namespace std; int n; struct point { double x,y; }p[100005]; double eps = 5e-5; double check(double x) { double dist = -1; for(int i=0;i\u003cn;i++) { dist = max(dist,(x-p[i].x)*(x-p[i].x) + p[i].y*p[i].y); } return sqrt(dist); } int main() { cin\u003e\u003en; for(int i=0;i\u003cn;i++) scanf(\"%lf %lf\",\u0026p[i].x,\u0026p[i].y); double l = -10000.0; double r = 10000.0; while(r-l\u003eeps) { double mid = l + (r -l)/2; //这里的三分 double midmid = mid+(r-mid)/2; if(check(mid)\u003echeck(midmid)) l=mid; else r=midmid; } printf(\"%.5lf\\n\",check(l)); return 0; } ","date":"2020-02-14","objectID":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/:0:0","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/"},{"categories":["algorithm"],"content":"Graph Theory","date":"2020-02-05","objectID":"/graph-theory/","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等 ","date":"2020-02-05","objectID":"/graph-theory/:0:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"链式前向星存图 struct edge{ int to , w , next; }e[maxn]; int tot,head[maxn]; void add_edge(int u,int v,int w){ e[tot].to = v; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++; } for(int i=head[u];~i;i=e[i].next){ int v = e[i].to; int w = e[i].w; } //init memset(head , -1 , sizeof(head)); ","date":"2020-02-05","objectID":"/graph-theory/:1:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"二分图判定 通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图 用dfs判断每个点是否可染色，如果每个点都是可染色的，就是二分图 //input vector\u003cint\u003e G[max_v]; int V; int color[max_v] //顶点i的颜色 1或-1 bool dfs(int v,int c) { color[v]=c; //染色 for(int i=0;i\u003cG[v].size();i++) { if(color[v][i]==c) return false; //相邻顶点同色 if(color[G[v][i]]==0 \u0026\u0026 !dfs(G[v][i],-c)) return false; //对于还没染色的点，如果不能染色则返回false } return true; } bool bipartite_graph() { for(int i=0;i\u003cV;i++) { if(color[i]==0) //还未着色//如果是连通图，遍历一次就够 if(!dfs(i,1)) return false; } return true; } 把顶点和边都算的话，时间复杂度是O(|V|+|E|) ","date":"2020-02-05","objectID":"/graph-theory/:2:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"求DAG的拓扑序 求拓扑序可以dfs，删边法（通过栈或队列） 求每个点的入度，将入度为0的点入栈，遍历栈里的点，将于这些点相邻的点的入度减1，如果有点入度为0，则入栈。依靠这个顺序，得到的就是拓扑序。如果点访问两次，则有圈。可以通过这个方法判断有向图是否有圈 //input vector\u003cint\u003e G[max_v] int V; int indgree[max_v] //每个顶点的入度 vector\u003cint\u003e res; //拓扑排序的结果 bool topological_sort() //判断是否能拓扑排序 ，若果有圈就不能 { stack\u003cint\u003e s; //int counter=0; //遍历的点的个数 for(int i=0;i\u003cV;i++) if(indegree[i]==0) s.push(i); //入度为0 的顶点入栈 while(!s.empty()) { int v=s.top(); s.pop(); res.push_back(v); //counter++; for(int i=0;i\u003cG[v].size();i++) { int k=G[v][i]; if(--indegree[k] == 0) s.push(k); //遍历到的点入度间1，入度为0则入栈 } } if(res.size()==n) return true; else return false; } 时间复杂度是O(|V|+|E|) ","date":"2020-02-05","objectID":"/graph-theory/:3:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Bellman-Ford算法 求单源最短路 d[i]=min{d[j]+e(j,i)} 只要图中不存在负圈，这样的更新操作是有限的（由于最短路不会经过一个顶点两次，所以这种操作只会重复|v|-1次） 时间复杂度O(|V|*|E|) struct edge { int from,to,cost; }es[max_e]; int d[max_v]; int V,E; void bellman_ford(int s) { for(int i=0;i\u003cV;i++) d[i]=inf; //把最短距离初始化成无限 d[s]=0; while(true) { bool update=false; //判断while是否进行了更新操作，没有更新操作则退出循环 for(int i=0;i\u003cE;i++) //根据公式，遍历边 { edge e=es[i]; if(d[e.from]!=inf \u0026\u0026 d[e.to]\u003ed[e.from]+e.cost) { d[e.to]=d[e.from]+e.cost; update=true; } } if(!update) break; } } 如果更新操作（while循环）进行了超过|V|-1次，则存在负圈 所以判断负圈的一个方法可以是 把所有d[i]都变成0，如果有负圈，则一定执行超过|V|-1次 bool find_negative_loop() { memset(d,0,sizeof(d)); for(int i=0;i\u003cV;i++) { for(int j=0;j\u003cE;j++) { edge e=es[j]; if(d[e.to]\u003ed[e.from]+e.cost) { d[e.to]\u003ed[e.from]+e.cost; if(i==V-1) return true; //这条语句不能放在if外，如果放在if外需要加update } } } return false; } ","date":"2020-02-05","objectID":"/graph-theory/:4:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Dijkstra算法 求单源最短路，适用于没有负边的情况 将已求出最短路的点，放入一个集合中 ，每次从集合外找到一个和集合距离最近的点，加入集合 int cost[max_v][max_v]; //权值，不存在时为inf int d[max_v]; bool used[max_v]; int V; void dijkstra(int s) { fill(d,d+v,inf); fill(used,used+v,false); d[s]=0; while(true) { int v=-1; //从尚未使用过的点中选一个距离最小的点 for(int u=0;u\u003cV;u++) { if(!used[u] \u0026\u0026 (v==-1 || d[u]\u003cd[v])) v=u; } if(v==-1) break; used[v]=true; for(int u=0;u\u003cV;u++) d[u]=min(d[u],d[v]+cost[v][u]); } } 时间复杂度O(V^2) 优化 如果将点放入优先队列中，这要查找和更新就会节省很多时间，时间复杂度O(ElgV) struct edge { int to,cost; } typedef pair\u003cint,int\u003e pii; //first 是距离 ，second是点编号 int V; vector\u003cedge\u003e G[max_v]; int d[max_v]; void dijkstra(int s) { priority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; //使小的在上面 fill(d,d+V,inf); d[s]=0; q.push(pii(0,s)); while(!q.empty()) { pii p=q.top(); q.pop(); int v=p.second; if(d[v]\u003cp.first) continue; for(int i=0;i\u003cG[v].size();i++) { edge e=G[v][i]; if(d[e.to]\u003ed[v]+e.cost) { d[e.to]=d[v]+e.cost; q.push(pii(d[e.to],e.to)); } } } } ","date":"2020-02-05","objectID":"/graph-theory/:5:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Floyd-Warshall算法 求任意两点最短路，暴力枚举思想 d[i][j]=min(d[i][j],d[i][k]+d[k][j]) 遍历所有的k 时间复杂度O(V^3) int d[max_v][max_v]; //存储权值，边不存在时为inf，d[i][i]=0 int V; void floyd_warshall() { for(k=0;k\u003cV;k++) for(int i=0;i\u003cV;i++) for(int j=0;j\u003cV;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); } ","date":"2020-02-05","objectID":"/graph-theory/:6:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"路径还原 通过找满足d[j]=d[k]+cost[k][j]的顶点k，来寻找前趋节点，不断寻找前趋节点来还原路径，时间复杂度O(E) 还可以用prev[j]在算法内直接记录前趋节点，最后遍历数组即可，时间复杂度O(V) //算法内记录前趋节点 (优化的dijkstra算法) int prev[max_v] //前趋节点 struct edge { int to,cost; } typedef pair\u003cint,int\u003e pii; //first 是距离 ，second是点编号 int V; vector\u003cedge\u003e G[max_v]; int d[max_v]; void dijkstra(int s) { priority_queue\u003cpii,vector\u003cpii\u003e,greater\u003cpii\u003e \u003e q; //使小的在上面 fill(d,d+V,inf); fill(prev,prev+V,-1); //!!!! d[s]=0; q.push(pii(0,s)); while(!q.empty()) { pii p=q.top(); q.pop(); int v=p.second; if(d[v]\u003cp.first) continue; for(int i=0;i\u003cG[v].size();i++) { edge e=G[v][i]; if(d[e.to]\u003ed[v]+e.cost) { d[e.to]=d[v]+e.cost; prev[e.to]=v; //!!!! q.push(pii(d[e.to],e.to)); } } } } vector\u003cint\u003e get_path(int t) { vector\u003cint\u003e path; for(;t!=-1;t=prev[t]) path.push_back(t); reverse(path.begin(),path.end()); return path; } ","date":"2020-02-05","objectID":"/graph-theory/:7:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Prim算法 求最小生成树 prim算法和dijkstra算法很像，也是把已确定的点放入一个集合中，贪心地选取集合和未确定的点相连的最小权边，并加入到集合中，得到一棵生成树，可以证明是MST(minimum spanning tree) //也可以堆优化 int cost[max_v][max_v] //权值 int mincost[max_v]; //从集合出发到其他点的最小权值,!!!这个权值是 集合 和 点 之间的 bool used[max_v]; //是否在集合中 int V; int prim() //返回MST的权值 { fill(mincost,mincost+V,inf); //初始化 fill(used,used+V,false); mincost[0]=0; //从0开始 int res=0; while(true) { int v=-1; for(int u=0;u\u003cV;u++) { if(!used[u] \u0026\u0026 (v==-1 || mincost[u]\u003cmincost[v])) v=u; } if(v==-1) break; used[v]=true; res+=mincost[v]; for(int u=0;u\u003cV;u++) { mincost[u]=min(mincost[u],cost[v][u]); //每次往集合中加入一个点，所有点的mincost都有可能改变 } } return res; } 时间复杂度与dijkstra算法一样 ","date":"2020-02-05","objectID":"/graph-theory/:8:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Kruskal算法 求MST 将边的权值按大小排序，如果不产生圈和重边，就依次把边加入到生成树中 要判断是否产生圈和重边，只需要判断加入这条边前，这条边的两个端点是否已在同一个连通分量里，这样就可以用并查集 Kruskal在边的排序上最费时，算法复杂度O(ElgV) Kruskal适用于sparse graph Prim适用于dense graph 在实际应用中，Kruskal更普遍 struct edge { int u,v,cost; }es[max_e]; int V,E; int par[max_v]; //union find需要 int rankk[max_v]; //key word \"rank\" bool cmp(const edge\u0026 e1,const edge\u0026 e2) { return e1.cost\u003ce2.cost; } void init_union_find(int x) { for(int i=0;i\u003cx;i++) { par[i]=i; rankk[i]=0; } } int find(int x) { if(par[x]==x) return x; else return par[x]=find(par[x]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return; if(rankk[x]\u003crankk[y]) par[x]=y; else { par[y]=x; if(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y) { return find(x)==find(y); } int kruskal() { sort(es,es+E,cmp); init_union_find(V); int res=0; for(int i=0;i\u003cE;i++) { edge e=es[i]; if(!same(e.u,e.v)) { unite(e.u,e.v); res+=e.cost; } } return res; } ","date":"2020-02-05","objectID":"/graph-theory/:9:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Kosaraju算法 强连通分量(strongly connected component)分解高效的算法有kosaraju算法， tarjan算法，gabow算法 kosaraju算法通过随便选一点dfs，给点标号 把边的方向反过来，再一次dfs 由于在强连通分量中的点，其可达性不受边反向的影响 所以最后需独立进行k次搜索 即分裂出k个强连通分量 时间复杂度 O(V+E) //kosaraju int V; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv]; vector\u003cint\u003e vs; //后序遍历顺序的顶点列表（标号） bool used[maxv]; //是否访问 int cmp[maxv]; //所属强连通分量的拓扑序（序号） void add_edge(int from,int to){ G[from].push_back(to); rG[to].push_back(from); } void dfs(int v){ used[v]=true; for(int i=0;i\u003cG[v].size();i++){ if(!used[G[v][i]]) dfs(G[v][i]); } vs.push_back(v); } void rdfs(int v,int k){ used[v]=true; cmp[v]=k; for(int i=0;i\u003crG[v].size();i++){ if(!used[rG[v][i]]) rdfs(rG[v][i],k); } } int kosaraju_scc(){ memset(used,0,sizeof(used)); vs.clear(); for(int i=0;i\u003cV;i++) if(!used[i]) dfs(i); memset(uesd,0,sizeof(used)); int k=0; for(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++); return k; } ","date":"2020-02-05","objectID":"/graph-theory/:10:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Tarjan算法 （scc部分） 求scc的tarjan算法是给一个点赋上两个属性 dfn low分别表示dfs的访问时间和该点可追踪到的最小访问时间 dfs过程中先访问自己，再访问邻接点，最后对自己进行操作 在访问自己时，将两个属性初始化为当前时间，并且进栈 接下来访问未被访问过的邻接点，并且更新low属性 如果已被访问过且在栈里也更新low属性 最后对自己的操作就是判断dfn 和 low是否相等 相等说明它是连通块的头，已经无法再更新了 这时候不断出栈直到自己也出栈 总的操作就是遍历每个点，没访问就dfs tarjan算法和kosaraju算法有点类似，都是利用了反向边的性质，本质上是强连通分量中反向边的可达性，依此对每个点都最小化点的属性，而属性选择dfs序较高效 tarjan算法要dfs一次，邻接表的时间复杂度是 O(V+E) 求连通块的出度和入度就是判断原本连接的两个点是否在同一个强连通分量中 int V; vector\u003cint\u003e G[maxv]; int dfn[maxv],low[maxv],cmp[maxv]; bool in_stack[maxv]; stack\u003cint\u003e s; int tim; int num=0; //最后的num是连通块数量 int in[maxv]; int out[maxv]; void tarjan_dfs(int x){ dfn[x] = low[x] = ++tim; s.push(x); in_stack[x] = true; for(int i=0;i\u003cG[x].size();i++){ int to = G[x][i]; if(dfn[to] == 0){ tarjan_dfs(to); low[x] = min(low[x] , low[to]); } else if(in_stack[to]){ low[x] = min(low[x] , low[to]); } } int tmp; if(dfn[x] == low[x]){ do{ tmp = s.top(); cmp[tmp] = num; s.pop(); in_stack[tmp] = false; }while(tmp != x); num++; } } void tarjan_scc(){ for(int i=0;i\u003cV;i++){ if(!dfn[i]){ tarjan_dfs(i); } } } void in_out_d(){ for(int i=0;i\u003cV;i++){ for(int j=0;j\u003cG[i].size();j++){ int to = G[i][j]; if(cmp[i] != cmp[to]){ in[cmp[to]]++; out[cmp[i]]++; } } } } ","date":"2020-02-05","objectID":"/graph-theory/:11:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Tarjan算法 （割点、桥部分） 利用dfn和low判定割点和桥，注意更新 int V; vector\u003cint\u003e G[maxv]; int dfn[maxv],low[maxv],cmp[maxv]; bool in_stack[maxv]; stack\u003cint\u003e s; int tim; int num=0; //最后的num是连通块数量 set\u003cint\u003e cut; int Rchild; int cnt_root; set\u003cpair\u003cint,int\u003e\u003e bridge; void tarjan_dfs(int x,int p){ dfn[x] = low[x] = ++tim; s.push(x); in_stack[x] = true; for(int i=0;i\u003cG[x].size();i++){ int to = G[x][i]; if(to != p){ if(dfn[to] == 0){ if(x == cnt_root) Rchild++; tarjan_dfs(to , x); low[x] = min(low[x] , low[to]); if(x != cnt_root and low[to] \u003e= dfn[x]) cut.insert(x); //不是根，求割点 if(low[to] \u003e dfn[x]) bridge.insert({min(x,to),max(x,to)}); //求桥 } else if(in_stack[to]){ low[x] = min(low[x] , dfn[to]); //注意这里是dfn，而不是求scc的low } } } int tmp; if(dfn[x] == low[x]){ do{ tmp = s.top(); cmp[tmp] = num; s.pop(); in_stack[tmp] = false; }while(tmp != x); num++; } } void tarjan_scc(){ for(int i=0;i\u003cV;i++){ if(!dfn[i]){ cnt_root = i; Rchild = 0; tarjan_dfs(i,-1); if(Rchild \u003e 1) cut.insert(cnt_root); //是根，求割点 } } } 割点的模板测试 这个题的数据好像有森林 桥的模板测试 ","date":"2020-02-05","objectID":"/graph-theory/:12:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"LCA 大致的做法就是直接法，直接向上追溯 对于多次查询通过跳级预处理，利用二分的思想 单次查询，O(n) vector\u003cint\u003e G[maxv]; int root; int parent[maxv]; int depth[maxv]; void dfs(int v,int p,int d){ parent[v] = p; depth[v] = d; for(int i=0;i\u003cG[v].size();i++){ if(G[v][i] != p) dfs(G[v][i] , v , d+1); } } void init(){ dfs(root , -1 , 0); } int lca(int u,int v){ while(depth[u] \u003e depth[v]) u = parent[u]; while(depth[v] \u003e depth[v]) v = parent[v]; while(u != v){ u = parent[u]; v = parent[v]; } return u; } 多次查询 O(nlogn) vector\u003cint\u003e G[maxv]; int root; int parent[max_logv][maxv]; int depth[maxv]; void dfs(int v,int p,int d){ parent[0][v]=p; depth[v]=d; for(int i=0;i\u003cG[v].size();i++){ if(G[v][i]!=p) dfs(G[v][i],v,d+1); } } void init(int V){ dfs(root,-1,0); for(int k=0;k+1\u003cmax_logv;k++){ for(int v=0;v\u003cV;v++){ if(parent[k][v]\u003c0) parent[k+1][v]=-1; else parent[k+1][v]=parent[k][parent[k][v]]; } } } int lca(int u,int v){ if(depth[u]\u003edepth[v]) swap(u,v); for(int k=0;k\u003cmax_logv;k++){ if((depth[v]-depth[u])\u003e\u003ek\u00261) v=parent[k][v]; } if(u==v) return u; for(int k=max_logv-1;k\u003e=0;k--){ if(parent[k][u]!=parent[k][v]){ u=parent[k][u]; v=parent[k][v]; } } return parent[0][u]; } ","date":"2020-02-05","objectID":"/graph-theory/:13:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"dfs序 (与线段树和树状数组结合) vector\u003cint\u003e G[maxv]; //图的领接表 int od[maxv]; //dfs序 int L[maxv]; //子树区间左边界 int R[maxv]; //子树区间有边界 int cnt = 1; //当前是第几个节点（dfs序） void dfs(int x,int p){ od[x] = cnt++; L[x] = cnt - 1; for(int i:G[x]){ if(i!=p){ dfs(i,x); } } R[x] = cnt - 1; } ","date":"2020-02-05","objectID":"/graph-theory/:14:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"树链剖分 树链剖分利用重孩子的定义和dfs序将树上路径权值和子树整体权值的修改和查询压缩成连续的区间的查询，对于区间的修改和查询可以利用线段树 以这道题为例 （无注释代码点击此处） #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 1e5+10; struct edge{ //链式前向星存图 int to,nxt; }e[maxn\u003c\u003c1]; //用双向边代替无向边 struct tnode{ //线段树的节点 节点权值，覆盖的左区间，覆盖的右区间，覆盖的范围，lazy标签 int w,l,r,siz,lazy; }tn[maxn\u003c\u003c2]; // 大小要*4 //wch：重孩子 sz：子树大小 head：链式前向星的head //wt：原来树上节点的权值 dep：深度 dfn：dfs序 //par：父节点 top：树上节点所属链的链首 rdfn：dfs序的反映射 int wch[maxn],sz[maxn],head[maxn],wt[maxn],dep[maxn],dfn[maxn],par[maxn],top[maxn],rdfn[maxn]; int n,m,r,mod; int cnt_e; //链式前向星的计数器 int cnt_d; //dfs序的计数器 void add_edge(int u,int v){ //链式前向星的建图函数 e[++cnt_e].to = v; e[cnt_e].nxt = head[u]; //头插法 head[u] = cnt_e; } void dfs1(int u,int p){ //获得子树大小 ，深度，父节点，重孩子 sz[u] = 1; for(int i = head[u]; i ; i=e[i].nxt){ int t = e[i].to; if(t != p){ dep[t] = dep[u] + 1; par[t] = u; dfs1(t,u); sz[u] += sz[t]; if(sz[t] \u003e sz[wch[u]]) wch[u] = t; } } } void dfs2(int u,int p,int tp){ //剖分重链和轻链 top[u] = tp; dfn[u] = ++cnt_d; //dfs序 rdfn[cnt_d] = u; //反dfs序 if(wch[u]){ //先操作重孩子，目的是让重链节点的dfs序连续，便于在线段树上的区间操作 dfs2(wch[u],u,tp); } for(int i=head[u]; i ; i=e[i].nxt){ int t = e[i].to; if(t != p and t != wch[u]){ dfs2(t,u,t); //操作轻孩子 } } } void pushup(int u){ //通过两个孩子，更新自己的权值 由于题目要求，所以是求和形式 tn[u].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1|1].w) % mod; } void build(int u,int l,int r){ //建立线段树 tn[u].l = l; tn[u].r = r; tn[u].siz = r - l + 1; if(l == r){ tn[u].w = wt[rdfn[l]]; //此时获得线段树节点的权值 return ; } int mid = (l+r) \u003e\u003e 1; build(u\u003c\u003c1 , l , mid); //递归建树 build(u\u003c\u003c1|1 , mid+1 , r); pushup(u); //每建一层就通过两个孩子更新自己 } void pushdown(int u){ //通过迟滞，下放lazy，在需要的时候更新，这样会减少操作量 if(tn[u].lazy){ tn[u\u003c\u003c1].w = (tn[u\u003c\u003c1].w + tn[u\u003c\u003c1].siz * tn[u].lazy) % mod; //通过迟滞来更新子节点的权值 tn[u\u003c\u003c1|1].w = (tn[u\u003c\u003c1|1].w + tn[u\u003c\u003c1|1].siz * tn[u].lazy) % mod; tn[u\u003c\u003c1].lazy = (tn[u\u003c\u003c1].lazy + tn[u].lazy) % mod; //下放迟滞 tn[u\u003c\u003c1|1].lazy = (tn[u\u003c\u003c1|1].lazy + tn[u].lazy) % mod; tn[u].lazy = 0; //该节点迟滞的作用结束，清空 } } void update(int u,int l,int r,int w){ //更新区间 if(l\u003c=tn[u].l and r\u003e=tn[u].r){ // 当目标区间包含了节点区间时，无法往下操作，更新节点的权值和迟滞 tn[u].w += tn[u].siz * w; tn[u].lazy += w; return ; } pushdown(u); // 下放迟滞准备对子节点的更新操作 int mid = (tn[u].l + tn[u].r) \u003e\u003e 1; //这里是节点区间的一半 if(l\u003c=mid) update(u\u003c\u003c1, l , r , w); if(r\u003emid) update(u\u003c\u003c1|1, l , r , w); pushup(u); //子树更新完毕,通过子节点更新自己 } void add_path(int u,int v,int w){ //对路径的更新操作 while(top[u]!=top[v]){ //如果不属于一条重链 if(dep[top[u]] \u003c dep[top[v]]) swap(u,v); //现在它们属于两条链，始终对链头深度大的进行操作 update(1,dfn[top[u]],dfn[u],w); //更新这条链 u = par[top[u]]; //这条链更新完毕，跳到链头的父节点，这样最终它们会相遇，处在同一条链上 } if(dep[u] \u003e dep[v]) swap(u,v); //让深度低的节点在左，才可以区间操作 update(1,dfn[u],dfn[v],w); //根据dfs序 } int query(int u,int l,int r){ //区间查询 if(l\u003c=tn[u].l and r\u003e=tn[u].r) return tn[u].w; //已经缩到最小区间，直接返回值 int ans = 0; pushdown(u); //下放迟滞，以备后续操作 int mid = (tn[u].l + tn[u].r) \u003e\u003e 1; if(l\u003c=mid) ans = (ans + query(u\u003c\u003c1 , l , r)) % mod; if(r\u003emid) ans = (ans + query(u\u003c\u003c1|1 , l , r)) % mod; return ans; } int query_path(int u,int v){ //路径上的查询 int ans = 0; while(top[u] != top[v]){ //与路径上的更新相同 if(dep[top[u]] \u003c dep[top[v]]) swap(u,v); ans = (ans + query(1, dfn[top[u]] , dfn[u])) % mod; u = par[top[u]]; } if(dep[u] \u003e dep[v]) swap(u,v); ans = (ans + query(1,dfn[u],dfn[v])) % mod; return ans; } int main(){ //freopen(\"in.txt\",\"r\",stdin); cin\u003e\u003en\u003e\u003em\u003e\u003er\u003e\u003emod; for(int i=1;i\u003c=n;i++){ cin\u003e\u003ewt[i]; } for(int i=0;i\u003cn-1;i++){ int x,y; cin\u003e\u003ex\u003e\u003ey; add_edge(x,y); add_edge(y,x); } dfs1(r,0); //初始化 dfs2(r,0,r); build(1,1,n); for(int i=0;i\u003cm;i++){ int tp; cin\u003e\u003etp; switch(tp){ case 1:{ int x,y,z; cin\u003e\u003ex\u003e\u003ey\u003e\u003ez; add_path(x,y,z%mod); break; } case 2:{ int x,y; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003cquery_path(x,y)\u003c\u003cendl; break; } case 3:{ int x,z; cin\u003e\u003ex\u003e\u003ez; update(1,dfn[x],dfn[x]+sz[x]-1,z%mod); break; } case 4:{ int x; cin\u003e\u003ex; cout\u003c\u003cquery(1,dfn[x],dfn[x]+sz[x]-1)\u003c\u003cendl; break; } } } return 0; } ","date":"2020-02-05","objectID":"/graph-theory/:15:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"树上启发式合并 dsu on tree 并查集的按秩合并是启发式，即小的往大的合并，减少查询难度 树上启发式合并通过树链剖分中重孩子的定义，在对子树查询时，先处理所有轻孩子，然后撤销（消除轻孩子对父节点的影响），再处理重孩子，不撤销，最后再处理一遍轻孩子，把对父节点的贡献和重孩子合并 撤销的目的在于对节点信息查询时会开辟一个数组，对于不同子节点，这个数组要再开辟一次，这样会MLE 以这道题为例 （无注释代码点击此处） #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 1e5 + 10; struct edge{ int to,nxt; }e[maxn\u003c\u003c1]; int sz[maxn],par[maxn],c[maxn],head[maxn],wch[maxn],ans[maxn],num[maxn]; //这些变量见树链剖分部分 int n,m; int sum; //子树颜色数 int cnt; //计数器 void add_edge(int u,int v){ e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; } void dfs(int u,int p){ sz[u] = 1; for(int i = head[u]; i ; i=e[i].nxt){ int t = e[i].to; if(t != p){ dfs(t,u); sz[u] += sz[t]; if(sz[t] \u003e sz[wch[u]]) wch[u] = t; } } } void cal(int u,int p,int wch,int val){ if(!num[c[u]]) sum++; //如果之前数量为0，说明是新颜色 num[c[u]] += val; for(int i=head[u]; i ; i=e[i].nxt){ int t = e[i].to; if(t != p and t != wch){ //跳过重孩子 cal(t,u,wch,val); } } } void dsu(int u,int p,int kp){ //kp表示是否撤销 for(int i=head[u]; i ; i=e[i].nxt){ int t = e[i].to; if(t != p and t != wch[u]){ dsu(t,u,0); //先处理轻孩子，需要撤销 } } if(wch[u]) dsu(wch[u] , u , 1); //处理重孩子，需要保留 cal(u,p,wch[u],1); //计算轻孩子 ans[u] = sum; if(!kp){ cal(u,p,0,-1); //撤销操作 sum = 0; } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003en; for(int i=0;i\u003cn-1;i++){ int x,y; cin\u003e\u003ex\u003e\u003ey; add_edge(x,y); add_edge(y,x); } for(int i=1;i\u003c=n;i++){ cin\u003e\u003ec[i]; } dfs(1,0); //初始化 dsu(1,0,1); cin\u003e\u003em; while(m--){ int foo; cin\u003e\u003efoo; cout\u003c\u003cans[foo]\u003c\u003cendl; } return 0; } ","date":"2020-02-05","objectID":"/graph-theory/:16:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["algorithm"],"content":"Dinic算法 用来解决最大流问题 有两类算法 增广路算法（dinic ek isap ff） 预流推进算法 （hlpp） dinic算法是经典算法，hlpp可能更快一点 dinic算法的本质还是贪心+暴力 通过不断地对残余网络(residual networks)求增广路(augmenting paths)，对每一条增广路求流量，然后把流量加起来就是最大流 有一个问题：在对增广路下放流量时，可能错过最优解 解决的方法是，对每条边加一条反向边，流量在原来的边减多少，就在反向边加多少，这样可以通过流入反向边来达到撤销的操作 dinic的操作过程分两步 bfs建立分层图，通过最短路的原则分层，每次在最短路的前提下找增广路，这是贪心的思想，这样会使找增广路高效且达到可行解 dfs找增广路，不断对边进行流量增减操作，暴力枚举思想 不断迭代每次产生的残余网络 三种优化（主要是后两者）参考文章 当前弧优化 ： 增广路搜索中不再考虑之前搜索过的边 多路增广优化： 对于某一条边减去的流量，因增广路覆盖的次数会进行多次操作，现在只需要一次操作就行（操作总的流量），从一次bfs，多次dfs到多次bfs，一次dfs 炸点优化 ： 当某一条增广路中流量为0时，这个点在当前dfs搜索增广路中将不可达，所以直接炸点 时间复杂度 O(n*n*m) 实际合理运用优化之后，很难达到这样的时间复杂度，dinic算法还是很高效的，甚至可以跑十万个点 根据最大流最小割定理(maximum flow minimum cut theorem) 最大流就是有源汇最小割 对于无源汇最小割和全局最小割可以用Stoer Wagner算法 对于有源汇无源汇上下界最大流，参考此处 对于时间要求苛刻的最大流可以用HLPP算法 对于费用流，可以用spfa 对于最大流的各种变体，参考其他资料 测模板题 无注释代码 //有时需改成long long #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 205; const int maxm = 5005; int n,m,s,t; const int inf = 0x3f3f3f3f; struct edge{ int to , w , nex; }e[maxm\u003c\u003c1]; //maxm int tot=2,head[maxn]; // tot = 2 !! int dep[maxn],cur[maxn]; //dep : dfs得到的最短距离 cur : 当前弧优化需要拷贝的数组 void add_edge(int u,int v,int w){ e[tot].to = v; e[tot].w = w; e[tot].nex = head[u]; head[u] = tot++; } bool bfs(){ memset(dep , 0 , sizeof(dep)); //memset(dep , 0 , (tot+2)\u003c\u003c2); queue\u003cint\u003e q; q.push(s); dep[s] = 1; int u , v; while(q.size()){ u = q.front(); q.pop(); for(int i = head[u] ; i ; i = e[i].nex){ v = e[i].to; if(dep[v] or e[i].w \u003c= 0) continue; //v 已达到不能作为dfs的增广路 ， 断流的点不能作为dfs的增广路 dep[v] = dep[u] + 1; q.push(v); } } for(int i=0;i\u003c=n;i++) cur[i] = head[i]; //拷贝作为当前弧优化 return dep[t]; //是否到达汇点 } int dfs(int u , int flow){ if(u == t) return flow; int nowflow = 0; //当前流量 for(int\u0026 i = cur[u] , v ; i ; i = e[i].nex){ //当前弧优化 v = e[i].to; if(dep[v] != dep[u] + 1 or e[i].w \u003c= 0) continue; //不满足深度递增或断流就不能作为增广路 if(int delta = dfs(v , min(flow - nowflow , e[i].w))){ e[i].w -= delta; e[i^1].w += delta; nowflow += delta; //多路增广优化，for循环一直进行，nowflow一直增加 if(nowflow == flow) break; //已达到最大流量 } } if(!nowflow) dep[u] = -2; //炸点优化 return nowflow; } ll dinic(){ ll ans = 0 ; while(bfs()){ //对残余网络不断分层，以备之后dfs求增广路，当汇点不可达时，残余网络将永远不可达 ans += dfs(s , inf); } return ans; } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin\u003e\u003en\u003e\u003em\u003e\u003es\u003e\u003et; for(int i=0;i\u003cm;i++){ int x,y,z; cin\u003e\u003ex\u003e\u003ey\u003e\u003ez; add_edge(x,y,z); add_edge(y,x,0); } ll ans = dinic(); cout\u003c\u003cans\u003c\u003cendl; return 0; } ","date":"2020-02-05","objectID":"/graph-theory/:17:0","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"/graph-theory/"},{"categories":["poj"],"content":"poj","date":"2020-01-27","objectID":"/poj/","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"线段相交 1127 ","date":"2020-01-27","objectID":"/poj/:1:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 判断两条线段是否相交，对于N条线段，间接相交也算相交。对于每次询问，判 断给定的两条线段是否相交 ","date":"2020-01-27","objectID":"/poj/:1:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 这个题目分成两部分，一部分是基础的判断两条线段是否相交，用一个bool数组来存储信息。另一部分是判断间接相交，可以用floyd-warshall（比较巧妙）或者并查集.第一部分就是套模板。 点可以用结构体存储（推荐），线段也可以用结构体存储或pair 判断两条线段相交有多重模板，比如判是否平行、重合、求两条直线交点，判断交点是否在线段上，还有ccw（counter clock wise）函数，可参考discuss 比较常见的是快速排斥和跨立检验 以线段为对角线，作平行于x轴、y轴的射线，使之形成矩形，若两个矩形没有相交，则线段不相交（可以排除大部分） 不满足快速排斥进入跨立检验,判断两个点是否在线段的两侧（即跨立），判断方法是外积的符号是否相反，等于0说明在线上 如果两两互相跨立，则线段相交 #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; int n; bool con[15][15]; int p,q; struct point { double x,y; //point(double a,double b) : x(a),y(b) {} //!!!!!会发生编译错误 }; pair\u003cpoint,point\u003e seg[15]; double dir(point a,point b,point c) //用外积 { return (c.x-a.x)*(c.y-b.y) - (c.y-a.y)*(c.x-b.x); } bool judge(pair\u003cpoint,point\u003e p1,pair\u003cpoint,point\u003e p2) { point a,b,c,d; a=p1.first; b=p1.second; c=p2.first; d=p2.second; //快速排斥 if(min(a.x,b.x)\u003emax(c.x,d.x) or min(c.x,d.x)\u003emax(a.x,b.x) or min(a.y,b.y)\u003emax(c.y,d.y) or min(c.y,d.y)\u003emax(a.y,b.y)) return false; //跨立检验 (int 可改成double) else { int d1,d2,d3,d4; d1=dir(a,b,c); d2=dir(a,b,d); d3=dir(c,d,a); d4=dir(c,d,b); return d1*d2\u003c=0 and d3*d4\u003c=0; //!!! } } int main() { while(scanf(\"%d\",\u0026n)==1 and n!=0) { for(int i=1;i\u003c=n;i++) con[i][i]=true; for(int i=1;i\u003c=n;i++) scanf(\"%lf%lf%lf%lf\",\u0026seg[i].first.x,\u0026seg[i].first.y,\u0026seg[i].second.x,\u0026seg[i].second.y); for(int i=1;i\u003c=n;i++) for(int j=1;j\u003ci;j++) { if(judge(seg[i],seg[j])) con[i][j]=con[j][i]=true; else con[i][j]=con[j][i]=false; } for(int k=1;k\u003c=n;k++) //Floyd-Warshall算法或并查集都可以 for(int i=1;i\u003c=n;i++) for(int j=1;j\u003c=n;j++) con[i][j] |= con[i][k] and con[k][j]; while(scanf(\"%d%d\",\u0026p,\u0026q)==2 and p!=0) puts(con[p][q] ? \"CONNECTED\" : \"NOT CONNECTED\"); } return 0; } ","date":"2020-01-27","objectID":"/poj/:1:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"艰难的debug 计算几何有些很麻烦，代码太相似，debug比较难，有时还要考虑精度问题（即误差eps） debug一个上午 写完代码CE，seg[i].first.x错误，把stl_pair.h中的代码小改一下可以通过，但放到oj上肯定不行，怕污染代码还是不这样做。最后发现把构造函数去掉可以通过 自测，最后一个样例没过，发现是边界情况，把跨立检验最后一步的等号加上 自测，中间有一个样例没过，作图，把样例分离出来，过了。说明可能不是judge函数的问题。 单测样例，没过，说明错误不是受别组影响 编译器debug，把函数内的局部变量，变成全局变量，add watch 发现d1 d2 d3 d4都等于0，a.x a.y b.x b.y ….有问题 继续add watch 发现seg[1].first的内容就有问题，是double边界数，然后发现最终问题 %d 赋值给了double型变量 ","date":"2020-01-27","objectID":"/poj/:1:3","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 提高debug能力，少犯白痴错误。 写代码要有清晰性和完整性，这样鲁棒性更强。 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:1:4","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"并查集 1182 ","date":"2020-01-27","objectID":"/poj/:2:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 并查集 看到信息的内容，有并查集的影子 依次遍历信息，对于每一条信息，因为没有说种类，所以设置三个种类，把每一种情况都加上去，比如：x和y属于同一类，则合并x和y属于A类，B类，C类 判断是否是错误信息，只要判断是否与前面信息矛盾即可 并查集的时间复杂度O(α(n)) α(n)是阿克曼函数的反函数，比O(lgn)还快 代码如下（并查集的模板 + 并查集的应用） #include\u003ciostream\u003e using namespace std; int T[100005],X[100005],Y[100005]; int n,k; //union find int par[150005]; //父亲 int rankk[150005]; //树的高度,!!!元素是根 （优化用）//reference to \"rank\" is ambiguous //初始化，要用并查集前要初始化 void init(int n) { for(int i=0;i\u003cn;i++) { par[i]=i; rankk[i]=0; } } //查询树的根 int find(int x) { if(par[x]==x) return x; else return par[x]=find(par[x]); //return find(par[x]);也可以 。par[x]=find(par[x]) 是路径压缩优化 } //合并x,y //优化高度（如果rankk不同，那么从rankk小的向大的连边 void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return ; //判断是否已在同一个集合内 if(rankk[x]\u003crankk[y]) par[x]=y; //!!!利用它们的 根 进行合并 else { par[y]=x; if(rankk[x]==rankk[y]) rankk[x]++; //这时候rankk还是原来的高度 } } //判断是否在同一个集合内 bool same(int x,int y) { return find(x)==find(y); } int main() { cin\u003e\u003en\u003e\u003ek; for(int i=0;i\u003ck;i++) scanf(\"%d%d%d\",\u0026T[i],\u0026X[i],\u0026Y[i]); init(n*3); int ans=0; for(int i=0;i\u003ck;i++) { int t=T[i],x=X[i]-1,y=Y[i]-1; //错误的编号 if(x\u003c0 || x\u003e=n || y\u003c0 || y\u003e=n) { ans++; continue; } else if(t==1) //第一种类型 { if(same(x,y+n) || same(x,y+2*n)) ans++; //判断是否矛盾 //!!!只需要判断x在A类就行，因为每次unite都 //涵盖所有情况，它们是平行影响的，判断一个就相当于判断所有 else { unite(x,y); unite(x+n,y+n); unite(x+n+n,y+n+n); } } else if(t==2) { if(same(x,y) || same(x,y+2*n)) ans++; else { unite(x,y+n); unite(x+n,y+2*n); unite(x+2*n,y); } } } cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:2:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"完全背包问题 1384 ","date":"2020-01-27","objectID":"/poj/:3:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 题意：完全背包问题求最小价值 时间复杂度O(nm) 二维数组如下，MLE #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; int dp[505][10005]; int v[505]; int w[505]; int t; int e,f; int n,m; const int inf=0x3f3f3f3f; int main() { cin\u003e\u003et; while(t--) { cin\u003e\u003ee\u003e\u003ef; m=f-e; cin\u003e\u003en; //init fill(dp[0],dp[0]+n*(m+1),inf); dp[0][0]=0; for(int i=1;i\u003c=n;i++) scanf(\"%d%d\",\u0026v[i],\u0026w[i]); for(int i=1;i\u003c=n;i++) for(int j=0;j\u003c=m;j++) if(j\u003cw[i]) dp[i][j]=dp[i-1][j]; else dp[i][j]=min(dp[i-1][j],dp[i][j-w[i]]+v[i]); if(dp[n][m]!=inf) printf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[n][m]); else printf(\"This is impossible.\\n\"); } return 0; } 改一维数组，AC #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; int dp[10005]; int v[505]; int w[505]; int t; int e,f; int n,m; const int inf=0x3f3f3f3f; int main() { cin\u003e\u003et; while(t--) { cin\u003e\u003ee\u003e\u003ef; m=f-e; cin\u003e\u003en; //init fill(dp,dp+m+1,inf); //!!!!! dp[0]=0; for(int i=1;i\u003c=n;i++) scanf(\"%d%d\",\u0026v[i],\u0026w[i]); for(int i=1;i\u003c=n;i++) for(int j=w[i];j\u003c=m;j++) dp[j]=min(dp[j],dp[j-w[i]]+v[i]); if(dp[m]!=inf) printf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[m]); else printf(\"This is impossible.\\n\"); } return 0; } 这个地方要注意 fill 到 dp+m+1 滚动数组好啊 AC代码 #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; int dp[2][10005]; int v[505]; int w[505]; int t; int e,f; int n,m; const int inf=0x3f3f3f3f; int main() { //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003et; while(t--) { cin\u003e\u003ee\u003e\u003ef; m=f-e; cin\u003e\u003en; //init fill(dp[0],dp[0]+2*(m+1),inf); dp[0][0]=0; for(int i=1;i\u003c=n;i++) scanf(\"%d%d\",\u0026v[i],\u0026w[i]); for(int i=1;i\u003c=n;i++) for(int j=0;j\u003c=m;j++) if(j\u003cw[i]) dp[i\u00261][j]=dp[(i-1)\u00261][j]; else dp[i\u00261][j]=min(dp[(i-1)\u00261][j],dp[i\u00261][j-w[i]]+v[i]); if(dp[n\u00261][m]!=inf) printf(\"The minimum amount of money in the piggy-bank is %d.\\n\",dp[n\u00261][m]); else printf(\"This is impossible.\\n\"); } return 0; } ","date":"2020-01-27","objectID":"/poj/:3:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 这种类型的dp有两个重点，初始化边界条件，找递推式 求最小，一般初始化为inf，dp[0][0]=0; 求最大，一般初始化为0 必要时可用滚动数组 完全背包递推式的证明（这里证明求最大值的情况） dp[i][j]=max{dp[i-1][j-k*w[i]]+k*v[i] | k\u003e=0} =max(dp[i-1][j] , max{dp[i-1][j-k*w[i]]+k*v[i] | k\u003e=1} =max(dp[i-1][j] , max{dp[i-1][(j-w[i])-k*w[i]]+k*v[i] | k\u003e=0}+v[i]) =max(dp[i-1][j] , dp[i][j-w[i]]+v[i]) 这种分离思想很常见 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:3:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"线性dp LCS 1458 ","date":"2020-01-27","objectID":"/poj/:4:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 水一题线性dp裸题–LCS(longest common subsequence) 因为没加string头文件CE了3次（被error误导了） ac代码 #include\u003ciostream\u003e #include\u003ccstring\u003e #include\u003cstring\u003e using namespace std; string s1,s2; int dp[1000][1000]; //dp[i][j] 表示s1到i，s2到j的lcs长度 int len1,len2; int lcs(string s1,string s2) { len1=s1.length(); len2=s2.length(); memset(dp,0,sizeof(dp)); for(int i=0;i\u003clen1;i++) for(int j=0;j\u003clen2;j++) if(s1[i]==s2[j]) dp[i+1][j+1]=dp[i][j]+1; else dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]); return dp[len1][len2]; } int main() { //freopen(\"input.txt\",\"r\",stdin); while(cin\u003e\u003es1\u003e\u003es2) cout\u003c\u003clcs(s1,s2)\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:4:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"凸包 2187 ","date":"2020-01-27","objectID":"/poj/:5:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 平面上有n个不重合的点，求两个点的最远距离 ","date":"2020-01-27","objectID":"/poj/:5:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 由于点的个数为50000，所以暴力超时 构造凸包，遍历凸包上的点即可 坐标范围在n内的凸多边形（顶点在格点上）的顶点个数最多为O（√n）（尝试不严谨的画图证明，和公差为1的等差数列求和有关，所以是平方关系） 所以构造凸包后，暴力遍历的时间复杂度为O（n） 构造凸包可以用模板 此处介绍的是时间复杂度O(nlgn）的graham扫描法 外积是很常用的工具，此处利用外积的坐标公式的符号判断凹凸性 可以对点先排序，然后按逆时针方向依次遍历点，先构造凸包的下侧，到达最右端时，构造凸包的上侧 代码如下 #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; int n; struct point { double x,y; }ps[50005]; double s_dist(point a,point b) { double dx=a.x-b.x,dy=a.y-b.y; return dx*dx+dy*dy; } bool cmp(point a,point b) { if(a.x!=b.x) return a.x\u003cb.x; return a.y\u003cb.y; } double out_product(double x1,double y1,double x2,double y2) { return x1*y2-x2*y1; } vector\u003cpoint\u003e convex_hull(point* ps,int n) { sort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序 int k=0; // 凸包点的index vector\u003cpoint\u003e qs(n*2); //构造凸包 //逆时针构造凸包 //构造凸包的下侧 for(int i=0;i\u003cn;i++) { while(k\u003e1 \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--; qs[k++]=ps[i]; } //继续构造凸包的上侧 for(int i=n-2,t=k;i\u003e=0;i--) { while(k\u003et \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--; //这里有个k\u003et 和 k\u003e1效果一样 qs[k++]=ps[i]; } qs.resize(k-1); return qs; } int main() { cin\u003e\u003en; for(int i=0;i\u003cn;i++) { point p; scanf(\"%lf%lf\",\u0026p.x,\u0026p.y); ps[i]=p; } vector\u003cpoint\u003e qs=convex_hull(ps,n); double res=0; for(int i=0;i\u003cqs.size();i++) for(int j=0;j\u003ci;j++) res=max(res,s_dist(qs[i],qs[j])); cout\u003c\u003c(int)res\u003c\u003cendl; //!!!不加int 或不用printf(\"%.0lf\\n\",res); 就会WA return 0; } 还有一种时间复杂度更低的方法 convex hull + rotating calipers 这是一种常见、经典的方法 对踵点：如果凸包上过两个点画两条平行线，使凸包所有的点都夹在这两条线之间，这两个点就叫对踵点，称为一对对踵点对 对于一个凸包，最远距离一定是对踵点对 所以先找一对对踵点对，根据判断凹凸性，确定哪个点向后面的点移动（如图）（图懒得画），宏观来看就是对踵点对的连线旋转了180° 这样就总时间复杂度就是O（√n） 代码如下 #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; int n; struct point { double x,y; }ps[50005]; inline double s_dist(point a,point b) { double dx=a.x-b.x,dy=a.y-b.y; return dx*dx+dy*dy; } bool cmp(point a,point b) { if(a.x!=b.x) return a.x\u003cb.x; return a.y\u003cb.y; } inline double out_product(double x1,double y1,double x2,double y2) { return x1*y2-x2*y1; } vector\u003cpoint\u003e convex_hull(point* ps,int n) { sort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序 int k=0; // 凸包点的index vector\u003cpoint\u003e qs(n*2); //构造凸包 //逆时针构造凸包 //构造凸包的下侧 for(int i=0;i\u003cn;i++) { while(k\u003e1 \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--; qs[k++]=ps[i]; } //继续构造凸包的上侧 for(int i=n-2,t=k;i\u003e=0;i--) { while(k\u003et \u0026\u0026 out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u003c=0) k--; //这里有个k\u003et 和 k\u003e1效果一样 qs[k++]=ps[i]; } qs.resize(k-1); return qs; } int main() { cin\u003e\u003en; for(int i=0;i\u003cn;i++) { point p; scanf(\"%lf%lf\",\u0026p.x,\u0026p.y); ps[i]=p; } vector\u003cpoint\u003e qs=convex_hull(ps,n); double res=0; int m=qs.size(); if(m==2) //特殊处理凸包退化情况 { cout\u003c\u003c(int)s_dist(qs[0],qs[1])\u003c\u003cendl; return 0; } int i=0,j=0; //表示左右俩对踵点 //求x轴方向上的对踵点对 for(int k=0;k\u003cm;k++) if(cmp(qs[j],qs[k])) j=k; //rotating calipers int si=i,sj=j; while(!(i==sj \u0026\u0026 j==si)) //旋转180°，注意判断条件 { //cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cj\u003c\u003cendl; res=max(res,s_dist(qs[i],qs[j])); //这条语句放在while循环体的前端，可以把x轴方向上的对踵点对都比较 //通过外积判断凹凸性，判断是i移到i+1，还是j移到j+1 if(out_product(qs[(i+1)%m].x-qs[i].x , qs[(i+1)%m].y-qs[i].y , qs[(j+1)%m].x-qs[j].x , qs[(j+1)%m].y-qs[j].y)\u003c0) //\u003c0 或\u003c=0都可以 i=(i+1)%m; //把m错写成n,tle好久 else j=(j+1)%m; //!!!要%m 这样转一圈才能回到起点，退出循环 } //之前添加的debug条件忘记屏蔽，WA了特久 cout\u003c\u003c(int)res\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:5:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"bfs dfs 2386 ","date":"2020-01-27","objectID":"/poj/:6:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 bfs dfs都行 基础dfs 时间复杂度 O(mn) //dfs #include\u003ciostream\u003e using namespace std; char field[105][105]; int n,m; void dfs(int x,int y) { field[x][y]='.'; for(int dx=-1;dx\u003c=1;dx++) for(int dy=-1;dy\u003c=1;dy++) { int nx=x+dx,ny=y+dy; if(0\u003c=nx \u0026\u0026 nx\u003cn \u0026\u0026 0\u003c=ny \u0026\u0026 ny\u003cm \u0026\u0026 field[nx][ny]=='W') dfs(nx,ny); } return ; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin\u003e\u003en\u003e\u003em; for(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) { cin\u003e\u003efield[i][j]; } int res=0; for(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) { if(field[i][j]=='W') { dfs(i,j); res++; } } cout\u003c\u003cres\u003c\u003cendl; return 0; } ","date":"2020-01-27","objectID":"/poj/:6:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 经典dfs就是递归思想 如果图外面是可达且连通的，就在图外面加一圈 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:6:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"状态压缩dp 2686 ","date":"2020-01-27","objectID":"/poj/:7:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 TSP问题 不能在多项式时间内求解 暴力求解是阶乘数量级的 在数据不是很大的时候可以用状态压缩dp 对于这道题时间复杂度O((2^n)*m*m*n) 基础状态压缩dp 以3.667为例 道路图为 dp[S][x] S表示剩余车票集合 x表示从a出发到达x（单源最短路） dp表示最小花费 这样就变成DAG求最短路问题，不需要使用dijkstra算法，用dp就可以 dp的初始条件是 dp=inf , dp[U][a]=0 dp的状态转移方程 dp[S/{i}][u] = min{dp[S][v]+d[v][u]/t[i] (i∈S)} 将集合用整数的二进制表示 根据状态转移方程，可以用记忆化搜索+递归 这个问题可以用循环嵌套求解 约束条件很重要 这道题的约束条件是“车票” 如果题目要求每个点只能走一遍的话 那么又有一个约束条件是“点”（即判断这个点是否走过） 循环嵌套的写法就是按照套路 遍历所有子集，嵌套遍历每种子集的操作情况 遍历集合的所有情况（逆序） 嵌套遍历每个点 再嵌套遍历每个点 依题意再嵌套遍历剩下的所有车票（顺序可与上一步调换） 最后遍历所有的dp[S’][b] S’⊆U，获得最小值 ac代码 #include\u003ciostream\u003e #include\u003ccstring\u003e #define maxn 8 #define maxm 30 #define inf 0x3f3f3f3f using namespace std; int n,m,p,a,b; int t[maxn]; int d[maxm][maxm]; double dp[1\u003c\u003cmaxn][maxm]; //dp[剩下的车票集合][目标城市]=从a到达目标城市的最短时间 int main() { while(scanf(\"%d%d%d%d%d\",\u0026n,\u0026m,\u0026p,\u0026a,\u0026b)==5 and !(n==0 and m==0 and p==0 and a==0 and b==0)) { for(int i=0;i\u003cn;i++) scanf(\"%d\",\u0026t[i]); memset(d,-1,sizeof(d)); int temp1,temp2,temp3; for(int i=0;i\u003cp;i++) { scanf(\"%d%d%d\",\u0026temp1,\u0026temp2,\u0026temp3); d[temp1-1][temp2-1]=temp3; d[temp2-1][temp1-1]=temp3; } for(int i=0;i\u003c1\u003c\u003cn;i++) fill(dp[i],dp[i]+m,inf); //注意这里要用循环初始化二维数组 //inf是因为要用到min dp[(1\u003c\u003cn)-1][a-1]=0; double res=inf; //inf是因为要用到min for(int s=(1\u003c\u003cn)-1;s\u003e=0;s--) { res=min(res,dp[s][b-1]); for(int v=0;v\u003cm;v++) { for(int u=0;u\u003cm;u++) { if(d[v][u]\u003e=0) { for(int i=0;i\u003cn;i++) { if(s\u003e\u003ei\u00261) { dp[s\u0026~(1\u003c\u003ci)][u]=min(dp[s\u0026~(1\u003c\u003ci)][u],dp[s][v]+(double)d[u][v]/t[i]); } } } } } } if(res==inf) printf(\"Impossible\\n\"); else printf(\"%.3lf\\n\",res); //discuss里面说poj用lf会wa,用f就ac ，但我试了lf也可以ac } return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:7:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"强连通分量 2816 ","date":"2020-01-27","objectID":"/poj/:8:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 如果一头牛被其他所有牛认为是红牛，那么和它在同一个强连通分量的所有牛都 是红牛，所以scc分解，拓扑序最后一个强连通分量是红牛群，最后检查这个连通 块中的一头红牛是否对所有牛可达 #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003ccstring\u003e using namespace std; int V,m; int t1,t2; #define maxv 10005 vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv]; vector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; void add_edge(int from,int to){ G[from].push_back(to); rG[to].push_back(from); } void dfs(int v){ used[v]=true; for(int i=0;i\u003cG[v].size();i++){ if(!used[G[v][i]]) dfs(G[v][i]); } vs.push_back(v); } void rdfs(int v,int k){ used[v]=true; cmp[v]=k; for(int i=0;i\u003crG[v].size();i++){ if(!used[rG[v][i]]) rdfs(rG[v][i],k); } } int kosaraju_scc(){ memset(used,0,sizeof(used)); vs.clear(); for(int i=0;i\u003cV;i++) if(!used[i]) dfs(i); memset(used,0,sizeof(used)); int k=0; for(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++); return k; } int main(){ cin\u003e\u003eV\u003e\u003em; while(m--){ cin\u003e\u003et1\u003e\u003et2; add_edge(t1-1,t2-1); } int k=kosaraju_scc(); int u=0,num=0; //备选个数 u取得正序最后一个 for(int i=0;i\u003cV;i++){ if(cmp[i]==k-1){ u=i; num++; } } memset(used,0,sizeof(used)); rdfs(u,0); //反向判断是否都可达 for(int i=0;i\u003cV;i++){ if(!used[i]){ num=0; break; } } cout\u003c\u003cnum\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:8:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"扫描线 2932 ","date":"2020-01-27","objectID":"/poj/:9:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 坐标上有n个不相交的圆，求最外层圆的index ","date":"2020-01-27","objectID":"/poj/:9:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 由于数据规模，暴力超时 sweeping line 一般有两种，平移扫描，环形扫描 对于这一题，从左到右平移扫描 用一个容器维护每个圆的左右两个端点，代表扫描到圆和扫描出圆 对于扫描到的圆，判断它是否在别的圆内 只需要判断上下最近的两个圆（可画图证明，不严谨） 用一个容器维护还没扫描出的最外圆，可以排序，再查找。总时间复杂度O(nlgn) 可以选用set 当扫描到右时，把圆从set中去除，意味着扫描过了 #include\u003ciostream\u003e #include\u003cset\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; double x[40005],y[40005],r[40005]; int n; typedef pair\u003cdouble ,int\u003e pdi; bool inside(int i,int j) { double dx=x[i]-x[j],dy=y[i]-y[j]; return dx*dx+dy*dy\u003c=r[j]*r[j]; } int main() { cin\u003e\u003en; for(int i=0;i\u003cn;i++) scanf(\"%lf%lf%lf\",\u0026r[i],\u0026x[i],\u0026y[i]); vector\u003cpdi\u003e vt; //存左右两边界 for(int i=0;i\u003cn;i++) { vt.push_back(make_pair(x[i]-r[i],i)); vt.push_back(make_pair(x[i]+r[i],i+n)); } sort(vt.begin(),vt.end()); //扫描 set\u003cpdi\u003e outers; //set为了排序 vector\u003cint\u003e res; //存放结果 for(int i=0;i\u003cvt.size();i++) { int id=vt[i].second%n; if(vt[i].second\u003cn) //扫描到左 { set\u003cpdi\u003e::iterator it=outers.lower_bound(make_pair(y[id],id)); if(it!=outers.end() \u0026\u0026 inside(id,it-\u003esecond)) continue; //上面最近的圆 if(it!=outers.begin() \u0026\u0026 inside(id,(--it)-\u003esecond)) continue; //下面最近的圆 res.push_back(id); outers.insert(make_pair(y[id],id)); } else //扫描到右 outers.erase(make_pair(y[id],id)); } sort(res.begin(),res.end()); cout\u003c\u003cres.size()\u003c\u003cendl; for(int i=0;i\u003cres.size();i++) printf(\"%d%c\",res[i]+1,i+1==res.size()? '\\n' : ' '); return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:9:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"贪心 3069 ","date":"2020-01-27","objectID":"/poj/:10:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 一条路上有n个路灯，每个路灯都能照亮左右的一段距离，问最少需要多少路灯才能使街道都亮着 ","date":"2020-01-27","objectID":"/poj/:10:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 greedy 从最左开始向右延伸r，在r的范围内将最右的路灯点亮，此时这盏路灯将照亮左边和右边，从暗处的最左路灯开始，已知重复下去。 时间复杂度 O(n) !!!!需要将路灯位置排序 #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; int r,n; int x[1006]; int main() { while(scanf(\"%d%d\",\u0026r,\u0026n)==2 \u0026\u0026 r!=-1) { for(int i=0;i\u003cn;i++) scanf(\"%d\",\u0026x[i]); sort(x,x+n); // ！！！记得排序 int j=0,ans=0; while(j\u003cn) { int s=x[j++]; while(j\u003cn \u0026\u0026 x[j]\u003c=s+r) j++; int p=x[j-1]; while(j\u003cn \u0026\u0026 p+r\u003e=x[j]) j++; ans++; } printf(\"%d\\n\",ans); } return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:10:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"贪心 3617 ","date":"2020-01-27","objectID":"/poj/:11:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题意 给一个字符串s和空字符串p，每次进行以下操作之一 删除s的头部字符，加入到p的尾部 删除s的尾部字符，加入到p的尾部 最后s为空，p的字典序最小 ","date":"2020-01-27","objectID":"/poj/:11:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 greedy 时间复杂度最坏 O($n^2$) #include\u003ciostream\u003e using namespace std; int n; char s[2005]; int c=0; int main() { cin\u003e\u003en; for(int i=0;i\u003cn;i++) { cin\u003e\u003es[i]; } int a=0,b=n-1; bool left=false; while(a\u003c=b) { for(int i=0;a+i\u003c=b;i++) { if(s[a+i]\u003cs[b-i]) { left=true; break; } else if(s[a+i]\u003es[b-i]) { left=false; break; } } if(left) putchar(s[a++]); else putchar(s[b--]); c++; if(c%80==0) putchar('\\n'); } return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:11:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"01背包问题 3624 ","date":"2020-01-27","objectID":"/poj/:12:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 基础01背包问题 如果用二维数组写的话就会MLE 猜测测试数据可能不会满，就随着数据动态申请内存，想侥幸过（可以用new/delete 或 malloc/free）结果还是MLE 这是MLE代码 #include\u003ciostream\u003e using namespace std; //int dp[3410][12885]; int n,m; //int w[3410]; //int v[3410]; int main() { cin\u003e\u003en\u003e\u003em; int **dp,*w,*v; dp=new int*[n+3]; for(int i=0;i\u003cn+3;i++) dp[i]=new int[m+3]; w=new int[n+3]; v=new int[n+3]; for(int i=1;i\u003c=n;i++) { scanf(\"%d%d\",\u0026w[i],\u0026v[i]); } //initialized for(int i=0;i\u003c=n;i++) dp[i][0]=0; for(int i=0;i\u003c=m;i++) dp[0][i]=0; for(int i=1;i\u003c=n;i++) for(int j=0;j\u003c=m;j++) if(j\u003cw[i]) dp[i][j]=dp[i-1][j]; else dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); cout\u003c\u003cdp[n][m]; delete dp,w,v; return 0; } 在discuss找了一圈也没有二维数组过的 优化成一维数组（节省内存，容易出bug） AC代码 #include\u003ciostream\u003e using namespace std; int n,m; int dp[12885]; int w[3410]; int v[3410]; int main() { cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++) scanf(\"%d%d\",\u0026w[i],\u0026v[i]); for(int i=1;i\u003c=n;i++) for(int j=m;j\u003e=w[i];j--) dp[j]=max(dp[j],dp[j-w[i]]+v[i]); cout\u003c\u003cdp[m]; return 0; } 这个内层循环是递减的，如果是递增则解决完全背包问题 由于01背包问题的dp[i]只依赖于dp[i-1]，内层循环递减时，dp[j]依赖的dp[j]为i-1的dp[j] 由于原来在二维数组中就是递增的，是同一个i，所以内层循环递增时，dp[j]依赖的dp[j]为i的dp[j]，符合完全背包问题 由于有两种状态（i和i-1），所以可利用奇偶性滚动数组实现 AC代码 #include\u003ciostream\u003e using namespace std; int n,m; int dp[2][12885]; int w[3410]; int v[3410]; int main() { cin\u003e\u003en\u003e\u003em; for(int i=1;i\u003c=n;i++) scanf(\"%d%d\",\u0026w[i],\u0026v[i]); for(int i=1;i\u003c=n;i++) for(int j=0;j\u003c=m;j++) if(j\u003cw[i]) dp[i\u00261][j]=dp[(i-1)\u00261][j]; else dp[i\u00261][j]=max(dp[(i-1)\u00261][j],dp[(i-1)\u00261][j-w[i]]+v[i]); cout\u003c\u003cdp[n\u00261][m]; return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:12:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"2-SAT 3683 ","date":"2020-01-27","objectID":"/poj/:13:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 xi表示某一婚礼 xi为真表示在开始举行 xi为假表示在结束举行 对于两个婚礼 如果同在开始时间举行会产生冲突 则 ¬xi ∨ ¬xj 为真 遍历所有的关系对，检查是否产生冲突 如果产生冲突则有一个析取式成立 遍历完之后得到一个合取范式 这样就把问题转换成2-SAT 根据蕴含等值式 a ∨ b ⇒ (a ∨ b) ∧ (b ∨ a) ⇒ (¬a → b) ∧ (¬b → a) 对于每一个蕴含式都可以构造一条有向边 最后scc分解 判断合取范式是否是可满足式，只需要检查¬xi 和 xi 是否在同一个强连通分量中 最后对于所在强连通分量的拓扑序，依次给出真值 ac代码 #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003ccstring\u003e using namespace std; int n; int V; const int maxv=2005; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv]; vector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; int s[1005],t[1005],d[1005]; void add_edge(int from,int to){ G[from].push_back(to); rG[to].push_back(from); } void dfs(int v){ used[v]=true; for(int i=0;i\u003cG[v].size();i++){ if(!used[G[v][i]]) dfs(G[v][i]); } vs.push_back(v); } void rdfs(int v,int k){ used[v]=true; cmp[v]=k; for(int i=0;i\u003crG[v].size();i++){ if(!used[rG[v][i]]) rdfs(rG[v][i],k); } } int kosaraju_scc(){ memset(used,0,sizeof(used)); vs.clear(); for(int i=0;i\u003cV;i++) if(!used[i]) dfs(i); memset(used,0,sizeof(used)); int k=0; for(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++); return k; } int main(){ cin\u003e\u003en; int t1,t2,t3,t4,t5; for(int i=0;i\u003cn;i++){ scanf(\"%d:%d%d:%d%d\",\u0026t1,\u0026t2,\u0026t3,\u0026t4,\u0026t5); s[i]=t1*60+t2; t[i]=t3*60+t4; d[i]=t5; } V=n*2; for(int i=0;i\u003cn;i++)for(int j=i+1;j\u003cn;j++){ if( min( s[i]+d[i] , s[j]+d[j] ) \u003e max(s[i] , s[j])){ add_edge(i,n+j); add_edge(j,n+i); } if(min(s[i]+d[i] , t[j]) \u003e max(s[i] , t[j]-d[j])){ add_edge(i,j); add_edge(n+j,i+n); } if(min(t[i] , s[j]+d[j]) \u003e max(s[j] , t[i]-d[i])){ add_edge(i+n,j+n); add_edge(j,i); } if(min(t[i] , t[j]) \u003e max(t[i]-d[i] , t[j]-d[j])){ add_edge(n+i,j); add_edge(n+j,i); } } kosaraju_scc(); for(int i=0;i\u003cn;i++){ if(cmp[i]==cmp[i+n]){ cout\u003c\u003c\"NO\\n\"; return 0; } } cout\u003c\u003c\"YES\\n\"; for(int i=0;i\u003cn;i++){ if(cmp[i]\u003ecmp[i+n]){ printf(\"%02d:%02d %02d:%02d\\n\",s[i]/60,s[i]%60,(s[i]+d[i])/60,(s[i]+d[i])%60); } else{ printf(\"%02d:%02d %02d:%02d\\n\",(t[i]-d[i])/60,(t[i]-d[i])%60,t[i]/60,t[i]%60); } } return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:13:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"bfs dfs 3984 ","date":"2020-01-27","objectID":"/poj/:14:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 dfs/bfs都行 基础bfs （这个测试点只有一个，就是样例） 时间复杂度O(mn) #include\u003ciostream\u003e #include\u003cmap\u003e #include\u003cvector\u003e #include\u003cqueue\u003e #include\u003calgorithm\u003e using namespace std; int n,m; int maze[7][7]; int d[7][7]; const int inf=0x3f3f3f3f; typedef pair\u003cint,int\u003e pii; //表示坐标 int sx,sy,gx,gy; //起点终点 int dx[]={0,0,1,-1}; int dy[]={1,-1,0,0}; map\u003cpii,pii \u003e mp; //记录前驱节点,目的是记录路径 （如果记录路径就可以不用求最短距离） vector\u003cpii \u003e vt; //记录路径 void bfs() { queue\u003cpii\u003e q; fill(d[0],d[0]+7*7,inf); q.push(pii(sx,sy)); d[sx][sy]=0; while(q.size()) { pii p=q.front(); q.pop(); if(p.first==gx and p.second==gy) break; //很重要的终止判断条件 for(int i=0;i\u003c4;i++) { int nx=p.first+dx[i],ny=p.second+dy[i]; if(nx\u003e=0 and ny\u003e=0 and nx\u003cn and ny\u003cm and maze[nx][ny]==0 and d[nx][ny]==inf) //inf的判断很重要 { q.push(pii(nx,ny)); d[nx][ny]=d[p.first][p.second]+1; mp[pii(nx,ny)]=pii(p.first,p.second); } } } } int main() { //freopen(\"input.txt\",\"r\",stdin); n=5; m=5; for(int i=0;i\u003cn;i++) for(int j=0;j\u003cm;j++) cin\u003e\u003emaze[i][j]; sx=0,sy=0,gx=4,gy=4; bfs(); //cout\u003c\u003cd[gx][gy]\u003c\u003cendl; pii p; p=pii(gx,gy); while(p!=pii(sx,sy)) { vt.push_back(p); p=mp[p]; } reverse(vt.begin(),vt.end()); printf(\"(%d, %d)\\n\",sx,sy); for(vector\u003cpii\u003e::iterator it=vt.begin();it!=vt.end();it++) { printf(\"(%d, %d)\\n\",it-\u003efirst,it-\u003esecond); } return 0; } ","date":"2020-01-27","objectID":"/poj/:14:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"总结 一个经典的bfs模板就是用队列来控制广度优先 =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:14:2","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"强连通分量 1236 ","date":"2020-01-27","objectID":"/poj/:15:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 第一问就是求scc的数量，第二问就是求对每个scc出度为0的数量和入度为0的数量 #include\u003ciostream\u003e #include\u003ccstring\u003e #include\u003cvector\u003e using namespace std; const int maxv = 105; int V; vector\u003cint\u003e G[maxv]; vector\u003cint\u003e rG[maxv]; vector\u003cint\u003e vs; bool used[maxv]; int cmp[maxv]; int in[maxv],out[maxv]; void add_edge(int from,int to){ G[from].push_back(to); rG[to].push_back(from); } void dfs(int v){ used[v]=true; for(int i=0;i\u003cG[v].size();i++){ if(!used[G[v][i]]) dfs(G[v][i]); } vs.push_back(v); } void rdfs(int v,int k){ used[v]=true; cmp[v]=k; for(int i=0;i\u003crG[v].size();i++){ if(!used[rG[v][i]]) rdfs(rG[v][i],k); } } int kosaraju_scc(){ memset(used,0,sizeof(used)); vs.clear(); for(int i=0;i\u003cV;i++) if(!used[i]) dfs(i); memset(used,0,sizeof(used)); int k=0; for(int i=vs.size()-1;i\u003e=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++); return k; } int main(){ cin\u003e\u003eV; for(int i=0;i\u003cV;i++){ while(1){ int tmp; cin\u003e\u003etmp; if(tmp==0) break; tmp--; add_edge(i,tmp); } } int k = kosaraju_scc(); for(int i=0;i\u003cV;i++){ for(int j=0;j\u003cG[i].size();j++){ int to = G[i][j]; if(cmp[i] != cmp[to]){ in[cmp[to]]++; out[cmp[i]]++; } } } int ind =0; int outd = 0; for(int i=0;i\u003ck;i++){ if(in[i]==0) ind++; if(out[i]==0) outd++; } int ans; if(k==1) ans = 0;else ans = max(ind,outd); cout\u003c\u003cind\u003c\u003cendl; cout\u003c\u003cans\u003c\u003cendl; return 0; } =========================================================================================================== ","date":"2020-01-27","objectID":"/poj/:15:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"平面点分治 3714 ","date":"2020-01-27","objectID":"/poj/:16:0","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["poj"],"content":"题解 懒得写 #include \u003ciostream\u003e #include \u003ciomanip\u003e #include \u003calgorithm\u003e #include \u003ccmath\u003e using namespace std; typedef double db ; struct node{ db x, y; int flag; }vt[200005], tmp[200005]; bool compy(node n1, node n2){ return n1.y \u003c n2.y; } bool compx(node n1, node n2){ return n1.x \u003c n2.x; } db dist(node n1, node n2){ db dx = fabs(n1.x - n2.x); db dy = fabs(n1.y - n2.y); return sqrt(dx * dx + dy * dy); } db solve(int l, int r){ if(l == r) return 1e50; int m = (l + r) / 2; db d = min(solve(l, m), solve(m + 1, r)); int cnt = 0; for(int i = l; i \u003c= r; ++i){ if(abs(vt[i].x - vt[m].x) \u003c d){ tmp[++cnt] = vt[i]; } } sort(tmp + 1, tmp + cnt + 1, compy); for(int i = 1; i \u003c= cnt; ++i){ for(int j = i + 1; j \u003c= cnt; ++j){ if(tmp[j].y - tmp[i].y \u003e= d) break; if(tmp[j].flag == tmp[i].flag) continue; d = min(d, dist(tmp[i], tmp[j])); } } return d; } int main() { int _; cin \u003e\u003e _; while (_--) { int n; cin \u003e\u003e n; for(int i = 1; i \u003c= n; ++i){ cin \u003e\u003e vt[i].x \u003e\u003e vt[i].y; vt[i].flag = 0; } for(int i = n + 1; i \u003c= 2 * n; ++i){ cin \u003e\u003e vt[i].x \u003e\u003e vt[i].y; vt[i].flag = 1; } sort(vt + 1, vt + 2 * n + 1, compx); cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c solve(1, 2 * n) \u003c\u003c endl; } return 0; } ","date":"2020-01-27","objectID":"/poj/:16:1","tags":["cpp","poj"],"title":"poj","uri":"/poj/"},{"categories":["note"],"content":"简易对拍","date":"2020-01-27","objectID":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/","tags":["cpp"],"title":"简易对拍","uri":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/"},{"categories":["note"],"content":"以这道题为例 准备一个对拍的文件夹，里面装这些东西 duipai_random_input_src.cpp是产生随机测试数据的代码 #include\u003ccstdlib\u003e #include\u003ciostream\u003e #include\u003cctime\u003e using namespace std; int t=100; //数据组数 int main() { srand(time(0)); freopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"w\",stdout); int a,b; while(t--) { a=rand(); b=rand(); if(a\u003eb) swap(a,b); cout\u003c\u003ca\u003c\u003c\" \"\u003c\u003cb\u003c\u003cendl; } return 0; } 将产生的随机测试数据写入duipai_random_input.txt中 ac代码或暴力搜索正确的代码 //ac #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll t1,t2; ll ad; ll fun(ll x) { if(x\u003c=50) return x; if(x\u003e50 and x\u003c=60) return 50; ll m; if(x%60==0) return x-x*10/60; else { m=x/60; ll n=50+m*60; if(x-n\u003e0) { return n-10*m; } else { return x-10*m; } } } int main() { freopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"r\",stdin); freopen(\"D:\\\\c++\\\\duipai\\\\duipai_ac_output.txt\",\"w\",stdout); while(~scanf(\"%lld%lld\",\u0026t1,\u0026t2)) { printf(\"input data are %lld %lld --- \",t1,t2); printf(\"%lld\\n\",fun(t2)-fun(t1-1)); } //cout\u003c\u003cfun(180); return 0; } 从duipai_random_input.txt读入，写到duipai_ac_output.txt中 wa代码 //wa #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; ll t1,t2; ll ad; ll fun(ll x) { if(x\u003c=50) return x; if(x\u003e50 and x\u003c=60) return 50; ll m; if(x%60==0) return x-x*10/60; else { m=x/60; ll n=50+m*60; if(x-n\u003e0) { return n-10*m; } else { return x-10*m; } } } int main() { freopen(\"D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\",\"r\",stdin); freopen(\"D:\\\\c++\\\\duipai\\\\duipai_wa_output.txt\",\"w\",stdout); while(~scanf(\"%lld%lld\",\u0026t1,\u0026t2)) { printf(\"input data are %lld %lld --- \",t1,t2); printf(\"%lld\\n\",fun(t2)-fun(t1)+1); } //cout\u003c\u003cfun(180); return 0; } 从duipai_random_input.txt读入，写到duipai_wa_output.txt中 比较duipai_ac_output.txt 和 duipai_wa_output.txt 在duipai文件夹下运行批处理命令（duipai.bat） @echo off fc duipai_ac_output.txt duipai_wa_outout.txt pause echo off是不回显，fc是文件比较 运行cpp和bat程序 得到结果 过于复杂的输入数据和输出数据，简易对拍不好实现 要产生大随机数，可以用 long long r=123456789; cout\u003c\u003c(long long)((double)(rand()*r)/RAND_MAX); 这题也可对拍 ","date":"2020-01-27","objectID":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/:0:0","tags":["cpp"],"title":"简易对拍","uri":"/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/"},{"categories":["abc"],"content":"abc152-D","date":"2020-01-26","objectID":"/abc152-d/","tags":["cpp"],"title":"abc152-D","uri":"/abc152-d/"},{"categories":["abc"],"content":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数 字，B的第一个数字是A的最后一个数字，个位数也算，输出满足条件的正整数对的个数 这种题感觉abc一贯的风格 当时第一感觉是纯模拟肯定巨麻烦，就想着有没有规律，发现没有规律 又想着按数位分类。 按数位分类就要考虑对子里面的数位 花了一些时间把它整理成元素都是9^n的矩阵（一个对称矩阵） 然而并没有什么用，还是得求N-10^k这个剩余部分 问题又回到起点 试图从9^n求和中找规律，无果 试图简化模拟或换个角度模拟，无果 看了别人的解答，大同小异 遍历一遍N，二维数组存N中第一个数字为 i ，最后一个数字为 j 的个数 最后遍历ans+=c[i][j]*c[j][i] #include\u003cbits/stdc++.h\u003e using namespace std; int n; long long ans; long long c[10][10]; int main() { //freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003en; for(int i=1;i\u003c=n;i++) { string s=to_string(i); c[s[0]-'0'][s[s.length()-1]-'0']++; } for(int i=0;i\u003c10;i++) for(int j=0;j\u003c10;j++) ans+=c[i][j]*c[j][i]; cout\u003c\u003cans; return 0; } 总结：我好弱啊 ","date":"2020-01-26","objectID":"/abc152-d/:0:0","tags":["cpp"],"title":"abc152-D","uri":"/abc152-d/"},{"categories":["note"],"content":"排序算法的时间复杂度","date":"2020-01-23","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","tags":["cpp","sort"],"title":"排序算法的时间复杂度","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["note"],"content":"时间复杂度与计算时间的关系","date":"2020-01-23","objectID":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","tags":["cpp"],"title":"时间复杂度与计算时间的关系","uri":"/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"},{"categories":["note"],"content":"CP笔记","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"记录的东西十分零散，适用于速查，不适合系统学习 由于记录的时候所掌握的知识很浅，所以可能存在错误 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:0:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"快速排序 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; void quicksort(int s[], int l, int r) { if (l \u003c r) { int i = l, j = r, x = s[l]; while (i \u003c j) { while (i \u003c j \u0026\u0026 s[j] \u003e= x) j--; if (i \u003c j) s[i++] = s[j]; while (i \u003c j \u0026\u0026 s[i] \u003c x) i++; if (i \u003c j) s[j--] = s[i]; } s[i] = x; quicksort(s, l, i - 1); quicksort(s, i + 1, r); } } int main() { int a[10] = {3, 5, 1, 8, 9, 4, 2, 6, 0, 1}; int i; quicksort(a, 1, 9); for (i = 0; i \u003c 10; i++) cout \u003c\u003c a[i] \u003c\u003c ' '; return 0; } //3 0 1 1 2 4 5 6 8 9 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:1:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"产生随机数 古老的生成随机数的方法 srand(time(nullptr)); cout \u003c\u003c rand() % 30 + 2 \u003c\u003c '\\n'; //大随机数 long long r = 123456789; cout \u003c\u003c rand() * r / RAND_MAX; c++11生成随机数的方法 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; //#include \u003crandom\u003e //#include \u003cchrono\u003e int main() { mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); //cout \u003c\u003c rd() % 101 + 1; uniform_int_distribution\u003cint\u003e dis(2, 100); //闭区间 cout \u003c\u003c dis(rng); return 0; } 以下这种方法更好，但只在Linux下有效，在win下无效，在win下会生成固定顺序的随机数 mt19937 gen{random_device{}()}; uniform_int_distribution\u003cint\u003e dis(4, 70); //闭区间 for (int i = 0; i \u003c 10; i++) { cout \u003c\u003c dis(gen) \u003c\u003c '\\n'; } // 41 // 52 // 27 // 65 // 4 // 43 // 62 // 38 // 68 // 69 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:2:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"洗牌 vector\u003cint\u003e a{1, 2, 3, 4, 5, 6}; mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); shuffle(a.begin(), a.end(), rng); for (int i : a) { cout \u003c\u003c i \u003c\u003c ' '; } //3 4 5 1 2 6 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:2:1","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"STL ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"list ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:1","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"set #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { set\u003cint\u003e st; int a[] = {1, 2, 3}; st.insert(a, a + 3); st.erase(2); for (int i : st) { cout \u003c\u003c i \u003c\u003c ' '; } st.erase(st.begin(), st.end()); return 0; } //1 3 集合运算 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:2","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"map 和set差不多 map按key倒序排 map\u003cint, int, greater\u003cint\u003e\u003e mp; map想按value排，就要提取出来变成vector\u003cpair\u003cint, int» 想要询问map是否存在一个key，不应该用map[key]==0来判断，应该用map.find(key) == mp.end()来判断 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:3","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"deque 双端队列 front() back() clear() erase() insert(pos, v) insert(pos, n, v) push_back() pop_back() push_front() pop_front() ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:4","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"stack push() pop() top() empty() size() find() unique() sort() count() ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:5","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"queue push() pop() front() empty() size() back() find() unique() sort() count() queue和stack没有clear()，要清空应该这样 queue\u003cint\u003e a; a.push(2); a.push(1); cout \u003c\u003c a.size() \u003c\u003c '\\n'; //2 queue\u003cint\u003e tmp; swap(tmp, a); cout \u003c\u003c a.size() \u003c\u003c '\\n'; //0 stack\u003cint\u003e s; s.push(3); s.push(2); cout \u003c\u003c s.size() \u003c\u003c '\\n'; //2 stack\u003cint\u003e t; swap(t,s); cout \u003c\u003c s.size() \u003c\u003c '\\n'; //0 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:6","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"其他 multiset允许值重复 multiset的erase(x)会把所有x都删掉，而不是删一个 multimap允许key重复 求数组中k出现几次的一种方法，排序+二分查找，upper_bound - lower_bound set\u003cint\u003e s; map\u003cint\u003e m s.lower_bound()比lower_bound(s.begin(),s.end())要快很多，内置的lower_bound()是专为红黑树写的 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:3:7","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"约瑟夫环 总共有people个人，喊到num的倍数退出，求最后一个人 int Josephus(int people, int num) { int i, r = 0; for (i = 2; i \u003c= people; i++) r = (r + num) % i; return r + 1; } ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:4:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"流操作符boolalpha #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int main() { bool a = true; cout \u003c\u003c boolalpha \u003c\u003c a; return 0; } ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:5:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"自定义排序 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; struct cmp { bool operator()(const int \u0026l, const int \u0026r) const { return l \u003e r; } }; int main() { set\u003cint, cmp\u003e s; return 0; } #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; struct Student { int a; bool operator\u003c(const Student \u0026s) const { return this-\u003ea \u003e s.a; //始终把this放s前，不能是s.a \u003c this-\u003ea } }; int main() { set\u003cStudent\u003e s; return 0; } ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:6:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"字符串和字符 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:7:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"c语言有关函数 strXXX #include \u003cbits/stdc++.h\u003e #include \u003ccctype\u003e using namespace std; using ll = long long; #define log(x) cout \u003c\u003c x \u003c\u003c '\\n' int main() { char x ; isalpha(x); isdigit(x); isupper(x); islower(x); isalnum(x); isblank(x); // space \\t isspace(x); // space \\t \\r \\n char a[20] = \"hello\"; char b[20] = \" world\"; char c[20]; strcpy(c, a); log(c); // hello memset(c, 0, sizeof(c)); strncpy(c, a, 3); log(c); // hel strcat(a, b); // a = a + b log(a); // hello world log(strlen(a)); // 11 bool yes = strcmp(a, b); char* chptr = strchr(a, 'l'); log(chptr); // llo world char* chptr2 = strstr(a, \"rl\"); log(chptr2); // rld return 0; } ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:7:1","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"子串相关 string a = \"qwer\"; cout \u003c\u003c a.find(\"we\"); // 1 cout \u003c\u003c a.substr(1, 2); // we ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:7:2","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"字符串和字符数组的转化 string to char[] 字符串转字符数组 char a[20]; string s = \"qwer\"; strcpy(a, s.c_str()); cout \u003c\u003c a \u003c\u003c '\\n'; // qwer 字符数组转字符串 char x[] = \"wertt\"; string s = x; cout \u003c\u003c s; //wertt ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:7:3","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"按字符分割字符串 strtok char s[] = \"s1mple is the best sniper of the world\"; char* token; token = strtok(s, \" \"); while (token != nullptr) { //vector\u003cstring\u003e v; //v.push_back(token); cout \u003c\u003c token \u003c\u003c '\\n'; token = strtok(nullptr, \" \"); } ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:7:4","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"char[]从下标为1开始读入 char a[20]; scanf(\"%s\", a + 1); cout \u003c\u003c strlen(a + 1); ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:7:5","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"其他 string有时要用c_str() ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:7:6","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"背包问题 01背包2维 int n; // 物品个数 int W; // 背包容量 int dp[n + 5][W + 5]; int w[n + 5]; // 每个物品的体积 int v[n + 5]; // 每个物品的价值 for (int i = 1; i \u003c= n; ++i) { for (int j = 0; j \u003c= W; ++j) { if(j \u003c w[i]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); } } } cout \u003c\u003c dp[n][W]; 完全背包 2维 int n; // 物品个数 int W; // 背包容量 int dp[n + 5][W + 5]; int w[n + 5]; // 每个物品的体积 int v[n + 5]; // 每个物品的价值 for (int i = 1; i \u003c= n; ++i) { for (int j = 0; j \u003c= W; ++j) { if(j \u003c w[i]) { dp[i][j] = dp[i - 1][j]; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]); // 注意是dp[i]不是dp[i-1] } } } cout \u003c\u003c dp[n][W]; 完全背包2维公式推导 01背包1维 for (int i = 1; i \u003c= n; ++i) for (int j = W; j \u003e= w[i]; j--) dp[j] = max(dp[j], dp[j - w[i]] + v[i]); return dp[W]; 完全背包1维 for (int i = 1; i \u003c= n; ++i) for (int j = w[i]; j \u003c= W; j++) dp[j] = max(dp[j], dp[j - w[i]] + v[i]); return dp[W]; ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:8:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"memset memset只能初始化0, 1, 0x3f, 0xc0这种的，不能写2,3这种的 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:9:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"memmove int a[3] = {2, 1, 3}; int b[20]; memmove(b, a + 1, 2 * sizeof(int)); for (int i = 0; i \u003c 2; i++) { cout \u003c\u003c b[i] \u003c\u003c ' '; } //1 3 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:10:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"binary_search binary_search 用在有序数组里 #include \u003calgorithm\u003e vector\u003cint\u003e v = {1, 2, 3}; bool condition = binary_search(v.begin(), v.begin() + 2, 1); ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:11:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"next_permutation next_permutation #include \u003calgorithm\u003e int a[3] = {1, 2, 3}; do { cout \u003c\u003c a[0] \u003c\u003c ' ' \u003c\u003c a[1] \u003c\u003c ' ' \u003c\u003c a[2] \u003c\u003c '\\n'; }while (next_permutation(a, a + 3)); //1 2 3 //1 3 2 //2 1 3 //2 3 1 //3 1 2 //3 2 1 next_permutation只能用在数字和字符中 prev_premutation类似 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:12:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"unique unique作用域有序数组 vector\u003cint\u003e a = {3, 3, 2, 2, 1, 1}; sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end(), [\u0026](int i, int j){return (i + 1) == j;}), a.end()); ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:13:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"加速读写 ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); 这样最好只用cin cout，不要用scanf和printf和gets()和puts() scanf和printf比这种加速读写快 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:14:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"While 读取 int a; while (~scanf(\"%d\", \u0026a)) { } while (scanf(\"%d\", \u0026a) != EOF) { } ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:15:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"sizeof退化 #include \u003cbits/stdc++.h\u003e #include \u003calgorithm\u003e using namespace std; using ll = long long; #define log(x) cout \u003c\u003c x \u003c\u003c '\\n' void fun(int a[]) { cout \u003c\u003c sizeof(a) \u003c\u003c '\\n'; } int main() { int a[] = {1, 2, 3, 4, 5, 6, 7}; fun(a); // output 8 return 0; } 此处int[]变为指针，sizeof算的是地址长度，不是数组长度 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:16:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"find string的find没找到返回string::npos，stl返回end()，找到则返回下标的迭代器或偏移地址 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:17:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"incline 内联函数，如果一个自定义函数内容较少且调用次数较多，可以在函数前加incline，这样调用时，直接将代码复制，避免大开销 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:18:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"浮点数的向下取整 double x = 2.4567; printf(\"%.2f\", x); // 四舍五入 printf(\"%.2f\", floor(x * 100) / 100); // 向下取整，保留几位就乘pow(10,n) // 2.46 // 2.45 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:19:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"merge 使用merge之前要对数组分配空间，vector可以用resize，merge(first1, last1, first2, last2, dest, cmp) vector\u003cint\u003e a{3, 4, 1}; vector\u003cint\u003e b{1, 9, 7, 7}; vector\u003cint\u003e c; c.resize(10); merge(a.begin(), a.end(), b.begin(), b.end(), c.begin()); for (int i : c) { cout \u003c\u003c i \u003c\u003c ' '; } //1 3 4 1 9 7 7 0 0 0 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:20:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"inplace_merge() ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:20:1","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"字符串和数字转化 stringstream只能用一次，用ss.clear()重置 #include \u003cstring\u003e int a = 123; string s = to_string(a); cout \u003c\u003c s \u003c\u003c '\\n'; //123 double b = 0.123; cout \u003c\u003c to_string(b) \u003c\u003c '\\n'; //0.123000 stringstream ss; string t; ss \u003c\u003c b; ss \u003e\u003e t; cout \u003c\u003c t \u003c\u003c '\\n'; //0.123 string c = \"7355608\"; int n = stoi(c); cout \u003c\u003c n \u003c\u003c '\\n'; // 7355608 string d = \"6653.9418\"; double dq = stod(d); cout \u003c\u003c dq \u003c\u003c '\\n'; //6653.94 double db; stringstream sss; sss \u003c\u003c d; sss \u003e\u003e db; cout \u003c\u003c db \u003c\u003c '\\n'; //6653.94 总结，整数最好用to_string()和stoi()，小数最好用stringstream ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:21:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"进制转化 python可以用ord 十进制转任意进制 char a[30]; int x = 176; itoa(x, a, 15); //第三个参数不能太大，不能超过30 cout \u003c\u003c a \u003c\u003c '\\n'; //bb 任意进制转十进制 char a[20] = \"e4cxxx\"; char b[20] = \"e4c\"; char *ed; cout \u003c\u003c strtol(a, \u0026ed, 15); //第三个参数不能太大，不能超过30 cout \u003c\u003c strtol(b, \u0026ed, 15); // 3222 // 3222 任意进制的互相转化可以通过十进制过渡 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:22:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"__int128 __int128是128位的整数类型，long long只有64位 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:23:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"数据类型范围 cout \u003c\u003c numeric_limits\u003cint\u003e::min() \u003c\u003c '\\n'; //-2147483648 cout \u003c\u003c numeric_limits\u003cint\u003e::max() \u003c\u003c '\\n'; //2147483647 cout \u003c\u003c numeric_limits\u003clong long\u003e::min() \u003c\u003c '\\n'; //-9223372036854775808 cout \u003c\u003c numeric_limits\u003clong long\u003e::max() \u003c\u003c '\\n'; //9223372036854775807 cout \u003c\u003c numeric_limits\u003cfloat\u003e::min() \u003c\u003c '\\n'; //1.17549e-38 cout \u003c\u003c numeric_limits\u003cfloat\u003e::max() \u003c\u003c '\\n'; //3.40282e+38 cout \u003c\u003c numeric_limits\u003cdouble\u003e::min() \u003c\u003c '\\n'; //2.22507e-308 cout \u003c\u003c numeric_limits\u003cdouble\u003e::max() \u003c\u003c '\\n'; //1.79769e+308 cout \u003c\u003c numeric_limits\u003clong double\u003e::min() \u003c\u003c '\\n'; //3.3621e-4932 cout \u003c\u003c numeric_limits\u003clong double\u003e::max() \u003c\u003c '\\n'; //1.18973e+4932 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:24:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"fill int a[20]; fill(a, a + 5, 3); vector\u003cint\u003e v(30); fill(v.begin(), v.begin() + 5, 4); fill_n(a, 10, 3); int b[20][20] = {0}; fill(b[0], b[0] + 10 * 10, 3); // 前5行，每一列都为3 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:25:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"最大最小值 const int inf = 0x3f3f3f3f; const long long inf = 0x3f3f3f3f3f3f3f3f; const int ninf = 0xc0c0c0c0; const long long ninf = 0xc0c0c0c0c0c0c0c0; 用memset时 memset(a, 0x3f, sizeof(a)); ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:26:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"__builtin_XXX __builtin_popcount(x)求数的二进制中1的个数 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:27:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"lambda表达式 vector\u003cint\u003e a; sort(a.begin(), a.end(), [\u0026](int a, int b){return a \u003e b;}); sort(a.begin(), a.end(), greater\u003c\u003e()); ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:28:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"modf()返回小数的小数部分 double x, y, z; x = 1.234; z = modf(x, \u0026y); cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c ' ' \u003c\u003c z \u003c\u003c '\\n'; //1.234 1 0.234 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:29:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"bitset bitset\u003c4\u003e bs1; // 0000 bitset\u003c8\u003e bs2(12); // 00001100 bitset\u003c5\u003e bs3(\"1101\"); // 01101 //有些可带参数也可不带参数 bitset\u003c10\u003e bs; bs[5]; // 表示第6位，从右往左数，从小往大 bs.count(); // 求1的个数 bs.size(); // 大小 bs.test(4); //下标为4的数是否为1 bs.any(); //是否有1 bs.none(); //是否没有1 bs.all(); //是否全是1 bs.flip(4); // 将下标为4的位取反 bs.set(); // 置1 bs.set(4, false); //下标为4的置零 bs.reset(); //置0 bs.to_string(); //转string bs.to_ulong(); bs.to_ullong(); ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:30:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"算法 树上两点的距离 dist(x, y) = dep(x) + dep(y) - 2 * dep(lca(x,y)) ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:31:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"switch switch只能在int和char中选 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:32:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"accumulate 求和 int a[20]; accumulate(a, a + 3, 20); ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:33:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"pb_ds库 #include \u003cbits/extc++.h\u003e ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:34:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"double输入输出 float 用%f %f double 用%lf %f ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:35:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"程序运行加速 long long换int 把main外的函数放main里 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:36:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"size和int类型转换 size和int计算时要强制类型转换 (int) s.size() - 1 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:37:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"迭代器移动 advance(it, 5)把it迭代器向后移动5 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:38:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"pair_hash 当map等排序数组的key是pair时，需要pair_hash struct pair_hash{ template\u003cclass T1, class T2\u003e std::size_t operator() (const std::pair\u003cT1, T2\u003e\u0026 p) const { auto h1 = std::hash\u003cT1\u003e{}(p.first); auto h2 = std::hash\u003cT2\u003e{}(p.second); return h1 ^ h2; } }; map\u003cpair\u003cint, int\u003e, int, pair_hash\u003e ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:39:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"auto \u0026 不带\u0026 map\u003cint, int\u003e mp; mp[1] = 2; for (auto [x, y] : mp) { y += 2; } cout \u003c\u003c mp[1]; // 2 对于引用，参数如果是string类型，应该尽量用引用来减少复制的开销 ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:40:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"hypot() #include \u003ccmath\u003e cout \u003c\u003c hypot(3, 4); //5 cout \u003c\u003c hypotf(3, 4); cout \u003c\u003c hypotl(3, 4); ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:41:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"a / b向下取整、四舍五入、向上取整 int a, b; c = a / b; //floor c = round((float)a / b); c = (a + b - 1) / b; //ceil ","date":"2020-01-19","objectID":"/cp%E7%AC%94%E8%AE%B0/:42:0","tags":["cpp"],"title":"CP笔记","uri":"/cp%E7%AC%94%E8%AE%B0/"},{"categories":["note"],"content":"c++交集、并集、差、对称差函数","date":"2020-01-17","objectID":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/"},{"categories":["note"],"content":" #include\u003ciostream\u003e #include\u003cset\u003e //#include\u003cmap\u003e //#include\u003cstring\u003e #include\u003calgorithm\u003e #include\u003citerator\u003e using namespace std; int main() { int a[]={3,2,1}; int b[]={3,4,5,6}; set\u003cint\u003e s1(a,a+3); set\u003cint\u003e s2(b,b+4); set\u003cint\u003e s3; set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin())); for(set\u003cint\u003e::iterator it=s3.begin();it!=s3.end();it++) cout\u003c\u003c*it\u003c\u003c\" \"; cout\u003c\u003cendl; set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\"*\")); cout\u003c\u003cendl; set_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \")); cout\u003c\u003cendl; set_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \")); cout\u003c\u003cendl; set_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u003cint\u003e(cout,\" \")); return 0; } ","date":"2020-01-17","objectID":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/:0:0","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/"},{"categories":["note"],"content":"c++每种类型的值域","date":"2020-01-17","objectID":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/","tags":["cpp"],"title":"c++每种类型的值域","uri":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/"},{"categories":["note"],"content":" #include\u003ciostream\u003e #include\u003cstring\u003e #include \u003climits\u003e using namespace std; int main() { cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; cout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl; // \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; return 0; } ","date":"2020-01-17","objectID":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/:0:0","tags":["cpp"],"title":"c++每种类型的值域","uri":"/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/"},{"categories":["algorithm","note"],"content":"extended euclidean algorithm","date":"2020-01-17","objectID":"/extended-euclidean-algorithm/","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"/extended-euclidean-algorithm/"},{"categories":["algorithm","note"],"content":" #include\u003cbits/stdc++.h\u003e using namespace std; int ex_gcd(int a,int b,int\u0026 x,int\u0026 y) { int t,res; if(!b) { x=1;y=0;return a; } else { res=ex_gcd(b,a%b,x,y); t=x; x=y;y=t-a/b*y; return res; } } int main() { int a,b,x,y; a=60; b=22; cout\u003c\u003cex_gcd(a,b,x,y)\u003c\u003cendl; cout\u003c\u003cx\u003c\u003c\" \"\u003c\u003cy\u003c\u003cendl; return 0; } ","date":"2020-01-17","objectID":"/extended-euclidean-algorithm/:0:0","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"/extended-euclidean-algorithm/"},{"categories":["algorithm","note"],"content":"ford fulkerson algorithm","date":"2020-01-17","objectID":"/ford-fulkerson-algorithm/","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"/ford-fulkerson-algorithm/"},{"categories":["algorithm","note"],"content":" //O(FE) /* input 5 7 1 3 6 3 5 8 2 5 5 3 2 3 1 2 6 4 1 10 4 2 2 4 5 output 11 */ #include\u003cbits/stdc++.h\u003e using namespace std; #define maxv 100 #define inf 0x3f3f3f3f int v,e; int s,t; struct edge{int to,cap,rev; }; vector\u003cedge\u003e G[maxv]; bool used[maxv]; void add_edge(int from ,int to,int cap) { G[from].push_back((edge){to,cap,G[to].size()}); G[to].push_back((edge){from,0,G[from].size()-1}); } int dfs(int s,int t,int f) { if(s==t) return f; used[s]=true; for(int i=0;i\u003cG[s].size();i++) { edge \u0026e =G[s][i]; if(!used[e.to] \u0026\u0026 e.cap\u003e0) { int d=dfs(e.to,t,min(f,e.cap)); if(d\u003e0) { e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0; } int max_flow(int s,int t) { int flow=0; for(;;) { memset(used,0,sizeof(used)); int f=dfs(s,t,inf); if(f==0) return flow; flow+=f; } } int main() { freopen(\"input.txt\",\"r\",stdin); cin\u003e\u003ev\u003e\u003ee; for(int i=0;i\u003ce;i++) { int from,to,cap; scanf(\"%d%d%d\",\u0026from,\u0026to,\u0026cap); add_edge(from,to,cap); } cin\u003e\u003es\u003e\u003et; cout\u003c\u003cmax_flow(s,t); return 0; } ","date":"2020-01-17","objectID":"/ford-fulkerson-algorithm/:0:0","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"/ford-fulkerson-algorithm/"},{"categories":["algorithm","note"],"content":"筛法求区间内质数个数？","date":"2020-01-17","objectID":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/"},{"categories":["algorithm","note"],"content":"很早以前写的懒得去审查。。。 不知道对不对。。。 Eprime #include\u003cbits/stdc++.h\u003e using namespace std; #define MAX 10000 long long prime1[MAX],num1; long long prime2[MAX],num2; bool isprime1[MAX],isprime2[MAX]; int qprime1(int n) { num1=0; memset(isprime1,1,sizeof(isprime1)); isprime1[0]=isprime1[1]=0; for(int i=2;i\u003c=n;i++) { if(isprime1[i]) { prime1[num1++]=i; for(int j=2;j*i\u003c=n;j++) isprime1[j*i]=0; } } return num1; } int qprime2(int m,int n) { num2=0; qprime1((int)sqrt(n)); memset(isprime2,1,sizeof(isprime2)); for(int i=0;i\u003cnum1;i++) { for(int j=m/prime1[i];j*prime1[i]\u003c=n;j++) { isprime2[j*prime1[i]]=0; } } for(int i=m;i\u003c=n;i++) if(isprime2[i]) num2++; return num2; } int main() { cout\u003c\u003cqprime2(10,100); return 0; } ","date":"2020-01-17","objectID":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/:0:0","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/"},{"categories":["algorithm","note"],"content":"字符串匹配算法(未完成)","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"从学习方法和代码实现debug花了挺长时间。。。 这个算法是从字符串s中找子串p出现的第一个位置 以下是两个常见的字符串匹配算法（还有其他更高效的比如Turbo-bm算法，sunday算法） kmp算法和bm算法 时间复杂度是O(s+p) bm算法总体比kmp算法要快3倍 当然也可以直接用函数，比如 s.find( p ); //懒得写更多，懒得修饰代码 plus:字符串的读入常常会出现读空格、读回车等奇妙现象 ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:0","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"kmp算法 //kmp without optimization //strncpy() memmove() #include\u003cbits/stdc++.h\u003e using namespace std; int kmp(char s[],char p[]) { //preprocess int sl=strlen(s); int pl=strlen(p); char subp[pl+1][pl+1]; int next[pl+1]; for(int k=0;k\u003cpl;k++) { strncpy(subp[k],p,k+1); } //can optimized for(int k=0;k\u003cpl;k++) { string tl; string tr; int len_sub=k+1; int len=0; for(int m=len_sub-1;m\u003e0;m--) { tl=string(subp[k],subp[k]+m); tr=string(subp[k]+len_sub-m,subp[k]+len_sub); if(tl==tr) { len=m; break; } } next[k]=len; } for(int k=pl-1;k\u003e0;k--) { next[k]=next[k-1]; } next[0]=-1; //match int i=0;int j=0; while(1) { if(s[i]==p[j]) { i++; j++; } else { int t=next[j]; if(t==-1) { i++; j=0; } else { j=t; } } if(j\u003e=pl) { return i-pl; } if(i\u003e=sl) { return -1; } } } int main() { freopen(\"input.txt\",\"r\",stdin); char a[100]; char b[100]; cin\u003e\u003ea\u003e\u003eb; cout\u003c\u003ckmp(a,b); return 0; } ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:1","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["algorithm","note"],"content":"bm算法 //bm algorithm three to five times faster than kmp in genneral #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003ccstring\u003e #include\u003cstring\u003e #include\u003cvector\u003e using namespace std; int get_badc(char t,char a[]) { int k=strlen(a)-1; while(1) { if(k\u003e=0) //assert { if(a[k--]==t) { return k+1; } } else return -1; } } int get_goods(vector\u003cchar\u003e t,char a[]) //most difficult { int k=strlen(a)-1; vector\u003cchar\u003e temp; int max_len=0; int m=0; int loc=-1; while(1) { if(k\u003e=0) //assert { if(t[m]==a[k]) { temp.push_back(a[k]); m++; k--; } else { m=0; k--; if(temp.size()\u003emax_len) { max_len=temp.size(); loc=k+1; temp.clear(); } } } else return loc; } } int bm(char s[],char p[]) { int sl=strlen(s); int pl=strlen(p); int i=pl-1; int j=pl-1; while(1) { if(i\u003csl and j\u003e=0) //asseert // i\u003csl !!!!!!!!!! not i\u003e0 { if(s[i]==p[j]) { vector\u003cchar\u003e goods; goods.push_back(s[i]); while(1) { i--; j--; if(i\u003e=0 and j\u003e=0) //assert { if(s[i]!=p[j]) { char badc1=s[i]; string str(p,p+pl-goods.size()); int loc1=get_badc(badc1,\u0026str[0]); int loc2=get_goods(goods,\u0026str[0]); if(loc1==-1 and loc2!=-1) { i+=pl-1-loc2; j=pl-1; } else if(loc2==-1 and loc1!=-1) { i+=pl-1-loc1; j=pl-1; } else { i+=pl-1-min(loc1,loc2); j=pl-1; } } else { goods.push_back(s[i]); //still add in good-suffix } } else break; } } else //only have bad-character { char badc2=s[i]; int loc=get_badc(badc2,p); i+=pl-1-loc; j=pl-1; } } else if(i\u003e=sl) return -1; //!!!!!!!!!!!!! else return i+1; //!!!!!!!!!!!! } } int main() { freopen(\"input.txt\",\"r\",stdin); char a[100]; char b[100]; cin\u003e\u003ea\u003e\u003eb; cout\u003c\u003cb\u003c\u003cendl\u003c\u003ca; cout\u003c\u003cbm(b,a)\u003c\u003cendl; return 0; } ","date":"2020-01-17","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/:0:2","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"categories":["note"],"content":"输入输出优化(提高读入输出速度)","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291 ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:0:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"1.用scanf,printf代替cin,cout ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:1:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"2.取消同步和绑定 ios::sync_with_stdio(false); cin.tie(0); //cout.tie(0); 此时只能用cin,cout ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:2:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"},{"categories":["note"],"content":"3.对整型输入输出，将每个数字变成字符 inline int read() { int x=0;int f=1;char s=getchar(); while(s\u003c'0' or s\u003e'9') { if(s=='-') f-=1; s=getchar(); } while(s\u003e='0' and s\u003c='9') { x=x*10+s-'0'; s=getchar(); } return x*f; } void write(int x) { if(x/10\u003e0) write(x/10); putchar(char(x%10+'0')); } int main() { //freopen(\"input.txt\",\"r\",stdin); int n=read(); cout\u003c\u003cn\u003c\u003cendl; write(200); return 0; } ","date":"2020-01-14","objectID":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/:3:0","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/"}]
{"categories":[{"title":"abc","uri":"https://dyhgo.github.io/categories/abc/"},{"title":"algorithm","uri":"https://dyhgo.github.io/categories/algorithm/"},{"title":"android","uri":"https://dyhgo.github.io/categories/android/"},{"title":"anime","uri":"https://dyhgo.github.io/categories/anime/"},{"title":"codeforces","uri":"https://dyhgo.github.io/categories/codeforces/"},{"title":"cources","uri":"https://dyhgo.github.io/categories/cources/"},{"title":"GAME","uri":"https://dyhgo.github.io/categories/game/"},{"title":"hduoj","uri":"https://dyhgo.github.io/categories/hduoj/"},{"title":"linux","uri":"https://dyhgo.github.io/categories/linux/"},{"title":"note","uri":"https://dyhgo.github.io/categories/note/"},{"title":"nowcoder","uri":"https://dyhgo.github.io/categories/nowcoder/"},{"title":"poj","uri":"https://dyhgo.github.io/categories/poj/"},{"title":"problemlist","uri":"https://dyhgo.github.io/categories/problemlist/"},{"title":"Python web","uri":"https://dyhgo.github.io/categories/python-web/"},{"title":"test","uri":"https://dyhgo.github.io/categories/test/"}],"posts":[{"content":"A - Payment 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std;\rint main(){\rint n;\rcin\u0026gt;\u0026gt;n;\rint i=1000;\rwhile(i\u0026lt;n){\ri+=1000;\r}\rcout\u0026lt;\u0026lt;i-n;\rreturn 0;\r}\r B - Judge Status Summary 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std;\rconst int maxn = 1e5+2;\rint wa,tle,ac,re;\rint main(){\rint n;\rcin\u0026gt;\u0026gt;n;\rwhile(n--){\rstring s;\rcin\u0026gt;\u0026gt;s;\rswitch(s[0]){\rcase 'A':{\rac++;\rbreak;\r}\rcase 'W':{\rwa++;\rbreak;\r}\rcase 'T':{\rtle++;\rbreak;\r}\rdefault:{\rre++;\rbreak;\r}\r}\r}\rcout\u0026lt;\u0026lt;\u0026quot;AC x \u0026quot;\u0026lt;\u0026lt;ac\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026quot;WA x \u0026quot;\u0026lt;\u0026lt;wa\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026quot;TLE x \u0026quot;\u0026lt;\u0026lt;tle\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026quot;RE x \u0026quot;\u0026lt;\u0026lt;re\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - H and V 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std;\rchar a[7][7];\rchar b[7][7];\rint n,m;int k;\rvoid row(int x){\rfor(int i=0;i\u0026lt;m;i++){\rb[x][i] = '.';\r}\r}\rvoid col(int x){\rfor(int i=0;i\u0026lt;n;i++){\rb[i][x] = '.';\r}\r}\rvoid sol(int x,int y){\rfor(int i=0;i\u0026lt;n;i++){\rif(x\u0026gt;\u0026gt;i\u0026amp;1){\rrow(i);\r}\r}\rfor(int j=0;j\u0026lt;m;j++){\rif(y\u0026gt;\u0026gt;j\u0026amp;1){\rcol(j);\r}\r}\r}\rint cal(){\rint ans =0;\rfor(int i=0;i\u0026lt;n;i++){\rfor(int j=0;j\u0026lt;m;j++){\rif(b[i][j] == '#') ans++;\r}\r}\rreturn ans;\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;cin\u0026gt;\u0026gt;k;\rchar c;\rfor(int i=0;i\u0026lt;n;i++){\rfor(int j=0;j\u0026lt;m;j++){\rcin\u0026gt;\u0026gt;a[i][j];\r}\r}\rint ans = 0;\rfor(int i=0;i\u0026lt;(1\u0026lt;\u0026lt;n);i++){\rfor(int j=0;j\u0026lt;(1\u0026lt;\u0026lt;m);j++){\rmemcpy(b,a,sizeof(a));\rsol(i,j);\rif (cal() == k) ans++;\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Chat in a Circle 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std;\rusing ll = long long;\rll a[200005];\rll n;\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\rsort(a,a+n,[](int a,int b){return a\u0026gt;b;});\rif(n==2) {\rcout\u0026lt;\u0026lt;a[0]\u0026lt;\u0026lt;endl;\rexit(0);\r}\rn--;\rll t;\rll q = n;\rif(n\u0026amp;1){\rt = (n-1)/2;\rt++;\r}\relse{\rn++;\rt = (n-1)/2;\rt++; }\rll ans = a[0];\rfor(ll i=1;i\u0026lt;t;i++){\rans += 2LL * a[i];\r}\rif(q%2 == 0){\rans -= a[t-1];\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Multiplication 4 题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll a[200005];\rll n,k;\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\rsort(a,a+n);\rint L = 0,R = n-1;\rif(k\u0026amp;1){\rif(a[n-1] \u0026lt; 0){\rll ans = 1;\rfor(int i=n-1;i\u0026gt;=n-k;i--){\rans *= a[i];\rans %= mod;\r}\rif(ans \u0026lt; 0) cout\u0026lt;\u0026lt;ans+mod\u0026lt;\u0026lt;endl;else cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rexit(0);\r}\rR--,k--;\r}\rwhile(k){\rll lv = a[L] * a[L+1];\rll rv = a[R] * a[R-1];\rif(lv \u0026lt; rv){\rR -= 2;\r}\telse L += 2;\rk -= 2;\r}\rll ans = 1;\rfor(int i=0;i\u0026lt;L;i++){\rans *= a[i];\rans %= mod;\r}\rfor(int i=R+1;i\u0026lt;n;i++){\rans *= a[i];\rans %= mod;\r}\rif(ans \u0026lt; 0) cout\u0026lt;\u0026lt;ans+mod\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Intervals on Tree 题解 对于一个森林，点和边对连通图个数的贡献是每个点+1，每条边-1\n所以计算点被遍历几次，边被遍历几次\n这与区间的左右数字个数有关\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint n;\rint main(){\rll ans = 0;\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++){\rans += (ll)i * (n-i+1);\r}\rint _ = n;\r_--;\rwhile(_--){\rint a,b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rif(a \u0026gt; b) swap(a,b);\rans -= (ll)a * (n-b+1);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":0,"section":"posts","summary":"A - Payment 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n; cin\u0026gt;\u0026gt;n; int i=1000; while(i\u0026lt;n){ i+=1000; } cout\u0026lt;\u0026lt;i-n; return 0; } B - Judge Status Summary 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+2; int wa,tle,ac,re; int main(){ int n; cin\u0026gt;\u0026gt;n; while(n--){ string s; cin\u0026gt;\u0026gt;s; switch(s[0]){ case 'A':{ ac++; break; } case 'W':{ wa++; break; } case 'T':{ tle++; break; } default:{ re++; break; }","tags":["cpp","graph_theory"],"title":"abc173","uri":"https://dyhgo.github.io/2020/07/abc173/","year":"2020"},{"content":"简单思维 题目\n题解 直接法，注意数组大小爆long long\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing ll = long long;\rconst ll mod = 1e6+3;\rll fac[mod+2];\rint main(){\rfac[0] = 1LL;\rfac[1] = 1LL;\rfor(ll i=2;i\u0026lt;mod+2;i++){\rfac[i] = i*fac[i-1];\rfac[i] %= mod;\r}\rll n;\rwhile(std::cin\u0026gt;\u0026gt;n){\rif(n\u0026gt;=mod) puts(\u0026quot;0\u0026quot;);else\rstd::cout\u0026lt;\u0026lt;fac[n]\u0026lt;\u0026lt;std::endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n并查集 排列组合 容斥原理 题目\n题解 并查集模拟操作\n每次的答案依赖于上一次的答案\n对于当前给出的两个数\n如果在一个集合内，则 ans = ans\n如果不在一个集合内，假设一个在A集合，一个在B集合\nnum(S) 表示满足条件S的方案数\n四元组为 Q\n并查集的集合为 U\n设合并A、B后的集合为C\nans -= num(∃q ∈ Q , (q∈A) ∧ (Q\\q ∈ U\\(A , B) ) )\nans -= num(∃q ∈ Q , (q∈B) ∧ (Q\\q ∈ U\\(A , B) ) )\nans -= num(∃q1,q2 ∈ Q , (q1 ∈ A) ∧ (q2 ∈ B) ∧ (Q\\(q1 , q2) ∈ U\\(A , B) )\nans += num(∃q ∈ Q , (q ∈ C) ∧ (Q\\q ∈ U\\C) )\n由于12式和4式相抵消，所以实际只要操作3式\n由于3式需要在并查集中选两个的方案数，所以维护两个变量\nans two (在并查集中选两个元素的方案数，选的元素可重复)\n利用容斥原理和排列组合\nnum(∃q1,q2 ∈ Q , (q1 ∈ A) ∧ (q2 ∈ B) ∧ (Q\\(q1 , q2) ∈ U\\(A , B) ) = size(A) * size(B) * (two - (size(A) * (n - size(A)) - (size(B) * (n - size(B)) + size(A) * size(B) )\n更新完ans后更新two\n初始化\nans = C(n,4) two = C(n,2)\n数据规模大，用unsigned long long\n注意这样初始化\nll ans = n*(n-1)/4*(n-2)/3*(n-3)/2;  而不是\nll ans = n*(n-1)*(n-2)*(n-3)/24;  #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = unsigned long long;\r//using ld = long double;\rconst int maxn = 1e5+3;\rll n,m;\rll par[maxn]; ll rankk[maxn]; ll sizz[maxn];\rvoid init(ll n) {\rfor(ll i=0;i\u0026lt;n;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\rfill(sizz,sizz+n,1);\r} ll find(ll x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); } void unite(ll x,ll y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; if(rankk[x]\u0026lt;rankk[y]) par[x]=y,sizz[y]+=sizz[x]; else\r{\rpar[y]=x;\rsizz[x]+=sizz[y];\rif(rankk[x]==rankk[y]) rankk[x]++; } } bool same(ll x,ll y)\r{\rreturn find(x)==find(y);\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rll two = n*(n-1)/2;\rll ans = n*(n-1)/4*(n-2)/3*(n-3)/2; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rinit(n);\rfor(ll i=0;i\u0026lt;m;i++){\rll x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rx--,y--;\rif(!same(x,y)){\rll szx = sizz[find(x)];\rll szy = sizz[find(y)];\rans -= (szx * szy * (two - szx * (n - szx) - szy * (n - szy) + szx * szy));\rtwo -= szx * szy;\runite(x,y);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}else cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\nkmp 题目\n题解 先找既是前缀又是后缀的最长子串\n这可以利用kmp的next数组\n然后去掉原串的头尾作为匹配串，由next数组得到的作为模式串\n再进行kmp匹配，如果匹配不成功，则在模式串中取前next[len]的长度\n不断重复，直到与匹配串匹配\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rchar s[100005],p[100005],pp[100005],ppp[100005];\rint n,m;\rint nextt[100005];\rvoid get_next(){\rint i=0,j=-1;\rnextt[0]=-1;\rwhile(i\u0026lt;m){\rif(j==-1 || p[i]==p[j]) nextt[++i]=++j;\relse j=nextt[j]; //!!!\r}\r}\rint kmp(){\rint i=0,j=0;\rwhile(1){\rif(s[i]==p[j]) i++,j++;\relse{\rint t=nextt[j];\rif(t==-1) i++,j=0;\relse j=t;\r}\rif(j\u0026gt;=m) return i-m; if(i\u0026gt;=n) return -1;\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;p;\rm = strlen(p);\rget_next();\rint len = nextt[m];\rstrncpy(pp,p,len);\rlen = strlen(p) - 2;\rstrncpy(s,p+1,len);\rstrcpy(p,pp);\rm = strlen(p);\rn = strlen(s);\rwhile(1){\rif(kmp()!=-1){\rcout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl;\rbreak;\t}//else if(nextt[strlen(p)] == -1) break;\relse{\rstrncpy(ppp,p,nextt[strlen(p)]); //不能拷贝给自身\rstrcpy(p,ppp);\rm = strlen(p);\r//cerr\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r ===========================================================================================================\n换根dp 题目\n题解 dpd[u] 表示以u为根的子树的连通块数\ndpu[u] 表示u之上的连通块数\nans[u] 表示包含u的连通块数\n假设 v 是 u 的子节点，p 是 u 的父节点 ，s 是 u 的兄弟节点\ndpd[u] = (dpd[v1] + 1) * (dpd[v2] + 1) * (dpd[v3] + 1) * ...\nans[u] = dpd[u] * (dpu[u] + 1)\ndpu[u] = ans[p] / (dpd[u] + 1)\n当 (dpd[u] + 1) % mod = 0 时，模数无效，所以这种情况要特殊处理\ndpu[u] = (dpu[p] + 1) * (dpd[s1] + 1) * (dpd[s2] + 1) * ...\n两次dfs，一次求dpd，一次求dpu并更新ans\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9 + 7;\rconst int maxn = 1e6 + 5;\rstruct edge{\rint to , next;\r}e[maxn\u0026lt;\u0026lt;1];\rll tot,head[maxn\u0026lt;\u0026lt;1];\rvoid add_edge(int u,int v){\re[tot].to = v;\re[tot].next = head[u];\rhead[u] = tot++;\r}\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rll dpu[maxn],par[maxn],dpd[maxn],ans[maxn];\rll V;\rvoid dfs1(int u,int p){\rdpd[u] = 1;\rpar[u] = p;\rfor(int i=head[u]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == p) continue;\rdfs1(v,u);\rdpd[u] *= (dpd[v] + 1);\rdpd[u] %= mod;\r}\r}\rvoid dfs2(int u,int p){\rif(u != 1){\rif((dpd[u] + 1) % mod){\rdpu[u] = ans[p] * qpow(dpd[u] + 1 , mod - 2);\rdpu[u] %= mod;\rans[u] = dpd[u] * (dpu[u] + 1);\rans[u] %= mod;\r}\relse{\rll tmp = dpu[p] + 1;\rfor(int i=head[p]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == par[p] or v == u) continue;\rtmp *= dpd[v] + 1;\rtmp %= mod;\r}\rdpu[u] = tmp;\rans[u] = dpd[u] * (dpu[u] + 1);\rans[u] %= mod;\r}\r}\rfor(int i=head[u]; ~i ;i=e[i].next){\rint v = e[i].to;\rif(v == p) continue;\rdfs2(v,u);\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rmemset(head,-1,sizeof(head));\rcin\u0026gt;\u0026gt;V;\rfor(int i=0;i\u0026lt;V-1;i++){\rll x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\radd_edge(x,y);\radd_edge(y,x);\r}\tdfs1(1,0);\rans[1] = dpd[1];\rdfs2(1,0);\rfor(int i=1;i\u0026lt;=V;i++){\rcout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n贪心 思维 题目\n题解 把L大的放左边，把R大的放右边\n假设L大的有a个，R大的有b个\n可以把他们分开放置\n先处理前a个位置（这些都放置L大的数）\n再处理后b个位置（这些都放置R大的数）\n对于前a个位置\n遍历L大的集合（L大的排前面）\n对于当前数，贪心地把它放在不超过k的最右边\n如果不满足条件，就放在区间的最右边（此时放哪里，贡献都一样，为了给别的数腾出位置，贪心地放在最右边）\n对于后b个位置\n遍历R大的集合（R大的排前面）\n对于当前数，贪心地把它放在超过k的最左边\n如果不满足条件，就放在区间的最左边（此时放哪里，贡献都一样，为了给别的数腾出位置，贪心地放在最左边）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vL;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vR;\rint t;\rint n;\rset\u0026lt;int\u0026gt; sL;\rset\u0026lt;int\u0026gt; sR;\r#define fi first\r#define se second\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rll ans = 0;\rcin\u0026gt;\u0026gt;n;\rvL.clear();\rvR.clear();\rfor(int i=0;i\u0026lt;n;i++){\rint k,l,r;\rcin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\rif(l\u0026lt;r) vR.push_back({l-r,k});\relse vL.push_back({l-r,k});\rans += r;\r}\rfor(int i=1;i\u0026lt;=vL.size();i++) sL.insert(i);\rfor(int i=vL.size()+1;i\u0026lt;=n;i++) sR.insert(i);\rsort(vL.begin(),vL.end(),greater\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;());\rsort(vR.begin(),vR.end());\rfor(auto i:vL){\rauto tmp = sL.upper_bound(i.se);\rif(tmp == sL.begin()){\rsL.erase(--sL.end());\r}else{\rans += i.fi;\rsL.erase(--tmp);\r}\r}\rfor(auto i:vR){\rauto tmp = sR.upper_bound(i.se);\rif(tmp == sR.end())\t{\rsR.erase(sR.begin());\rans += i.fi;\r}\relse{\rsR.erase(tmp);\r}\t}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n栈 题目\n题解 栈的经典应用\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll a[10005];\rstack\u0026lt;int\u0026gt; sk;\rint ans[10005];\rint main(){\rll n;\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++) {\rcin\u0026gt;\u0026gt;a[i];\r}\rint i = 0;\rwhile(i \u0026lt; n){\rif(sk.empty() or a[i] \u0026lt;= a[sk.top()]){\rsk.push(i);\ri++;\r}\relse{\rans[sk.top()] = i;\rsk.pop();\r}\r}\rwhile(!sk.empty()){\rans[sk.top()] = -1;\rsk.pop();\r}\rfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;ans[i]+1\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\rreturn 0;\r}\r 树链剖分 题目\n题解 树链剖分裸题\n线段树需支持区间平方和操作\n这道题用int不能过\n注意细节\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 1e5+10;\rstruct edge{ ll to,nxt;\r}e[maxn\u0026lt;\u0026lt;1]; struct tnode{ ll w,l,r,siz,alazy;\rll sq,mlazy=1LL;\r}tn[maxn\u0026lt;\u0026lt;2]; ll wch[maxn],sz[maxn],head[maxn],wt[maxn],dep[maxn],dfn[maxn],par[maxn],top[maxn],rdfn[maxn];\rll n,q;\rconst ll mod = 23333;\rll cnt_e; ll cnt_d; void add_edge(ll u,ll v){ e[++cnt_e].to = v; e[cnt_e].nxt = head[u]; head[u] = cnt_e;\r}\rvoid dfs1(ll u,ll p){ sz[u] = 1;\rfor(ll i = head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p){\rdep[t] = dep[u] + 1;\rpar[t] = u;\rdfs1(t,u);\rsz[u] += sz[t];\rif(sz[t] \u0026gt; sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid dfs2(ll u,ll p,ll tp){ top[u] = tp;\rdfn[u] = ++cnt_d; rdfn[cnt_d] = u; if(wch[u]){ dfs2(wch[u],u,tp);\r}\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch[u]){\rdfs2(t,u,t); }\r}\r}\rvoid pushup(ll u){ tn[u].w = (tn[u\u0026lt;\u0026lt;1].w + tn[u\u0026lt;\u0026lt;1|1].w) % mod;\rtn[u].sq = (tn[u\u0026lt;\u0026lt;1].sq + tn[u\u0026lt;\u0026lt;1|1].sq) % mod;\r}\rvoid build(ll u,ll l,ll r){ tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[rdfn[l]]; tn[u].sq = wt[rdfn[l]] * wt[rdfn[l]];\rreturn ;\r}\rll mid = (l+r) \u0026gt;\u0026gt; 1;\rbuild(u\u0026lt;\u0026lt;1 , l , mid); build(u\u0026lt;\u0026lt;1|1 , mid+1 , r);\rpushup(u); }\rvoid pushdown(ll u){ if(tn[u].alazy != 0 or tn[u].mlazy != 1){\rtn[u\u0026lt;\u0026lt;1].sq = ((tn[u\u0026lt;\u0026lt;1].sq + 2LL * tn[u\u0026lt;\u0026lt;1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u0026lt;\u0026lt;1].siz % mod) % mod; tn[u\u0026lt;\u0026lt;1|1].sq = ((tn[u\u0026lt;\u0026lt;1|1].sq + 2LL * tn[u\u0026lt;\u0026lt;1|1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u0026lt;\u0026lt;1|1].siz % mod) % mod;\rtn[u\u0026lt;\u0026lt;1].w = (tn[u\u0026lt;\u0026lt;1].w * tn[u].mlazy % mod + tn[u\u0026lt;\u0026lt;1].siz * tn[u].alazy % mod) % mod;\rtn[u\u0026lt;\u0026lt;1|1].w = (tn[u\u0026lt;\u0026lt;1|1].w * tn[u].mlazy % mod + tn[u\u0026lt;\u0026lt;1|1].siz * tn[u].alazy % mod) % mod;\rtn[u\u0026lt;\u0026lt;1].alazy = (tn[u\u0026lt;\u0026lt;1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u0026lt;\u0026lt;1|1].alazy = (tn[u\u0026lt;\u0026lt;1|1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod;\rtn[u\u0026lt;\u0026lt;1].mlazy = (tn[u\u0026lt;\u0026lt;1].mlazy * tn[u].mlazy) % mod;\rtn[u\u0026lt;\u0026lt;1|1].mlazy = (tn[u\u0026lt;\u0026lt;1|1].mlazy * tn[u].mlazy) % mod;\rtn[u].alazy = 0; tn[u].mlazy = 1;\r}\r}\rll query(ll u,ll l,ll r,ll t){ if(l\u0026lt;=tn[u].l and r\u0026gt;=tn[u].r) {\rif(t == 1) return tn[u].w;\rif(t == 2) return tn[u].sq;\r} ll ans = 0;\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u0026gt;\u0026gt; 1;\rif(l\u0026lt;=mid) ans = (ans + query(u\u0026lt;\u0026lt;1 , l , r , t)) % mod;\rif(r\u0026gt;mid) ans = (ans + query(u\u0026lt;\u0026lt;1|1 , l , r , t)) % mod;\rreturn ans;\r}\rvoid update(ll u,ll l,ll r,ll wa,ll wm){ if(l\u0026lt;=tn[u].l and r\u0026gt;=tn[u].r){ tn[u].sq = ((tn[u].sq + 2LL * tn[u].w * wa % mod) % mod + wa * wa % mod * tn[u].siz % mod) % mod;\rtn[u].w = (tn[u].w * wm % mod + tn[u].siz * wa % mod) % mod;\rtn[u].alazy = (tn[u].alazy * wm % mod + wa) % mod;\rtn[u].mlazy = (tn[u].mlazy * wm) % mod;\rreturn ;\r}\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u0026gt;\u0026gt; 1; if(l\u0026lt;=mid) update(u\u0026lt;\u0026lt;1, l , r , wa , wm);\rif(r\u0026gt;mid) update(u\u0026lt;\u0026lt;1|1, l , r , wa , wm);\rpushup(u); }\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q;\rfor(ll i=1;i\u0026lt;=n;i++){\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;wt[i]);\r}\rfor(ll i=0;i\u0026lt;n-1;i++){\rll x,y;\rscanf(\u0026quot;%lld %lld\u0026quot;,\u0026amp;x,\u0026amp;y);\radd_edge(x,y);\radd_edge(y,x);\r}\rdfs1(1,0);\rdfs2(1,0,1);\rbuild(1,1,n);\rfor(ll i=0;i\u0026lt;q;i++){\rll t;\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;t);\rif(t==1){\rll x,y;\rscanf(\u0026quot;%lld %lld\u0026quot;,\u0026amp;x,\u0026amp;y);\rupdate(1,dfn[x],dfn[x]+sz[x]-1,y%mod,1LL);\r}\relse{\rll x;\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;x);\rprintf(\u0026quot;%lld\\n\u0026quot;, query(1,dfn[x],dfn[x]+sz[x]-1,2));\r}\r}\rreturn 0;\r}\r ===========================================================================================================\n计算几何 题目\n题解 两两求圆心，圆心相同表示能在同一个圆上\n求最多的圆心数量\n需要固定一个点，每次换点时求一次max，如果在遍历完所有点对求max，就变成排列组合\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing db = double;\rstruct point{\rdb x,y;\r}ps[2005];\rmap\u0026lt;pair\u0026lt;db,db\u0026gt;,int\u0026gt; mp;\rdb X,Y;\rinline db out(point a,point b,point c) {\rreturn (c.x - a.x) * (c.y - b.y) - (c.y - a.y) * (c.x - b.x); }\rbool circle_center(point a,point b,point c){\rif(out(a,b,c) == 0 ) return false;\rdb a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;\rdb a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;\rdb d = a1 * b2 - a2 * b1;\rX = a.x + (c1 * b2 - c2 * b1) / d , Y = a.y + (a1 * c2 - a2 * c1) / d;\rreturn true;\r}\rint main(){\rint n;\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++) {\rcin\u0026gt;\u0026gt;ps[i].x;\rcin\u0026gt;\u0026gt;ps[i].y;\r}\rint ans = 0;\rfor(int i=0;i\u0026lt;n;i++){\rmp.clear();\rfor(int j=i+1;j\u0026lt;n;j++){\rif(circle_center((point){0,0} , ps[i] , ps[j]))\rmp[{X,Y}]++;\r}\rint tmp = 0;\rfor(auto i:mp) tmp = max(tmp , i.second);\rans = max(ans , tmp);\r}\rcout\u0026lt;\u0026lt;ans+1\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n并查集 题目\n题解 并查集模改\n细节参考官方题解\n并查集模拟操作，链表维护相同颜色的节点\n注意要记录初始的状态（debug好久）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rconst int maxn = 8e5 + 10;\rvector\u0026lt;int\u0026gt; G[maxn];\rlist\u0026lt;int\u0026gt; ls[maxn];\rint par[maxn]; void init(int n) {\rfor(int i=0;i\u0026lt;n;i++)\r{\rpar[i]=i;\rls[i].push_back(i);\r}\r} int find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); }\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint n,m;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\r//reset\rfor(int i = 0;i\u0026lt;=n;i++) {\rG[i].clear(); ls[i].clear();\r}\rfor(int i = 0;i\u0026lt;m;i++){\rint x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rG[x].push_back(y);\rG[y].push_back(x);\r}\rinit(n);\rint q;\rcin\u0026gt;\u0026gt;q;\rwhile(q--){\rint x;\rcin\u0026gt;\u0026gt;x;\rif(x != par[x]) continue;\rint sz = ls[x].size(); //记录初始的链表大小\rint px = find(x); //记录初始的根节点\rwhile(sz--){\rint cnt = ls[x].front();\rls[x].pop_front();\rfor(int i:G[cnt]){\rint pi = find(i); //记录初始的根节点\rif(px == pi) continue;\rpar[pi] = px; //这样合并\rls[x].splice(ls[x].end() , ls[pi]);\t}\r}\r}\rfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;find(i)\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rputs(\u0026quot;\u0026quot;);\r}\rreturn 0;\r}\r ===========================================================================================================\n数论 思维 题目\n题解 1和大于n/2的质数都不能匹配\n先处理质因子稀有的数，就是从大到小遍历质数\n然后把含有这个质因子的数两两匹配\n如果含有这个质因子的数的个数是奇数个\n就不匹配 2*p 这个数，留给下一个质因子，因为2是最多的质因子\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rconst int maxnn = 2e5+10;\rbool isprime[maxnn];\rvoid e_sieve(int n = maxnn){\rfor(int i = 1;i\u0026lt;n;i++){\risprime[i] = true;\r}\risprime[0] = isprime[1] = false;\rfor(int i = 2;i \u0026lt; n;i++){\rif(isprime[i]){\rfor(int j = 2 * i ; j \u0026lt; n ; j += i){\risprime[j] = false;\r}\r}\r}\r}\rint use[maxnn] ;\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\re_sieve();\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile (t--){\rint n;\rcin\u0026gt;\u0026gt;n;\rfor(int i = 1; i \u0026lt;= n ; i++) use[i] = 0;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; ans;\rfor(int i = n/2 ; i \u0026gt;= 2 ; --i){\rif(isprime[i]){\rvector\u0026lt;int\u0026gt; tmp;\rfor(int j = i; j \u0026lt;= n ; j += i){\rif(use[j] == 0){\rtmp.push_back(j);\r}\r}\rif(tmp.size() \u0026amp; 1){\rfor(int x = 0 ; x \u0026lt; tmp.size() ; ++x){\rif(tmp[x] == i * 2) tmp.erase(tmp.begin() + x);\r}\r}\rfor(int i = 0 ; i \u0026lt; tmp.size() - 1 ; i += 2){\rans.push_back({tmp[i] , tmp[i+1]});\ruse[tmp[i]] = 1;\ruse[tmp[i+1]] = 1;\r}\r}\r}\r//for(int i = 2; i \u0026lt; 20 ; i++) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;isprime[i]\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\rcout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl;\rfor(auto i : ans){\rcout\u0026lt;\u0026lt;i.first\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;i.second\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r ===========================================================================================================\n数论 题目\n题解 如果没有 d\u0026lt;b f\u0026lt;b 的条件直接让 d = f = b\n如果 a/b 能约分成 a\u0026rsquo; / b\u0026rsquo;\n则 d = f = b\u0026rsquo;\ne = 1 , c = a‘+1（随便赋值）\n如果 a/b不能约分\n就把b分解质因数（预处理每个数最小的质因子）\n设b分解成 p1 p2\n如果p1 p2 有1 无解\n否则根据通分公式 d = p1 , f = p2\ncf - de = a\n因为d f是b的因子 ，b 和 a 互质 ，所以gcd(f/a , d/a) = 1\n-(d/a)e + c(f/a) = 1\n用扩展欧几里得公式求出 c e\ne = -e 如果 e c有负数 ，正数化\n然后 e c 都乘上 a\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 2e6+10;\rll gcd(ll a , ll b){\rreturn b == 0 ? a : gcd(b , a % b);\r}\rbool isprime[maxn+1]; //is i a prime number\rll minp[maxn+1];\rvoid e_sieve(int n = maxn)\r{\rfor(int i=0;i\u0026lt;=n;i++) isprime[i]=true; //initialize\risprime[0]=isprime[1]=false;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rif(isprime[i])\r{\rfor(int j=2*i;j\u0026lt;=n;j+=i) isprime[j]=false;\r}\r}\rfor(ll i = 2 ; i \u0026lt;= n; i++){\rif(isprime[i]){\rfor(ll j = i; j \u0026lt;= n; j += i){\rif(minp[j] == 0) minp[j] = i;\r}\r}\r}\r}\rll ex_gcd(ll a,ll b,ll\u0026amp; x,ll\u0026amp; y)\r{\rll t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main() {\r#ifdef LOCAL\rfreopen(\u0026quot;in1.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\rfreopen(\u0026quot;out1.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\r#endif\re_sieve();\r//for(int i = 2; i\u0026lt; 100;i++) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;minp[i]\u0026lt;\u0026lt;endl;\rint _;\rcin \u0026gt;\u0026gt; _;\rwhile (_--) {\rll a, b;\rcin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b;\rll c , d , e , f;\rll t = gcd(a , b);\rif(t != 1){\ra /= t;\rb /= t;\rd = f = b;\re = 1;\rc = a + 1;\rcout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;e\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl;\rcontinue;\r}\rll p1 = 1,p2 = b,p = minp[b];\rif(p == 0) {\rcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\rcontinue;\r}\rwhile(p2 % p == 0){\rp2 /= p;\rp1 *= p;\r}\rif(p2 == 1){\rcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\rcontinue;\r}\rd = p1;\rf = p2;\rex_gcd(d, f, e, c);\re = -e;\rif(e \u0026lt;= 0 or c \u0026lt;= 0){\rll et = (e % f + f) % f;\rll ct = (c % d + d) % d;\rll mm = max(0ll , max((et - e) / f , (ct - c) / d));\re += f * mm;\rc += d * mm;\r}\re *= a;\rc *= a;\rcout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;e\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n计算几何 区间dp 题目\n题解 很难的一道题\n由于切割的方案数太多，所以考虑dp\ndp[i][j] 表示点 i 到点 j 的答案\n转移方程\ndp[i][j] = min(dp[i][j] , max( max (dp[i][k] , dp[k][j]) , area(ps[i] , ps[j] , ps[k]) ) )\n计算面积直接用外积 1/2 * (A-\u0026gt;B) X (A-\u0026gt;C)\n由于题目存在凹多边形的情况\n所以当有点在三角形 i j k中，这个区间不可分割（根据面积判断，这个技巧可以用于求一个点是否在凸多边形内）\ndp的初始化\ndp[i][i+2] = area(ps[i] , ps[i+1] , ps[i+2])\ndp[i][i] = dp[i][i+1] = 0\ndp[i][i+m] = inf [m\u0026gt;2]\n几个注意点\n用eps ， 初始化只有一类为inf ， 用外积求面积要加绝对值 ， dp的遍历先遍历区间长度（因为从小的先更新，大的区间依赖于小的，这也是很多区间dp要求的）\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int maxn = 105;\rdouble eps = 1e-10;\rstruct point{\rdouble x,y;\r}ps[maxn];\rdouble dp[maxn][maxn];\rint n;\r//a-\u0026gt;c X b-\u0026gt;c\rdouble area(point a,point b,point c) {\rreturn fabs((c.x - a.x) * (c.y - b.y) - (c.y - a.y) * (c.x - b.x)) / 2;\r}\rbool judge(int a,int b,int c){\rdouble s = area(ps[a], ps[b], ps[c]);\rfor(int i =1;i\u0026lt;=n;i++){\rif(i == a or i == b or i == c) continue;\rdouble t = area(ps[i],ps[a],ps[b]) + area(ps[i],ps[a],ps[c]) + area(ps[i],ps[b],ps[c]);\rif(fabs(t - s) \u0026lt; eps) return false;\r}\rreturn true;\r}\rint main() {\r#ifdef LOCAL\rfreopen(\u0026quot;in1.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\rfreopen(\u0026quot;out1.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\r#endif\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rwhile(cin\u0026gt;\u0026gt;n){\rfor(int i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;ps[i].x\u0026gt;\u0026gt;ps[i].y;\rif(i\u0026gt;=3){\rdp[i-2][i] = area(ps[i] , ps[i-1] , ps[i-2]);\r}\r}\rfor(int len = 3 ; len \u0026lt;= n ; len++){\rfor(int i = 1,j = i+len;j\u0026lt;=n;i++,j++){\rdp[i][j] = inf;\rfor(int k = i + 1 ; k \u0026lt; j ; k++){\rif(judge(i,j,k)){\rdp[i][j] = min(dp[i][j] , max(max(dp[i][k] , dp[k][j]) , area(ps[i] , ps[j] , ps[k])));\r}\r}\r}\r}\rprintf(\u0026quot;%.1lf\\n\u0026quot;, dp[1][n]);\r}\rreturn 0;\r}\r ===========================================================================================================\n并查集 思维 题目\n题解 选择权值不为0的极大连通块，全部-1，不断重复，并记录操作次数\n由于点变成0后要从连通块中分裂出来很麻烦，所以考虑倒着来，即单个点合并成连通块\n权值从大到小处理，对于u先假设它是单点，ans+=该点的权值，标记为访问\n对于它相邻的点v，如果访问过（表示v比u权值大）但不在一个集合内，则合并，然后减去u的权值\n因为u和v在一个集合内，v和u共享了u的权值次操作\n注意用scanf\n//#include \u0026quot;bits/stdc++.h\u0026quot;\r#include \u0026quot;iostream\u0026quot;\r#include \u0026quot;algorithm\u0026quot;\r#include \u0026quot;vector\u0026quot;\rusing namespace std;\rusing ll = long long;\rconst int maxn = 100005;\rpair\u0026lt;int,int\u0026gt; b[maxn];\rvector\u0026lt;int\u0026gt; G[maxn];\r//union find\rint par[maxn];\rint rankk[maxn];\rint sz[maxn];\rint used[maxn];\rvoid init(int n)\r{\rfor(int i=0;i\u0026lt;n;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ;\rif(rankk[x]\u0026lt;rankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main() {\r#ifdef LOCAL\rfreopen(\u0026quot;in1.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\rfreopen(\u0026quot;out1.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\r#endif\rint _;\rcin \u0026gt;\u0026gt; _;\rwhile (_--) {\rint n,m;\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rfor(int i=0;i\u0026lt;=n;i++) G[i].clear();\rfor(int i=1;i\u0026lt;=n;i++) {\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;b[i].first);\rb[i].second = i;\r}\rfor(int i=0;i\u0026lt;m;i++){\rint u,v;\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;u,\u0026amp;v);\rG[u].push_back(v);\rG[v].push_back(u);\r}\rsort(b+1,b+n+1,[](pair\u0026lt;int,int\u0026gt; a,pair\u0026lt;int,int\u0026gt; b){return a.first\u0026gt;b.first;});\rinit(n+1);\rfor(int i=0;i\u0026lt;=n;i++) used[i] = 0;\rll ans = 0;\rfor(int i=1;i\u0026lt;=n;i++){\rans += b[i].first;\rused[b[i].second] = 1;\rfor(int j:G[b[i].second]){\rif(used[j]){\rif(!same(b[i].second,j)){\runite(b[i].second,j);\rans -= b[i].first;\r}\r}\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n哈希 题目\n题解 把问题转化成求 A * B = C + Fk\n由于k很大，所以这些数会溢出，用除余法哈希，除数选择不超过ull的数，然后遍历k找到满足C + Fk等于 A * B的k\n实际上不哈希也可以，所以数都自然溢出（可以看做是特殊的哈希），也可以找到答案\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ull = unsigned long long;\rull fib[2000005];\rull a,b,c;\rint n;\rvoid init(){\rfib[1] = 1;\rfib[2] = 2;\rfor(int i=3;i\u0026lt;2000005;i++){\rfib[i] = fib[i-1] + fib[i-2];\r}\r}\rvoid cal(ull \u0026amp;x,int n){\rx = 0;\rfor(int i=1;i\u0026lt;=n;i++){\rint t;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rif(t){\rx += fib[i];\r}\r}\r}\rint main() {\r#ifdef LOCAL\rfreopen(\u0026quot;in1.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\rfreopen(\u0026quot;out1.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\r#endif\rinit();\rint _;\rcin \u0026gt;\u0026gt; _;\rwhile (_--) {\ra = b = c = 0;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rcal(a,n);\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rcal(b,n);\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rcal(c,n);\ra *= b;\rfor(int i=1;i\u0026lt;=n;i++){\rif(fib[i] + c == a){\rprintf(\u0026quot;%d\\n\u0026quot;,i);\rcontinue; //应该是break 但这样也不会超时\r}\r}\r}\rreturn 0;\r}\r ===========================================================================================================\n置换群 题目\n题解 求排列中每个循环的长度，对它们求lcm\n注意大数（可不必取模）\n贴一份队友的代码\ndef gcd(a, b):\rreturn a if b == 0 else gcd(b, a % b)\rdef dfs(i):\rglobal vis\ru = i\rans = 1\rwhile p[i] != u:\rans += 1\rvis[i] = 1\ri = p[i]\rreturn ans\rn = int(input())\rMOD = pow(10, n)\rvis = [0] * 100007\rp = [0] * 100007\rpp = list(map(int, input().split()))\rfor i in range(1, n + 1):\rp[i] = pp[i-1]\rans = 1\rfor i in range(1, n + 1):\rif vis[i] == 1:\rcontinue\rk = dfs(i)\rans = ((ans * k) // gcd(ans, k)) % MOD\rprint(ans)\r ===========================================================================================================\n思维 LIS 题目\n题解 invert操作不会改变数的相对位置，drop2操作会改变数的相对位置\ndrop2操作是把最后一个数之前的数往数列头部移动\n由于这两种操作的性质，把数列看成一个环\n那么invert操作就是旋转环，drop2操作就是把最后一个数（在环里就是任意一个数）插到任意位置上\n所以问题转化成对于一个数列（排列），最少有多少次“将任意数插入到任意位置上”的操作，使得数列递增\n操作数 = n - len(LIS) , 对于环的不同起始位置求LIS，取最大值\n时间复杂度 O(n*n*logn)\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rint dp[505];\rconst int inf = 0x3f3f3f3f;\rint a[1010];\rint main() {\rint n;\rint ma = -1 ;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rfor(int i=0;i\u0026lt;n;++i){\rcin\u0026gt;\u0026gt;a[i];\r}\rint i,j;\rfor(i=0;i\u0026lt;n;i++){\rfill(dp,dp+n,inf);\rfor(j=i;j\u0026lt;i+n;j++){\r*lower_bound(dp,dp+n,a[j]) = a[j];\r}\rma = max(ma , (int)(lower_bound(dp,dp+n,inf) - dp));\ra[j] = a[i];\r}\rcout\u0026lt;\u0026lt;n-ma\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\rreturn 0;\r}\r ===========================================================================================================\n数据结构 实现 题目\n题解 对于每个数，判断能否把前min(i,k)个数作为一个排列，即在它的后面放置切割\n判断是否是排列，即判断这些数中每个数是否只出现一次，出现次数可以用unordered_map记录(map超时)\n想了一个非常复杂的方法，不知道怎么实现，以下是参考了别人的代码，实现效率非常高\n#include \u0026quot;iostream\u0026quot;\r#include \u0026quot;unordered_map\u0026quot;\r#include \u0026quot;cstring\u0026quot;\r#pragma GCC optimize(2)\rusing namespace std;\rtypedef long long ll;\rint a[500005],cut[500005];\runordered_map\u0026lt;int,int\u0026gt; mp;\rinline int read()\r{\rint x=0;int f=1;char s=getchar();\rwhile(s\u0026lt;'0' or s\u0026gt;'9')\r{\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u0026gt;='0' and s\u0026lt;='9')\r{\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rint main() {\rint _;\r_ = read();\rwhile (_--) {\rmp.clear();\rint flag = 0;\rint n,k;\rn = read() , k = read();\rfor (register int i = 1; i \u0026lt;= n; ++i) {\ra[i] = read();\rif(a[i] \u0026gt; k) {\rflag = 1;\rbreak;\r}\r}\rif(flag) {\rputs(\u0026quot;NO\u0026quot;);\rcontinue;\r}\rint dif_num = 0; memset(cut , 0 , sizeof(cut));\rcut[0] = 1;\rfor(register int i=1;i\u0026lt;=n;++i){\rif(i \u0026gt; k) {\rif (mp[a[i - k]] == 1) dif_num-- ; mp[a[i - k]]--;\r}\rif(mp[a[i]] == 0) dif_num++; mp[a[i]]++;\rif(dif_num == k or dif_num == i){\rcut[i] = (i\u0026gt;=k ? cut[i-k] : 1);\r}\r}\rdif_num = 0 ; mp.clear();\rflag = 0;\rfor(register int i=n;i\u0026gt;=max(n-k,0);--i){\rif(dif_num == n-i and cut[i] == 1){\rflag = 1;\rbreak;\r}\rif(mp[a[i]] == 0) dif_num++;\rmp[a[i]]++;\r}\rflag ? puts(\u0026quot;YES\u0026quot;) : puts(\u0026quot;NO\u0026quot;);\r}\rreturn 0;\r}\r ===========================================================================================================\n状态压缩dp 题目\n题解 对于铁路线，肯定是过某个点最划算，而且是过不同的点，即一个点一条线穿过\n所以枚举即将被穿线的点集，每个点有被特定的一条线穿过，穿过的方式有横线、竖线（对于特定的点集，枚举横线竖线的所有情况）\n对于每种情况，更新答案 （两条铁路重合的情况不会影响答案，因为这始终不是最优解）\n玄学时间复杂度 O(sum(2^i * C(n,i) * n * n) 应该有千亿计算量\n一直以为会超时，想把n*n优化成O(1) 无果，看了别人的做法，居然不会超时？？？\n最后跑了2700+ms ，时限是3000ms\n注意long long的强制类型转化\n实际上还有更快的暴力方法和dfs，但我不会\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rint n,x[16],y[16],d[16],D[16],p[16];\rll ans[16];\rint main() {\rmemset(ans , 0x3f , sizeof(ans));\rcin \u0026gt;\u0026gt; n;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;y[i]\u0026gt;\u0026gt;p[i];\r}\rfor(int i=0;i\u0026lt;n;i++){\rD[i] = min(abs(x[i]) , abs(y[i]));\r}\rans[0] = 0;\rfor(int i=0;i\u0026lt;n;i++){\rans[0] += (ll)D[i]*p[i];\r}\rfor(int i=1;i\u0026lt;(1\u0026lt;\u0026lt;n);i++){\rint j = i;\rdo{\rmemcpy(d,D,sizeof(D));\rfor(int k=0;k\u0026lt;n;k++){\rif(i\u0026gt;\u0026gt;k\u0026amp;1){\rif(j\u0026gt;\u0026gt;k\u0026amp;1){\rfor(int q=0;q\u0026lt;n;q++){\rd[q] = min(d[q] , abs(x[q] - x[k]));\r}\r}\relse{\rfor(int q=0;q\u0026lt;n;q++){\rd[q] = min(d[q] , abs(y[q] - y[k]));\r}\r}\r}\r}\rll tmp = 0;\rfor(int i=0;i\u0026lt;n;i++) tmp += (ll)d[i] * p[i];\rans[__builtin_popcount(i)] = min(ans[__builtin_popcount(i)] , tmp);\rj = (j-1) \u0026amp; i;\r}while(j != i);\r}\rfor(int i=0;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n01背包问题 题目\n题解 01背包问题模改\ndp[i][j][k] 表示前i个从者，前j个装备，容量为k的最大价值\n由于从者和装备是平级的，所以分别对它们用01背包问题\n但是有约束条件，装备数量不多于从者，从者最多选5个\n所以应该这样dp ， dp[a][i][b][j][k] 表示从前i个选a个，从前j个选b个，容量为k的最大价值，其中a，b只需遍历到5\n但这样内存超限，由于01背包问题可以从2维降到1维（重复利用，滚动原理），所以这个dp也可以将2维\ndp[i][j][k] 表示选i个从者，j个装备，容量为k的最大价值\n由于装备数量不多于从者，所以先枚举从者（即j=0），然后枚举不大于从者的装备\n最后3重循环求最大值\n#include \u0026quot;bits/stdc++.h\u0026quot;\r#include \u0026quot;algorithm\u0026quot;\rusing namespace std;\rusing ll = long long;\rint dp[6][6][140];\rint a1[305],c1[305],a2[305],c2[305];\rint main() {\rint n,m,c;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;c;\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a1[i]\u0026gt;\u0026gt;c1[i];\rfor(int i=1;i\u0026lt;=m;i++) cin\u0026gt;\u0026gt;a2[i]\u0026gt;\u0026gt;c2[i];\rmemset(dp,0xc0,sizeof(dp));\rdp[0][0][0] = 0;\rfor(int i=1;i\u0026lt;=n;i++){\rfor(int j=c;j\u0026gt;=c1[i];j--){\rfor(int k=1;k\u0026lt;=5;k++){\rdp[k][0][j] = max(dp[k][0][j] , dp[k-1][0][j-c1[i]] + a1[i]);\r}\r}\r}\rfor(int i=1;i\u0026lt;=m;i++){\rfor(int j=c;j\u0026gt;=c2[i];j--){\rfor(int k=1;k\u0026lt;=5;k++){\rfor(int x=1;x\u0026lt;=k;x++){\rdp[k][x][j] = max(dp[k][x][j] , dp[k][x-1][j-c2[i]] + a2[i]);\r}\r}\r}\r}\rint ans = -1;\rfor(int i=1;i\u0026lt;=5;i++){\rfor(int j=0;j\u0026lt;=i;j++){\rfor(int k=0;k\u0026lt;=c;k++){\rans = max(ans , dp[i][j][k]);\r}\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n容斥原理 题目\n题解 考虑特定的k种颜色的染色方案，那么答案就乘上 C(m,k)\n如果是选k种颜色涂色，方案数就是 k(k-1)^(n-1)\n但这是不多于k种颜色的方案，对于“恰好”的方案，可以考虑用容斥原理\n设不多于k种颜色的方案为f(k)\nexactly(k) = f(k) - ( f(k-1) - ( f(k-2) - ( f(k-3) - ( f(k-4) -\u0026hellip; f(1) ))))\nf(k) - part 锁定了第k个元素必须使用，f(k-1) - part锁定了k-1个元素必须使用，以此类推\n把括号打开，就是容斥原理的结构\nexactly(k) = f(k) - f(k-1) + f(k-2) - f(k-3) + f(k-4) \u0026hellip; f(1)\n由于在加减的过程中不断锁定第i个元素，但没有指定在哪个位置锁定这个元素，所以f要乘上所有的方案数\n即F(i) = C(k,i)f(i)\n所以答案为\n$$ C_{m}^{k}\\sum\\limits_{i=0} ^ {k-1} {(-1)^iC_{k}^{k-i}(k-i)(k-i-1)^{n-1}} $$\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rll ans,n,m,k;\rconst int maxn = 1e6+10;\rconst ll mod = 1e9+7;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rll inv[maxn];\rll fac[maxn];\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rint main() {\rfor(ll i=0;i\u0026lt;maxn;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u0026lt;maxn;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!!\rfor(ll i=2;i\u0026lt;maxn;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u0026lt;maxn;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rint _;\rcin \u0026gt;\u0026gt; _;\rwhile (_--) {\rll ckm = 1;\rans = 0;\rcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k;\rfor(ll i=0;i\u0026lt;k;i++){\rckm *= (m-i);\rckm %= mod;\r}\rckm *= inv[k];\rckm %= mod;\rint sign = 1;\rfor(int i = k; i \u0026gt;0 ; --i){\rll tmp = 1;\rtmp *= C(i,k);\rtmp %= mod;\rtmp *= i;\rtmp %= mod;\rtmp *= qpow(i-1 , n-1);\rtmp %= mod;\rif(sign == 1) ans += tmp ; else ans -= tmp;\rans += mod;\rans %= mod;\rsign = -sign;\r}\rans *= ckm;\rans %= mod;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\nbfs 题目\n题解 问题转化成创建一条路径连通三个国家，使路径长度最短\n那么路径一定汇集于一个点\n这就是bfs问题，枚举每个点，求它们到每个国家的最小值，然后和的最小值就是答案，但这样会超时\n以每个国家为起点，bfs到每个点，这样每个点会得到三个信息（分别到三个国家的最短距离），和的最小值就是答案，不会超时\n当这个点是平地时，距离和-2，因为它被创造了三条公路\n我的bug：用fill初始化产生错误，用memset初始化正常，bfs时当点是国家时，距离不需要+1 ， 在求距离和时，要将一个数强制类型转化成long long，它才会升级\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rint n,m;\rchar maze[1005][1005];\rint dist[1003][1003][4];\rusing pii = pair\u0026lt;int,int\u0026gt;;\rint dir[4][2] = {{0,1} , {1,0} , {-1,0} , {0,-1}};\rconst ll inf = 0x3f3f3f3f;\rvoid bfs(int x){\rqueue\u0026lt;pii\u0026gt; q;\rchar ch = '0' + x;\rfor(int i=0;i\u0026lt;n;i++)for(int j=0;j\u0026lt;m;j++){\rif(maze[i][j] == ch) {\rdist[i][j][x] = 0;\rq.push({i,j});\r}\r}\rwhile(q.size()){\rpii tmp = q.front();\rq.pop();\rfor(int i=0;i\u0026lt;4;i++){\rint xt = tmp.first + dir[i][0];\rint yt = tmp.second + dir[i][1];\rif(maze[xt][yt] == '#') continue;\rif(xt \u0026lt;0 or yt\u0026lt;0 or xt\u0026gt;=n or yt\u0026gt;=m) continue;\rint cost = (maze[xt][yt] == '.');\rif(dist[tmp.first][tmp.second][x] + cost \u0026lt; dist[xt][yt][x]){\rdist[xt][yt][x] = dist[tmp.first][tmp.second][x] + cost;\rq.push({xt,yt});\r}\r}\r}\r}\rint main() {\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rmemset(dist , inf , sizeof(dist));\rfor(int i=0;i\u0026lt;n;i++){\rscanf(\u0026quot;%s\u0026quot;,\u0026amp;maze[i]);\r} bfs(1);bfs(2);bfs(3);\rll ans = inf;\rfor(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++){\rif(maze[i][j] == '#') continue;\rll sum = (ll)dist[i][j][1] + dist[i][j][2] + dist[i][j][3];\rif(maze[i][j] == '.') sum -= 2;\rans = min(ans , sum);\r}\rcout\u0026lt;\u0026lt;(ans == inf ? -1 : ans)\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\ndfs 图论 题目\n题解 把问题转化成求在所有简单路径中，每个点被遍历了几次，如果是偶数次，异或和为0，奇数次异或和为本身\n这样就是图论中求所有简单路径XX被遍历几次的经典模型，基础的有边和点\n如果是边\n$$ f(edge) = size[x] * ( n - size[x]) $$\n如果是点，考虑三种情况，以这个点为端点，有n-1条，这个点的子树连到子树外面有 (size[x] - 1) * ( n - size[x]) ， 这个点的子节点的子树连到另外一个子节点的子树有 (sum(size[ch] * (size[x] - 1 - size[ch]))) / 2 除以2因为每个点都作为起点和终点一次，但这样只有一条\n$$ f(node) = n-1 + (size[x] - 1) * (n-size[x]) + \\frac{\\sum\\limits_{} ^ {} {size[ch] * (size[x] - 1 - size[ch])} }{2} $$\n还有另一种算法\n$$ f(node) = \\frac{\\sum{f(edge) [connected \\ to \\ node]+ n-1} }{2} $$\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rvector\u0026lt;ll\u0026gt; G[500005];\rll sz[500005];\rll a[500005];\rll ans ;\rll n;\rll dfs(ll u,ll p){\rsz[u] = 1;\rfor(ll i:G[u]){\rif(i == p) continue;\rsz[u] += dfs(i,u);\r}\rll sum = 0;\rfor(ll i:G[u]){\rif(i == p) continue;\rsum += sz[i] * (sz[u] - 1 - sz[i]) ;\r}\rsum /= 2;\rsum += (sz[u] - 1) * (n - sz[u]);\rsum += n - 1;\rif(sum\u0026amp;1) ans ^= a[u];\rreturn sz[u];\r}\rint main() {\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n-1;i++){\rll x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rG[x].push_back(y); G[y].push_back(x);\r}\rfor(ll i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i];\rdfs(1,0);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":1,"section":"posts","summary":"简单思维 题目 题解 直接法，注意数组大小爆long long #include\u0026lt;bits/stdc++.h\u0026gt; using ll = long long; const ll mod = 1e6+3; ll fac[mod+2]; int main(){ fac[0] = 1LL; fac[1] = 1LL; for(ll i=2;i\u0026lt;mod+2;i++){ fac[i] = i*fac[i-1]; fac[i] %= mod; } ll n; while(std::cin\u0026gt;\u0026gt;n){ if(n\u0026gt;=mod) puts(\u0026quot;0\u0026quot;);else std::cout\u0026lt;\u0026lt;fac[n]\u0026lt;\u0026lt;std::endl; } return 0; } =========================================================================================================== 并查集 排列","tags":["cpp","problemlist"],"title":"某不科学的暑假做题记录","uri":"https://dyhgo.github.io/2020/07/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84%E6%9A%91%E5%81%87%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","year":"2020"},{"content":"A - Calc 题意 看题目\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rint a;\rcin\u0026gt;\u0026gt;a;\rcout\u0026lt;\u0026lt;a+a*a+a*a*a\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r B - Minor Change 题意 看题目\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rstring s,t;\rcin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;\rint ans = 0;\rfor(int i=0;i\u0026lt;s.length();i++){\rif(s[i]!=t[i])ans++;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Tsundoku 题意 看题目\n题解 前缀和+双指针\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll a[200005];\rll b[200005];\rint main(){\rll n,m,k;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k;\ra[0] = 0;\rb[0] = 0;\rfor(ll i=1;i\u0026lt;=n;i++){\rll tmp;\rcin\u0026gt;\u0026gt;tmp;\ra[i] = a[i-1] + tmp;\r}\rfor(ll j=1;j\u0026lt;=m;j++){\rll tmp;\rcin\u0026gt;\u0026gt;tmp;\rb[j] = b[j-1] + tmp;\r}\rll ans = 0;\rll j = m;\rll i;\rfor(i=0;i\u0026lt;=n;i++){\rwhile(a[i] + b[j] \u0026gt; k and j\u0026gt;=0){\rj--;\r}\rif(a[i] + b[j] \u0026lt;= k) {\rans = max(ans , i+j);\r//cerr\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl;\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Sum of Divisors 题意 看题目\n题解 筛法预处理因子个数，O(1)查询\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n;\rll num[10000005];\rvoid init(){\rfor(ll i=1;i\u0026lt;=10000005;i++){\rfor(ll x=i;x\u0026lt;10000005;x+=i){\rnum[x]++;\r}\r}\r}\rint main(){\rinit();\rcin\u0026gt;\u0026gt;n;\rll ans = 0;\rfor(ll i=1;i\u0026lt;=n;i++){\rans += i*num[i];\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - NEQ 题意 看题目\n题解 对于从M个选N个全排列的每一种方案都有对应的若干个情况，它们都是等价的\n比如M=4 N=3 ，对于全排列的一种方案 123\n与之对应的有第一个数字不能为1、第二个数字不能为2，第三个数字不能为3\n第一个数字和第二个数字不能同时为12，第二个和第三个数字不能同时为23，第一个和第三个数字不能同时为13\n第一个第二个第三个数字不能同时为123\n这样就是基于容斥原理的排列组合\n总的方案数是\n$$ A_{M}^{N}*\\sum\\limits_{i=0} ^ {n} {C_{N}^{i}A_{M-i}^{N-i}(-1)^n} $$\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n;\rll m;\rconst ll mod = 1e9+7;\rconst ll maxn = 500005;\rll inv[maxn+3];\rll fac[maxn+3];\rinline ll A(ll n,ll m){\rreturn fac[n]*inv[n-m]%mod;\r}\rinline ll C(ll n,ll m){\rreturn A(n,m)*inv[m]%mod;\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u0026lt;maxn;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u0026lt;=maxn;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u0026lt;=maxn;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rll ans =0;\rfor(ll i=0;i\u0026lt;=n;i++){\rll tmp = C(n,i) * A(m-i,n-i);\rtmp %= mod;\rif(i%2==0){\rans += tmp;\r}else ans -= tmp;\rans += mod;\rans %= mod;\r}\rans *= A(m,n);\rans += mod;\rans %= mod;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r//cout\u0026lt;\u0026lt;tmp\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Unfair Nim 题意 看题目\n题解 题解url\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rll n;\rcin\u0026gt;\u0026gt;n;\rll q,w;\rcin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;w;\rll x = 0;\rfor(ll i=2;i\u0026lt;n;i++){\rll tmp;\rcin\u0026gt;\u0026gt;tmp;\rx ^= tmp;\r}\rll d = (q+w-x) / 2;\rif(d\u0026lt;0 or d\u0026gt;q or (d\u0026amp;x) or (q+w-x)%2==1){\rcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\rexit(0);\r}\rfor(ll i=45;i\u0026gt;=0;i--){\rif(x\u0026gt;\u0026gt;i\u0026amp;1LL){\rif(d+(1LL\u0026lt;\u0026lt;i) \u0026lt;= q){\rd += (1LL\u0026lt;\u0026lt;i);\r}\r}\r}\rif(d==0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;q-d\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":2,"section":"posts","summary":"A - Calc 题意 看题目 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ int a; cin\u0026gt;\u0026gt;a; cout\u0026lt;\u0026lt;a+a*a+a*a*a\u0026lt;\u0026lt;endl; return 0; } B - Minor Change 题意 看题目 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int ans = 0; for(int i=0;i\u0026lt;s.length();i++){ if(s[i]!=t[i])ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } C - Tsundoku 题意","tags":["cpp","counting","prefix","bit"],"title":"abc172","uri":"https://dyhgo.github.io/2020/06/abc172/","year":"2020"},{"content":"挺好的比赛\nA-找规律 题解 玄学题，打表找规律或者猜测规则是每次洗牌是将一个位置移动到另一个固定位置\n13次洗牌之后所有的位置都占过一遍，所以13次是循环\n要求洗牌5次的结果就是求9次两次洗牌的结果\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rstring s[30];\rstring t[30];\rint a[30];\rvoid init_a(){\rfor(int i=0;i\u0026lt;13;i++){\rfor(int j=0;j\u0026lt;13;j++){\rif(s[i] == t[j]){\ra[i] = j;\rbreak;\r}\r}\r}\r}\rvoid sol(){\rfor(int i=0;i\u0026lt;13;i++){\rt[a[i]] = s[i];\r}\rfor(int i=0;i\u0026lt;13;i++){\rs[i] = t[i];\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rwhile(cin\u0026gt;\u0026gt;s[0]){\rfor(int i=1;i\u0026lt;13;i++) cin\u0026gt;\u0026gt;s[i]; for(int i=0;i\u0026lt;13;i++) cin\u0026gt;\u0026gt;t[i]; init_a();\rfor(int i=0;i\u0026lt;9;i++) sol();\rfor(int i=0;i\u0026lt;13;i++) cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\r//cout\u0026lt;\u0026lt;\u0026quot;end\u0026quot;\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B-签到题 题解 排列组合\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+9;\rll fac[100005];\rll inv[100005];\rll C(ll n,ll m){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rll A(ll n,ll m){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main(){\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u0026lt;100005;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rinv[0] = 1;\rinv[1] = 1; //inv[0]=1 !!! for(ll i=2;i\u0026lt;=100005;i++){\rinv[i] = (mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u0026lt;=100005;i++){\rinv[i] = (inv[i]*inv[i-1])%mod;\r}\rll n;\rwhile(cin\u0026gt;\u0026gt;n){\rcout\u0026lt;\u0026lt;n*C(n,2)%mod*A(n-1,n-2)%mod\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C-救救AR 题意 找规律\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint n;\rcin\u0026gt;\u0026gt;n;\rif(n==1 or n==2 or n==3){\rcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\r}\relse{\rif(n\u0026amp;1){\rcout\u0026lt;\u0026lt;\u0026quot;ARA\u0026quot;;\rfor(int i=0;i\u0026lt;n/2;i++){\rcout\u0026lt;\u0026lt;\u0026quot;R\u0026quot;;\r}\rcout\u0026lt;\u0026lt;endl;\r}\relse{\rcout\u0026lt;\u0026lt;\u0026quot;AA\u0026quot;;\rfor(int i=0;i\u0026lt;n/2;i++) cout\u0026lt;\u0026lt;\u0026quot;R\u0026quot;;\rcout\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r D-ar采蘑菇 题解 状态压缩dp\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\rusing namespace std;\rusing ll = long long;\rint r[7],u[7];\rint dp[105][105][35];\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rint n,m,k;\rwhile(t--){\rmemset(r,0,sizeof(r));\rmemset(u,0,sizeof(u));\rmemset(dp,0,sizeof(dp));\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;k;i++){\rstring s;\rcin\u0026gt;\u0026gt;s;\rfor(int j=0;j\u0026lt;s.length();j++){\rif(s[j] == 'R') r[i]++; else u[i]++;\r}\r}\rdp[0][0][0] = 1;\rfor(int i=0;i\u0026lt;=n;i++){\rfor(int j=0;j\u0026lt;=m;j++){\rfor(int st=0;st\u0026lt;(1\u0026lt;\u0026lt;k);st++){\rfor(int q=0;q\u0026lt;k;q++){\rint nn = i - r[q];\rint mm = j - u[q];\rif(nn\u0026lt;0 or nn\u0026gt;n or mm\u0026lt;0 or mm\u0026gt;m) continue;\rif(st\u0026gt;\u0026gt;q\u0026amp;1){\rdp[i][j][st] |= dp[nn][mm][st];\rdp[i][j][st] |= dp[nn][mm][st^(1\u0026lt;\u0026lt;q)];\r}\r}\r}\r}\r}\rint ans = 0; //等于0就ac,-1wa\rfor(int i=0;i\u0026lt;(1\u0026lt;\u0026lt;k);i++){\rif(dp[n][m][i]){\rans = max(ans , __builtin_popcount(i));\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r E-呼兰河传 题解 最大的lcm为全选取\n经典的大数求lcm\n暴力超时，且除以gcd无法取模\n由于题目的数据规模可以去重\n对于每一个因数，求这些数对于它幂次方贡献的最大值\n最后遍历所有因数，对于最大贡献求积\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+9;\rll pn[100005];\rset\u0026lt;ll\u0026gt; st;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rvoid did(ll x){\rfor(ll i=2;i*i\u0026lt;=x;i++){\rif(x%i==0){\rll num = 0;\rwhile(x%i==0){\rx /= i;\rnum++;\r}\rpn[i] = max(pn[i] , num);\r}\r}\rif(x != 1){\rpn[x] = max(pn[x] , 1LL);\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rll n;\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n;i++){\rll x;\rcin\u0026gt;\u0026gt;x;\rst.insert(x);\r}\rfor(ll i:st){\rdid(i);\r}\rll ans = 1;\rfor(ll i=2;i\u0026lt;=1e5+2;i++){\rans *= qpow(i,pn[i]);\rans %= mod;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F-月出皎兮，佼人僚兮。 题解 对于某一节点u，设子树颜色数最大是 p，颜色总数是sum，如果p*2 \u0026gt; sum\n最大匹配数是sum - p，否则都能匹配 sum/2\n所以只要求子树颜色最多的数量\n暴力dfs超时，所以用树上启发式合并\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 2e5+3;\rstruct edge{\rint to,nxt;\r}e[maxn\u0026lt;\u0026lt;1];\rll sz[maxn],par[maxn],c[maxn],num[maxn],head[maxn],wch[maxn],tot[maxn],ans[maxn];\rll n;\rll cnt;\rll tmax;\rll sum;\rvoid add_edge(ll u,ll v){\re[++cnt].to = v;\re[cnt].nxt = head[u];\rhead[u] = cnt;\r}\rvoid dfs(ll u,ll p){\rsz[u] = 1;\rfor(ll i=head[u]; i ;i=e[i].nxt){\rll t = e[i].to;\rif(t != p){\rdfs(t,u);\rsz[u] += sz[t];\rif(sz[t] \u0026gt; sz[wch[u]]) wch[u] = t;\r}\r}\r}\rvoid cal(ll u,ll p,ll wch,ll val){\rtot[c[u]] += val * num[u];\rsum += val * num[u];\rtmax = max(tmax , tot[c[u]]);\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch){\rcal(t,u,wch,val);\r}\r}\r}\rvoid dsu(ll u,ll p,ll kp){\rfor(ll i=head[u]; i ; i=e[i].nxt){\rll t = e[i].to;\rif(t != p and t != wch[u]){\rdsu(t,u,0);\r}\r}\rif(wch[u]) dsu(wch[u],u,1);\rcal(u,p,wch[u],1);\rif(2*tmax \u0026gt; sum) ans[u] = sum - tmax;\relse ans[u] = sum / 2; if(!kp) {\rcal(u,p,0,-1);\rtmax = 0;\rsum = 0;\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n-1;i++){\rll x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\radd_edge(x,y); add_edge(y,x);\r}\rfor(ll i=1;i\u0026lt;=n;i++){\rll x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rc[i] = x;\rnum[i] = y;\r}\rdfs(1,0);\rdsu(1,0,1);\rfor(int i=1;i\u0026lt;=n;i++){\rcout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl;\r} return 0;\r}\r G-寻找未曾见过的你 题解 不会\nH-AR的背包 题解 不会\n","id":3,"section":"posts","summary":"挺好的比赛 A-找规律 题解 玄学题，打表找规律或者猜测规则是每次洗牌是将一个位置移动到另一个固定位置 13次洗牌之后所有的位置都占过一遍，所以13","tags":["cpp","dp","counting","number_theory","graph"],"title":"西南科技大学第十六届ACM程序设计竞赛暨绵阳市邀请赛","uri":"https://dyhgo.github.io/2020/06/%E8%A5%BF%E5%8D%97%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8Aacm%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E6%9A%A8%E7%BB%B5%E9%98%B3%E5%B8%82%E9%82%80%E8%AF%B7%E8%B5%9B/","year":"2020"},{"content":"A - αlphabet 题意 看题目\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rchar a;\rcin\u0026gt;\u0026gt;a;\rif(isupper(a)) cout\u0026lt;\u0026lt;'A';else cout\u0026lt;\u0026lt;'a';\rreturn 0;\r}\r B - Mix Juice 题意 看题目\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint n,k;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rint a[n];\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rsort(a,a+n);\rint ans = 0;\rfor(int i=0;i\u0026lt;k;i++) ans+=a[i];\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - One Quadrillion and One Dalmatians 题意 类似于十进制转26进制\n不同的是27是 aa\n题解 这个题目没有像正常的转化那样进位\n所以对每一位求值前先减1\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rll a;\rcin\u0026gt;\u0026gt;a;\rstring s = \u0026quot;\u0026quot;;\r//a--;\rwhile(a!=0){\ra--;\rs += (a%26) + 'a';\ra /= 26;\r}\rreverse(s.begin(),s.end());\rcout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Replacing 题意 看题目\n题解 模拟\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rlong long a[100005];\rint main(){\rlong long n;\rcin\u0026gt;\u0026gt;n;\rlong long sum = 0;\rfor(long long i=0;i\u0026lt;n;i++) {\rlong long x;\rcin\u0026gt;\u0026gt;x;\ra[x]++;\rsum+=x;\r}\rlong long q;\rcin\u0026gt;\u0026gt;q;\rfor(long long i=0;i\u0026lt;q;i++){\rlong long t,y;\rcin\u0026gt;\u0026gt;t\u0026gt;\u0026gt;y;\rsum+=((y-t)*a[t]);\rcout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl;\ra[y]+=a[t];\ra[t] = 0;\r}\rreturn 0;\r}\r E - Red Scarf  题意 对于一个数列，第一个位置的值是原数列其他位置的异或，依此类推\n还原数列\n题解 利用异或性质\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint a[200005];\rint main()\r{\rint n;\rcin\u0026gt;\u0026gt;n;\rint ans = 0;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\rans ^= a[i];\r}\rfor(int i=0;i\u0026lt;n;i++){\rcout\u0026lt;\u0026lt;(ans^a[i])\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r}cout\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Strivore 题意 看题目\n题解 把问题转化成满足长度为n的，包含子序列s的字符串有几个\n然后就变成排列组合题\n考虑所有情况减去不包含子序列s的字符串\n不含子序列s的字符串可以这样构造\n目标串T可以包含子序列中的1个，2个，3个。。。s.length() - 1个\n这样取子序列只能是前几个，因为取s的中间部分就一定不满足条件\n对于其中一种情况，举个例子\ns = \u0026quot; acf\u0026rdquo; 总长度为8\n假设从s中选两个，那这两个就一定是 a c\n假设它们被安排在这样的位置\n12a45c78\n那么1号和2号一定不能选到a，4号和5号一定不能选到c，7号和8号一定不能选到f\n这样T就一定没有子序列s\n对于除ac外的位置都有25种选择\n所以这种情况（选两个）就有\n$$ C_{8}^{2} * 25^6 $$\n种方案\n所以对于所有情况(n是T的长度，s是子序列的长度)，方案数\n$$ 26^{n} - \\sum\\limits_{i=0} ^ {s-1} {C_n^i*25^{n-i}} $$\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll fac[2000005];\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rll C(ll n,ll m){\rreturn fac[n]*qpow(fac[m] , mod-2)%mod*qpow(fac[n-m] , mod-2)%mod;\r}\rint main(){\rfac[0] = 1;\rfac[1] = 1;\rfor(ll i=2;i\u0026lt;2000002;i++){\rfac[i] = i * fac[i-1];\rfac[i] %= mod;\r}\rll k;\rcin\u0026gt;\u0026gt;k;\rstring ss;\rcin\u0026gt;\u0026gt;ss;\rll s = ss.size();\rll ans = 0;\rfor(ll i=0;i\u0026lt;s;i++){\rans += C(k+s , i) * qpow(25 , k+s-i);\rans %= mod;\r}\rcout\u0026lt;\u0026lt;(qpow(26 , k+s) - ans + mod) % mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 如果用逆元\ninline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u0026lt;=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u0026lt;=n;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\r ","id":4,"section":"posts","summary":"A - αlphabet 题意 看题目 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ char a; cin\u0026gt;\u0026gt;a; if(isupper(a)) cout\u0026lt;\u0026lt;'A';else cout\u0026lt;\u0026lt;'a'; return 0; } B - Mix Juice 题意 看题目 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; int a[n]; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; sort(a,a+n); int ans = 0; for(int i=0;i\u0026lt;k;i++) ans+=a[i]; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } C","tags":["cpp","counting"],"title":"abc171","uri":"https://dyhgo.github.io/2020/06/abc171/","year":"2020"},{"content":"安装vmware 点击这里\n需要注册账号\nvmware的安装基本选择默认选项，一直next\n准备一个ubuntu镜像文件 点击这里\n选择对应版本的ubuntu文件\n文件类似于\n安装ubuntu 打开vmware\n点击“创建新的虚拟机”\n点击“自定义”\n点击“下一步”\n硬件兼容性选低一点能兼容的比较多\n点击“下一步”\n选择“稍后安装操作系统”\n点击“下一步”\n选择linux 选择 ubuntu64位\n点击“下一步”\n选择”虚拟机名称“和安装的路径\n点击“下一步”\n根据自身计算机性能来分配处理器数量\n点击“下一步”\n选择虚拟机内存，一般2G就行\n点击“下一步”\n选择“桥接网络”\n点击“下一步”\n选择推荐的那个\n点击“下一步”\n选择推荐的那个\n点击“下一步”\n选择“创建新的虚拟磁盘”\n点击“下一步”\n根据需求选择磁盘空间大小（一般20G以上）\n点击“立即分配磁盘空间”\n选择“将虚拟磁盘拆分成多个文件”\n点击“下一步”\n点击“下一步”\n点击“完成”，开始创建（需要花很长的时间）\n完成之后\n先不要开启虚拟机\n点击“编辑虚拟机设置”\n点击”cd/dvd“ 选择“使用iso影像文件”\n点击“浏览”\n找到最开始装的iso文件\n点击“确定\n点击“开启虚拟机”\n选择”中文“，点击“安装ubuntu”\n点击“继续”\n点击“继续”\n点击“现在安装”\n完成后\n点击“继续”\n点击“继续”\n输入信息\n点击“继续”，开始安装\n完成后\n点击“现在重启”\n点击“小圆”，选择”ubuntu2d“\n输入密码，登录\n完成\n附加 鼠标滚轮无法使用的问题 应该只有罗技鼠标会出现这种情况吧\n参考此处\nchromium无法打开的问题 升级版本，据说chrome不支持ubuntu12及以下\n中文输入法无法显示候选词框的问题 莫名其妙可以，如果fcitx不行，尝试安装搜狗输入法，要重启才能启用搜狗，但一般搜狗输入法也无法显示，可能与kde桌面有关，真正的原理未知\n创建快捷方式（在启动器中） 在dash中输入，找到后直接拖到启动器中，可调整顺序\n安装flatabulous主题 参考此处\n安装clion 官网下载 tar.gz压缩包\n然后 tar -zxvf XXX.tar.gz 解压缩\n然后在bin目录下./clion.sh\n安装gcc sudo apt-get update\nsudo apt-get install build-essential\ngcc --version\n如果没有\nsudo apt-get install gcc-对应的版本号\n安装cmake 参考此处\n初步使用ubuntu的感想\n虽然ubuntu有图形界面，但它不像windows那样丰富，大多数的操作都可以通过点击可视化界面完成\nubuntu类似于万物皆文件，以抽象的形式存在，所以很多操作只能由命令行完成\nubuntu的很多操作都比windows直接，且安全性也比windows高，管理c++工程，比如安装库都要比windows方便，我觉得很大的原因在于windows要服务于大众，而linux更像自娱自乐的工具\n使用linux只是使用它的特性，整体上windows还是大大优于linux\n","id":5,"section":"posts","summary":"安装vmware 点击这里 需要注册账号 vmware的安装基本选择默认选项，一直next 准备一个ubuntu镜像文件 点击这里 选择对应版本的ubu","tags":["cpp","linux"],"title":"install ubuntu in vmware","uri":"https://dyhgo.github.io/2020/06/install-ubuntu-in-vmware/","year":"2020"},{"content":"A - Five Variables 题意 找5个数中值为0的下标\n题解 a = list(map(int , input().split()))\rprint(a.index(0) + 1)\r B - Crane and Turtle 题意 鸡兔同笼问题\n题解 n , m = map(int , input().split())\rprint('Yes') if (m - 2 * n) % 2 == 0 and (m - 2 * n) \u0026gt;= 0 and 4 * n - m \u0026gt;= 0 and (4 * n - m) % 2 == 0 else print('No')\r C - Forbidden List 题意 给一数x 和一数列，找不在数列中离x最近的数\n题解 x , n = map(int , input().split())\rb = []\rif n!=0:\rb = list(map(int,input().split()))\rt = 0\rans = 0\rwhile 1:\rif x-t not in b:\rans = x - t\rbreak\rif x+t not in b:\rans = x + t\rbreak\rt += 1\rprint(ans)\r D - Not Divisible 题意 给一数列，对于数列中的每个数，如果都不能被其他数整除，计数器 + 1\n求计数器的值\n题解 暴力时间复杂度 O(n*√(V)) 好像会超时\n可以排序，从小到大遍历，对于当前数，考虑 2*x 3*x 4*x 的值是否在数列里，如果在数列里（只会比当前数大）则移除\n这样总共要算\n(1/2 + 1/3 + 1/4 + 1/5 + 1/6 + \u0026hellip; + 1/n) * V = (ln(n) + 0.578) * V 次\n时间复杂度为 O(n*ln(n))\n注意当数列中有重复数，则都不能算\n注意特判1个数\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\r//int a[200005];\rset\u0026lt;int\u0026gt; st;\rset\u0026lt;int\u0026gt; stt;\rmultiset\u0026lt;int\u0026gt; ms;\rvoid did(int x){\rfor(int i=2;i*x\u0026lt;=1000005;i++){\rint tmp = i*x;\rif(st.find(tmp)!=st.end()){\rst.erase(tmp);\r}\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\r//for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rfor(int i=0;i\u0026lt;n;i++){\rint x;\rcin\u0026gt;\u0026gt;x;\rst.insert(x);\rstt.insert(x);\rms.insert(x);\r}\r//for(int i:st) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl;\rif(st.size()==1 and n\u0026gt;1) {\rcout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\rreturn 0;\r}\rif(n==1) { // WA!!!\rcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl;\rreturn 0;\r}\rfor(int i:st){\rdid(i);\r}\r//for(int i:st) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl;\rint ans = st.size(); // WA !!!!\rfor(int i:st){\rif(ms.count(i)\u0026gt;1) ans--;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Smart Infants 题意 每个小朋友都有一个分数和初始的幼儿园\n每次转学的操作是\n将第 i 个小朋友转到第 j 个幼儿园\n对于q次转学\n每次输出每个幼儿园中分数最高的最小值\n题解 一开始的思路是最小值的更新肯定在有变动的幼儿园和当前最小值之间选择\n但这是错的，因为当前最小值被覆盖之后，更新后的最小值可能是之前的次小值（而次小值没有记录）\n所以：用集合模拟幼儿园（目的在于log时间内排序）\n对于每次操作都用集合模拟，用多重集维护所有的最大值\n通过查看幼儿园最大值是否被更换来决定是否对多重集进行增删\n一百万个数据错了3个，原因竟然是：\n多重集的erase操作是全删而不是删一个\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,q;\rset\u0026lt;pair\u0026lt;int,int\u0026gt;, greater\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; \u0026gt; st[200005];\rmultiset\u0026lt;int\u0026gt; ms;\rint rat[200005];\rint wh[200005];\r//multiset\u0026lt;int , greater\u0026lt;int\u0026gt;\u0026gt; ts[200005];\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q;\rfor(int i=0;i\u0026lt;n;i++){\rint a,b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rb--;\rrat[i] = a;\rwh[i] = b;\rst[b].insert({a,i});\r//ts[b].insert(a);\r}\rfor(int i=0;i\u0026lt;200005;i++){\rif(st[i].empty()) continue;\r//int num = ts[i].count(*ts[i].begin());\r//for(int j=0;j\u0026lt;num;j++){\rms.insert(st[i].begin()-\u0026gt;first);\r//}\r}\rwhile(q--){\rint a,b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\ra--,b--;\rbool ismax = false;\rif(st[wh[a]].begin()-\u0026gt;second == a) ismax = true;\rif(ismax){\rms.erase(ms.find(rat[a]));\rst[wh[a]].erase({rat[a] , a});\rif(st[wh[a]].empty()) ;\relse ms.insert(st[wh[a]].begin()-\u0026gt;first);\rwh[a] = b;\rif(st[b].empty()) ;\relse ms.erase(ms.find(st[b].begin()-\u0026gt;first));\rst[b].insert({rat[a] , a});\rms.insert(st[b].begin()-\u0026gt;first);\r}\relse{\rst[wh[a]].erase({rat[a] , a});\rwh[a] = b;\rif(st[b].empty()) ;\relse ms.erase(ms.find(st[b].begin()-\u0026gt;first));\rst[b].insert({rat[a] , a});\rms.insert(st[b].begin()-\u0026gt;first);\r}\rcout\u0026lt;\u0026lt;*ms.begin()\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r F - Pond Skater 题意 给一个迷宫、起点、终点\n对于走的方向，只能是上下左右\n对于每一步，最多只能走k格且不能转弯\n求是否能到达终点，如果能，最少走几步\n题解 bfs 每次沿一个方向，尽可能地走k步\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint h ,w ,k;\rint xs,ys,xt,yt;\rconst int inf = 1e9;\rint dirx[] = {0,-1,1,0};\rint diry[] = {1,0,0,-1};\rint main(){\rcin \u0026gt;\u0026gt; h \u0026gt;\u0026gt; w \u0026gt;\u0026gt; k;\rcin\u0026gt;\u0026gt;xs\u0026gt;\u0026gt;ys\u0026gt;\u0026gt;xt\u0026gt;\u0026gt;yt;\rxs--,ys--,xt--,yt--;\rvector\u0026lt;string\u0026gt; vt(h);\rfor(int i=0;i\u0026lt;h;i++) cin\u0026gt;\u0026gt;vt[i];\rvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; d(h , vector\u0026lt;int\u0026gt;(w,inf));\rqueue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; q;\rq.push({xs,ys});\rd[xs][ys] = 0;\rwhile(q.size()){\rauto tmp = q.front();\rq.pop();\rint tmpx = tmp.first;\rint tmpy = tmp.second;\rfor(int i=0;i\u0026lt;4;i++){\r//\tint tox = tmpx + dirx[i];\r//\tint toy = tmpy + diry[i];\rint ttmpx = tmpx;\rint ttmpy = tmpy;\rint j;\rfor(j=0;j\u0026lt;k;j++){\rttmpx += dirx[i];\rttmpy += diry[i];\rif(ttmpx\u0026gt;=0 and ttmpy\u0026gt;=0 and ttmpx\u0026lt;h and ttmpy\u0026lt;w and vt[ttmpx][ttmpy]!='@' and d[ttmpx][ttmpy] \u0026gt; d[tmpx][tmpy]){\rif(d[ttmpx][ttmpy] \u0026gt; d[tmpx][tmpy] + 1){\rd[ttmpx][ttmpy] = d[tmpx][tmpy] + 1;\rq.push({ttmpx , ttmpy});\r}\r}else break;\r}\r}\r}\rcout\u0026lt;\u0026lt;(d[xt][yt]==1e9 ? -1 : d[xt][yt])\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":6,"section":"posts","summary":"A - Five Variables 题意 找5个数中值为0的下标 题解 a = list(map(int , input().split())) print(a.index(0) + 1) B - Crane and Turtle 题意 鸡兔同笼问题 题解 n , m = map(int , input().split()) print('Yes') if (m - 2 * n) % 2 == 0 and (m - 2 * n) \u0026gt;= 0 and 4","tags":["cpp","bfs","greedy","data_structure"],"title":"abc170","uri":"https://dyhgo.github.io/2020/06/abc170/","year":"2020"},{"content":"A. Shovels and Swords 题意 两个钻石和一个棍子可以造出A，两个棍子和一个钻石可以造出B\n每个A或B都可以卖出一块钱，求 x个棍子和y个钻石最多可以卖多少钱\n题解 钻石和棍子是等价的，他们一共用了三个，只要贪心地将总数/3即可\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint t;\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint a,b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;min({a,b,(a+b)/3})\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. Shuffle 题意 初始有n个数，第i个为1，其他为0，给若干个区间，对每个区间，可以选择区间内的数（两个或自身）交换数值\n问有多少个数字能在合理选择后达到1\n题解 首先前面的区间是否覆盖1，没覆盖全部抛弃，否则从那个区间开始做以下事\n判断接下来的区间和这个区间有没有交集，有则用并集刷新当前区间，否则抛弃\n最后求集合包含了几个数\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n,x,m;\rint t;\rint l,r;\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;m;\rint L=-1,R=-1;\rbool ok = false;\rwhile(m--){\rcin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\rif(ok){\rif(l\u0026lt;=R and L\u0026lt;=r){\rL = min(L,l);\rR = max(R,r);\r}\r}\relse\r{\rif(x\u0026lt;l or x\u0026gt;r ) continue;\rL = l,R = r;\rok = true;\r}\r}\rif(L==-1 and R==-1) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;R-L+1\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C. Palindromic Paths 题意 给一充满01的矩阵，从左上角走到右下角，只能向右走和向下走\n改变矩阵中的若干元素，使得所有路径按序组成的字符串都是回文串\n求最小改动数\n题解 由于题限，到每个点都走固定的步数，每个步数值与对称的步数值相同（同为0或1）\nbfs求每格步数，然后对于每一组求0多还是1多，以此决定全是0还是全是1\n[WARNING] 以下代码，逻辑低效(懒得改)\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n,m;\rint t;\rint a[32][32];\rint d[32][32];\rvector\u0026lt;int\u0026gt; stp[62];\rint used[32][32];\rpriority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; pq;\rvoid bfs(){\rpq.push({0,0});\rd[0][0] = 0;\rused[0][0] = 1;\rwhile(pq.size()){\rpair\u0026lt;int,int\u0026gt; pii = pq.top();\rpq.pop();\rif(pii.first+1 \u0026lt; n and used[pii.first+1][pii.second]==0) {\rpq.push(make_pair(pii.first+1,pii.second));\rd[pii.first+1][pii.second] = d[pii.first][pii.second] + 1;\rused[pii.first+1][pii.second] = 1;\r}\rif(pii.second+1 \u0026lt; m and used[pii.first][pii.second+1]==0){\rpq.push(make_pair(pii.first,pii.second+1));\rd[pii.first][pii.second+1] = d[pii.first][pii.second] + 1;\rused[pii.first][pii.second+1] = 1;\r}\r}\rfor(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++) stp[d[i][j]].push_back(a[i][j]);\r}\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint ans = 0;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;62;i++) stp[i].clear();\rmemset(used,0,sizeof(used));\rfor(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++) cin\u0026gt;\u0026gt;a[i][j];\rbfs();\rfor(int i=0,j=n+m-2;i\u0026lt;j;i++,j--){\rif((n+m-2)%2==0 and i==j) continue;\rint zero = count(stp[i].begin(),stp[i].end(),0) + count(stp[j].begin(),stp[j].end(),0);\rint one = count(stp[i].begin(),stp[i].end(),1) + count(stp[j].begin(),stp[j].end(),1);\rans += 2*stp[i].size() - max(zero,one);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r D. Two Divisors 题意 给一数n，判断n的所有因子中（1除外）是否存在 d1 d2使得 d1+d2与n互质\n题解 如果存在，则这组数可以是 d1*d2 = n\nd1 与d2一定互质\n让n一直除以最小因子，除到最后不为1，则剩下的数与之前的除数互质，满足条件\n最小因子可以筛法预处理\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rint n;\rint d1[500005];\rint d2[500005];\rint a[500005];\rint f[10000005];\rvoid preprocess(){\rfor(int i=2;i\u0026lt;10000005;i++)\rif(f[i] == 0)\r{\rf[i] = i;\rfor(int j=i+i;j\u0026lt;10000005;j+=i) f[j] = i;\r}\r}\rvoid did(int x,int ind){\rint foo = f[x];\rint bar = x;\rwhile(x%foo==0) x /= foo;\rif(x==1) d1[ind]=-1,d2[ind]=-1;\relse d1[ind]=x,d2[ind]=bar/x;\r}\rint main(){\rpreprocess();\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rfor(int i=0;i\u0026lt;n;i++) did(a[i] , i);\rfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;d1[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\rfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;d2[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl; return 0;\r}\r E. Two Arrays 题意 给两个数组A B（B为递增），B的大小为m，将A分成m个区间，使得每个区间的最小值与B的每个数相同（按顺序对应），求方案数\n题解 隔板法，双指针锁定每个数之间隔板可以移动的范围，最后乘法原理\n对于可移动范围，因为B是递增的，从右往左遍历\n就是A B数组元素比大小，然后右边的指针贪心地选择可满足数中最右边的数，左指针贪心地选择可满足数中最左边的数\n（即右指针左移过程中，碰到可满足数就停下来，左指针要一直移动直到不满足，这样得到最大的区间）\n注意特判！！\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll ans = 1;\rint a[200005];\rint b[200005];\rint n,m;\rint l[200005];\rint r[200005];\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rfor(int i=0;i\u0026lt;m;i++) cin\u0026gt;\u0026gt;b[i];\rfor(int i=0;i\u0026lt;m;i++) l[i] = r[i] = -1;\rint ind = m-1;\rfor(int i=n-1;i\u0026gt;=0;i--){\rwhile(ind\u0026gt;=0 and b[ind] \u0026gt; a[i]) ind--;\rif(ind\u0026lt;0) {\rcout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\rexit(0);\r}\rl[ind] = i;\rif(a[i] == b[ind] and r[ind]==-1){ //greedy\rr[ind] = i;\r}\r}\rif(l[0]==-1 or r[0]==-1) {\rcout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\rexit(0);\r}\rfor(int i=1;i\u0026lt;m;i++){\rif(l[i]==-1 or r[i]==-1) {\rcout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\rexit(0);\t}\rans *= (ll) (r[i] - l[i] + 1);\rans %= mod;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F. Jog Around The Graph 题意 不懂\n题解 不会\nG. Construct the String 题意 不懂\n题解 不会\n","id":7,"section":"posts","summary":"A. Shovels and Swords 题意 两个钻石和一个棍子可以造出A，两个棍子和一个钻石可以造出B 每个A或B都可以卖出一块钱，求 x个棍子和y个钻石最多可以卖多少钱 题解 钻","tags":["cpp","greedy","bfs","number_theory"],"title":"Educational Codeforces Round 89 (Rated for Div. 2) A~E","uri":"https://dyhgo.github.io/2020/06/educational-codeforces-round-89-rated-for-div.-2-a~e/","year":"2020"},{"content":"Python web的框架有Django Flask Tornado\nFlask 是一个使用 Python 编写的轻量级 Web 应用程序框架，由werkzeug服务器和jinja2模板引擎组成\nRESTful是一个与资源（resource）有关的架构理念\nREST全称Representational State Transfer，详细信息参考下面的资料\n功能说明 接下来用Flask-RESTful扩展实现一个非常简单的实例，没有用到数据库，没有用到前端页面（模板），没有表单验证，没有复杂的业务逻辑\n只用字典存储数据，实现crud（后期将增加数据库）\n实现原理 安装 pip install flask-restful\nFlask-RESTful最基本的套路\n实例化app api\n实例化解析器，将待验证的参数加进解析器中\n根据路由编写对应的类，在类下面编写需要的函数\n将类和对应的路由集成到api中\n代码如下\nfrom flask import Flask\rfrom flask_restful import reqparse , abort , Api , Resource\r#实例化\rapp = Flask(__name__)\rapi = Api(app)\r#创造初始数据\rPERSONS = {\r'p1' : {'name' : 'qaz' , 'num' : '15'} ,\r'p2' : {'name' : 'wsx' , 'num' : '16'} ,\r'p3' : {'name' : 'edc' , 'num' : '17'} ,\r}\rdef not_exist(ps_id):\rif ps_id not in PERSONS:\rabort(404 , message = 'person {} not exist'.format(ps_id))\r#实例化解析器\r#增加验证参数\rparser = reqparse.RequestParser()\rparser.add_argument('name' , type=str , required=True , help='it is a string') #把它设为必填项\rparser.add_argument('num' , type=int , required=True , help='it is a number') #把它设为必填项\r#对单个人的操作\rclass Person(Resource):\rdef get(self , ps_id):\rnot_exist(ps_id)\rreturn PERSONS[ps_id]\rdef delete(self , ps_id):\rnot_exist(ps_id)\rdel PERSONS[ps_id]\rreturn '' , 204\rdef put(self , ps_id):\rnot_exist(ps_id)\rargs = parser.parse_args() #开始数据验证\rinfo = {'name' : args['name'] , 'num' : args['num']}\rPERSONS[ps_id] = info #更新\rreturn info , 201\r#对所有人的操作\rclass PersonList(Resource):\rdef get(self):\rreturn PERSONS\rdef post(self):\rglobal ps_id\rargs = parser.parse_args()\r#暴力求缺失id\rlis = []\r#求每个键，然后过滤出数字，加进列表中，遍历获得空位置\rfor i in PERSONS.keys():\rtmp_filter = filter(str.isdigit , i)\rtmp_list = list(tmp_filter)\rtmp_str = ''.join(tmp_list)\rtmp_int = int(tmp_str)\rlis.append(tmp_int)\rlis.sort()\rflag = False\rfor i,j in range(len(lis)),lis:\rif i+1 != j:\rps_id = i+1\rflag = True\rbreak\rif(not flag): ps_id = len(lis) + 1\rps_id = 'p%d' % (ps_id)\rPERSONS[ps_id] = {'name':args['name'] , 'num':args['num']}\rreturn PERSONS[ps_id] , 201\r#增加对应的路由\rapi.add_resource(Person , '/persons/\u0026lt;string:ps_id\u0026gt;')\rapi.add_resource(PersonList , '/persons')\rif __name__ == '__main__':\rapp.run()\r 测试 查询所有信息 根据ps_id查询单个人的信息 根据ps_id删除某个人的信息 再查看所有人的信息\n增加某个人的信息 查看所有人的信息\n由于之前删除了2号，所以它占据了2号的位置\n改变某个人的信息 现在p3 的name是edc num是17\n改成name是uuu，num是27\n查看所有人的信息以验证\n参考资料（部分） ","id":8,"section":"posts","summary":"Python web的框架有Django Flask Tornado Flask 是一个使用 Python 编写的轻量级 Web 应用程序框架，由werkzeug服务器和jinja2模板引擎组成 RESTful是","tags":["python"],"title":"Flask-RESTful简单实例","uri":"https://dyhgo.github.io/2020/06/flask-restful%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B/","year":"2020"},{"content":"由于事情太多，拖了这么久\nA - Multiplication 1 题意 输入两个数，求积\n题解 n,m = map(int,input().split())\rprint(n*m)\r B - Multiplication 2 题意 输入很多大数，求积是否超过1e18\n题解 用 __int128 ， 样例有个情况是前面超过1e18但后面有0\n所以遍历一遍数组判断是否有0\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing INT = __int128;\rll a[100005];\rint main(){\rll n;\rcin\u0026gt;\u0026gt;n;\rINT ans = 1;\rbool flag = true;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\rif(!a[i]) flag = false;\r}\rif(!flag) {\rcout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\rexit(0);\r}\rfor(ll i=0;i\u0026lt;n;i++){\rll x = a[i];\rans *= (INT) x;\rif(ans \u0026gt; (INT) 1e18) {\rcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\rexit(0);\r}\r}\rcout\u0026lt;\u0026lt;(ll)ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Multiplication 3 题意 输入两个数，求积 。一个数上限 1e15 ，一个数为小于10的正两位小数\n题解 因为精度问题，先 *100 再 /100\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rll a,b,c;\rscanf(\u0026quot;%lld %lld.%lld\u0026quot;,\u0026amp;a,\u0026amp;b,\u0026amp;c);\rll ans = a*(b*100+c) ;\rans /= 100LL;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Div Game 题意 看题目\n题解 根据唯一分解定理分解，得到质因子和每种质因子的个数\n要求次数最多，对于每种质因子，取1次方，2次方，3次方。。。\n有个WA点，当无法整除时，ans+1（本身的质数）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rmap\u0026lt;ll,ll\u0026gt; mp;\rbool isprime(ll n){\rif(n==1) return false;\rfor(ll i=2;i*i\u0026lt;=n;i++){\rif(n%i==0){\rreturn false;\r}\r}\rreturn true;\r}\rint main(){\rll n;\rcin\u0026gt;\u0026gt;n;\rll nn = n;\rfor(ll i=2;i*i\u0026lt;=nn;i++){\rwhile(n%i==0){\rn/=i;\rmp[i]++;\r}\r}\r//cout\u0026lt;\u0026lt;mp[2]\u0026lt;\u0026lt;mp[5];\rll ans = 0;\rfor(auto i:mp){\r//cout\u0026lt;\u0026lt;i.first\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;i.second\u0026lt;\u0026lt;endl;\rll tmp = i.second;\rll cnt = 0;\rll ct = 1;\rwhile(cnt\u0026lt;=tmp){\rcnt += ct++; }\rct -= 2;\rans += ct;\r}\rif(isprime(n)) ans++; //wa点 做不下去时要判断是不是质数 如果是质数那么z可以等于这个数 即答案+1 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Count Median 题意 给 n 个区间，可以在每个区间中选一个数，这样就有 n 个数，对这n个数求中位数，问所有方案中，中位数有几种\n题解 数学题\n求最小的可能中位数和最大的可能中位数，在此之间的所有数都能取到\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll a[200005],b[200005];\rint main(){\rll n;\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n;i++){\rscanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;a[i],\u0026amp;b[i]);\r}\rsort(a,a+n);\rsort(b,b+n);\rll low ,hi;\rif(n\u0026amp;1){\rlow = a[(n-1)/2];\rhi = b[(n-1)/2];\r}else{\rlow = a[(n-2)/2] + a[(n-2)/2+1] ;\rhi = b[(n-2)/2] + b[(n-2)/2+1];\r}\rcout\u0026lt;\u0026lt;hi-low+1\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Knapsack for All Subsets 题意 给一堆数，和一个数s\n对于这堆数形成的集合，对于它的每个子集\n如果该子集中有一个子集的数和为s，计数器加1\n求计数器的值\n题解 计数dp题\n可以考虑其中一种方案是 i 个数加起来等于 s\n那么容纳它的所有集合都满足条件\n所以计数器加  i*2^(n-i)\n要求一堆数中，哪些数加起来能等于s就类似于背包问题\n所以考虑dp\ndp[i][j] 表示前 i 个数和为 j 的答案\n对于当前数，可以选择，也可以不选\n转移方程\ndp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]]\n根据上面的结论加上dp表示的是答案，所以每多选一个数，就会在前一个的基础上 /2\n所以真正的转移方程为\ndp[i][j] = dp[i-1][j] + ( dp[i-1][j-a[i]] ) / 2\n这样初始条件就是\ndp[0][0] = 2^n\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll dp[3005][3005];\rll n,s;\rll a[3005];\rconst ll mod = 998244353;\rll qpow(ll a, ll b, ll m){\rif(b == 0)\rreturn 1;\relse if(b % 2 == 1)\rreturn a * qpow(a, b - 1, m) % m;\relse{\rll num = qpow(a, b/2, m) % m;\treturn num * num % m;\r}\r}\rconst ll inv2 = (mod+1) / 2;\rint main(){\rcin\u0026gt;\u0026gt;n;\rcin\u0026gt;\u0026gt;s;\rfor(ll i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i];\rdp[0][0] = qpow(2,n,mod);\rfor(int i=1;i\u0026lt;=n;i++){\rfor(int j=0;j\u0026lt;=s;j++){\r(dp[i][j] += dp[i-1][j]) %= mod;\rif(j\u0026gt;=a[i]) {\r(dp[i][j] += dp[i-1][j-a[i]] * inv2) %= mod;\r}\r}\r}\rcout\u0026lt;\u0026lt;dp[n][s]%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":9,"section":"posts","summary":"由于事情太多，拖了这么久 A - Multiplication 1 题意 输入两个数，求积 题解 n,m = map(int,input().split()) print(n*m) B - Multiplication 2 题意 输入很多大数，求积是否超过1e18 题解 用 __int128 ， 样例有个情况是前面超","tags":["cpp","dp","counting","number_theory"],"title":"abc169","uri":"https://dyhgo.github.io/2020/06/abc169/","year":"2020"},{"content":"堆 贪心 题目\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n;\rstruct p{\rll v,s;\r}ps[100005];\rbool cmp(p a,p b){return a.s\u0026gt;b.s;}\rpriority_queue\u0026lt;ll , vector\u0026lt;ll\u0026gt; , greater\u0026lt;ll\u0026gt; \u0026gt; pq;\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;ps[i].v\u0026gt;\u0026gt;ps[i].s;\rsort(ps,ps+n,cmp);\rll temp=0,ans=0;\rfor(ll i=0;i\u0026lt;n;i++){\rtemp+=ps[i].v;\rpq.push(ps[i].v);\rwhile(pq.size()\u0026gt;ps[i].s){\rtemp-=pq.top();\rpq.pop();\r}\rans=max(ans,temp);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n区间dp 题目\n不会做，看了别人的题解写的\n考虑到数据大小\n区间dp\ndp[i][j][k][l] 表示在s1中取i到j区间，在s2中取k到l区间是否能组成回文串\n这样它有四种状态转移（分别考虑边界）\n对于每一种状态，只要有一种满足就行，用或运算实现\n注意一些边界条件，长度从0开始、特判\n先枚举长度，对于每一种长度，枚举区间\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rchar s1[52];\rchar s2[52];\rint dp[52][52][52][52];\rint ans=0;\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rans=0;\rmemset(dp,0,sizeof(dp)); //没有重置又WA了 scanf(\u0026quot;%s\u0026quot;,s1+1);\rscanf(\u0026quot;%s\u0026quot;,s2+1);\rint len1=strlen(s1+1);\rint len2=strlen(s2+1);\rfor(int i=0;i\u0026lt;=len1;i++)\rfor(int j=0;j\u0026lt;=len2;j++)\rfor(int l1=1,r1=i+l1-1;r1\u0026lt;=len1 ;l1++,r1++)\rfor(int l2=1,r2=j+l2-1;r2\u0026lt;=len2 ;l2++,r2++){\rif(i+j\u0026lt;=1) dp[l1][r1][l2][r2]=1;\relse{\rif(s1[l1]==s1[r1] and r1\u0026gt;0) dp[l1][r1][l2][r2] |= dp[l1+1][r1-1][l2][r2]; if(s1[l1]==s2[r2] and r2\u0026gt;0) dp[l1][r1][l2][r2] |= dp[l1+1][r1][l2][r2-1];\rif(s2[l2]==s1[r1] and r1\u0026gt;0) dp[l1][r1][l2][r2] |= dp[l1][r1-1][l2+1][r2];\rif(s2[l2]==s2[r2] and r2\u0026gt;0) dp[l1][r1][l2][r2] |= dp[l1][r1][l2+1][r2-1];\r} if(dp[l1][r1][l2][r2]) ans=max(ans,r2-l2+r1-l1+2);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n前缀和 区间dp 题目\n暴力时间复杂度 O(n^2)\ndp[i] 表示右区间的右边界为i时的最大值\nmaxv[i] 表示前 i+1个数区间长度为k的最大值（单区间）\n那么 dp[i]=右区间的值+maxv[i]\n求 maxv[i] 直接用前缀和预处理，时间复杂度 O(n)\n依次遍历数组求答案\n据说用st表也可以做，但我不会\n思考问题的变形\n一：不限制长度——在一个数列里找两个不相交区间使得他们权值和最大\n二：区间数目变多——找 m个长度为 k 的不相交区间使得他们的权值和最大 (1≤n≤5000)\n三：区间数目变多且不限制长度——找 m 个不相交长度不限的区间使得他们权值和最大(1≤n≤5000)\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll t;\rll a[200005];\rll n,k;\rll maxv[200005];\rll sum[200005];\rll ans=0;\rll asn1=0;\rll ans2=0;\rll dp[200005];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\r//reset TODO ans=-1e15; //开1e9WA了一发 无语\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\rif(i\u0026gt;0) sum[i]=sum[i-1]+a[i]; else sum[i]=a[i];\r}\r//preprocess\rmaxv[k-1]=sum[k-1];\rfor(ll i=k;i\u0026lt;n-k;i++){\rmaxv[i]=max(maxv[i-1],sum[i]-sum[i-k]);\r}\rll temp=0;\rfor(ll i=k;i\u0026lt;2*k;i++) temp+=a[i];\rfor(ll i=2*k-1;i\u0026lt;n;i++){\rdp[i]=temp+maxv[i-k];\rans=max(ans,dp[i]);\rif(i\u0026lt;n-1){\rtemp+=a[i+1];\rtemp-=a[i+1-k];\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n位运算 题目\n模拟位运算\n暴力超时\n可优化为\n(a1+a2+a3...)*(a1+a2+a3...)\na为每一位的1\n这样只需要计算每一位1的数量\n对于每一位，数量平方乘上二次幂系数\n最后求和\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n;\rll a[100005];\rll bin[100];\rint main(){\rcin\u0026gt;\u0026gt;n;\rll temp;\rfor(ll i=0;i\u0026lt;n;i++){\rll p=0;\rcin\u0026gt;\u0026gt;temp;\rwhile(temp!=0){\rif(temp%2==1) bin[p]++;\rp++;\rtemp/=2;\r}\r}\rll ans=0;\rfor(ll i=0;i\u0026lt;100;i++){\rans+=(bin[i]*bin[i])*(1\u0026lt;\u0026lt;i);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n双端队列 （滑动窗口求最值） 题目\n经典的滑动窗口求最大最小值问题\n经典的做法就是利用双端队列\n可以参考此处的讲解\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,k;\rint num[1000005];\rdeque\u0026lt;int\u0026gt; dq1;\rdeque\u0026lt;int\u0026gt; dq2;\rvector\u0026lt;int\u0026gt; ans1;\rvector\u0026lt;int\u0026gt; ans2;\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;num[i];\rfor(int i=0;i\u0026lt;n;i++){\rif(!dq2.empty() and dq2.front()\u0026lt;=i-k){\rdq2.pop_front();\r}\rwhile(!dq2.empty() and num[dq2.back()]\u0026lt;=num[i]){\rdq2.pop_back();\r}\rdq2.push_back(i);\rif(i\u0026gt;=k-1){\rans2.push_back(num[dq2.front()]);\r}\r//-----------------华丽的分割线--------------------------- if(!dq1.empty() and dq1.front()\u0026lt;=i-k){\rdq1.pop_front();\r}\rwhile(!dq1.empty() and num[dq1.back()]\u0026gt;=num[i]){\rdq1.pop_back();\r}\rdq1.push_back(i);\rif(i\u0026gt;=k-1){\rans1.push_back(num[dq1.front()]);\r}\r}\rfor(int i:ans1) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\rfor(int i:ans2) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n树形dp 题目\ndp[i] 表示以i为节点的最小费用\n则 dp[i]+=min(dp[ch],w) w表示当前i与ch的费用，即不断更新成最小值然后加上去\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n,m,s;\rvector\u0026lt;pair\u0026lt;ll,ll\u0026gt; \u0026gt; G[100005];\rll dp[100005];\rll deg[100005];\rconst ll inf=0x3f3f3f3f3f3f;\rvoid dfs(ll s,ll p){\rfor(auto i:G[s]){\rll x=i.first;\rll y=i.second;\rif(x!=p){\rdfs(x,s); dp[s]+=min(dp[x],y);\r}\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s;\rwhile(m--){\rll u,v,w;\rcin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w;\rG[u].emplace_back(v,w);\rG[v].emplace_back(u,w);\rdeg[u]++;\rdeg[v]++;\r}\rfor(ll i=1;i\u0026lt;=n;i++)\rif(deg[i]==1 and i!=s) dp[i]=inf;\rdfs(s,-1);\rcout\u0026lt;\u0026lt;dp[s]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n二分查找 题目\n和abc157-E很像\n用集合存26个字母对应的下标\n依次查找p中字符在s中的位置\n每次对集合二分查找\n有一个防止集合为空的小技巧\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rchar s[1000005];\rint n;\rchar p[1000005];\rset\u0026lt;int\u0026gt; st[27];\rint main(){\rscanf(\u0026quot;%s\u0026quot;,s+1);\rint len=strlen(s+1);\r//preprocess\rfor(int i=0;i\u0026lt;27;i++){ //防止为空 st[i].insert(len+1);\r}\rfor(int i=1;i\u0026lt;=len;i++){\rst[s[i]-'a'].insert(i);\r}\rcin\u0026gt;\u0026gt;n;\rwhile(n--){\rbool ok=true;\rscanf(\u0026quot;%s\u0026quot;,p+1);\rint lenp = strlen(p+1);\rint foo=1;\rfor(int i=1;i\u0026lt;=lenp;i++){\rauto ind=st[p[i]-'a'].lower_bound(foo);\rif(*ind==len+1){\rok=false;\rbreak;\r} else{\rfoo=(*ind)+1;\r}\r}\rputs(ok?\u0026quot;Yes\u0026quot;:\u0026quot;No\u0026quot;);\r}\rreturn 0;\r}\r ===========================================================================================================\n树形dfs 题目\n对于一个节点，如果以这个节点为根的树的节点（包含自己）是奇数，则这个节点必须与父节点相连，子节点内部自己配对\n如果是偶数，则这个节点与子节点一起参与配对\n以下代码的缺点是存储数据和求解不够高效\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll t,n;\rvector\u0026lt;ll\u0026gt; G[10005];\rll cn[10005];\rll par[10005];\rmap\u0026lt;ll,ll\u0026gt; W[10005];\rvoid dfs_par(ll u,ll p){\rpar[u]=p;\rfor(auto i:G[u]){\rif(i!=p){\rdfs_par(i,u);\r}\r}\r}\rvoid dfs_cn(ll u,ll p){\rfor(auto i:G[u]){\rif(i!=p){\rdfs_cn(i,u);\rcn[u]+=cn[i];\r}\r}\rcn[u]++;\r}\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n;\rll t1,t2,w;\rfor(ll i=0;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2\u0026gt;\u0026gt;w;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\rW[t1].insert(make_pair(t2,w));\rW[t2].insert(make_pair(t1,w));\r} dfs_par(1,0);\rdfs_cn(1,0);\rll ans=0;\rfor(ll i=2;i\u0026lt;=n;i++){\rif(cn[i]\u0026amp;1){\rans+=W[i][par[i]];\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r//reset TODO\rmemset(cn,0,sizeof(cn));\rfor(ll i=0;i\u0026lt;=n;i++){\rG[i].clear();\rW[i].clear();\r}\r}\rreturn 0;\r}\r ===========================================================================================================\n树形dp 贪心 dfs 题目\n主要是树上dp\n从子节点向根一直贪心地染色\n这样就会出现一个问题，最优解需要染的顶点已经被染过了\n所以要不断地更新两个值\ndp[i] 现在在i，往根的方向还能染多少个\nk[i] 每个点向根方向还能染多少个\n那么 dp[i]=max(dp[i],dp[ch]-1)\n如果最后 dp[i]==0 那么新的染色点开启 ans++\n否则处理完一个点后k要更新\nk[par]=max(k[par],k[i]-1)\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rvector\u0026lt;int\u0026gt; c[100005];\rint ans;\rint dp[100005];\rint k[100005];\rint n;\rvoid dfs(int u,int par){\rfor(auto i:c[u]){\rdfs(i,u);\rdp[u]=max(dp[u],dp[i]-1);\r}\rif(dp[u]==0){\r//can't reach next\rans++;\rdp[u]=k[u];\r}\relse{\r//updata k\rk[par]=max(k[par],k[u]-1);\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\rint tmp;\rfor(int i=2;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;tmp;\rc[tmp].push_back(i);\r}\rfor(int i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;k[i];\r}\rdfs(1,0);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\rreturn 0;\r}\r ===========================================================================================================\n堆 （对顶堆求实时中位数） 题目\n经典的对顶堆求实时中位数问题\n用两个堆存数据\n大顶堆存小的一半\n小顶堆存大的一半\n这样中位数只在大顶堆或小顶堆的顶部\n每次存数据需要将它与顶部（中间数）比较\n确认放入哪一堆\n每次放数后，需要平衡堆的大小，使大小相差不超过1\n最后取堆大的顶部即可\nplus：几个很坑的点，容易PE，要用快读才能过（还以为算法有问题。。。）\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;queue\u0026gt;\rusing namespace std;\rint p,n,m;\rint t;\rint main(){\r//ios::sync_with_stdio(0);\rcin\u0026gt;\u0026gt;p;\rwhile(p--){\rpriority_queue\u0026lt;int\u0026gt; q1; //大顶堆 priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; q2; //小顶堆 scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m);\rif(n!=1) cout\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;(m+1)/2\u0026lt;\u0026lt;endl;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rq1.push(t);\rif(m==1) cout\u0026lt;\u0026lt;t; else cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rfor(int i=2;i\u0026lt;=m;i++){\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rif(t\u0026gt;q1.top()) q2.push(t); //比大顶堆大，放入小顶堆\relse q1.push(t);\rif(q1.size()\u0026gt;q2.size()+1){ //平衡两个堆的大小\rq2.push(q1.top());\rq1.pop();\r}\rif(q2.size()\u0026gt;q1.size()+1){\rq1.push(q2.top());\rq2.pop();\r}\rif(i\u0026amp;1){\tint x;\rif(q1.size()\u0026gt;q2.size()) x=q1.top(); //中位数在堆大的顶部\relse x=q2.top();\rif( ((i+1)/2)%10==0 and m-i\u0026gt;1){\rcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl;\r}\relse if(m-i\u0026gt;1){\rcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r}\relse cout\u0026lt;\u0026lt;x;\r}\r}\r}\rreturn 0;\r}\r ===========================================================================================================\n在线区间预处理 前缀 题目\n暴力枚举右区间的左右边界，这样时间复杂度就是 O(n^2)\n前缀和预处理\n对于每个右区间，O(1) 查询这个区间的异或值，然后找前面有几个区间的异或值等于这个区间\n这时候只要计算以右区间左边界-1为右边界的区间中每一个的异或，然后与前面计算好的累加即可\n最后直接累加到个数上\n（注意区间的边界下标）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,a[1005],b[1000005]; //b要开大一点 否则数组越界\rlong long sum; //sum要用long long\rint main(){\rcin\u0026gt;\u0026gt;n;\rint tmp;\ra[0]=0;\rfor(int i=1;i\u0026lt;=n;i++) {\rcin\u0026gt;\u0026gt;tmp;\ra[i]=a[i-1]^tmp;\r}\rfor(int i=0;i\u0026lt;n;i++){\rfor(int j=i-1;j\u0026gt;=0;j--){\rb[a[i]^a[j]]++;\r}\rfor(int j=i+1;j\u0026lt;=n;j++){\rsum+=b[a[j]^a[i]];\r}\r}\rcout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n图论 dfs 题目\n奇数层的点到奇数层的点就是偶数路径\n偶数同理\n注意同一层也可达\n还有long long 的转化\n还可以树形dp\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rvector\u0026lt;int\u0026gt; G[100005];\rint dep[100005];\rint ln[100005];\rlong long sum=0;\r//int deg[100005];\rvoid dfs(int u,int v){\rfor(auto i:G[u]){\rif(i!=v){\rdep[i]=dep[u]+1;\rdfs(i,u);\r}\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\rint t1,t2;\rfor(int i=0;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdep[1]=0;\rdfs(1,0);\rfor(int i=1;i\u0026lt;=n;i++){\rln[dep[i]]++;\r}\rint maxd=*max_element(dep+1,dep+n+1);\rfor(int i=0;i\u0026lt;maxd+1;i++){\rfor(int j=i;j\u0026lt;maxd+1;j+=2){\rif(j==i){\rsum+=(long long)ln[i]*(ln[i]-1)/2;\r}\relse{\rsum+=(long long)ln[i]*ln[j];\r}\r}\r}\rcout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl;\r//cout\u0026lt;\u0026lt;maxd\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n排列组合 题目\n对于一个长度为n的二进制串\n随便选两个数前面放1后面放0\n其他随便放\n总共有 C(n,2)*2^(n-2) 种\n注意对 n 取模\n还有一个卡我的点是“特判”！！！\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = unsigned long long;\rll n;\rconst ll mod = 1e9+7;\rll qpow(ll x,ll t){\rll res=1;\rwhile(t\u0026gt;0){\rif(t\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rt\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\rif(n==1) cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\relse if(n==2) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl;\relse{\rcout\u0026lt;\u0026lt;qpow(2,n-3)%mod*(n%mod)%mod*((n-1)%mod)%mod\u0026lt;\u0026lt;endl; //记得给n取模\r}\rreturn 0;\r}\r ===========================================================================================================\n二分法 尺取 题目\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll t;\rll n,a[100005];\rll m,k;\rll k_th(ll x){\rll num=0;\rll sum=0;\rll l=0,r=0;\rif(a[0]\u0026gt;x) num++;\rwhile(r\u0026lt;n and l\u0026lt;n){\rif(num\u0026lt;k){\rr++;\rif( r\u0026lt;n and a[r]\u0026gt;x) num++;\r}\relse{\rsum += n-r; //不小心+1 就错了\rl++;\rif(l\u0026lt;n and a[l-1]\u0026gt;x ) num--; }\r}\rreturn sum;\r}\rbool check(ll x){\rreturn k_th(x) \u0026gt; m-1 ? true : false;\r}\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m;\rfor(ll i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rll l = 1,r=1e10,mid;\rwhile(l\u0026lt;r){\rmid = (l+r)\u0026gt;\u0026gt;1;\rif(check(mid)) l = mid+1;\relse r=mid;\r}\rcout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n计数dp 题目\n不会做，参考了别人的代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 1e9+7;\rll a[100005];\rll dp[100005][12];\rll ls[100005];\rll n,m,k;\rint main(){\rwhile(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k){ //TODO reset\rmemset(dp,0,sizeof(dp));\rmemset(ls,-1,sizeof(ls));\rfor(ll i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\r// TODO init 极端情况\rfor(ll i=0;i\u0026lt;=n;i++) dp[i][0] = 1;\rfor(ll i=0;i\u0026lt;=11;i++) dp[i][i] = 1;\rfor(ll i=1;i\u0026lt;=n;i++){\rfor(ll j=1;j\u0026lt;=min(i-1 , m);j++){\rdp[i][j] = (dp[i-1][j] + dp[i-1][j-1])%mod;\rll rm = ls[a[i]] - i +j;\rll part = dp[ls[a[i]] - 1][rm];\rif(ls[a[i]]!=-1 and rm\u0026gt;=0) dp[i][j] = (dp[i][j] - part + mod)%mod; //这里也要模\r}\r//update ls[a[i]] = i;\r}\rcout\u0026lt;\u0026lt;dp[n][m]%mod\u0026lt;\u0026lt;endl;\r} return 0;\r}\r ===========================================================================================================\n贪心 堆 题目\n贪心\n按截至时间从小到大排序\n如果按这个顺序选择，则有可能因为当前建筑耗费的时间比别的长，而错过最优解（即选择耗费时间短的，即使它的截至时间更久）\n所以我们可以选择耗费时间更短的（相当于有一次反悔的机会），这样ans都加1，但是有更多的选择空间\n用一个大顶堆维护当前选中的建筑的耗费时间\n遍历所有建筑，如果能在截至时间内完成，就入堆\n否则与堆顶比较（耗费时间最长的）\n如果堆顶大，则用当前建筑替换堆顶的建筑，使耗费时间尽可能小\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vt;\rint main(){\rint n;\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rint x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rvt.emplace_back(x,y);\r}\rsort(vt.begin(),vt.end(),[](pair\u0026lt;int,int\u0026gt; pii1,pair\u0026lt;int,int\u0026gt; pii2){return pii1.second\u0026lt;pii2.second;});\rpriority_queue\u0026lt;int\u0026gt; pq;\rint sum = 0;\rfor(auto i:vt){\rif(sum+i.first\u0026lt;=i.second){\rsum+=i.first;\rpq.push(i.first);\r}else if(pq.top()\u0026gt;i.first){\rsum-=pq.top();\rpq.pop();\rsum+=i.first;\rpq.push(i.first);\r}\r}\rcout\u0026lt;\u0026lt;pq.size()\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n完全背包问题 题目\n目标货币系统是子集，所以对于当前数，判断前面的数能否组合到这个数\n这就变成完全背包问题，a[i] 表示体积，背包的最大体积是25000，价值就是是否可达到 (dp[i]=0 or 1)\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint a[25005];\rint dp[25005];\rint ans;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rmemset(dp,0,sizeof(dp));\rans=0;\rint n;\rcin\u0026gt;\u0026gt;n;\rdp[0]=1;\rfor(int i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\rsort(a+1,a+1+n);\rfor(int i=1;i\u0026lt;=n;i++){ if(!dp[a[i]]) ans++;\rfor(int j=a[i];j\u0026lt;=25000;j++){\rdp[j] = dp[j] |= dp[j-a[i]];\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n贪心 题目\n贪心，只要定排序规则就行\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vt;\rint main(){\rint n;\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rint x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rvt.emplace_back(x,y);\r}\rsort(vt.begin(),vt.end(),[](pair\u0026lt;int,int\u0026gt; pii1,pair\u0026lt;int,int\u0026gt; pii2){return pii1.first*pii2.second \u0026lt; pii1.second*pii2.first;});\rlong long ans = 0;\rlong long tm = 0;\rfor(auto i:vt){\rans += i.second*tm;\rtm += 2LL*i.first;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\ndp 思维 题目\ndp\n第一次做真的很难想到\n首先题目这么设计肯定是要把式子转换成物理意义\n那就是“有两个装置，同时取到相同的排列的方案数，再求和”\n设 dp[k][i][j] 表示两个装置都取出k个，第一个装置的上管道取出i个，第二个装置的上管道取出j个\n那么第一个装置的下管道取出k-i个，第二个装置的下管道取出 k-j 个\ndp 表示进行到此时的 ans\n所以 dp 在传导的过程中用 +=\n最后的结果就是 dp[n+m][n][n]\ndp 的初始条件是 dp[0][0][0] = 1\ndp 的转移方程考虑四种情况\n(a[i]==a[j]) dp[k][i][j] += dp[k-1][i-1][j-1] 即两个装置的上管道 各加一个球结果相同\n(a[i]==b[k-j]) dp[k][i][j] += dp[k-1][i-1][j] 即第一个装置的上下两个管道各加一个球结果相同\n(b[k-i]==a[j]) dp[k][i][j] += dp[k-1][i][j-1] 同上\n(b[k-i]==b[k-j]) dp[k][i][j] += dp[k-1][i][j] 同上\n由于数据规模，需要用01滚动数组\n注意 assert\n注意continue 否则超时\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rconst int mod = 1024523;\rint n,m;\rint dp[2][505][505];\rchar u[505];\rchar d[505];\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rcin\u0026gt;\u0026gt;(u+1)\u0026gt;\u0026gt;(d+1);\rdp[0][0][0] = 1;\rfor(int k=1;k\u0026lt;=n+m;k++){\rmemset(dp[k\u0026amp;1],0,sizeof(dp[k\u0026amp;1]));\rfor(int i=0;i\u0026lt;=n;i++){\rif(k-i\u0026lt;0 or k-i\u0026gt;m) continue; //不加这个超时 for(int j=0;j\u0026lt;=n;j++){\rif(k-j\u0026lt;0 or k-j\u0026gt;m) continue; //不加这个超时 if(u[i]==u[j] and i and j) {\rdp[k\u0026amp;1][i][j] += dp[(k-1)\u0026amp;1][i-1][j-1];\rdp[k\u0026amp;1][i][j] %= mod;\r}\rif(u[i]==d[k-j] and i and k-j and k-j\u0026lt;=m){\rdp[k\u0026amp;1][i][j] += dp[(k-1)\u0026amp;1][i-1][j];\rdp[k\u0026amp;1][i][j] %= mod;\r}\rif(u[j]==d[k-i] and j and k-i and k-i\u0026lt;=m){\rdp[k\u0026amp;1][i][j] += dp[(k-1)\u0026amp;1][i][j-1];\rdp[k\u0026amp;1][i][j] %= mod;\r}\rif(d[k-i]==d[k-j] and k-i and k-j and k-i\u0026lt;=m and k-j\u0026lt;=m){\rdp[k\u0026amp;1][i][j] += dp[(k-1)\u0026amp;1][i][j];\rdp[k\u0026amp;1][i][j] %= mod;\r}\r}\r}\r}\rcout\u0026lt;\u0026lt;dp[(n+m)\u0026amp;1][n][n]%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n差分 规律 题目\n暴力差分\n最重要的是所有的点在 log(n) 时间内都会变成 n\n此时停机就不会超时\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,k;\rint dat[200005];\rint dif[200005];\rbool check(){\rfor(int i=1;i\u0026lt;=n;i++){\rif(dat[i]\u0026lt;n){\rreturn false;\r}\r}\rreturn true;\r}\rvoid did(int x){\rint L = max(1,x-dat[x]);\rint R = min(n , x+dat[x]);\rdif[L]++;\rdif[R+1]--;\r}\rvoid update(){\rfor(int i=1;i\u0026lt;=n;i++){\rdat[i] = dat[i-1] + dif[i];\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;dat[i];\rwhile(1 and k\u0026gt;0){\rfor(int i=1;i\u0026lt;=n;i++) did(i);\rk--;\rif(check()) break;\rupdate();\rmemset(dif,0,sizeof(dif));\r}\rif(k\u0026gt;0) {\rfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r}\relse for(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;dat[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rcout\u0026lt;\u0026lt;'\\n';\rreturn 0;\r}\r ===========================================================================================================\n分治（01背包问题 + 枚举） 题目\n第一次做分治，太妙了\n暴力超时\n如果在树上用dp预处理，内存超限\n解决方法就是分治\n完全二叉树有18层，前9层dp预处理所有的点\n后9层枚举，然后将两个结果相加。这样将时间复杂度也分开了\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rvector\u0026lt;int\u0026gt; vt;\rint n,q;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; info((1\u0026lt;\u0026lt;18) + 3);\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; res;\r#define fi first\r#define se second\rconst int MAX = 100001;\rint dp[515][MAX];\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rint v,w;\rcin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;w;\rinfo[i] = make_pair(v,w);\r}\r//preprocess\rconst int MAX = 100001;\rint lim = min(512,n);\rfor(int j=0;j\u0026lt;MAX;j++){\rdp[0][j] = (j\u0026gt;=info[0].se ? info[0].fi : 0);\r}\rfor(int i=1;i\u0026lt;lim;i++){\rint p = (i-1)/2;\rfor(int j=0;j\u0026lt;MAX;j++){\rif(j\u0026lt;info[i].se){\rdp[i][j] = dp[p][j];\r}else{\rdp[i][j] = max(dp[p][j] , dp[p][j - info[i].se] + info[i].fi);\r}\r}\r}\rcin\u0026gt;\u0026gt;q;\rwhile(q--){\rint V,L;\rcin\u0026gt;\u0026gt;V\u0026gt;\u0026gt;L;\rV--;\rvector\u0026lt;int\u0026gt; rem;\rwhile(V\u0026gt;=lim){\rrem.push_back(V);\rV = (V-1)/2;\r}\rint ans = 0;\rint sz = rem.size();\rfor(int i=0;i\u0026lt;(1\u0026lt;\u0026lt;sz);i++){\rint sv = 0;\rint sw = 0;\rfor(int j=0;j\u0026lt;sz;j++){\rif(i\u0026gt;\u0026gt;j\u0026amp;1){\rsv += info[rem[j]].fi;\rsw += info[rem[j]].se;\r}\r}\rif(sw \u0026lt;= L){\rans = max(ans , dp[V][L-sw] + sv);\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ===========================================================================================================\n博弈 题目\n如果只有一个串，1的个数是奇数，alice必赢\n所以只要有1个串1的个数是奇数，alice就对此操作，占据先机\n接下来bob怎么操作，alice只要跟着操作就行\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint n;\rcin\u0026gt;\u0026gt;n;\rbool ok=false;\rfor(int i=0;i\u0026lt;n;i++){\rstring s;\rcin\u0026gt;\u0026gt;s;\rbitset\u0026lt;1005\u0026gt; bs(s);\rif(bs.count()\u0026amp;1) ok=true;\r}\rif(ok) puts(\u0026quot;sdzNB\u0026quot;);else puts(\u0026quot;kgNB\u0026quot;);\r}\rreturn 0;\r}\r ===========================================================================================================\n递推 构造 题目\n第一个数有两种情况0,1，根据第二例的信息不断往后递推，中途判断格子是否是0或1\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rint a[10005];\rint b[10005];\rint sol(int x){\rmemset(b,0,sizeof(b));\rb[0] = 0;\rb[1] = x;\rfor(int i=2;i\u0026lt;=n;i++){\rint tmp = a[i-1] - (b[i-1] + b[i-2]);\rif(tmp == 0 or tmp==1) {\rb[i] = tmp;\r}\relse{\rreturn 0;\r}\rif(i==n){\rif(a[n] == b[n-1] + b[n]){\rreturn 1;\r}\relse{\rreturn 0;\r}\r}\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i];\rint ans = sol(0) + sol(1);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n筛法 题目\n筛法，注意从 i * i 开始，否则会超时\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll maxn = 30000005;\rll a[maxn];\rll b[maxn];\rint main(){\rll n;\rcin\u0026gt;\u0026gt;n;\r// b[1] = 0;\r// for(ll i = 2; i \u0026lt; maxn;i++){\r// if(a[i] == 0){ // ll q = i;\r// while(q \u0026lt; maxn){\r// if(a[q] == 0){\r// a[q] = i;\r// }q += i;\r// }\r// }\r// b[i] = a[i] + b[i-1]; // }\rll ans = 0;\rfor(ll i = 2;i \u0026lt; n+1;i++){\rif(a[i] == 0){\rans += i;\rll q = i * i; //从i*i开始，否则会超时 while(q \u0026lt; n+1){\rif(a[q] == 0){\ra[q] = 1;\rans += i;\r}q += i;\r}\r}\r} cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n背包问题 dp 题目\n由于N=30所以求出所有的方案\n类似于完全背包问题\ndp[i][k] 表示选 i 个，价值达到 k 的方案数\ndp[i][k] = sum(dp[i-1][k-j])\n其中j是每张彩票的面值\n最后求 k在 3n 到 4n 之间的方案数\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll dp[35][150];\rint main(){\rint n;\rcin\u0026gt;\u0026gt;n;\rdp[0][0] = 1;\rfor(int i=1;i\u0026lt;=n;i++){\rfor(int j=1;j\u0026lt;=4;j++){\rfor(int k=j;k\u0026lt;=4*n;k++){\rdp[i][k] += dp[i-1][k-j];\r}\r}\r}\rll ans = 0;\rfor(int i=3*n;i\u0026lt;=4*n;i++){\rans += dp[n][i];\r}\r//cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rll tol = pow(4,n);\rll x = __gcd(tol, ans);\rans /= x;\rtol /= x;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026quot;/\u0026quot;\u0026lt;\u0026lt;tol\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":10,"section":"posts","summary":"堆 贪心 题目 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; ll n; struct p{ ll v,s; }ps[100005]; bool cmp(p a,p b){return a.s\u0026gt;b.s;} priority_queue\u0026lt;ll , vector\u0026lt;ll\u0026gt; , greater\u0026lt;ll\u0026gt; \u0026gt; pq; int main(){ cin\u0026gt;\u0026gt;n; for(ll i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;ps[i].v\u0026gt;\u0026gt;ps[i].s; sort(ps,ps+n,cmp); ll temp=0,ans=0; for(ll i=0;i\u0026lt;n;i++){ temp+=ps[i].v; pq.push(ps[i].v); while(pq.size()\u0026gt;ps[i].s){ temp-=pq.top(); pq.pop(); } ans=max(ans,temp); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } =========================================================================================================== 区间dp 题目 不会做，看了别","tags":["problemlist"],"title":"每日一题 (X)","uri":"https://dyhgo.github.io/2020/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-x/","year":"2020"},{"content":"可能是最简单的div3（不考dp dfs？）\nA. Minimal Square 题意 给俩相同的长方形，求面积最小的正方形使得容纳两个长方形，且长方形之间不重合\n题解 两倍宽或两倍长\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u0026lt;int,int\u0026gt;;\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint a,b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rif(a\u0026gt;b) swap(a,b);\rif(2*a\u0026lt;=b) cout\u0026lt;\u0026lt;b*b\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;4*a*a\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. Honest Coach 题意 把一堆数分成两堆，求第一堆最大值和第二堆最小值的差的最小值\n题解 排序，求相邻两数差的最小值，以此为分界\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u0026lt;int,int\u0026gt;;\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint n;\rcin\u0026gt;\u0026gt;n;\rint a[55];\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rsort(a,a+n);\rint ans = 1000000000;\rfor(int i=0;i\u0026lt;n-1;i++){\rans = min(ans,a[i+1]-a[i]);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C. Similar Pairs 题意 定义好数对 (a,b) a,b具有相同的奇偶性或者a,b差为1\n给一堆数（偶数个），问是否能被划分成若干个好数对\n题解 如果奇数的个数有偶数个就一定可以\n否则检测是否有差为1的数对\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u0026lt;int,int\u0026gt;;\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint n;\rcin\u0026gt;\u0026gt;n;\rvector\u0026lt;int\u0026gt; vt1;\rvector\u0026lt;int\u0026gt; vt2;\rfor(int i=0;i\u0026lt;n;i++){\rint x;\rcin\u0026gt;\u0026gt;x;\rif(x\u0026amp;1) vt1.push_back(x);else vt2.push_back(x);\r}\rif(vt1.size()%2==0) puts(\u0026quot;yes\u0026quot;);\relse{\rbool flag=false;\rfor(int i:vt1){\rif(find(vt2.begin(),vt2.end(),i+1)!=vt2.end() || find(vt2.begin(),vt2.end(),i-1)!=vt2.end()){\rflag=true;\rbreak;\r}\r}\rif(flag) puts(\u0026quot;yes\u0026quot;);\relse puts(\u0026quot;no\u0026quot;);\r}\r}\rreturn 0;\r}\r D. Buying Shovels 题意 第i种包里有i个铁铲，总共有k种，只能选择一种包，可以买无数个，求最小需要买几包才能获得恰好n个铁铲\n题解 k\u0026gt;=n时特判\n其他只要遍历到开方，一一检测是否能被整除，不断min\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u0026lt;int,int\u0026gt;;\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rint main(){\rll t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rll n,k;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rif(n\u0026lt;=k) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl;\relse{\rbool flag = false;\rll ans = 1e10;\rfor(ll i=2;i\u0026lt;=(ll)(sqrt(n));i++){\rif(n%i==0 and i\u0026lt;=k){\rans = min(ans , n/i);\rif(n/i\u0026lt;=k) ans = min(ans , i);\rflag=true;\r//break;\r}\r}\rif(!flag) cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r E. Polygon 题意 判断一个矩阵是否是polygon游戏的产物\n题解 对于每一个元素，如果是1就判断右边和下面是否有1\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u0026lt;int,int\u0026gt;;\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint n;\rcin\u0026gt;\u0026gt;n;\rchar mat[55][55];\rfor(int i=0;i\u0026lt;n;i++) {\rcin\u0026gt;\u0026gt;mat[i];\r}\rbool ok = true;\rfor(int i=0;i\u0026lt;n;i++)for(int j=0;j\u0026lt;n;j++){\rif(mat[i][j]=='1'){\rif(i==n-1 or j==n-1) continue;\relse{\rif(mat[i+1][j]=='1' or mat[i][j+1]=='1') continue;\relse {\rok = false;\rbreak;\r}\r}\r}\r}\rif(ok) puts(\u0026quot;yes\u0026quot;);\relse puts(\u0026quot;no\u0026quot;);\r}\rreturn 0;\r}\r F. Spy-string 题意 给一堆长度都是m的字符串，问是否存在一个长度也为m的字符串使得它对每个字符串都有“相同或不同的个数为1”\n题解 数据小，暴力枚举\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u0026lt;int,int\u0026gt;;\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rvector\u0026lt;string\u0026gt; vt;\rint n,m;\rbool ck(string q1,string q2){\rint dif = 0;\rfor(int i=0;i\u0026lt;m;i++){\rif(q1[i]!=q2[i]) dif++;\r}\rreturn dif\u0026lt;=1 ? true : false;\r}\rbool check(string ss){\rbool ok = true;\rfor(auto i : vt){\rif(!ck(ss,i)){\rok = false;\rbreak;\r}\r}\rreturn ok;\r}\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rstring s;\rcin\u0026gt;\u0026gt;s;\rvt.clear();\rfor(int i=0;i\u0026lt;n-1;i++) {\rstring s1;\rcin\u0026gt;\u0026gt;s1;\rvt.push_back(s1);\r}\rbool ok = false;\rstring s3;\rfor(int i=0;i\u0026lt;m;i++){\rfor(int j=0;j\u0026lt;26;j++){\rstring s2 = s;\rs2[i] = 'a' + j;\rif(check(s2)){\rok = true;\rs3 = s2;\rbreak;\r}\r}\r}\rif(ok) cout\u0026lt;\u0026lt;s3\u0026lt;\u0026lt;endl;\relse{\rcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r G. A/B Matrix 题意 是否存在一个n*m的矩阵使得每一行有a个1，每一列有b个1，其他都是0\n题解 第一行开头先填a个1，第二行在这个之后填1，然后回到第一个，直到填满a个\n第三行以此类推\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u0026lt;int,int\u0026gt;;\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint n,m,a,b;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rif(n*a!=m*b) puts(\u0026quot;no\u0026quot;);\relse{\rint mat[55][55] = {0};\rint one = 0;\rfor(int i=0;i\u0026lt;n;i++){\rfor(int j=0;j\u0026lt;a;j++){\rmat[i][one] = 1;\rone++;\rone%=m;\r}\r}\rputs(\u0026quot;yes\u0026quot;);\rfor(int i=0;i\u0026lt;n;i++){\rfor(int j=0;j\u0026lt;m;j++){\rcout\u0026lt;\u0026lt;mat[i][j];\r}puts(\u0026quot;\u0026quot;);\r}\r}\r}\rreturn 0;\r}\r H. Binary Median 题意 给几个长度为m的01串，求对于所有长度为m的01串形成的集合的补集中的中位数（字典序）\n题解 将01串转成十进制，最后再转回来\n由于数据规模是 2^60 所以不能枚举\n以每个给定的数为节点，求补集内比它小的数有几个\n求中位数是补集内的第几个\n假设是第 i 个，求 i 落在以节点划分的哪个区间内\n（几个WA点\n要用1LL\niota和strtol函数做进制转化时精度太低，是int\n）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing pii = pair\u0026lt;int,int\u0026gt;;\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rll tot;\rll ans;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rll n,m;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rtot = (1LL\u0026lt;\u0026lt;m); // use 1LL ll rem = tot - n;\rrem--;\rll ind = rem / 2;\rvector\u0026lt;pll\u0026gt; vt;\rvector\u0026lt;string\u0026gt; vts;\rfor(ll i=0;i\u0026lt;n;i++) {\rstring s;\rcin\u0026gt;\u0026gt;s;\rvts.push_back(s);\r}\rsort(vts.begin(),vts.end()); //sort first for(ll i = 0;i\u0026lt;vts.size();i++){\rstring st = vts[i];\rll res=0;\rfor(ll j=0;j\u0026lt;m;j++){\rres+=(st[j]=='1' ? (1LL\u0026lt;\u0026lt;(m-j-1)) : 0);\r}\rvt.emplace_back(res,res-i-1LL);\r}\r//sort(vt.begin(),vt.end());\rvt.emplace_back((1LL\u0026lt;\u0026lt;m),(1LL\u0026lt;\u0026lt;m) - n-1LL);\rfor(ll i=0;i\u0026lt;vt.size();i++){\rif(vt[i].second==ind){\rans = vt[i].first - 1;break;\r}else if(vt[i].second\u0026gt;ind){\rif(vt.size()==1 or i==0){\rans = ind;break;\r}else{\rans = vt[i-1].first + (ind - vt[i-1].second);break;\r}\r}\r}\rfor(ll i=m-1;i\u0026gt;=0;i--){\rcout\u0026lt;\u0026lt;(ans\u0026gt;\u0026gt;i\u0026amp;1);\r}puts(\u0026quot;\u0026quot;);\r}\rreturn 0;\r}\r ","id":11,"section":"posts","summary":"可能是最简单的div3（不考dp dfs？） A. Minimal Square 题意 给俩相同的长方形，求面积最小的正方形使得容纳两个长方形，且长方形之间不重合 题解 两倍宽或两","tags":["cpp","greedy","construct"],"title":"Codeforces Round #644 (Div. 3)","uri":"https://dyhgo.github.io/2020/05/codeforces-round-644-div.-3/","year":"2020"},{"content":"A - ∴ (Therefore) 题意 看题目\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rstring s;\rcin\u0026gt;\u0026gt;s;\rchar c=s[s.length()-1];\rswitch(c){\rcase '2' :case '4': case '5': case '7': case '9': cout\u0026lt;\u0026lt;\u0026quot;hon\\n\u0026quot;;\rbreak;\rcase '3':\rcout\u0026lt;\u0026lt;\u0026quot;bon\\n\u0026quot;;\rbreak;\rdefault :cout\u0026lt;\u0026lt;\u0026quot;pon\\n\u0026quot;; }\rreturn 0;\r}\r B - \u0026hellip; (Triple Dots) 题意 看题目\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint k;\rcin\u0026gt;\u0026gt;k;\rstring s;\rcin\u0026gt;\u0026gt;s;\rif(s.length()\u0026lt;=k)cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl;\relse{\rfor(int i=0;i\u0026lt;k;i++){\rcout\u0026lt;\u0026lt;s[i];\r}cout\u0026lt;\u0026lt;\u0026quot;...\u0026quot;\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C - : (Colon) 题意 给定时针和分针的长度，起始为12点，问经过h小时m分钟后，时针和分针不连接的端点的距离\n题解 用比例求夹角，然后余弦定理\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rconst double pi = acos(-1);\rusing db = double;\rdouble toRad(double x){\rreturn x/180*pi;\r}\rdb COS(db x,db y,db d){\rreturn sqrt(x*x+y*y-2*x*y*cos(d));\r}\rdb a,b,m,h;\rint main(){\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;h\u0026gt;\u0026gt;m;\rdb ma = ((int)(h*60+m)%60)*(db)6;\rdb ha = ((int)(h*60+m)%720)/(db)2;\rdb delta = fabs(ma-ha);\rdb Rdel = toRad(delta);\rdb ans = COS(a,b,Rdel);\rprintf(\u0026quot;%.10lf\\n\u0026quot;,ans);\rreturn 0;\r}\r D - .. (Double Dots) 题意 由n个点组成的边权为1的双向图，每个点一个标志，从这个点开始沿着标志所指向的点（要有边连接）一直走，就可以到达1号点，且是最短路。问对于所有的点是否都存在这样的标志，存在则输出每个标志。\n题解 bfs 求前趋\n最无脑的做法应该是单源最短路求前趋\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rconst double pi = acos(-1);\rusing db = double;\rconst int max_v = 200005;\rint n,m;\rint prevv[max_v]; struct edge\r{\rint to,cost;\redge(int to,int cost){\rthis-\u0026gt;to = to;\rthis-\u0026gt;cost = cost;\r}\r};\rtypedef pair\u0026lt;int,int\u0026gt; pii; int V;\rvector\u0026lt;edge\u0026gt; G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; fill(d,d+V,inf);\rfill(prevv,prevv+V,-1); d[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rprevv[e.to]=v; q.push(pii(d[e.to],e.to));\r}\r}\r} }\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rV=n+1;\rfor(int i=0;i\u0026lt;m;i++){\rint t1,t2;\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rG[t1].push_back(edge(t2,1));\rG[t2].push_back(edge(t1,1));\r}\rdijkstra(1);\rbool ok=true;\rfor(int i=2;i\u0026lt;=n;i++){\rif(prevv[i]==-1) {\rok=false;break;\r}\r}\rif(ok){\rputs(\u0026quot;Yes\u0026quot;);\rfor(int i=2;i\u0026lt;=n;i++){\rcout\u0026lt;\u0026lt;prevv[i]\u0026lt;\u0026lt;endl;\r}\r}else{\rputs(\u0026quot;No\u0026quot;);\r}\r//cout\u0026lt;\u0026lt;d[1]\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;d[2]\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;d[3]\u0026lt;\u0026lt;d[4];\rreturn 0;\r}\r E - ∙ (Bullet) 题意 给n个数对 (ai,bi)\n求满足下列条件的集合个数\n集合由数对组成，集合中任意两个数对满足 ai*aj + bi*bj != 0\n题解 以上的公式是内积形式，把问题转化成给n个向量，找满足任意两个向量不垂直的集合数\n由于零向量和任意向量垂直，所以它只能单独在一个集合内\n遍历数对，记录每个斜率（用map存出现的次数）\n斜率为0和斜率不存在可以特殊处理\n遍历每个斜率（出现次数为num），如果没有和它垂直的（找是否有 -1/k）\n那么这个斜率的全集就是num个相同的数\n子集有 2^num 个\n如果有和它垂直的（个数分别为num1,num2），这两种斜率就不能放在一个集合 内，所以要把它们看成一个整体\n从两个集合分开选子集，再合并，总的子集个数为 2^num1 -1+ 2^num2 -1 + 1\n减去各自的空集加上总体的空集\n然后把每个子集数乘起来（乘法原理）（包括斜率为0和不存在）\n最后再加上零向量的个数，减去1（除去空集）\n照这个方法做是错的\ndebug半天一直错6个点，看了下数据，都是大数，看了下程序，觉得自己逻辑一点也没有漏洞，模数也没有溢出\n直到看到这句话\n1E18 long double 精度不够！！所以只能存原始的数对 (ai,bi) 用gcd处理倍数关系\n由于 (-a,b) 和 (a,-b) 是一致的，所以让第一个数始终大于0\n想想 long double 确实精度不够，但那时真的没想到\n发现一个提供atcoder测试数据的网站\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long ;\rll n,x,y;\rusing ld = long double;\rmap\u0026lt;pair\u0026lt;ll,ll\u0026gt;,ll\u0026gt; mp;\rconst ll mod = 1000000007;\rll zero;\rll h;\rll v;\rll ans = 1;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rif(x==0 and y==0) zero++;\relse if(x==0) v++;\relse if(y==0) h++;\relse {\rll g = __gcd(x,y);\rx/=g;\ry/=g;\rif(x\u0026lt;0) x=-x,y=-y;\rmp[{x,y}]++;\t}\t}\rfor(auto i:mp){\rll a = i.first.first;\rll b = i.first.second;\rll c = i.second;\rif(c==0) continue;\rll cnt;\rif(-b\u0026lt;0) b=-b,a=-a;\rpair\u0026lt;ll,ll\u0026gt; pll = {-b,a};\rif(!mp.count(pll)){\rcnt = qpow(2,c); ans=(ans*cnt)%mod;\r}else{\rcnt = qpow(2,c)-1LL+qpow(2,mp[pll]);\rcnt %= mod;\rans=(ans*cnt)%mod;\rmp[pll]=0;\r}\r}\rif(h!=0 and v!=0){\rll foo = qpow(2,h)-1LL+qpow(2,v);\rfoo %= mod;\rans = (ans*foo)%mod;\r}else if(h==0 and v!=0){\rll foo = qpow(2,v);\rans = (ans*foo)%mod;\r}else if(h!=0 and v==0){\rll foo = qpow(2,h);\rans = (ans*foo)%mod;\r}\rans = (ans+zero)%mod;\rans-=1LL;\rans+=mod;\rans%=mod;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - . (Single Dot) 题解 待补\n好像是细节很多的离散化bfs\n","id":12,"section":"posts","summary":"A - ∴ (Therefore) 题意 看题目 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ string s; cin\u0026gt;\u0026gt;s; char c=s[s.length()-1]; switch(c){ case '2' :case '4': case '5': case '7': case '9': cout\u0026lt;\u0026lt;\u0026quot;hon\\n\u0026quot;; break; case '3': cout\u0026lt;\u0026lt;\u0026quot;bon\\n\u0026quot;; break; default :cout\u0026lt;\u0026lt;\u0026quot;pon\\n\u0026quot;; } return 0; } B - \u0026hellip; (Triple Dots) 题意 看题目 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int k; cin\u0026gt;\u0026gt;k; string s; cin\u0026gt;\u0026gt;s; if(s.length()\u0026lt;=k)cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl;","tags":["cpp","bfs","counting","computational_geometry"],"title":"abc168","uri":"https://dyhgo.github.io/2020/05/abc168/","year":"2020"},{"content":"A. Sequence with Digits 题意 看题目\n题解 模拟，minDigit(x) 等于0 时打断\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rll t;\rll a,k;\rll maxD(ll n)\r{\rll res=n%10;\rwhile(n)\r{\rres=max(res,n%10);\rn/=10;\r}\rreturn res;\r}\rll minD(ll n)\r{\rll res=n%10;\rwhile(n)\r{\rres=min(res,n%10);\rn/=10;\r}\rreturn res;\r}\rll cal(ll n)\r{\rreturn n+maxD(n)*minD(n);\r}\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;k;\rfor(ll i=1;i\u0026lt;k;i++)\r{\r//cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;maxD(a)\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;minD(a)\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;endl;\ra=cal(a);\rif(minD(a)==0) break;\r}\rcout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. Young Explorers 题意 有一个数组，将它们划分成n组（不用每一个数字都被划分），保证每一组的每个数字都\u0026lt;=这组数字的个数，求最多划分成几组\n题解 贪心\n方法有很多，其中之一是\n排序，对当前数字x，从它开始选x个，如果有不满足的就继续选，直到满足条件\n最后一个区间如果不能满足条件则并到前一个区间内\n（之前一直以为只要从头到尾或从尾到头贪心地选择数字对应的区间即可）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst int inf = 0x3f3f3f3f;\rconst int ninf = 0xc0c0c0c0;\rint t;\rint n;\rint a[200005];\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\rsort(a,a+n);\rint ans=0;\rfor(int i=0;i\u0026lt;n;){\rint t=a[i];\rint x=i+t-1;\rwhile(t\u0026lt;a[x] and t\u0026lt;=n and x\u0026lt;=n){\rt++;\rx++;\r}\rif(x\u0026lt;n) ans++;\ri+=t;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C. Count Triangles 题意 给四个数 abcd （从小到大），划分成三个区间，分别从三个区间中选三个数组成三条边，求组成三角形的个数\n题解 由于顺序的特殊性，只要检查前两个区间选出来的数之和有没有大于第三个区间选出来的数\n对于前两个区间选出来的数之和落在 [a+b , b+c]\n然后再判断第三个区间有几个数满足条件\n记录一下每个数出现的次数（找规律）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll a,b,c,d;\rll ran[1000005];\rint main(){\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d;\rll low=a+b;\rll hi=b+c;\rll num=min(b-a,c-b);\rnum++;\rfor(ll i=1;i\u0026lt;=num;i++){\rran[low]=i;\rlow++;\r}\rfor(ll i=a+b+num;i\u0026lt;=hi-num;i++){\rran[i] = num;\r}\rfor(ll i=hi-num+1;i\u0026lt;=hi;i++){\rran[i] = num;\rnum--;\r}\r//for(ll i=3;i\u0026lt;=5;i++) cout\u0026lt;\u0026lt;ran[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rll ans=0;\rfor(ll i=a+b;i\u0026lt;=b+c;i++){\rll mul = ran[i];\rif(i-c-1\u0026gt;=0) {\rif(i-1\u0026gt;d){\rans+=(d-c+1)*mul;\r}else{\rans+=mul*(i-c);\r}\r}\r//cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D. Game With Array 题意 给俩数 n s (n\u0026lt;=s) 问是否存在满足下列条件的数组\n数组的长度为 n 元素和为 s\n存在k使得任何一个子数组的和都不等于 k或s-k\n题解 构造\n由于 k 或 s-k 所以当 s/2\u0026lt;n 时不存在\n由于数的奇偶性，可以构造全是偶数的数组(2) 这样随便选一个奇数就满足条件\n但对于s是奇数时，最后一个元素是奇数，如果把前面全部构造成2，且s/2\u0026lt;n\n这样最后一个一定\u0026gt;=3\n所以k选择1\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint n,s;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s;\rif(s/2\u0026lt;n){\rputs(\u0026quot;no\u0026quot;);\r}\relse{\rputs(\u0026quot;yes\u0026quot;);\rfor(int i=0;i\u0026lt;n-1;i++){\rcout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r}\rcout\u0026lt;\u0026lt;s-2*n+2\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ","id":13,"section":"posts","summary":"A. Sequence with Digits 题意 看题目 题解 模拟，minDigit(x) 等于0 时打断 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; const int inf = 0x3f3f3f3f; const int ninf = 0xc0c0c0c0; ll t; ll a,k; ll maxD(ll n) { ll res=n%10; while(n) { res=max(res,n%10); n/=10; } return res; } ll minD(ll","tags":["cpp","greedy","construct"],"title":"Codeforces Round #643 (Div. 2) A~D","uri":"https://dyhgo.github.io/2020/05/codeforces-round-643-div.-2-a~d/","year":"2020"},{"content":"A. Orac and Factors 题意 对于一个数，每一次操作加上他的最小因子（除1外）\n问k次操作后，这个数是多少\n题解 奇数找最小因子加一下就变成偶数，偶数最小因子是2\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,k,t;\rint ans;\rint f(int x){\rfor(int i=2;i*i\u0026lt;=x;i++){\rif(x%i==0){\rreturn i;\r}\r}\rreturn x;\r}\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rif(n\u0026amp;1){\rn+=f(n);\rans = n+(k-1)*2;\r}\relse{\rans = n+k*2;\t}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. Orac and Models 题意 给一数组，从中选几个数出来，满足严格递增，且对任意相邻下标a,b满足a|b，输出最长子序列的个数\n题解 对于每个数都可以选择x2 x3 x4 x5\u0026hellip;\n所以对于每个数依次判断x2 x3 x4 x5\u0026hellip;是否满足严格递增，由于越大的数越稀疏，所以不会超时\n即 if( a[j] \u0026gt; a[i] ) dp[j] = max(dp[j] , dp[i] + 1)\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,n;\rint dat[100005];\rint dp[100005];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;dat[i],dp[i]=1;\rfor(int i=1;i\u0026lt;=n;i++)for(int j=i+i;j\u0026lt;=n;j+=i){\rif(dat[j]\u0026gt;dat[i]) dp[j]=max(dp[j],dp[i]+1);\r}\rint ans=-1;\rfor(int i=1;i\u0026lt;=n;i++){\rans=max(ans,dp[i]);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C. Orac and LCM 题意 对于一个数组，每两个元素求lcm，把结果放到multi_set中，对multiset求gcd\n题解 从a[1]开始依次对后面的数求lcm，然后对结果求gcd\ngcd(lcm(a1,a2) , lcm(a1,a3) , ... , lcm(a1,an)) = lcm(a1 , gcd(a2,a3, ... , an)\n这样就可以利用后缀\n最后对所有lcm求gcd\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n;\rll dat[100005];\rvector\u0026lt;ll\u0026gt; vt;\rll suf[100005];\rll lcm(ll a,ll b){\rreturn a*b/__gcd(a,b);\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(ll i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;dat[i];\rsuf[n]=dat[n];\rfor(ll i=n-1;i\u0026gt;=2;i--){\rsuf[i]=__gcd(dat[i],suf[i+1]);\r}\rfor(ll i=1;i\u0026lt;=n-2;i++){\rvt.push_back(lcm(dat[i],suf[i+1]));\r}\rvt.push_back(lcm(dat[n-1],dat[n]));\rll gcd=vt[0];\rfor(ll i=1;i\u0026lt;vt.size();i++){\rgcd=__gcd(gcd,vt[i]);\r}\rcout\u0026lt;\u0026lt;gcd\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D. Orac and Medians 题意 对于一个数组，可以选择一个区间，将区间内的数变成这个区间的中位数，如果有两个，则选较小，问是否能在若干次操作后把所有数字变成k\n题解 特判数组是否有k\n对于有k的情况\n如果数组中\u0026gt;=k 的个数大于 \u0026lt;k的个数，就可以通过不断选2个数，其中一个是K\n同化另一个数，达到同化所有\n其他情况如果存在相邻的三个数，满足2个数\u0026gt;=k 就可以实现同化并不断同化\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,n,k;\rint dat[100005];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rbool ok=false;\rint low=0,hi=0;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;dat[i];\rif(dat[i]==k) ok=true;\rif(dat[i]\u0026lt;k) low++;\relse hi++;\r}\rif(!ok){\rputs(\u0026quot;no\u0026quot;);\r}\relse if(hi\u0026gt;low) puts(\u0026quot;yes\u0026quot;);\relse{\rbool okk = false;\rfor(int i=0;i\u0026lt;n-2;i++){\rint l=0,h=0;\rif(dat[i]\u0026lt;k) l++;else h++;\rif(dat[i+1]\u0026lt;k) l++;else h++;\rif(dat[i+2]\u0026lt;k) l++;else h++;\rif(h\u0026gt;l) okk=true;\r}\rif(okk) puts(\u0026quot;yes\u0026quot;); else puts(\u0026quot;no\u0026quot;);\r}\r}\rreturn 0;\r}\r ","id":14,"section":"posts","summary":"A. Orac and Factors 题意 对于一个数，每一次操作加上他的最小因子（除1外） 问k次操作后，这个数是多少 题解 奇数找最小因子加一下就变成偶数，偶数最小因子是2 #include\u0026lt;bits/stdc++.h\u0026gt;","tags":["cpp","number_theory","dp","construct"],"title":"Codeforces Round #641 (Div. 2) A~D","uri":"https://dyhgo.github.io/2020/05/codeforces-round-641-div.-2-a~d/","year":"2020"},{"content":"这个比赛尽犯些sb错🙃，先是把 j 写成 i ，然后把2E5写成1E5\nA - Registration 题意 判断字符串T是不是S后加一个字符\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rstring s1,s2;\rcin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2;\rif(s2.substr(0,s2.length()-1)==s1) puts(\u0026quot;Yes\u0026quot;);\relse puts(\u0026quot;No\u0026quot;);\rreturn 0;\r}\r 不知道strstr为啥就不行\nB - Easy Linear Programming 题意 有三种卡片，分别写上数字1，0，-1，选择k张，让数字和最大\n题解 贪心\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rint a,b,c,k;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k;\rint ans=0;\rif(a\u0026lt;=k){\rans+=a;\rk-=a;\rif(b\u0026lt;=k){\rk-=b;\rif(c\u0026lt;=k){\rans-=c;\r}else ans-=k;\r}\relse{\rans+=k;\r}\r}\relse{\rans+=k;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Skill Up 题意 高桥想学m个算法，有n本书，每本书有价格，和对每个算法的提升程度\n问高桥想要每个算法都达到X，最少需要花多少钱\n题解 数据不是很大，可以暴力模拟，数据大，可以考虑dp\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst long long inf = 0x3f3f3f3f;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint n,m,x;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;x;\rint ans=inf;\rint dat[n+1][m+1+1];\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;dat[i][0];\rfor(int j=1;j\u0026lt;=m;j++) cin\u0026gt;\u0026gt;dat[i][j];\r}\rfor(int i=0;i\u0026lt;=(1\u0026lt;\u0026lt;n)-1;i++){\rint e[m+1+1]={0};\rint foo=0;\rfor(int j=0;j\u0026lt;n;j++){\rif(i\u0026gt;\u0026gt;j\u0026amp;1){\rfor(int k=1;k\u0026lt;=m;k++){\re[k]+=dat[j][k];\r}\rfoo+=dat[j][0];\r}\r}\rbool ok=true;\rfor(int i=1;i\u0026lt;=m;i++) if(e[i]\u0026lt;x) ok=false;\rif(ok) ans=min(ans,foo);\r//for(int i=1;i\u0026lt;=m;i++) cout\u0026lt;\u0026lt;e[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\r}\rcout\u0026lt;\u0026lt;(ans==inf?-1:ans)\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Teleporter 题意 有一个数组（长度最大为2E5），当你在下标为 i 时，可以tp到下标为 a[i]\n问 N(N\u0026lt;=1E18) 次tp后在哪里\n题解 由于数据很大不能直接算\n考虑到数组最大为2E5，所以有最大为2E5的循环节\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rbool vis[200005];\rll tim[200005];\rll ind[2000005];\rll loop=0;\rll a[200005];\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rll n,k;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(ll i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\rll ans=1;\rvis[1]=true;\rtim[1] = 1;\rind[1] = 1;\rfor(int i=2;i\u0026lt;=k;i++){\rans = a[ans];\rif(vis[ans]){\rloop=i-tim[ans];break;\r}else{\rvis[ans]=true;\rtim[ans]=i;\rind[i]=ans;\r}\r}\rif(loop==0){\rcout\u0026lt;\u0026lt;a[ans]\u0026lt;\u0026lt;endl;\r}\telse{\rk-=tim[ans];\rk%=loop;\rcout\u0026lt;\u0026lt;a[ind[k+tim[ans]]]\u0026lt;\u0026lt;endl;\r}\r//cout\u0026lt;\u0026lt;loop\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Colorful Blocks 题意 给一排方块涂色，方块有n个，至多m种颜色，要求至多有k对相邻的块涂相同的颜色\n求方案数\n题解 高中排列组合\n$$ ans = \\sum\\limits_{i=0} ^ {k} {m * C_{n-1}^{i} * (m-1)^{n-1-i}} $$\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst ll mod = 998244353;\rll n,m,k;\rll fac[200005];\rll ans = 0;\rll qpow(ll x,ll n){\rll res = 1;\rwhile(n\u0026gt;0){\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rll C(int n,int m){\rreturn fac[n]%mod*qpow(fac[m],mod-2)%mod*qpow(fac[n-m],mod-2)%mod;\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k;\rfor(ll i=0;i\u0026lt;n+2;i++) fac[i] = 1;\rfor(ll i=1;i\u0026lt;n+2;i++) fac[i] = i*fac[i-1]%mod;\rfor(ll i=0;i\u0026lt;=k;i++){\rans = ans + m*C(n-1,i)%mod*qpow(m-1,n-1-i)%mod;\r}\rcout\u0026lt;\u0026lt;(ans+mod)%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Bracket Sequencing 题意 给n个由 \u0026lsquo;(\u0026rsquo; 和 \u0026lsquo;)\u0026rsquo; 组成的字符串，将n个字符串连接，问是否存在一种方案使得连接后的字符串是合法括号序列\n题解 很好玩的一道题\n一开始想用栈，太麻烦\n用计数器，每读入一个open +1 否则 -1 ，这样就得到每个字符串的计数\n把计数大的放前面，并且检查计数和是否为0\n这样做是错的，样例2不给过\n那就对连接后的备选字符串遍历，重新计数，查看中途不能有负数且最后为0\n但这样也是错的，因为有可能正确的答案不是按从大到小的顺序排的\n这种错误是因为（对于每个字符串）前面有几个close，后面一堆open导致计数变大，但其实是不合法的，因为前面几个close没得匹配\n所以应该记录由close影响的“计数的最小值”\n合理的排序应该是\n对于两个字符串a,b\n考虑两种情况 a+b b+a\n对于每种连接考虑两种情况\n遍历到a时，a的计数最小值\n遍历到a+b时，a+b的计数最小值\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rstring s;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vt;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rint sum=0;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;s;\rint cnt=0;int low=0; //int cnt,low=0 WA T_T\rfor(char c:s){\rif(c=='('){\rcnt++;\r}else cnt--;\rlow=min(low,cnt);\r}\rvt.emplace_back(cnt,low);\rsum+=cnt;\r}\rif(sum!=0) {\rputs(\u0026quot;No\u0026quot;);return 0;\r}\rsort(vt.begin(),vt.end(),[](pair\u0026lt;int,int\u0026gt; pii1,pair\u0026lt;int,int\u0026gt; pii2){return min(pii1.second,pii1.first+pii2.second) \u0026gt; min(pii2.second,pii2.first+pii1.second);});\rint foo=0;\rfor(pair\u0026lt;int,int\u0026gt; pii:vt){\rif(foo\u0026lt;-pii.second){\rputs(\u0026quot;No\u0026quot;);\rreturn 0;\r}foo+=pii.first;\r}\rputs(\u0026quot;Yes\u0026quot;);\rreturn 0;\r}\r ","id":15,"section":"posts","summary":"这个比赛尽犯些sb错🙃，先是把 j 写成 i ，然后把2E5写成1E5 A - Registration 题意 判断字符串T是不是S后加一个字符 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){ string s1,s2; cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2; if(s2.substr(0,s2.length()-1)==s1) puts(\u0026quot;Yes\u0026quot;);","tags":["cpp","greedy","counting"],"title":"abc167","uri":"https://dyhgo.github.io/2020/05/abc167/","year":"2020"},{"content":"C - 序列最小化 题解 贪心，每次选择的长度为k的区间首尾重叠\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing Int = long long;\rint main(){\rInt n,k;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; n-=k;\rInt ans = ceil((double)n/(k-1));\rcout\u0026lt;\u0026lt;ans+1\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - 简单瞎搞题 题解 位dp，dp[i] 表示前i个数能达到的数字集合\n加上第 i 个区间的数，遍历一遍这个区间对于其中一个数 j\n集合的结果变成 dp[i-1]\u0026lt;\u0026lt;(j*j)\n所以 dp[i] |= dp[i-1] \u0026lt;\u0026lt; (j*j)\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rbitset\u0026lt;1000005\u0026gt; dp[105];\rint n;\rint l[105];\rint r[105];\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++) dp[i].reset();\r//init\rdp[0][0]=1;\rfor(int i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;l[i]\u0026gt;\u0026gt;r[i];\r}\rfor(int i=1;i\u0026lt;=n;i++){\rfor(int j=l[i];j\u0026lt;=r[i];j++){\rdp[i] |= (dp[i-1]\u0026lt;\u0026lt;(j*j));\r}\r}\rcout\u0026lt;\u0026lt;dp[n].count();\rreturn 0;\r}\r D - 小雨坐地铁 题解 经典图论题\n丁老师说过如果由直线构成的图中，转弯需要花费时间，则可以构造虚点\n对于本身耗费的金钱a，可以构造虚点，对应于每个点，从实点到虚点有权为0的边，从虚点到实点有权为a的边\n把每条地铁线的点独立，这样就有(m+1)*n个点\n对于每条地铁线上的点，在对应的图层上连线，而图层之间由虚点连接\n最后跑一遍最短路\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,m,s,t;\rint a,b,c;\rint t1,t2;\rconst int inf = 0x3f3f3f3f;\rconst int max_v = 501505;\rstruct edge\r{\rint to,cost;\redge(int to,int cost){\rthis-\u0026gt;cost = cost;\rthis-\u0026gt;to = to;\r}\r};\rtypedef pair\u0026lt;int,int\u0026gt; pii; int V;\rvector\u0026lt;edge\u0026gt; G[max_v];\rint d[max_v];\rinline void add_edge(int a,int b,int c){\rG[a].push_back(edge(b,c));\r}\rvoid dijkstra(int s)\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; fill(d,d+V,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} } int main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;\rV=(m+1)*n+1;\rs=n*m+s;\rt=n*m+t;\rfor(int i=0;i\u0026lt;m;i++){\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;\rfor(int j=0;j\u0026lt;c;j++){\rcin\u0026gt;\u0026gt;t1;\rif(j\u0026gt;0){\radd_edge(i*n+t2,i*n+t1,b);\radd_edge(i*n+t1,i*n+t2,b);\r}\radd_edge(i*n+t1,m*n+t1,0);\radd_edge(m*n+t1,i*n+t1,a);\rt2=t1;\r}\r}\rdijkstra(s);\rcout\u0026lt;\u0026lt;(d[t]==inf ? -1 : d[t])\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":16,"section":"posts","summary":"C - 序列最小化 题解 贪心，每次选择的长度为k的区间首尾重叠 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using Int = long long; int main(){ Int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; n-=k; Int ans = ceil((double)n/(k-1)); cout\u0026lt;\u0026lt;ans+1\u0026lt;\u0026lt;endl; return 0; } E - 简单瞎搞题 题解 位dp，dp[i] 表","tags":["cpp","greedy","graph_theory","bit"],"title":"牛客算法周周练5(部分)","uri":"https://dyhgo.github.io/2020/05/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%835%E9%83%A8%E5%88%86/","year":"2020"},{"content":"git安装\n用户名和邮箱 初始化或切换用户名和邮箱\ngit config --global user.name \u0026quot;XXX\u0026quot;\ngit config --global user.email \u0026quot;XXX\u0026quot;\n查看当前用户名和邮箱\ngit config --global user.name\ngit config --global user.email\n查看用户名和邮箱列表\ngit config --list\n删除用户名和邮箱\ngit config --global --unset user.name \u0026quot;XXX\u0026quot;\ngit config --global --unset user.email \u0026quot;XXX\u0026quot;\ngit工作原理 三种状态 modified staged committed\n本地操作 基本操作 从工作目录移动到暂存区 git add XXX\n全部移动 git add .\n从暂存区移动到本地仓库 git commit -m \u0026quot;XXX\u0026quot;\n修改提交信息 git commit --amend\n打开vim编辑器\n只读状态下的保存退出\n[esc] :wq!\nvim使用\n查看状态 git status\n查看日志 git log\n查看更完全的日志并压缩排版\ngit reflog --oneline\n版本回退 从暂存区回退到工作目录 git reset XXX\n从本地仓库回退到暂存区(后面带数字可以选择回退几个版本) git reset --soft HEAD~\n从本地仓库回退到工作目录 git reset HEAD~\n从本地仓库回退到工作目录，并撤销在工作目录的操作（可能导致删除文件） git reset --hard HEAD~\n对因回退删除掉的文件还原 git reset --hard \u0026lt;filename\u0026gt; (这时候已经commit)\n恢复文件 在工作目录中删除，要恢复(把暂存区的恢复过来) git checkout XXX\n删除文件 删除工作目录和暂存区的文件，取消跟踪，不纳入版本管理（两个区文件要相同） git rm XXX\n此时本地仓库还有该文件\n通过回退实现彻底删除\ngit reset --soft HEAD~\n如果两个区文件不同\n全都删除\ngit rm -f XXX\n只删除暂存区\ngit rm --cached XXX\n重命名 git mv \u0026lt;before\u0026gt; \u0026lt;after\u0026gt;\n然后再添加，提交\n文件比较 比较两个历史快照 git diff XXX XXX\n比较工作目录和暂存区 git diff XXX\n比较工作目录和仓库 git diff XXX\n比较暂存区和仓库 git diff --cached XXX\n分支 创建分支 git branch XXX\n进入分支 git checkout XXX\n创建并进入分支 git checkout -b XXX\n列出所有分支 git branch -a\n查看当前分支 git branch\n图化所有分支 git log --decorate --oneline --graph --all\n与当前分支合并 git merge XXX\n合并冲突 打开文件，修改文件，重新添加提交\n删除分支 git branch -d XXX\n分支名删除，文件仍然存在\n远程操作 远程项目拷贝到本地 git clone XXX\npush/pull 推到远程分支上 git push\n需要输入github账号密码\n把远程分支更新的内容拉到本地 git pull\n连续两次 git push 内容不一样产生冲突 git pull\n文件会自动更新，改文件内容，重新添加提交\n其他 git push \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;\ngit pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;\ne.g\ngit push origin master\ngit pull origin master\npush需要创建upstream连接本地分支和远程分支\ngit branch --set-upstreamXXX\n更常用的是(建立upstream并push)(本地与远程同名)\ngit push -u origin XXX\nfetch git pull 类似于 git fetch + git merge\n和commitId的改动有关\ngit fetch 更安全\n具体参考 这篇文章\nremote 远程添加仓库\ngit remote add \u0026lt;name\u0026gt; \u0026lt;url\u0026gt;\n远程删除仓库\ngit remote remove XXX\n查看远程仓库\ngit remote\n查看有关联的远程仓库\ngit remote -v\n","id":17,"section":"posts","summary":"git安装 用户名和邮箱 初始化或切换用户名和邮箱 git config --global user.name \u0026quot;XXX\u0026quot; git config --global user.email \u0026quot;XXX\u0026quot; 查看当前用户名和邮箱 git config --global user.name git config --global user.email 查看用户名和邮箱列表 git config --list 删除用户名和","tags":["git"],"title":"git","uri":"https://dyhgo.github.io/2020/05/git/","year":"2020"},{"content":"A - A?C 题意 abc输出arc反之亦然\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rstring s;\rcin\u0026gt;\u0026gt;s;\rs[1]=s[1]=='B'? 'R': 'B';\rcout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl;\rreturn 0; }\r B - Trick or Treat 题意 snack_i被snuke_1,snuke_2..拥有\n问有多少个snuke没有snack\n题解 #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rset\u0026lt;int\u0026gt; st;\rint main(){\rint n,k;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=1;i\u0026lt;=k;i++){\rint x;\rcin\u0026gt;\u0026gt;x;\rwhile(x--){\rint y;\rcin\u0026gt;\u0026gt;y;\rst.insert(y);\r}\r}\rcout\u0026lt;\u0026lt;n-st.size()\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Peaks 题意 山上有n个观景台，有一些路连接两个观景台，一个观景台是好的当且仅当从它出发走一条路能到达的观景台海拔都比它低，没有路也算\n问有多少个好观景台\n题解 用二叉树排序\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rpriority_queue\u0026lt;int\u0026gt; p[100005];\rint a[100005];\rint main(){\rint n,m;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=1;i\u0026lt;=n;i++) p[i].push(0);\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i];\rwhile(m--){\rint t1,t2;\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rp[t1].push(a[t2]);\rp[t2].push(a[t1]);\r}\rint ans=0;\rfor(int i=1;i\u0026lt;=n;i++){\rif(p[i].top()\u0026lt;a[i]) ans++;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - I hate Factorization 题意 给定一个数X，求A，B使得A^5 - B^5 = X,A，B是整数\n题解 bf\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll x,a,b;\rbool check(ll a,ll b){\rif(a*a*a*a*a - b*b*b*b*b == x) return true;\rreturn false;\r}\rint main(){\rcin\u0026gt;\u0026gt;x;\rfor(ll i = -500;i\u0026lt;=500;i++) for(ll j=-500;j\u0026lt;=500;j++){\rif(check(i,j)){\ra = i,b = j;\rbreak;\r}\r}\rcout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - This Message Will Self-Destruct in 5s 题意 有一个数列，一对数字是好数对，当且仅当下标差等于数值和，求好数对个数\n题解 等式移项\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n;\rmap\u0026lt;ll,ll\u0026gt; mp;\rll ans;\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n;i++){\rll x;\rcin\u0026gt;\u0026gt;x;\rans+=mp[i-x];\rmp[i+x]++;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Three Variables Game 题意 有三个数a,b,c，有n轮抉择，每一轮抉择会给出一个字符串\u0026quot;ab\u0026rdquo; \u0026ldquo;bc\u0026rdquo; ,\u0026ldquo;ac\u0026rdquo;\n选择其中一个数加，另一个数减，问是否存在一种方案使得所有数最后都不是负数\n题解 这题做错了，因为思维局限在dfs找两个数字相同情况下该选哪个，然后不是WA就是TLE，理论上可以，没写好\n其实可以全搜索，然后找到一组解就exit(0)\n一定要退出，不能返回，因为真的搜索完全就超时\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,a,b,c;\rstring s[100005];\rchar ans[100005];\rbool ok;\rvoid dfs(int ind,int a,int b,int c){\rif(a\u0026lt;0 || b\u0026lt;0 || c\u0026lt;0) return;\rif(ind==n){\rputs(\u0026quot;Yes\u0026quot;);\rfor(int i = 0;i \u0026lt; n;i++){\rcout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl;\r}\rexit(0);\r}\relse{\rif(s[ind]==\u0026quot;AB\u0026quot;){\rans[ind]='A';\rdfs(ind+1,a+1,b-1,c);\rans[ind]='B';\rdfs(ind+1,a-1,b+1,c);\r}\relse if(s[ind]==\u0026quot;AC\u0026quot;){\rans[ind]='A';\rdfs(ind+1,a+1,b,c-1);\rans[ind]='C';\rdfs(ind+1,a-1,b,c+1);\r}\relse{\rans[ind]='B';\rdfs(ind+1,a,b+1,c-1);\rans[ind]='C';\rdfs(ind+1,a,b-1,c+1);\r}\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;\rfor(int i = 0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;s[i];\rdfs(0,a,b,c);\rputs(\u0026quot;No\u0026quot;);\rreturn 0;\r}\r ","id":18,"section":"posts","summary":"A - A?C 题意 abc输出arc反之亦然 题解 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ string s; cin\u0026gt;\u0026gt;s; s[1]=s[1]=='B'? 'R': 'B'; cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; return 0; } B - Trick or Treat 题意 snack_i被snuke_1,snuke_2..拥有 问","tags":["cpp","dfs"],"title":"abc166","uri":"https://dyhgo.github.io/2020/05/abc166/","year":"2020"},{"content":"A - We Love Golf 题意 询问在A到B之间是否有C的倍数\n题解 特判边界是否满足条件，否则判断左右边界除以C的值是否大于等于1\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rint a,b,c;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;\rif(b/(double)a == b/a) puts(\u0026quot;OK\u0026quot;);\relse if(c/(double)a == c/a) puts(\u0026quot;OK\u0026quot;);\relse if(c/a \u0026gt; b/a){\rputs(\u0026quot;OK\u0026quot;);\r}\relse puts(\u0026quot;NG\u0026quot;);\rreturn 0;\r}\r B - 1% 题意 初始有100円，每年利息1%，每年结算时将小数部分抛弃，问多久能达到A円\n题解 计数器模拟\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rll a;\rcin\u0026gt;\u0026gt;a;\rll dy = 0;\rdouble bs = 100;\rwhile(bs\u0026lt;a){\rbs*=1.01;\rbs = floor(bs);\rdy++; }\rcout\u0026lt;\u0026lt;dy\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Many Requirements 题意 构造一个数列A每个数不大于10，数列长度不大于M，且递增\n有q个四元组 a b c d\n如果Ab - Aa == c，则v+=d\n求v的最大值\n题解 最开始有两种思路，暴力构造（超时），对q个四元组贪心（会错过最优解）\n所以dfs，dfs到最后一个数时求v并更新v\n传入下标作为参数，不需要回溯\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint a[55],b[55],c[55],d[55];\rint n,m,q;\rint ans;\rint dat[12];\rvoid dfs(int ind , int pre){\rif(ind == n){\rint cnt = 0;\rfor(int i=0;i\u0026lt;q;i++){\rif(dat[b[i] - 1] - dat[a[i] - 1] == c[i]) cnt+=d[i];\r}\rans = max(ans , cnt);\r}\relse{\rfor(int i = pre;i\u0026lt;=m;i++){\rdat[ind] = i;\rdfs(ind + 1 , i);\r}\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q;\rfor(int i=0;i\u0026lt;q;i++) cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i]\u0026gt;\u0026gt;c[i]\u0026gt;\u0026gt;d[i];\rdfs(0,1);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Floor Function 题意 看题目\n题解 问题转化成在0~N中找一个数x，使得x/B的小数部分最接近0.99999\nx = B-1 如果N不允许，找最大N\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rint main(){\rdouble a,b,n;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n;\rdouble x;\rif(n\u0026gt;=b-1) x =b-1;\relse x=n;\rcout\u0026lt;\u0026lt;floor(a*x/b) - a*floor(x/b)\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Rotation Matching 题意 有N个玩家，M个竞技场（M*2+1\u0026lt;=N）\n每个玩家都有一个数字\n每个竞技场安排两个数字，不能重复\n共有N轮决斗\n对于每一轮，每个竞技场中数字对应的两个玩家进行battle\n每一轮决斗后，所有玩家的数字都+1\n求安排方案使得所有的人都不会和同一个人battle两次\n题解 应该是本次比赛最难的题\n由于M*2+1\u0026lt;=N\n所以合理安排，在进行N轮之后，一定会刚好满足条件\n其实就是号码的两两配对\n在纸上列出所有的情况，一直尝试、排除\n最后会发现，前半段要隔一个对称配对，后半段直接对称配对，这样就能完美错开\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rint dat1[100005],dat2[100005];\rusing namespace std;\rint main(){\rint n,m;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rif(!(n\u0026amp;1)) n--;\rint mm = (n-1)/2;\rif(mm\u0026amp;1){\rfor(int i=1;i\u0026lt;=mm/2;i++){\rdat1[i] = i;\rdat2[i] = (n+1)/2 - i;\r}\rfor(int j=(n+1)/2,i = mm/2+1,k=0;i\u0026lt;=mm;i++,j++,k++){\rdat1[i] = j;\rdat2[i] = n - k;\r}\r}\relse{\rfor(int i=1;i\u0026lt;=mm/2;i++){\rdat1[i] = i;\rdat2[i] = (n+3)/2 - i;\r}\rfor(int i=(n+3)/2,j=n,k=mm/2+1;k\u0026lt;=mm;i++,j--,k++){\rdat1[k] = i;\rdat2[k] = j;\r}\r}\r//for(int i=1;i\u0026lt;=6;i++) cout\u0026lt;\u0026lt;dat1[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;dat2[i]\u0026lt;\u0026lt;endl;\rfor(int i=1;i\u0026lt;=m;i++) cout\u0026lt;\u0026lt;dat1[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;dat2[i]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - LIS on Tree 题意 给一棵树，每个点有一个数字属性，求1到X的最短路径中，按1到X的顺序排列数字属性得到的序列中的最长上升子序列（LIS）\n对所有的X\n题解 dfs + lis\n注意回溯\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint dp[200005];\rvector\u0026lt;int\u0026gt; G[200005];\rint n;\rint a[200005];\rint ans[200005];\rconst int inf = 0x3f3f3f3f;\rvoid dfs(int u,int p){\rint ind = (int)(lower_bound(dp,dp+n,a[u]) - dp);\rint cnt = dp[ind];\rdp[ind] = a[u];\rans[u] = (int)(lower_bound(dp,dp+n,inf) - dp);\rfor(int i:G[u]){\rif(i!=p){\rdfs(i,u);\r}\r}\r//undo\rdp[ind] = cnt;\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\rfor(int i=0;i\u0026lt;n-1;i++){\rint t1,t2;\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rt1--,t2--;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rfill(dp,dp+n+2,inf);\rdfs(0,-1);\rfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":19,"section":"posts","summary":"A - We Love Golf 题意 询问在A到B之间是否有C的倍数 题解 特判边界是否满足条件，否则判断左右边界除以C的值是否大于等于1 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int main(){","tags":["cpp","dp","dfs","construct"],"title":"abc165","uri":"https://dyhgo.github.io/2020/05/abc165/","year":"2020"},{"content":"A - Sheep and Wolves 题意 判断两个数的大小\n题解 ac代码\nn,m = map(int,input().split())\rif n\u0026gt;m:\rprint('safe')\relse :\rprint('unsafe')\r B - Battle 题意 给定两个人的生命值和攻击力，两个人回合制battle，谁的生命值先小于等于0\n题解 模拟\nac代码\na,b,c,d = map(int,input().split())\rwhile a\u0026gt;0 and c\u0026gt;0:\rc=c-b\rif c\u0026lt;=0:\rbreak\ra=a-d\rif a\u0026lt;=0:\rbreak\rif a\u0026lt;=0:\rprint('No')\relse:\rprint('Yes')\r C - gacha 题意 给一堆字符串，求有多少种\n题解 ac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint n;\rset\u0026lt;string\u0026gt; st;\rcin\u0026gt;\u0026gt;n;\rstring s;\rwhile(n--){\rcin\u0026gt;\u0026gt;s;\rst.insert(s);\r}\rcout\u0026lt;\u0026lt;st.size()\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Multiple of 2019 题意 给一数字串，求多少个连续子串组成的数字是2019的倍数\n题解 后缀，和abc158E几乎一致\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rstring s;\rint a[2020]={0};\rcin\u0026gt;\u0026gt;s;\rint ans = 0;\rint t = 1;\rint cnt = 0;\ra[0]++;\rfor(int i=s.length()-1;~i;i--){\rcnt = (cnt+t*(s[i]-'0'))%2019;\rans+=(a[cnt]++);\rt=(t*10)%2019;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Two Currencies 题意 有n个城市，m条路（无向），每条路有两个属性（通过这条路要花费的时间和金\n钱），每个城市有两个属性（可以花费时间购买金钱），给初始的金钱数量，求\n从1城市到每个城市花费的最少时间\n题解 dijkstra算法的变形\n把时间当做最短路\n当金钱超过最大值时，就不需要考虑是否在每个城市购买金钱\n套一个dijkstra算法板子，加上对每个城市是否购买金币的判断\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rusing tp = tuple\u0026lt;ll,ll,ll\u0026gt;;\rll n,m,s;\rll a,b; ll c[55],d[55]; //存获得的银币和消耗的时间 ll dp[55][2505]; //到达i时还有j银币的最小时间 vector\u0026lt;tp\u0026gt; G[55]; //目标点 a b tp info; //时间 目标点 当前的钱 const ll inf = 0x3f3f3f3f3f3f3f3f;\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s;\rs = min(s,2504LL);\rfor(ll i=0;i\u0026lt;m;i++){\rll ta,tb,tc,td;\rcin\u0026gt;\u0026gt;ta\u0026gt;\u0026gt;tb\u0026gt;\u0026gt;tc\u0026gt;\u0026gt;td;\rG[ta].push_back(tp(tb,tc,td));\rG[tb].push_back(tp(ta,tc,td));\t}\rfor(ll i=1;i\u0026lt;=n;i++){\rll tc,td;\rcin\u0026gt;\u0026gt;tc\u0026gt;\u0026gt;td;\rc[i] = tc;\rd[i] = td;\r}\rfill(dp[0] , dp[0] + 54*2504 , inf);\rdp[1][s] = 0;\rpriority_queue\u0026lt;tp,vector\u0026lt;tp\u0026gt;,greater\u0026lt;tp\u0026gt;\u0026gt; pq;\rpq.push(tp(0,1,s));\rwhile(!pq.empty()){\rinfo = pq.top();\rpq.pop();\rll t = get\u0026lt;0\u0026gt;(info) , u = get\u0026lt;1\u0026gt;(info) , w = get\u0026lt;2\u0026gt;(info);\rif(dp[u][w] \u0026gt; t) continue;\rfor(auto i:G[u]){\rll v = get\u0026lt;0\u0026gt;(i) , aa = get\u0026lt;1\u0026gt;(i) , bb = get\u0026lt;2\u0026gt;(i);\rif(w\u0026gt;=aa and dp[v][w-aa] \u0026gt; t + bb){\rdp[v][w-aa] = t + bb;\rpq.push(tp(t+bb , v , w-aa));\r}\r}\rif(dp[u][min(w + c[u] , 2504LL)] \u0026gt; t + d[u]){\rdp[u][min(w + c[u] , 2504LL)] = t + d[u];\rpq.push(tp(t + d[u] , u , min(w + c[u] , 2504LL)));\r}\r}\tfor(ll i=2;i\u0026lt;=n;i++){\rll ans = inf;\rfor(ll j=0;j\u0026lt;2504;j++){\rans = min(ans , dp[i][j]);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r F - I hate Matrix Construction 似乎是位运算的构造。。。🤔\n","id":20,"section":"posts","summary":"A - Sheep and Wolves 题意 判断两个数的大小 题解 ac代码 n,m = map(int,input().split()) if n\u0026gt;m: print('safe') else : print('unsafe') B - Battle 题意 给定两个人的生命值和攻击力，两个人回合制battle，谁的生命值先小于","tags":["cpp","suffix","graph_theory"],"title":"abc164","uri":"https://dyhgo.github.io/2020/05/abc164/","year":"2020"},{"content":"Symmetric Matrix 题目描述 Count the number of n x n matrices A satisfying the following condition modulo m.\n Ai, j ∈ {0, 1, 2} for all 1 ≤ i, j ≤ n. Ai, j = Aj, i for all 1 ≤ i, j ≤ n. Ai, 1 + Ai, 2 + \u0026hellip; + Ai, n = 2 for all 1 ≤ i ≤ n. A1, 1 = A2, 2 = \u0026hellip; = An, n = 0.  输入描述 The input consists of several test cases and is terminated by end-of-file. Each test case contains two integers n and m.\n输出描述 For each test case, print an integer which denotes the result.\n样例输入 3 1000000000 100000 1000000000\n样例输出 1 507109376\n限制  1 ≤ n ≤ 105 1 ≤ m ≤ 109 The sum of n does not exceed 107.  题解 挺好一道题目\n这个题分三个步骤\n1.根据题意转化成图的邻接矩阵\n2.使用dp，找dp递推式\n3.化简递推式\n1.把题目转化成求n个点的无向图个数满足，没有自环，如果组成圈则边权为1\n如果是两个点相连则权值为2（参考下面的图片）\n2.f[n] 表示 n 个点时的方案数\n那么第 n 个点依赖于前 n-1 个点\n考虑两种情况\n① 将 n-1 个点中的一个点拉出来与第 n 个点组成边权为2的点对，对于每一种方\n案都有 n-1 个点可选，剩下的 n-2 个点方案数为 f[n-2] 所以 f[n] += (n-1)*f[n-2]\n② 把第 n 个点与前 n-1 个点组成圈\n考虑选 k 个点出来，那么就有\n$$ C_{n-1}^{k} $$\n种选法\n对于选出来的 k 个点全排列，有\n$$ A_{k}^{k} $$\n种，剩下的情况有 f[n-1-k] 种\n由于圈的首位相连，所以 /2\n那么所有的方案是\n$$ \\frac{1}{2} \\sum\\limits_{k=2} ^ {n-1} {C_{n-1}^{k}A_{k}^{k}f[n-1-k]} $$\n这样并不会重复，因为每次参与形成圈的点数是不同的，这一定互异\n3.化简\n最终式 f[n] = (n-1) * (f[n-1] + f[n-2]) - 1/2 * (n-1) * (n-2) * f[n-3]\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll ans[100005];\rint main(){\rll n,m;\rans[0] = 1;\rans[1] = 0;\rans[2] = 1;\rans[3] = 1;\rwhile(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m){\rfor(ll i=4;i\u0026lt;=n;i++){\rans[i] = 0;\r}\rfor(ll i = 4;i\u0026lt;=n;i++){\rans[i] += ((i-1)*((ans[i-1]+ans[i-2])%m)%m);\rans[i] -= (((i-1)*(i-2)/2%m)*ans[i-3])%m;\rans[i] += m;\rans[i] %= m;\r}\rcout\u0026lt;\u0026lt;ans[n]%m\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ","id":21,"section":"posts","summary":"Symmetric Matrix 题目描述 Count the number of n x n matrices A satisfying the following condition modulo m. Ai, j ∈ {0, 1, 2} for all 1 ≤ i, j ≤ n. Ai, j = Aj, i for all 1 ≤ i, j ≤ n. Ai, 1 + Ai, 2 + \u0026hellip; + Ai, n = 2 for all 1 ≤ i ≤ n. A1, 1 =","tags":["cpp","graph_theory","dp"],"title":"NC17134","uri":"https://dyhgo.github.io/2020/05/nc17134/","year":"2020"},{"content":"A. Candies 题意 给一个数n，找一个数x，满足 x+2x+4x+8x+\u0026hellip; = n\n题解 等比数列求和，变成2^m\n然后枚举，看哪个能整除\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rlong long n,t;\rint main(){\rcin\u0026gt;\u0026gt;t;\rlong long a[32];\rfor(long long i=1;i\u0026lt;=30;i++){\ra[i] = (1\u0026lt;\u0026lt;i) - 1;\r}\rwhile(t--){\rcin\u0026gt;\u0026gt;n;\rfor(long long i=2;i\u0026lt;=30;i++){\rif((double)n/a[i] == n/a[i]){\rcout\u0026lt;\u0026lt;n/a[i]\u0026lt;\u0026lt;endl;\rbreak;\r}\r}\r}\rreturn 0;\r}\r B. Balanced Array 题意 给一数n，问是否可以构造一个数列\n数列的个数是偶数\n前半部分都是偶数，后半部分都是奇数\n前半部分的和等于后半部分\n题解 按照样例那样有规律地构造\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,t;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n;\rif((n/2) \u0026amp; 1) puts(\u0026quot;NO\u0026quot;);\relse {\rputs(\u0026quot;YES\u0026quot;);\rfor(int i=1;i\u0026lt;=n/2;i++){\rcout\u0026lt;\u0026lt;i*2\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\t}\rfor(int i=1;i\u0026lt;=n/4;i++){\rcout\u0026lt;\u0026lt;i*2-1\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r}\rfor(int i=n/4+1;i\u0026lt;=n/2;i++){\rcout\u0026lt;\u0026lt;i*2+1\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r}\rcout\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\r}\r}\rreturn 0;\r}\r C. Alternating Subsequence 题意 在一个数列中找一个子序列（可以不连续）满足奇偶穿插\n对于满足这个条件的最长子序列中，求元素和最大值\n题解 将数列按奇偶性分割，每一部分取最大值\n可以用双指针锁定区间\n我的写法需要再最后添一个相反数，否则加不到最后一块区域\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n,t,a[200005];\rconst ll inf = 0x3f3f3f3f3f3f3f3f;\rconst ll ninf = 0xc0c0c0c0c0c0c0c0;\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n;\rvector\u0026lt;ll\u0026gt; ans;\rfor(ll i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rif(a[n-1]\u0026gt;0) a[n]=-1;\relse a[n]=1;\rbool pos;\rif(a[0]\u0026gt;0){\rpos=true;\r}else pos=false;\rll l = 0;\rll r = 0;\rfor(int i=0;i\u0026lt;=n;i++){\rif(pos){\rif(a[i]\u0026gt;0) r++;\relse {\rpos^=1;\rll cnt = *max_element(a+l , a+r);\rans.push_back(cnt);\rl = r;\rr++;\r}\r}\relse{\rif(a[i]\u0026lt;0) r++;\relse{\rpos^=1;\rll cnt = *max_element(a+l , a+r);\rans.push_back(cnt);\rl = r;\rr++;\r}\r}\r}\rll foo = 0;\rfor(ll i:ans){\r//cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl;\rfoo+=i;\r}\rcout\u0026lt;\u0026lt;foo\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r D. Constant Palindrome Sum 题意 对于一个长度为n的数列（n为偶数）\n对于数列中的每个数可以进行替换，使得所有的对称的一组数字和相等\n且所有数字不超过k\n求最小替换数\n题解 对于每组数，可以替换1次，2次0次\n由于数字不超过k，所以和的范围为[2,2*k]\n因为k的数据较小，所以可以枚举，对于每个x\n求替换数，然后一直min\n如果两个数和为x，则替换数为0\n如果替换一个数，则替换之后和的范围是[min(x1,x2)+1 , max(x1,x2)+k]\n所以检查x是否落在这个范围内\n除此之外要替换2个\n所以用一个容器存数字和的个数（目的是求0个）\n存左右区间的个数（目的是不断迭代求1个）（如果用这种方法1个的个数会覆盖0个）\n剩下就是2个\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,n,k;\rint a[200005];\rint eq[2*200005];\rint l[2*200005];\rint r[2*200005];\rint one[2*200005]; //只替换一个 int ans;\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\rfor(int i=1;i\u0026lt;=n/2;i++){\req[a[i]+a[n-i+1]]++;\rl[min(a[i],a[n-i+1])+1]++;\rr[max(a[i],a[n-i+1])+k]++;\r}\rfor(int i=1;i\u0026lt;=2*k+3;i++){\rone[i] = one[i-1]+l[i]-r[i-1];\r}\rans = n+2;\rfor(int i=1;i\u0026lt;=2*k+3;i++){\rans = min(ans , n - one[i] - eq[i]); //不能用2*eq，因为one会重复计算一个eq所以要再加上一个eq }\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r//TODO reset\rfor(int i=0;i\u0026lt;2*k+2;i++) { //这里用memeset就会超时 eq[i]=l[i]=r[i]=0;\r}\r}\rreturn 0;\r}\r E. Weights Distributing 题意 给一没有权值的无向图和权值序列\n问怎样给边赋值（一一对应）使得从a到b再到c的权值和最小\n题解 由于行走路径会重复的问题\n所以可以把问题转化成从a到 i ，从i到b，从b到 I ，从 i 到c\n遍历所有的点 i\n保证 i 到 b ，a 到 i ， i 到 c 都是最短路径（路径数最少）\n将权值最小的部分赋给 b到 i 的路径上，再将较小的权值赋给 a到 i 和 i 到 c\n要让路径数最少，直接bfs预处理\n然后给权值排序，因为要不断选一段有序的权值，所以前缀和预处理\n最后要特判\n如果在样例1中，i 在 a 上，那么 i 到 b 和 i 到 c 路径重复，这种情况是绝对不可\n能最优的（总能找到反例）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll t,n,m,a,b,c;\rll mm[200005];\rll d[3][200005];\rll spre[200005];\rvector\u0026lt;ll\u0026gt; G[200005];\rconst ll inf = 0x3f3f3f3f3f3f3f3f;\rvoid bfs(ll st,ll r){\rqueue\u0026lt;ll\u0026gt; q;\rq.push(st);\rwhile(!q.empty()){\rll cnt = q.front();\rq.pop();\rfor(auto i : G[cnt]){\rif(d[r][i] == -1){\rd[r][i] = d[r][cnt]+1;\rq.push(i);\r}\r}\r}\r}\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;\r//TODO reset\rfor(ll i=0;i\u0026lt;3;i++)for(ll j=0;j\u0026lt;=n;j++) d[i][j]=-1;\rfor(ll i=0;i\u0026lt;=n;i++) G[i].clear();\rfor(ll i=1;i\u0026lt;=m;i++){\rcin\u0026gt;\u0026gt;mm[i];\r}\rsort(mm+1,mm+m+1);\rspre[1] = mm[1];\rfor(ll i=2;i\u0026lt;=m;i++){\rspre[i]=spre[i-1]+mm[i];\r}\rll t1,t2;\rfor(ll i=1;i\u0026lt;=m;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rd[0][a]=0;d[1][b]=0,d[2][c]=0;\rbfs(a,0);\rbfs(b,1);\rbfs(c,2);\rll ans = inf;\rfor(ll i=1;i\u0026lt;=n;i++){\rif(d[0][i] + d[1][i] + d[2][i] \u0026gt; m) continue;\rans = min(ans , spre[ d[1][i] ] + spre[ d[0][i] + d[1][i] + d[2][i] ]);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\r//\tfor(ll i=1;i\u0026lt;=7;i++){\r//cout\u0026lt;\u0026lt;d[2][2]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r//\t}\r//for(ll i=1;i\u0026lt;=8;i++) cout\u0026lt;\u0026lt;spre[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r//cout\u0026lt;\u0026lt;d[1][1]\u0026lt;\u0026lt;endl;\r//cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;b\u0026lt;\u0026lt;c;\rreturn 0;\r}\r ","id":22,"section":"posts","summary":"A. Candies 题意 给一个数n，找一个数x，满足 x+2x+4x+8x+\u0026hellip; = n 题解 等比数列求和，变成2^m 然后枚举，看哪个能整除 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long n,t; int main(){ cin\u0026gt;\u0026gt;t; long long a[32]; for(long long i=1;i\u0026lt;=30;i++){ a[i] = (1\u0026lt;\u0026lt;i) -","tags":["cpp","prefix","graph_theory","bfs"],"title":"Codeforces Round #636 (Div. 3) A~E","uri":"https://dyhgo.github.io/2020/04/codeforces-round-636-div.-3-a~e/","year":"2020"},{"content":"A - Circle Pond 题意 求圆周长\n题解 ac代码\nprint(int(input())*2*3.14159265)\r B - Homework 题意 给定假期的时间和每一项作业完成的时间，求这个假期能玩几天\n题解 ac代码\nn,m = map(int , input().split())\ra = list(map(int , input().split()))\rs = sum(a)\rif n\u0026gt;=s:\rprint(n-s)\relse:\rprint(-1)\r C - management 题意 告诉每个员工的老板，询问每个老板有多少个员工\n题解 ac代码\nn=int(input())\ra=input().split()\rw=[0]*n\rfor i in a:\rw[int(i)-1]+=1\rfor i in w:\rprint(i)\r D - Sum of Large Numbers 题意 看题目\n题解 由于10^100次方的作用，这个题目就转化成求从中选n个数，有几种求和的结果\n种数就是最大的n个减最小的n个\n再遍历所有的n\nac代码\nn , k = map(int , input().split())\rsum = 0\rmod = 1e9+7\rdef func(x):\rreturn (2 * n - x + 1) * x / 2 - (x - 1) * x / 2 + 1\rfor i in range(k , n+2):\rsum = (sum + func(i)) % mod\rprint(int(sum))\r E - Active Infants 题意 看题目\n题解 贪心策略，尽可能地把值最大的点放到边边上,所以可以按降序排，然后从左到右\n遍历\ndp[i][j] 表示区间 [ i , j ] 确定的最大值\ncnt\u0026lt;value,index\u0026gt; 表示当前点，即比它大的点都已安置过\n那么 dp[i[[j] = max(dp[i+1][j] + cnt.first * | cnt.second - i| , dp[i][j-1] + cnt.first * |cnt.second - j| )\n对于 dp[i+1][j] 和 dp[i][j-1] 都需要用函数进行计算，就形成dfs\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\r#define fi first\r#define se second\rusing pll = pair\u0026lt;ll,ll\u0026gt;;\rll n;\rll ans=0;\rvector\u0026lt;pll\u0026gt; vt; //存value和index ll dp[2005][2005];\rll cal(ll a,ll b,ll cnt){\rif(a\u0026gt;b) return 0;\rif(dp[a][b]!=-1) return dp[a][b];\rreturn dp[a][b] = max(cal(a+1 , b , cnt+1) + vt[cnt].fi*abs(vt[cnt].se-a) , cal(a,b-1,cnt+1) + vt[cnt].fi*abs(vt[cnt].se -b));\r}\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rll t;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;t;\rvt.emplace_back(t,i) ;\r}\rsort(vt.begin() , vt.end() , [](pll x,pll y){if(x.fi != y.fi) return x.fi\u0026gt;y.fi; return x.se\u0026gt;y.se;}); //可以直接用greater\rmemset(dp,-1,sizeof(dp));\rcout\u0026lt;\u0026lt;cal(0,n-1,0)\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - path pass i 题意 一个n个节点的树，每个节点都有一种颜色，可能重复\n对于每种颜色，输出包含这种颜色的简单路径数量\n题解 挺好一道树上dfs求路径的题\n把问题转化成所有路径 - 不包含这种颜色的路径数\n所有路径数为 C(2,n)+n\n不包含这种颜色 i 的路径可以分成两部分\n以颜色 i 作为父节点的子树，任意一条都是满足的（注意子树可能有颜色 i ）\n将 i 节点作为父节点的子树切去的剩余部分\n如果暴力求连通块的话会超时，所以要dfs（回溯思想）\n因为分成两个部分，所以维护两种信息\npath_num[i] 以i为颜色的点作为父节点中子树里面不包含此颜色的路径数量\nch_num[i] 以 i 为颜色的点作为父节点中子树的大小，包含 i 颜色\n最后\nk = n - cn_num[i]\nans = all - path_num[i] - k(k+1)/2\n对于dfs的细节在代码中标注\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint c[200005];\rvector\u0026lt;long long\u0026gt; G[200005];\rlong long path_num[200005]; //以i为颜色的点作为父节点中子树里面不包含此颜色的路径数量 long long ch_num[200005]; //以i为颜色的点作为父节点中子树的大小，包含i颜色 long long n;\rlong long ans;\rlong long dfs(long long u,long long v){\rlong long pre = ch_num[c[u]]; //dfs到u时，ch_num[i]的大小 long long cnt_ch_num = 1; //记录以u为父节点，子树的大小，包含自己所以起始为1 long long update = ch_num[c[u]]; //每次访问一个子节点就更新，目的是实时地计算路径数（需要用到残差） for(auto i:G[u]){ if(i!=v){\rlong long cntt = dfs(i,u); //返回的是以这个点为父节点的子节点数 cnt_ch_num += cntt; //扩充新的子节点数 long long delta = ch_num[c[u]] - update; //计算下一个子节点对于上一个子节点该颜色子树点的数量差 long long k = cntt - delta; //对于每个点都要更新路径数，路径数就是多出来的剩余部分(切去该颜色的点为父节点的所有子树，因为之前算过一部分\r//所以这里算残差) path_num[c[u]] += (k+1)*k/2; update = ch_num[c[u]]; //为了残差，需要更新 }\r}\rch_num[c[u]] = pre + cnt_ch_num; //子树大小为之前的部分 + 以u为父节点子树的部分 return cnt_ch_num; }\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(long long i=0;i\u0026lt;n;i++) {\rcin\u0026gt;\u0026gt;c[i];\rc[i]--;\r}\rlong long t1,t2;\rfor(long long i=0;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rt1--;t2--;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdfs(0,-1);\rfor(long long i=0;i\u0026lt;n;i++){\rlong long k=n-ch_num[i];\rans = (n+1)*n/2 - path_num[i] - (k+1)*k/2; //所有路径 - 子树部分 - 剩余部分 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r 吃了一发爆long long\ndebug很久发现，“简单路径”居然可以是自己到自己\n一直在做android作业，debug快疯掉\ndebug一天多，发现recyclerview里面没有呈现cardview居然是getItemCount(){return 0;}\n","id":23,"section":"posts","summary":"A - Circle Pond 题意 求圆周长 题解 ac代码 print(int(input())*2*3.14159265) B - Homework 题意 给定假期的时间和每一项作业完成的时间，求这个假期能玩几天 题解 ac代码 n,m = map(int , input().split()) a = list(map(int , input().split())) s = sum(a) if","tags":["cpp","greedy","graph_theory","dp"],"title":"abc163","uri":"https://dyhgo.github.io/2020/04/abc163/","year":"2020"},{"content":"A. Candies and Two Sisters 题意 将一堆糖果分给两个女孩，其中一个要比另一个多，问有几种分法\n题解 可以看出规律\nac代码\nt=int(input())\rfor i in range(t):\rn=int(input())\rprint((int)((n-1)/2))\r B. Construct the String 题意 输入a,b,c 构造字符串，使字符串的长度为a，任意b个字符有c个不同字符\n题解 如果b=6,c=4就构造类似于aaabcdaaabcd..\n其他同理\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,n,a,b;\rchar s[2005];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rfor(int i=0;i\u0026lt;a-b+1;i++){\rs[i]='a';\r}\rchar x;\rfor(int i=a-b+1, x='b';i\u0026lt;a;i++,x++){\rs[i]=x;\r}\rfor(int j=0,i=0;j\u0026lt;n;j++){\rif(i==a) i=0;\rcout\u0026lt;\u0026lt;s[i++];\r}\rcout\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C. Two Teams Composing 题意 从一个数列中，选一些数组成两个数列，使这两个数列长度相等，一个数列数字\n全部相同，一个数列数字全部不同，求最长长度\n题解 求数列中出现次数最多的个数和总共有多少种数字，瞎比较一下即可\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rmap\u0026lt;int,int\u0026gt; mp;\rint t,n;\rint num;\rint m;\rint dat[200005];\rint ans;\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rset\u0026lt;int\u0026gt; st;mp.clear();\rm=-1;\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;dat[i];\rmp[dat[i]]++;\rif(mp[dat[i]]\u0026gt;m){\rm=mp[dat[i]];\rnum=dat[i];\r}\rst.insert(dat[i]);\r}\rint rem=n-m;\rif(m\u0026lt;=st.size()-1) ans=m;\relse if(m==st.size()) ans=m-1;\relse ans=st.size();\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r D. Anti-Sudoku 题意 输入一个数独\n每行每列每宫格只能改变一个数，使每行每列每宫格有两个数相同\n题解 思维题\n把所有的1改成2\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rchar s[9][10];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rfor(int i=0;i\u0026lt;9;i++){\rcin\u0026gt;\u0026gt;s[i];\r}\rfor(int i=0;i\u0026lt;9;i++){\rfor(int j=0;j\u0026lt;9;j++){\rif(s[i][j]=='1') s[i][j]='2';\r}\r}\rfor(int i=0;i\u0026lt;9;i++){\rputs(s[i]);\r}\r}\rreturn 0;\r}\r E. Three Blocks Palindrome (hard version) 题意 求一个字符串的子串（可以不连续）使得这个子串是三块回文串\n三块回文串：字符串被分成三块（长度可以为0），第一块和第三块必须相同\n第二块可以和第一块相同也可以不同\n题解 简单版的可以暴力枚举中间块的左边界和右边界\n然后前缀存每个数字出现的次数\n设长度为n，数字最大为m\n则时间复杂度O(n*n*m*m)\n困难版时间复杂度必须降到O(k*n)\n这时候不再遍历两个边界\n而是固定一个边界，遍历一个边界，这样时间复杂度为O(k*n)\n如此只能遍历第一块的右边界（对应第三块的左边界）\n对于一个特定的数 i\n假设共有 x 个\n第一块含有这个数的个数从1遍历到 x/2 个\n这就需要一个容器存储数字 i 出现 j 次对应的下标\n确定第一块和第三块后就要找第二块哪种数字出现得最多\n这和简单版的一样，用前缀存数字 i 在下标为 j 时出现的次数\n遍历一遍所有数字\n再总体遍历一遍所有数字\n时间复杂度O(m*m*n*lgn)\n看起来会超时，但实际不会 (跑了400ms)\n本来在存储下标pos时开二维静态数组，MLE(266K)\n改成动态map (166K)\n对于时间复杂度和空间复杂度都可以再优化\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rint n;\rint num[205][200005]; //num[i][j]存数字i在下标为j时出现的次数 map\u0026lt;int,int\u0026gt; pos[205]; //map\u0026lt;j,index\u0026gt;存数字i出现第j次的下标 int main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;t);\rwhile(t--){\r//TODO reset\r/*for(int i=0;i\u0026lt;202;i++) {\rnum[i][0]=0;\rpos[i][0]=0;\r}*/\rfor (int i=0;i\u0026lt;205;i++) pos[i].clear();\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;n);\rint tmp;\rfor(int i=1;i\u0026lt;=n;i++){\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;tmp);\rfor(int j=1;j\u0026lt;=200;j++){\rif(j==tmp){\rnum[j][i]=num[j][i-1]+1;\r}\relse{\rnum[j][i]=num[j][i-1];\r}\r}\rpos[tmp].insert(make_pair(num[tmp][i],i));\r}\rint ans=1;\rfor(int i=1;i\u0026lt;=200;i++){\rfor(int j=1;j\u0026lt;=num[i][n]/2;j++){\rint l=pos[i][j]+1;\rint r=pos[i][num[i][n]-j+1]-1;\rfor(int k=1;k\u0026lt;=200;k++){\rans=max(ans,num[k][r]-num[k][l-1]+2*j);\r}\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r//for(int i=1;i\u0026lt;=4;i++) cout\u0026lt;\u0026lt;num[i][8]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r//for(int i=1;i\u0026lt;=4;i++) cout\u0026lt;\u0026lt;pos[3][i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\r}\rreturn 0;\r}\r F. Robots on a Grid 题意 不懂\n题解 不会\n","id":24,"section":"posts","summary":"A. Candies and Two Sisters 题意 将一堆糖果分给两个女孩，其中一个要比另一个多，问有几种分法 题解 可以看出规律 ac代码 t=int(input()) for i in range(t): n=int(input()) print((int)((n-1)/2)) B. Construct the String 题意 输入a,b,c 构造","tags":["cpp","prefix","string"],"title":"Codeforces Round #634 (Div. 3) A~E","uri":"https://dyhgo.github.io/2020/04/codeforces-round-634-div.-3-a~e/","year":"2020"},{"content":"A - Lucky 7 题意 问一个整数中是否含有数字7！\n题解 ac代码\ns = input()\rif '7' in list(s):\rprint('Yes')\relse:\rprint('No')\r B - FizzBuzz Sum 题意 找出不大于n的自然数中不能被3和5整除的数的和\n题解 模拟或者集成成公式O(1)\nac代码\nn = int(input())\rans=0\rfor i in range(1,n+1):\rif i%3==0 or i%5==0:\rcontinue\relse:\rans+=i\rprint(ans)\r C - Sum of gcd of Tuples (Easy) 题意 看题目\n题解 ac代码\nfrom math import gcd\rk=int(input())\rans=0\rfor i in range(1,k+1):\rfor j in range(1,k+1):\rfor m in range(1,k+1):\rans+=gcd(i,gcd(j,m))\rprint(ans)\r D - RGB Triplets 题意 看题目\n题解 存rgb对应的下标\n每次for循环两个颜色，在第三种颜色的下标中二分查找\n时间复杂度O(n^2lgn)\n这种方法不是很高效，跑了1600ms\n利用乘法原理，跑一遍字符串应该可以O(n)\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rchar s[4005];\rvector\u0026lt;int\u0026gt; c[3];\rlong long ans=0;\rvoid sol(int q,int w,int e){\rfor(int i:c[q]) for(int j:c[w]){\rif(j\u0026gt;i){\rvector\u0026lt;int\u0026gt;::iterator it = upper_bound(c[e].begin(),c[e].end(),j);\rif(it!=c[e].end()){\rans+=(int)(c[e].end()-it);\rint tgt=j+j-i;\rif(find(c[e].begin(),c[e].end(),tgt)!=c[e].end()) ans--;\r}else break;\r}\r}\r}\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;s[i];\rswitch(s[i]){\rcase 'R':c[0].push_back(i);break;\rcase 'G':c[1].push_back(i);break;\rcase 'B':c[2].push_back(i);break;\r}\r}\rsol(0,1,2);\rsol(0,2,1);\rsol(1,2,0);\rsol(1,0,2);\rsol(2,1,0);\rsol(2,0,1);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r//cout\u0026lt;\u0026lt;s+1\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Sum of gcd of Tuples (Hard) 题意 C题的升级版，个人觉得出得很好\n官方题解，巧妙易懂\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll =long long;\rll n,k;\rll ans;\rll dp[1\u0026lt;\u0026lt;17];\rconst ll mod = 1e9+7;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(ll i=k;i\u0026gt;0;i--){\rdp[i]=qpow(k/i , n);\rfor(ll j=i+i;j\u0026lt;=k;j+=i){\rdp[i]-=dp[j]; //+mod%mod防溢出 }\r}\rfor(ll i=1;i\u0026lt;=k;i++) ans=(ans+dp[i]*i)%mod;\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Select Half 题意 看题目\n题解 贪心dp\n对于当前数，有两种情况，选和不选\n如果前一个数选了，这个数就不能选\n如果前一个数不选，这个数可选可不选，取决于选了是否会贡献\n对于下标的奇偶性需要分开判断\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll dat[1\u0026lt;\u0026lt;18];\rll sum[1\u0026lt;\u0026lt;18];\rll dp[1\u0026lt;\u0026lt;18];\rll n;\rint main(){\rcin\u0026gt;\u0026gt;n;\rfor(ll i=0;i\u0026lt;n;i++) {\rcin\u0026gt;\u0026gt;dat[i];\rif(i\u0026gt;=2 and i%2==0) sum[i]=dat[i]+sum[i-2];\relse if(i==0) sum[i]=dat[i];\r}\rfor(ll i=0;i\u0026lt;n;i++){\rif(i\u0026amp;1){\rdp[i]=max(dp[i-2]+dat[i] , sum[i-1]);\r}\relse{\rdp[i]=max(dp[i-2]+dat[i] , dp[i-1]);\r}\r}\rcout\u0026lt;\u0026lt;dp[n-1]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":25,"section":"posts","summary":"A - Lucky 7 题意 问一个整数中是否含有数字7！ 题解 ac代码 s = input() if '7' in list(s): print('Yes') else: print('No') B - FizzBuzz Sum 题意 找出不大于n的自然数中不能被3和5整除的数的和 题解 模拟或","tags":["cpp","greedy","number_theory","dp"],"title":"abc162","uri":"https://dyhgo.github.io/2020/04/abc162/","year":"2020"},{"content":"How many integers can you find Problem Description Now you get a number N, and a M-integers set, you should find out how many integers which are small than N, that they can divided exactly by any integers in the set. For example, N=12, and M-integer set is {2,3}, so there is another set {2,3,4,6,8,9,10}, all the integers of the set can be divided exactly by 2 or 3. As a result, you just output the number 7.\nInput There are a lot of cases. For each case, the first line contains two integers N and M. The follow line contains the M integers, and all of them are different from each other. 0\u0026lt;N\u0026lt;2^31,0\u0026lt;M\u0026lt;=10, and the M integer are non-negative and won’t exceed 20.\nOutput For each case, output the number.\nSample Input 12 2\n2 3\nSample Output 7\nSolution 容斥原理\nac代码\n几个注意点\ndata可能为0(这时候可以忽略)\n要开long long(一直没想到)\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rlong long n,m;\rlong long dat[11];\rlong long ans=0;\rvector\u0026lt;long long\u0026gt; vt;\rlong long mm;\rmain(){\rwhile(~scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;mm)){\rans=0; vt.clear();\rn--;\rlong long temp;\rfor(long long i=0;i\u0026lt;mm;i++) {\rcin\u0026gt;\u0026gt;temp;\rif(temp!=0)\rvt.push_back(temp);\r}\rm=vt.size();\rlong long x=0;\rfor(auto i:vt){\rdat[x++]=i;\r}\rfor(long long i=1;i\u0026lt;(1\u0026lt;\u0026lt;m);i++){ //i从1开始 long long lcm=1;\rfor(long long j=0;j\u0026lt;m;j++){\rif(i\u0026gt;\u0026gt;j\u0026amp;1){\rlcm=(lcm*dat[j])/__gcd(lcm,dat[j]);\r}\rif(lcm\u0026gt;n) break;\r}\rif(__builtin_popcount(i)\u0026amp;1) ans+=n/lcm;\relse ans-=n/lcm;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\r}\r ","id":26,"section":"posts","summary":"How many integers can you find Problem Description Now you get a number N, and a M-integers set, you should find out how many integers which are small than N, that they can divided exactly by any integers in the set. For example, N=12, and M-integer set is {2,3}, so there is another set {2,3,4,6,8,9,10}, all the integers of the set can be divided exactly by 2 or 3. As","tags":["cpp","counting"],"title":"hduoj1796","uri":"https://dyhgo.github.io/2020/04/hduoj1796/","year":"2020"},{"content":"A . 打怪 题解 模拟\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint t,a,b,c,d;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d;\rif(b\u0026gt;=c || d\u0026lt;=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\relse{\rint num=0;\rint cx=c;\rbool me=true;\rwhile(a\u0026gt;0){\rif(me){\rcx-=b; me^=1;\r}\relse{\ra-=d;me^=1;\r}\rif(cx\u0026lt;=0) {\rcx=c;num++;me=true;\r}\r}\rif(num\u0026gt;10000) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;else cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r B . 吃水果 题解 贪心\n其实就是找一些操作使两数相等，如果小的数*2比大的数小就*2，否则随着数的\n递减，y/x增大，需要乘很多次2才能相等\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint n,m;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rint c=0;\rwhile(n!=m){\rif(n\u0026gt;m) swap(n,m);\rif(2*n\u0026lt;=m) {\rn*=2;c++;\r}\relse{\rn--;m--;c++;\r}\r}\rcout\u0026lt;\u0026lt;c+n\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C . 四个选项 题解 z[12]用来存12道题的选项，每次停留在一道题时，根据剩余选项数进行dfs\n每次搜索到末尾时判断是否满足第i题和第j题答案相同，都相同则方案数+1\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint num[5];\rint z[13];\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vt;\rint ans=0;\rint m;\rvoid dfs(int ind){\rif(ind==13){\rbool flag=true;\rfor(auto i:vt){\rif(z[i.first]!=z[i.second]) {\rflag=false;break;\r}\r}\rif(flag) {\rans++;return;\r}\r}\rfor(int i=1;i\u0026lt;=4;i++){\rz[ind]=i;\rif(num[i]){\rnum[i]--;\rdfs(ind+1);\rnum[i]++;\r}\r}\r}\rint main(){\rcin\u0026gt;\u0026gt;num[1]\u0026gt;\u0026gt;num[2]\u0026gt;\u0026gt;num[3]\u0026gt;\u0026gt;num[4]\u0026gt;\u0026gt;m;\rint t1,t2;\rwhile(m--) {\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rvt.emplace_back(t1,t2);\r}\rdfs(1);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D . 最短路变短了 题解 设d1[x]是1到x的最短距离\nd2[x]是x到n的最短距离\n则每次反向一条边（u-\u0026gt;v,w）\n如果变短，那么一定是 1-\u0026gt;v-\u0026gt;u-\u0026gt;n\n所以只需要判断 d1[v]+w+d2[u] \u0026lt; d1[n]\n反向边的改变可能会影响d1,d2原始的数值\n但不影响结果\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rconst long long max_v=100005;\rconst long long max_q=200005;\rconst long long max_e=200005;\rconst long long inf=0x3f3f3f3f3f3f3f3f;\rstruct edge\r{\rlong long to,cost;\redge(long long to,long long cost){\rthis-\u0026gt;to=to;\rthis-\u0026gt;cost=cost;\r}\r};\rtypedef pair\u0026lt;long long,long long\u0026gt; pii; vector\u0026lt;edge\u0026gt; G1[max_v];\rvector\u0026lt;edge\u0026gt; rG[max_v];\rlong long V;\rlong long d1[max_v];\rlong long d2[max_v];\rlong long n,m,q;\rlong long t1,t2,t3;\rlong long x;\rlong long dat[max_e][3];\rvoid dijkstra(long long s,long long d[],vector\u0026lt;edge\u0026gt; G[])\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; fill(d,d+V+2,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rlong long v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(long long i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} } main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rV=n;\rfor(long long i=1;i\u0026lt;=m;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2\u0026gt;\u0026gt;t3;\redge e(t2,t3);\rG1[t1].push_back(e);\redge e1(t1,t3);\rrG[t2].push_back(e1);\rdat[i][0]=t1,dat[i][1]=t2,dat[i][2]=t3;\r}\rdijkstra(1,d1,G1);\rdijkstra(n,d2,rG);\rcin\u0026gt;\u0026gt;q;\rwhile(q--){\rcin\u0026gt;\u0026gt;x;\rlong long u=dat[x][0],v=dat[x][1],w=dat[x][2];\rif(d1[v]+d2[u]+w\u0026lt;d1[n]) puts(\u0026quot;YES\u0026quot;); else puts(\u0026quot;NO\u0026quot;);\r}\r//\tfor(long long i=1;i\u0026lt;4;i++) cerr\u0026lt;\u0026lt;d1[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cerr\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\r//\tfor(long long i=1;i\u0026lt;4;i++) cerr\u0026lt;\u0026lt;d2[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cerr\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;;\r}\r E . 相似的子串 F . 苹果树 ","id":27,"section":"posts","summary":"A . 打怪 题解 模拟 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ //freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin); int t,a,b,c,d; cin\u0026gt;\u0026gt;t; while(t--){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d; if(b\u0026gt;=c || d\u0026lt;=0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else{ int num=0; int cx=c; bool me=true; while(a\u0026gt;0){ if(me){ cx-=b; me^=1; } else{ a-=d;me^=1; } if(cx\u0026lt;=0) { cx=c;num++;me=true; } } if(num\u0026gt;10000) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;else cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; } } return 0; } B . 吃水果 题解 贪心 其实就是找","tags":["cpp","greedy","graph_theory","dfs"],"title":"牛客练习赛61(部分)","uri":"https://dyhgo.github.io/2020/04/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B61%E9%83%A8%E5%88%86/","year":"2020"},{"content":"A. Little Artem 题意 给一网格染色，黑或白。要求满足以下条件的黑方块比白方块少1\n如果是黑方块，则至少与一白方块边相邻，否则不计数\n反之亦然\n题解 左上角染白，其他全黑\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rint n,m;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;n;i++){\rfor(int j=0;j\u0026lt;m;j++){\rif(i==0 and j==0){\rcout\u0026lt;\u0026lt;'W';\r}\relse cout\u0026lt;\u0026lt;'B';\r}\rcout\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r B. Kind Anton 题意 两数组a,b\na初始时只由{0,-1,1}的子集组成\n操作方式：将一个数前面的某一个数加到这个数上\n问能否经过一些操作后得到数组b\n题解 由于一个数只会被前面的数影响，且前面的数不受影响\n再加上0,-1,1的特殊性，只需要考虑b[i]\u0026gt;a[i]时，前面是否有1\n或b[i]\u0026lt;a[i]时前面是否有-1\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rint n;\rint a[100005];\rint b[100005];\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rbool one=false;\rbool none=false;\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;b[i];\rif(a[0]!=b[0]) {\rcout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;; continue;\r}\rif(a[0]==1) one=true;\rif(a[0]==-1) none=true;\rbool ok=true;\rfor(int i=1;i\u0026lt;n;i++){\rif(b[i]\u0026gt;a[i] and !one) {\rok =false;break;\r}\rif(b[i]\u0026lt;a[i] and !none){\rok=false;break;\r}\rif(a[i]==1) one=true;\rif(a[i]==-1) none=true;\r}\rif(ok) cout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;; else cout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;;\r}\rreturn 0;\r}\r C. Eugene and an array 题意 给一数组，问有多少个“好子数组“\n定义，好子数组：这个数组是原数组的子集，元素之和不等于0，其子集都是好子\n数组\n题解 类似于依赖前缀和动态规划\n从左向右遍历，查看是否有和为0的区间，其中区间的右边界为当前数\n查看是否有和为0的区间只需要查看是否有前缀和为当前数的区间\n如果有则取最右端（因为好子数组的子集也是好子数组）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\tll n;ll x;ll sum=0;map\u0026lt;ll,ll\u0026gt; pos;ll cp=-1;ll ans=0;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rpos[0]=0;\rfor(int i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;x;\rsum+=x;\rif(pos.count(sum)) cp=max(cp,pos[sum]);\rans+=i-cp-1;\rpos[sum]=i;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D. Challenges in school №41 E. Road to 1600 F. Kate and imperfection ","id":28,"section":"posts","summary":"A. Little Artem 题意 给一网格染色，黑或白。要求满足以下条件的黑方块比白方块少1 如果是黑方块，则至少与一白方块边相邻，否则不计数 反之亦然 题解 左上角染白，","tags":["cpp","prefix"],"title":"Codeforces Round #632 (Div. 2) A~C","uri":"https://dyhgo.github.io/2020/04/codeforces-round-632-div.-2-a~c/","year":"2020"},{"content":"题目描述 shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。\n输入描述: 第一行两个整数n，k代表点数和颜色数； 接下来n-1行，每行两个整数x,y表示x与y之间存在一条边；\n输出描述: 输出一个整数表示方案数（mod 1e9+7）。\nsample input 4 3 1 2 2 3 2 4\nsample output 39\nsolution 动态规划\ndp[i][j] 表示现在在第 i 个点，用 j 中颜色染色的方案数\n那么对于下一个点有两种情况\n1.染同一种颜色 dp[i][j]=dp[i-1][j]\n2.染不同颜色 dp[i][j]+=dp[i-1][j-1]*(k-j+1)\n最后对所有的 dp[n][i] 1\u0026lt;=i\u0026lt;=k  求和\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll n,k;\rll dp[305][305];\rconst ll mod = 1e9+7;\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rdp[0][0]=1;\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=1;j\u0026lt;=k;j++){\rdp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-j+1))%mod;\r}\rll ans=0;\rfor(int i=1;i\u0026lt;=k;i++){\rans=(ans+dp[n][i])%mod;\r}\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 排列组合\n把问题转化成将树分解成不大于 k 个连通块的方案数\n将树分解成 i 个连通块，就要删掉 i-1 条边\n总共有\n$$\\ C_{n-1}^{i-1}$$\n种方案\n对于每一种方案，染 i 中颜色\n就有\n$$\\ A_{k}^{i}$$\n种方案\n所以一共有\n$$ \\sum\\limits_{i=1} ^ {min(n,k)} {\\ C_{n-1}^{i-1}\\ A_{k}^{i}} $$\n然后模拟\n逆元法\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll n,k;\rconst ll mod = 1e9+7;\rll inv[305];\rll fac[305];\rinline ll C(ll m,ll n){\rreturn fac[n]*inv[m]%mod*inv[n-m]%mod;\r}\rinline ll A(ll m,ll n){\rreturn fac[n]*inv[n-m]%mod;\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(ll i=0;i\u0026lt;=n;i++){\rfac[i]=1;\r}\rfor(ll i=2;i\u0026lt;=n;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\r//for(int i=1;i\u0026lt;=9;i++) cout\u0026lt;\u0026lt;fac[i]\u0026lt;\u0026lt;endl;\rinv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u0026lt;=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\rfor(ll i=2;i\u0026lt;=n;i++){\rinv[i]=(inv[i]*inv[i-1])%mod;\r}\rll ans=0;\rfor(ll i=1;i\u0026lt;=min(n,k);i++){\rans=(ans+C(i-1,n-1)*A(i,k)%mod)%mod;\r}\rcout\u0026lt;\u0026lt;ans%mod;\rreturn 0;\r}\r 快速幂法\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll n,k;\rconst ll mod = 1e9+7;\rll fac[305];\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rinline ll cal(ll i){\rreturn fac[n-1]*fac[k]%mod*qpow(fac[i-1],mod-2)%mod*qpow(fac[n-i],mod-2)%mod*qpow(fac[k-i],mod-2)%mod;\r}\rint main(){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(ll i=0;i\u0026lt;=n;i++){ //fac[0]=1!!!\rfac[i]=1;\r}\rfor(ll i=2;i\u0026lt;=n;i++){\rfac[i]=(fac[i-1]*i)%mod;\r}\rll ans=0;\rfor(ll i=1;i\u0026lt;=min(k,n);i++){\rans=(ans+cal(i))%mod;\r}\rcout\u0026lt;\u0026lt;ans%mod;\rreturn 0;\r}\r ","id":29,"section":"posts","summary":"题目描述 shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的","tags":["cpp","number_theory","dp"],"title":"NC13611","uri":"https://dyhgo.github.io/2020/04/nc13611/","year":"2020"},{"content":"A - ABC Swap 题意 给三个数a,b,c，交换ab的值，交换ac的值，输出\n题解 模拟\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint a,b,c;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;\rswap(a,b);\rswap(a,c);\rcout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r B - Popular Vote 题意 有n件商品，每种商品有一价格，给一数m\n求能否从中选出m件商品使得它们的价格都不小于商品总价格（n件）/(4*m)\n题解 对价格求和，求出界限，对商品价格排序，检查前m件商品价格是否都满足这个限\n制\nac代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r//using ll = long long;\rint n,m;\rint a[1005];\rbool cmp(int a,int b){\rreturn a\u0026gt;b;\r}\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;n;i++)cin\u0026gt;\u0026gt;a[i];\rint sum=0;\rfor(int i=0;i\u0026lt;n;i++) sum+=a[i]; int b=ceil((double)sum/(4*m));\r//cout\u0026lt;\u0026lt;sum;\r//cout\u0026lt;\u0026lt;b;\rbool ok=true;\rsort(a,a+n,cmp);\r//int ans=0;\rfor(int i=0;i\u0026lt;m;i++){\r//ans+=a[i];\rif(a[i]\u0026lt;b){\rok=false;\rbreak;\r}\r}\rputs(ok? \u0026quot;Yes\u0026quot;:\u0026quot;No\u0026quot;);\rreturn 0;\r}\r C - Replacing Integer  题意 给俩数n,k\n一直做如右操作，将n替换成|n-k|\n求这个过程中n能达到的最小值\n题解 找规律，不断地去迎合所有的情况，就会莫名其妙ac\n或者用数学方法做\nac代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n,k;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rif(n==k){\rcout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\r}\relse{\rif(n\u0026lt;k) n=k+(k-n);\rcout\u0026lt;\u0026lt;min((k-n%k)%k,n-k)\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r D - Lunlun Number 题意 定义“lunlun数”：对于一个数，相邻两个位数的数字差不大于1\n给一数n，求第n个“lunlun数”\n题解 预处理最大的情况\ndfs，dp都行\n数字，字符串都行\n此处用bfs做\n对于一个数，在它的末尾增加新的数字，9和0有两种情况，其他有三种情况\n先处理一位数，再处理两位数。。。\n用bfs经典方法队列实现\n用maxn进行循环退出判断\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rvector\u0026lt;string\u0026gt; vt;\rint num=0;\rqueue\u0026lt;string\u0026gt; q;\rbool cmp(string s1,string s2){\rif(s1.length()==s2.length()){\rreturn s1\u0026lt;s2;\r}\relse return s1.length()\u0026lt;s2.length();\r}\rint main(){\rq.push(\u0026quot;1\u0026quot;);\rq.push(\u0026quot;2\u0026quot;);\rq.push(\u0026quot;3\u0026quot;);\rq.push(\u0026quot;4\u0026quot;);\rq.push(\u0026quot;5\u0026quot;);\rq.push(\u0026quot;6\u0026quot;);\rq.push(\u0026quot;7\u0026quot;);\rq.push(\u0026quot;8\u0026quot;);\rq.push(\u0026quot;9\u0026quot;);\rwhile(!q.empty() and num\u0026lt;100005){\rstring s=q.front();\rq.pop();\rvt.push_back(s);\rnum++;\rint len=s.length();\rchar ch=s[len-1];\rif(ch=='9'){\rq.push(s+'8');\rq.push(s+'9');\r}\relse if(ch=='0'){\rq.push(s+'0');\rq.push(s+'1');\r}\relse{\rchar ch1= ch-1,ch2=ch,ch3=ch+1;\rstring s1=s,s2=s,s3=s;\rs1.insert(s1.end(),ch1);\rs2.insert(s2.end(),ch2);\rs3.insert(s3.end(),ch3);\rq.push(s1);\rq.push(s2);\rq.push(s3);\r}\r}\rsort(vt.begin(),vt.end(),cmp);\rint n;cin\u0026gt;\u0026gt;n;\rn--;\rcout\u0026lt;\u0026lt;vt[n]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r cmp可以用lambda表达式写\nE - Yutori 题意 给两个数k,c和一串由ox组成的字符串，表示每一天\n从中选k天上班\n限制条件：x不能上班，上完一天班后要连续休息c天\n求所有可能的上班方案中，哪一天是必须上班的\n题解 枚举必超时\n其实只要贪心地从第一个开始选k个，从最后开始贪心地往前选k个\n查看是否有交集就可\n小证明\n如果交集为空集，则不存在，因为这两种情况是所有情况的子集\n如果存在（数量不大于k，下证），则对于所有中间取的情况一定会和左右两种情\n况重叠，左右取产生的交集是最苛刻的满足条件\n有几个细节\n1.可以特判n==2\n2.当从最左边开始选可以选到k+1个，则不存在必须上班的那一天\n小证明\n如果有k+1天，则随便从中选一天不上班，其余的天数都上班\n对于所有的情况，它们的交集为空集，与右边的交集为空集（空集与任何集合\n的交集都为空集）\n3.同理右边也不能选到k+1个\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,k,c;\rchar s[200005];\rset\u0026lt;int\u0026gt; st;\rset\u0026lt;int\u0026gt; st2;\rset\u0026lt;int\u0026gt; st3;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rscanf(\u0026quot;%d%d%d%s\u0026quot;,\u0026amp;n,\u0026amp;k,\u0026amp;c,s);\rint cnt=0;\rfor(int i=0;i\u0026lt;n;i++){\rif(s[i]=='o') {\rst.insert(i+1);\rcnt++;\ri+=c;\r}\rif(cnt\u0026gt;k) return 0; //一定不存在必须工作的一天 }\rcnt=0;\rfor(int i=n-1;i\u0026gt;=0;i--){\rif(s[i]=='o'){\rst2.insert(i+1);\rcnt++;\ri-=c;\r}\rif(cnt\u0026gt;k) return 0; //一定不存在必须工作的一天 }\rset_intersection(st.begin(),st.end(),st2.begin(),st2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot;\\n\u0026quot;));\rreturn 0;\r}\r F - Division or Substraction 题意 给俩数n,k（2\u0026lt;=k\u0026lt;=n）\n不断进行如下操作\n如果k能整除n，则n/=k\n否则n-=k\n当n\u0026lt;k时停机\n问满足最后n==1的k的个数\n题解 设置一个计数器，遍历所有的k进行判断\n这样会T，所以进行优化\n首先只需遍历到√n（下证）\n对于每个k\n分两种情况\n如果n%k==1，则满足条件\n且(n-1)/k也满足条件\n如果n%k==0则不断进行n/=k\n最后判断是否n%k==1\n这种情况下只有k满足条件，计数器计数\n注意k*k=n-1只能计一个数\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rll n;\rcin\u0026gt;\u0026gt;n;\rif(n==2) {\rcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl;return 0;\r}\rll ans=2; //n和n-1 for(ll i=2;i*i\u0026lt;=n;i++){\rif(n%i==1){\rif(i*i==n-1) ans++; else ans+=2;\r}\relse if (n%i==0){\rll t=n;\rwhile(t%i==0) t/=i;\rif(t%i==1) ans++;\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":30,"section":"posts","summary":"A - ABC Swap 题意 给三个数a,b,c，交换ab的值，交换ac的值，输出 题解 模拟 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; swap(a,b); swap(a,c); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; return 0; } B - Popular Vote 题意 有n件商品，每","tags":["cpp","bfs","number_theory"],"title":"abc161","uri":"https://dyhgo.github.io/2020/04/abc161/","year":"2020"},{"content":"A. Dreamoon and Ranking Collection 题意 给n个数和数字k，你可以对数列进行扩充k个数，使得扩充后的数列出现1~m的\n数字至少一次，求m的最大值\n题解 用计数器对原始数列计数，如果不连续，则k递减，直到k耗光，最后还要判断\n原始数列能否再连续下去，直到断开\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,x;\rint a[105];\rint t;\rset\u0026lt;int\u0026gt; s;\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\r//reset\rs.clear();\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x;\rfor(int i=0;i\u0026lt;n;i++)\rcin\u0026gt;\u0026gt;a[i];\r//sort(a,a+n);\rfor(int i=0;i\u0026lt;n;i++){\rs.insert(a[i]);\r}\rint cnt=1;set\u0026lt;int\u0026gt;::iterator it;\rfor(it =s.begin();it!=s.end();){\rif((*it)!=cnt){\rx--;cnt++;\r}\relse {\rit++;\rcnt++;\r}\rif(x==0) break;\r}\rif(it==s.end() and x!=0){\rcnt+=x;\r}\rwhile(*it==cnt){\rit++;cnt++;\r}\rcout\u0026lt;\u0026lt;cnt-1\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. Dreamoon Likes Permutations 题意 定义“排列”为一个长度为n的数列，数列中1~n的数字必须且只能出现一次\n给一数列，对数列进行切割，将数列分成两部分，使得两部分都是“排列”\n求分割方案数\n题解 用两个集合存左右两部分\n如果两个集合的最大值都等于数量，则这种分割可以得到排列\n遍历数组，同时对俩集合进行增删操作\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rint n;\rint a[200005];\rset\u0026lt;int\u0026gt; s1;\rset\u0026lt;int\u0026gt; s2;\rvector\u0026lt;int\u0026gt; ans;\rint num[200005];\rint main(){\rios::sync_with_stdio(0);cin.tie(0);\r//\tfreopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\r//TODO reset\rs1.clear();\rs2.clear();\rans.clear();\rmemset(num,0,sizeof(num));\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\r}\r//preprocess\rs1.insert(a[0]);\rfor(int i=1;i\u0026lt;n;i++){\rs2.insert(a[i]);\rnum[a[i]]++;\r}\rfor(int i=1;i\u0026lt;n;i++){\rif(s1.size()==i and s2.size()==n-i and *(--s1.end())==i and *(--s2.end())==n-i){\rans.push_back(i);\r}\rs1.insert(a[i]);\rif(num[a[i]]==1){\rs2.erase(a[i]);\r}\rnum[a[i]]--;\r}\rif(ans.size()!=0)\r{\rcout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl;\rfor(auto i:ans){\rcout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;n-i\u0026lt;\u0026lt;endl;\r}\r}\relse cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C. Dreamoon Likes Coloring 题意 给一数列，每次可以对其中连续的li个元素进行染色，每次染的颜色都不相同，问\n所有染色结束后，能否使所有数字都染色，且每种颜色都存在\n题解 首先特判\n如果区间的长度和小于数列长度，则不存在\n如果对于第i个长度，区间的起始位置小于i，则不存在\n贪心法\n让第一个区间从第一个数开始，第二个区间从第二个数开始。。。\n这样就能保证至少有一个数染这种颜色\n但这样会出现一个问题\n当所有区间都用完之后，右边的数可能不会染色\n这时候就要将某些区间右移（不能在放在第i个）\n判断条件就是，对于这个区间，是否存在右边为空的情况（即n-sum\u0026gt;i）\n其中sum为剩余部分长度和\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n,m;\rll l[100005];\rll sum=0;\rll ans[100005];\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rbool ok=true;\rfor(int i=0;i\u0026lt;m;i++) {\rcin\u0026gt;\u0026gt;l[i];\r//l[i];\rsum+=l[i];\rif(n-l[i]+1\u0026lt;=i){\rok=false;\r}\r}\rif(!ok or sum\u0026lt;n) {\rcout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\rreturn 0;\r}\relse{\rfor(int i=0;i\u0026lt;m;i++){\rif(n-sum\u0026gt;i){\rans[i]=n-sum;\r}\relse ans[i]=i;\rsum-=l[i];\r}\rfor(int i=0;i\u0026lt;m;i++) cout\u0026lt;\u0026lt;ans[i]+1\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;return 0;\r}\r}\r D. Dreamoon Likes Sequences 题意 给俩数d,m\n求满足下列条件的数列的个数%m\n1\u0026lt;= a1 \u0026lt; a2 \u0026lt;\u0026hellip; \u0026lt; an \u0026lt;=d\na1 XOR a2 \u0026gt; a1\na1 XOR a2 XOR a3 \u0026gt; a1 XOR a2\na1 XOR a2 XOR a3 XOR a4 \u0026gt; a1 XOR a2 XOR a3\n\u0026hellip;\u0026hellip;.\n题解 二进制构造 + 动态规划\n对于一个数a，构造一个数b，使得b\u0026gt;a ，且 b XOR a \u0026gt; a\na的二进制首位为0（可以添加0，没影响）\nb的二进制首位为1\n那么b XOR a 的首位一定为1，满足条件\nb的首位为1，其他位随便填\n所以dp[i]表示长度为i的个数\n那么dp[i] = (2^i) * dp[i-1] + dp[i-1] （加上之前的个数）\n但这样一直做可能会超过d\n所以要判断条件2^i\u0026lt;=d\n剩余的部分不再有2^i种\n而是d-2^i+1种\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll d,m,t;\rll dp[30];\rll init=2;\rint main(){\r//\tfreopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;d\u0026gt;\u0026gt;m;\rif(d==1){\rcout\u0026lt;\u0026lt;1%m\u0026lt;\u0026lt;endl;\r}\relse{\rdp[0]=init;\rint i;\rfor( i=1;(1\u0026lt;\u0026lt;i)\u0026lt;=d;i++){\rdp[i]=(1\u0026lt;\u0026lt;i)*dp[i-1]%m+dp[i-1]%m;\r}\ri--;\rdp[i]=(d-(1\u0026lt;\u0026lt;i)+1)*dp[i-1]%m+dp[i-1]%m;\rcout\u0026lt;\u0026lt;(dp[i]-1+m)%m\u0026lt;\u0026lt;endl; //加m防止溢出 }\r}\rreturn 0;\r}\r ","id":31,"section":"posts","summary":"A. Dreamoon and Ranking Collection 题意 给n个数和数字k，你可以对数列进行扩充k个数，使得扩充后的数列出现1~m的 数字至少一次，求m的最大值 题解 用计数器对原始数列计数","tags":["cpp","dp","construct","greedy","data_structure"],"title":"Codeforces Round #631 (Div. 2) A~D","uri":"https://dyhgo.github.io/2020/04/codeforces-round-631-div.-2-a~d/","year":"2020"},{"content":"#0 0操作数检查 如果有一个数为0，则可以直接得出结果\n#1 用补码表示阶码，尾数 阶码的符号位为两位\n尾数的个位为符号位\n#2 对阶 小阶向大阶对齐（看原码），被对阶的数尾数右移阶差个\n#3 尾数加 将两个尾数相加得到新的尾数\n#4 溢出处理 太复杂，不作考虑\n#4 规格化处理 先检查是否规格化，如果尾数符号位与最高位相同则非规格化\n尾数左移直到规格化为止，阶码减少左移的位数（不含符号位）\n#5 舍入处理 最低有效位为0舍去，为1则尾数+1\n#6 还原 将补码还原成原码\nE.G. 1.设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y]\nx= 2^(-011) * (0.100101)\ny = 2^(-010) * (-0.011110)\n解：\n第一步，补码表示\nx :11 101 , 0.100101\n y : 11 110 , 1.100010\n第二步\n对阶，x阶小，y阶大，x向y对阶，阶差为1，所以x尾数右移一个\nx阶码变成与y相同，阶码为 11 110\n尾数0.010010(1)\n第三步\n尾数加\n 0. 0 1 0 0 1 0 (1)\r1. 1 0 0 0 1 0\r-------------------------\r1. 1 1 0 1 0 0 (1)  结果为\n1.110110(1) 符号位与最高位都是1，非规格化\n第四步\n规格化\n尾数左移两位变成 1.010010\n阶码减2（符号位不变），变成 11 100 \n第五步\n舍入处理\n没得舍入\n第六步\n还原\nx+y = 2^(-4) * (-0.101110)\n对于[x-y]\n根据[x-y]补码 = [x]补码 + [-y]补码\n在第三步尾数加时\n 0. 0 1 0 0 1 0 (1)\r0. 0 1 1 1 1 0\r-------------------------\r0. 1 1 0 0 0 0 (1)  结果为 0.110000(1)\n最高有效位和符号位不同，是规格化\n最低有效位为1\n尾数+1变成 0.110001\n还原\nx-y = 2^(-2) * (0.110001)\n=========================================================\n设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y]  x=2^(-101) × （-0.010110）\n y=2^(-100) × （0.010110）\n解：\n第一步\n补码表示\nx : 11 011 , 1.101010\ny : 11 100 , 0.010110\n第二步\n对阶，x阶小，y阶大\nx阶码变成y，阶差1，x尾数右移1位\nx : 11100 , 1.110101(0)\n第三步\n尾数加\n 1. 1 1 0 1 0 1 (0)\r0. 0 1 0 1 1 0\r-------------------------\r0. 0 0 1 0 1 1 (0)  结果为 0.001011(0)\n符号位与最高有效位相同，非规格化\n第四步\n规格化\n尾数左移两位，阶码减2\n尾数 0.101100\n阶码 11 010\n第五步\n舍入处理\n无需舍入\n第六步\n还原\nx+y = 2^(-6) * (0.101100)\n同理x-y的尾数加为\n 1. 1 1 0 1 0 1 (0)\r1. 1 0 1 0 1 0\r-------------------------\r1. 0 1 1 1 1 1 (0)  结果为 1.011111(0)\n符号位和最高有效位不同，为规格化\n最低有效位为0，全舍弃\n还原\nx-y = 2^(-4) * (-0.100001)\n（有缺漏，待改正）\n","id":32,"section":"posts","summary":"#0 0操作数检查 如果有一个数为0，则可以直接得出结果 #1 用补码表示阶码，尾数 阶码的符号位为两位 尾数的个位为符号位 #2 对阶 小阶向大阶对齐（看原码），","tags":["cs"],"title":"浮点数加减法","uri":"https://dyhgo.github.io/2020/04/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B3%95/","year":"2020"},{"content":"A. Exercising Walk 题意 给一坐标范围，初始位置，和左右上下移动的步数，问是否会出界\n题解 加各种条件判断即可\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rint a,b,c,d,x,y,x1,y1,x2,y2;\rbool ok;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rok=true;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y2;\rif( (a-b\u0026gt;=0 and x-x1\u0026lt;a-b) or (b-a\u0026gt;0 and x2-x\u0026lt;b-a) or (c-d\u0026gt;0 and y-y1\u0026lt;c-d) or (d-c\u0026gt;0 and y2-y\u0026lt;d-c) or (a==b and a!=0 and x1==x and x2==x) or (c==d and c!=0 and y1==y and y2==y) )\rok = false;\rif(ok) puts(\u0026quot;yes\u0026quot;); else puts(\u0026quot;no\u0026quot;);\r}\rreturn 0;\r}\r B. Composite Coloring 题意 给n个合数上色，要求相同颜色的数字必须不互质，求最小着色数和着色方案\n（题目保证着色数不大于11，且值不大于1000）\n题解 两个合数不互质，即最小质因子相同\n对每个数求最小质因子\n相同则染同一种颜色（贪心）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,n;\rint a[1005];\rint c[1005];\rint p[]={1,2,3,5,7,11,13,17,19,23,29,31};\rset\u0026lt;int\u0026gt; st;\rbool vi[1005];\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n;\r//reset\rmemset(c,0,sizeof(c));\rst.clear();\rmemset(vi,0,sizeof(vi));\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rfor(int i=0;i\u0026lt;n;i++){\rfor(int j=1;j\u0026lt;=12;j++){\rif(a[i]%p[j]==0){\rc[i]=j;\rst.insert(j);\rbreak;\r}\r}\r}\rint num=st.size();\rint index=0;\rint cnt;\rfor(int i=0;i\u0026lt;n;i++){\rif(!vi[i]){\rcnt=c[i];\rvi[i]=true;\rindex++;\rc[i]=index;\rfor(int j=i+1;j\u0026lt;n;j++){\rif(!vi[j] and c[j]==cnt){\rc[j]=index;\rvi[j]=true;\r}\r}\r}\r}\rcout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C. K-Complete Word 题意 给一字符串和k，要求改其中一些字符，使字符串是回文串且周期为k，求最小改\n动数\n题解 把字符串分成k个部分，每个部分都是回文串\n字符串中的一些字符是相互捆绑的（即要相同），与其他字符相互独立\n对于相互捆绑的字符，查询出现次数最多的字符，然后都替换成它\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,n,k;\rstring s;\rint kp;\rint z[27];\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rcin\u0026gt;\u0026gt;s;\r//reset\r//memset(z,0,sizeof(z));\rkp=0;\rfor(int i=0;i\u0026lt;=k-i-1;i++){\rmemset(z,0,sizeof(z));\rfor(int j=i;j\u0026lt;n;j+=k){\rz[s[j]-'a']++;\r}\rif(i\u0026lt;k-i-1)\r{\rfor(int j=k-i-1;j\u0026lt;n;j+=k){\rz[s[j]-'a']++;\r}\r}\rkp+=*max_element(z,z+27);\r//cout\u0026lt;\u0026lt;*max_element(z,z+27)\u0026lt;\u0026lt;endl;\r}\rcout\u0026lt;\u0026lt;n-kp\u0026lt;\u0026lt;endl;\r}\r}\r D. Walk on Matrix 题意 给一矩阵，从矩阵的左上角走到右下角，只能往右和往下走\n走到一个元素上，则自身的值变为当前自身的值\u0026amp;元素上的值\n存在一种走法使得最后得到的值最大\n给一dp算法和k，求满足经dp算法算出的值和最大值差k的矩阵\n题解 构造矩阵\n让最大值为k\n经dp算法输出的值为0\n根据(m+k)\u0026amp;k=k , (m+k)\u0026amp;m=m , m\u0026amp;k=0\n其中m的二进制位1000\u0026hellip;\n进行构造（不唯一）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint m=(1\u0026lt;\u0026lt;17);\rint k;\rint main(){\rcin\u0026gt;\u0026gt;k;\rcout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;m+k\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;m+k\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E. Height All the Same 题意 给一n*m的网格，和L，R\n在网格上进行初始化放方块，要求每一格的方块数在L到R之间\n有两种操作\n1.在两（边相邻）相邻网格上各增加一块\n2.在一个网格上增加两块\n求能够使所有网格高度相等的初始化方案数\n题解 dif=R-L+1\n当网格数量为奇数时，随便放，有dif^(n*m)种\n当网格数量为偶数时，如果dif为偶数，则有一半情况不满足（每个满足的都对应\n一个不满足的），有dif^(n*m)/2\n当dif为奇数时，则中间会多出一个没有对应的方案，有(dif^(n*m)+1)/2\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rconst ll mod = 998244353;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rll n,m,l,r;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\rll ans;\rll dif=r-l+1;\rif((n*m)\u0026amp;1) ans=qpow(dif,n*m)%mod;\relse if(dif%2==0) {\rans=qpow(dif,n*m)%mod*qpow(2,mod-2)%mod;\r}\relse{\rans=(qpow(dif,n*m)+1)%mod*qpow(2,mod-2)%mod;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\r ","id":33,"section":"posts","summary":"A. Exercising Walk 题意 给一坐标范围，初始位置，和左右上下移动的步数，问是否会出界 题解 加各种条件判断即可 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t; int a,b,c,d,x,y,x1,y1,x2,y2; bool ok; int main(){ //freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin); cin\u0026gt;\u0026gt;t; while(t--){ ok=true; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y2; if( (a-b\u0026gt;=0 and x-x1\u0026lt;a-b)","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round #630 (Div. 2) A~E","uri":"https://dyhgo.github.io/2020/04/codeforces-round-630-div.-2-a~e/","year":"2020"},{"content":"A - Coffee 题意 判断一个长度为6的字符串，第3位和第4位是否相等，第5位和第6位是否相等\n题解 模拟\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rstring s;\rcin\u0026gt;\u0026gt;s;\rif(s[2]==s[3] and s[4]==s[5]) cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;;\relse cout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;;\rreturn 0;\r}\r B - Golden Coins 题意 高桥有许多钱，可以兑换成各种硬币，每获得一枚500円的硬币，就能获得1000\n点快乐值，每获得一枚5円的硬币，就能获得5点快乐值，问最多能获得多少快乐\n值\n题解 贪心地兑换成500円的硬币，然后再兑换成5円的\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll x;\rll ans=0;\rint main(){\rcin\u0026gt;\u0026gt;x;\rans+=x/500;\rans*=1000;\rx%=500;\rans+=(x/5)*5;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Traveling Salesman around Lake 题意 在一个圆上有n个点，给定每个点的位置，问沿圆周访问所有点的最短长度\n题解 访问所有点的路径就是圆周长减去一段隔阂\n求隔阂的最大值，依次遍历即可\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,k;\rint dist[200005];\rint c;\rint ans=-1;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;n;\rc=k;\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;dist[i];\rsort(dist+1,dist+n+1);\rfor(int i=1;i\u0026lt;=n-1;i++){\rans=max(ans,dist[i+1]-dist[i]);\r}\rans=max(ans,c-dist[n]+dist[1]); //n是double不能当作index cout\u0026lt;\u0026lt;c-ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Line++ 题意 有n个点，依次连线，再把其中两个未连线的点连线\n求最短路径长度等于k的路径条数（对于所有的k=1,2,3..）\n题解 看似是图论题，其实只需要考虑两种情况\n枚举所有点对的最短距离\n1.直接按顺序走\n2.走过特殊的连线\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,x,y;\rmap\u0026lt;int,int\u0026gt; mp;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rfor(int i=1;i\u0026lt;=n;i++) for(int j=i+1;j\u0026lt;=n;j++)\rmp[min(j-i,abs(i-x)+abs(j-y)+1)]++;\rfor(int i=1;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;mp[i]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Red and Green Apples 题意 DIO有a个红苹果（X）红面包（√）和b片绿面包，c片白面包\n每片面包都有时停时间，聪明的DIO可以将白面包涂成红色或者绿色\n现在DIO要吃x片红面包和y片绿面包（！DIO居然记得吃几片面包）\nDIO的最终目的就是无限时停，问DIO最多能时停几秒\n题解 贪心地选取时停时间最多的面包\n但是有限制条件就是x和y（白色是不受限制的）\n所以从红色中选前x个，绿色中选前y个，与白色混合排序\n最后选前x+y个\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll x,y,aa,bb,cc;\rvector\u0026lt;ll\u0026gt; a,b,c;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;aa\u0026gt;\u0026gt;bb\u0026gt;\u0026gt;cc;\rll temp;\rfor(ll i=0;i\u0026lt;aa;i++) {\rcin\u0026gt;\u0026gt;temp;\ra.push_back(temp);\r}\rfor(ll i=0;i\u0026lt;bb;i++) {\rcin\u0026gt;\u0026gt;temp;\rb.push_back(temp);\r}\rsort(a.rbegin(),a.rend());\rsort(b.rbegin(),b.rend());\rfor(ll i=0;i\u0026lt;x;i++) c.push_back(a[i]);\rfor(ll i=0;i\u0026lt;y;i++) c.push_back(b[i]);\rfor(ll i=0;i\u0026lt;cc;i++) {\rcin\u0026gt;\u0026gt;temp;\rc.push_back(temp);\r}\rsort(c.rbegin(),c.rend());\rll sum=0;\rfor(ll i=0;i\u0026lt;x+y;i++) sum+=c[i];\rcout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Distributing Integers 题意 给一棵树，对于树上的一个顶点，赋值为1，然后对于已赋值顶点的相邻顶点依次\n赋值2,3,4..，求有多少种赋值方案，对于所有的顶点\n题解 又是不会做的一题\n树的拓扑序计数 + 换根\n（感谢出题人和这道题让我认识了“树的拓扑序计数”，然后第二次遇见了“换根”）\n对于某个顶点，方案数就是以这个点为根的“树的拓扑序的个数”\n树的拓扑序的个数为\n$$ {\\frac{n!}{\\prod\\limits_{} ^ {} {num}}} $$\nnum为每个节点的子节点数（含自己）\n小证明：\n如果没有限制，则排列组合有n!种\n由于子节点要排在父节点的的后面\n以根节点为例，它要排在第一个\n由于排序是随机的，所以排在第一个的概率为1/num\n同理所有的节点作为父节点时都与子节点等概率排序，所以每个都是1/num\n全部就是product(num)\nn!可以直接求\n现在要求product(num)\n为避免超时，可以用类似于记忆化搜索的思想\n先选取一个点为根（以1为例）求每个节点的子节点个数\n直接dfs\n然后求product(num[1])\n最后换根求不同节点的product(num)\n直接dfs\n此处换根product(num[i])=product(num[par])*(n-child[i])/child[i]\nac代码\n//#include\u0026quot;bits/stdc++.h\u0026quot;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\rusing namespace std;\rtypedef long long ll;\r// using pAr = product_as_root;\rconst ll mod = 1e9+7;\rll n;\rll sn[200005];\rll pAr[200005];\rvector\u0026lt;ll\u0026gt; G[200005];\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rvoid dfs_sn(ll u,ll v){\rfor(auto i:G[u]){\rif(i!=v){\rdfs_sn(i,u); sn[u]+=sn[i];\r}\r}\rsn[u]++;\r}\rvoid dfs_cr(ll u,ll v){\rfor(auto i:G[u]){\rif(i!=v){\rpAr[i]=pAr[u]*qpow(sn[i],mod-2,mod)%mod*(n-sn[i])%mod;\rdfs_cr(i,u);\r}\r}\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rll t1,t2;\rfor(ll i=0;i\u0026lt;n-1;i++) {\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdfs_sn(1,0);\r//init\rpAr[1]=1;\rfor(ll i=1;i\u0026lt;=n;i++) pAr[1]=pAr[1]*sn[i]%mod;\rdfs_cr(1,0);\r//factorial\rll fac=1;\rfor(ll i=2;i\u0026lt;=n;i++) fac=fac*i%mod;\rfor(ll i=1;i\u0026lt;=n;i++){\rcout\u0026lt;\u0026lt;fac*qpow(pAr[i],mod-2,mod)%mod\u0026lt;\u0026lt;endl;\r}\r//for(int i=1;i\u0026lt;=8;i++) cout\u0026lt;\u0026lt;pAr[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rreturn 0;\r}\r have a good day ^_^\n","id":34,"section":"posts","summary":"A - Coffee 题意 判断一个长度为6的字符串，第3位和第4位是否相等，第5位和第6位是否相等 题解 模拟 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ string s; cin\u0026gt;\u0026gt;s; if(s[2]==s[3] and s[4]==s[5]) cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;; else cout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;; return 0; } B - Golden","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"https://dyhgo.github.io/2020/03/abc160/","year":"2020"},{"content":"《星际牛仔》（カウボーイビバップ；Cowboy Bebop），是日本SUNRISE动画\n公司制作的原创电视动画，于1998年10月23日-1999年4月23日在东京电视台和\nWOWOW播出，同年夺得第三回神户动画奖的年度最佳电视动画奖，并于2000年\n获得日本科幻大会星云奖。 \u0026ndash;百度百科\n故事背景设定在2071 年。随着超光速航行技术的实现，人类得以在太阳系范围\n内方便的自由移动，但是由于设计上的失误，这一技术引发了月球的爆炸，无数\n月球碎片被吸引向地球，造成了空前绝后的大灾难。存活下来的人类逃离地球，\n并开始在太阳系各地建立家园。\n由于这次灾难，国家、政府等权力机构都极为不稳定，治安问题也成为了大难\n题。\n为了在人力资源不足的情况下抓捕罪犯，有些组织开始允许个人抓捕通缉的罪犯\n并换取奖金，“赏金猎人”这个职业也就由此诞生了。\u0026ndash;百度百科\n","id":35,"section":"posts","summary":"《星际牛仔》（カウボーイビバップ；Cowboy Bebop），是日本SUNRISE动画 公司制作的原创电视动画，于1998年10月23日-199","tags":[],"title":"星际牛仔","uri":"https://dyhgo.github.io/2020/03/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/","year":"2020"},{"content":"A. Divisibility Problem 题意 求一个数加上多少能被另一个数整除\n题解 如果b|(a+k)\n则k=b-a%b注意k=0特判\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,a,b;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;(b-(a%b)==b?0:b-(a%b))\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. K-th Beautiful String 题意 一个长度为n的字符串，由n-2个a组成和2个b组成\n求所有按字典序排列组合的第k个\n题解 只要定位b的位置就行\nb的位置是有规律的，模拟这个规律\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rlong long t,n,k;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rlong long fi=ceil((sqrt(1+8*k)-1)/2);\rlong long se=fi*(fi-1)/2;\rse=k-se;\rse=n-se; fi=n-1-fi;\rfor(long long i=0;i\u0026lt;n;i++) if(i==fi or i==se) cout\u0026lt;\u0026lt;'b'; else cout\u0026lt;\u0026lt;'a';\rcout\u0026lt;\u0026lt;endl;\r}\r}\r 没开long long WA掉一发\nC. Ternary XOR 题意 定义一种异或运算\nai XOR bi = (ai+bi)%3\n给一数c，求a,b使得(a XOR b)=c，使得max(a,b)尽可能小\nc由0,1，2组成，且首位为2\n题解 从左到右遍历\n以是否出现过1作为判断条件\n第一次出现1时，一边为0，一边为1\n之后把大的数填到之前填0的那一边\n就能保证max最小\n如果没有出现1则2分成1和1\n出现后2分成0和2\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rint n;\rshort up[50005];\rshort down[50005];\rbool one;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rone = false;\rcin\u0026gt;\u0026gt;n;\rchar temp1;\rint temp2;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;temp1;\rtemp2=temp1-'0';\rif(one){\rif(temp2==1){\rup[i]=1;down[i]=0;\r}\rif(temp2==2){\rup[i]=2;down[i]=0;\r}\rif(temp2==0){\rup[i]=0;down[i]=0;\r}\r}\relse{\rif(temp2==1) {\rone=true;up[i]=0;down[i]=1;\r} if(temp2==2){\rup[i]=1;down[i]=1;\r}\rif(temp2==0) {\rup[i]=0;down[i]=0;\r}\r}\r}\rfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;up[i]; cout\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;down[i]; cout\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r D. Carousel 题意 旋转木马的马上有很多图案，给它们涂色，要求相邻不同图案要涂不同的颜色\n问最少需要几种颜色，并求涂色方案（注意旋转木马是个环）\n题解 如果所有的图案都相同，只需要一种\n如果图案不同则有可能需要2种或3种，但不超过3种\n如果必须3种，则涂色可以为1,2,3,1,2,3\u0026hellip;（注意最后一个不能与第一个相同）（不一定）\n现在验证是否只需要2种\n因为不同的图案必须涂不同的颜色\n所以以不同的图案为点，用边连起来\n判定是否为二分图就行（同种图案涂色不受限，所以不需要考虑同种图案）\n还可以通过木马的奇偶性分类讨论\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint q;\rint n;\rint a[200005];\rint color[200005];\rvector\u0026lt;int\u0026gt; G[200005];\rbool dfs(int v,int c)\r{\rcolor[v]=c; for(int i=0;i\u0026lt;G[v].size();i++)\r{\rif(color[G[v][i]]==c) return false; if(color[G[v][i]]==0 \u0026amp;\u0026amp; !dfs(G[v][i],3-c)) return false; } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=1;i\u0026lt;=n;i++)\r{\rif(color[i]==0) if(!dfs(i,1)) return false; }\rreturn true;\r} int main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;q;\rwhile(q--){\r//reset TODO\rmemset(color,0,sizeof(color));\rfor(int i=0;i\u0026lt;=n;i++) G[i].clear();\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i];\r//特判\rbool flag=true;\rfor(int i=1;i\u0026lt;n;i++) if(a[i]!=a[i+1]) flag=false; if(a[n]!=a[1]) flag=false;\rif(flag) {\rcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\r}\relse{\r//preprocess\rfor(int i=1;i\u0026lt;n;i++){\rif(a[i]!=a[i+1]) {\rG[i].push_back(i+1);G[i+1].push_back(i);\r}\r}\rif(a[n]!=a[1]) {\rG[n].push_back(1);G[1].push_back(n);\r}\rif(bipartite_graph()){\rcout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl;\rfor(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;color[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\r}\relse{\rcout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl;\rif((n-1)%3==0) {\rfor(int i=1;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;(i%3==0? 3 : i%3 )\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; }\relse{\rfor(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;(i%3==0? 3 : i%3 )\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl; }\r}\r}\r}\rreturn 0;\r}\r E. Tree Queries 题意 给一棵树和几个树上的顶点\n问是否存在从根出发的一条简单路径\n使得所有的点都在这条路径上或离路径的距离为1\n题解 如果存在，这条路径一定是从根到深度最大的顶点\n接下来依次判断这些点是否满足这些条件\n对于某个点\n求这个点和最深的点的LCA\n判断这个点是否是LCA或LCA的子节点\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint V;\rint m;\rconst int maxv=200005;\rconst int max_logv=20;\rint data[maxv];\rint n;\rvector\u0026lt;int\u0026gt; G[maxv];\rint root=0;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(G[v][i]!=p) dfs(G[v][i],v,d+1);\r}\r}\rvoid init(int V){\rdfs(root,-1,0);\rfor(int k=0;k+1\u0026lt;max_logv;k++){\rfor(int v=0;v\u0026lt;V;v++){\rif(parent[k][v]\u0026lt;0) parent[k+1][v]=-1;\relse parent[k+1][v]=parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u]\u0026gt;depth[v]) swap(u,v);\rfor(int k=0;k\u0026lt;max_logv;k++){\rif((depth[v]-depth[u])\u0026gt;\u0026gt;k\u0026amp;1) v=parent[k][v];\r}\rif(u==v) return u;\rfor(int k=max_logv-1;k\u0026gt;=0;k--){\rif(parent[k][u]!=parent[k][v]){\ru=parent[k][u];\rv=parent[k][v];\r}\r}\rreturn parent[0][u];\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;V\u0026gt;\u0026gt;m;\rint temp1,temp2;\rfor(int i=0;i\u0026lt;V-1;i++){\rcin\u0026gt;\u0026gt;temp1\u0026gt;\u0026gt;temp2;\rG[temp1-1].push_back(temp2-1);\rG[temp2-1].push_back(temp1-1);\r}\rinit(V);\rwhile(m--){\rcin\u0026gt;\u0026gt;n;\rint maxdi;\rint maxd=-1e9;\rint temp;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;temp;\rdata[i]=temp-1;\rif(depth[data[i]]\u0026gt;=maxd) {\rmaxd=depth[data[i]];\rmaxdi=data[i];\r}\r}\r//cout\u0026lt;\u0026lt;maxdi\u0026lt;\u0026lt;endl;\rbool flag=true;\rfor(int i=0;i\u0026lt;n;i++){\rif(data[i]!=maxdi)\r{\rint foo=lca(maxdi,data[i]);\rif(!(data[i]==foo || foo==parent[0][data[i]])) {\rflag=false;break;\r}\r}\r}\rif(flag) cout\u0026lt;\u0026lt;\u0026quot;YES\u0026quot;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026quot;NO\u0026quot;\u0026lt;\u0026lt;endl; }\r//cout\u0026lt;\u0026lt;lca(2,4)\u0026lt;\u0026lt;endl;\r//for(int i=1;i\u0026lt;=4;i++) cout\u0026lt;\u0026lt;depth[i]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 因为max_logv开太小，WA了7次，一直停留在第80个测试点（我记得明明还往多了开的，难道是计算失误，还是记忆丧失）\nF. Make k Equal 题意 给一数列\n每次可进行这样的操作\n1.把最小的数+1\n2.把最大的数-1\n求最少需要多少次操作使数列中有k个相等的数\n题解 一开始想的是，这个数应该是中位数，然后从它往两边扩散，把两边的数往里压\n结果这应该不是最优解\n太困了（X）太菜了（√），直接看了别人的题解恍然大悟\n最后得到的这k个相同的数一定在数列中（由于两边往里压，中间的数可看成不变，最后的结果一定是压向不变的数）\n首先排序\n过一遍数列\n每次针对一片相同数字域\n求以此为目标需要进行的操作数\n不断min更新\n对于某块相同数字域\n遍历过程中维护数字域左边的数量lnum\n左边的和lsum\n右边的数量rnum\n右边的和rsum\n这样是便于计算操作数，降低时间复杂度\n考虑三种情况\n左边压到中间\n右边压到中间\n两边压到中间\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n,k;\rll a[200005];\rmap\u0026lt;ll,ll\u0026gt; mp;\rll lsum=0;\rll rsum=0;\rll lnum=0;\rll rnum;\rll re;\rll ans=1e15;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\rmp[a[i]]++;\rrsum+=a[i];\r}\r//特判\rfor(auto i:mp) if(i.second\u0026gt;=k) {cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;return 0;}\rrnum=n;\rfor(auto i:mp) {\rrnum-=i.second;\rrsum-=(i.first*i.second); re=k-i.second;\rif(lnum\u0026gt;=re){\rans=min(ans,(i.first-1)*lnum-lsum+re);\r}\rif(rnum\u0026gt;=re){\rans=min(ans,rsum-(i.first+1)*rnum+re);\r}\rif(re\u0026gt;=2){\rans=min(ans,(i.first-1)*lnum-lsum+re+rsum-(i.first+1)*rnum);\r}\rlsum+=(i.first*i.second);\rlnum+=i.second;\r} cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}  hava a good day ^_^\n","id":36,"section":"posts","summary":"A. Divisibility Problem 题意 求一个数加上多少能被另一个数整除 题解 如果b|(a+k) 则k=b-a%b注意k=0特判 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t,a,b; int main(){ //freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin); cin\u0026gt;\u0026gt;t; while(t--){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;(b-(a%b)==b?0:b-(a%b))\u0026lt;\u0026lt;endl; } return 0; } B. K-th","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"https://dyhgo.github.io/2020/03/codeforces-round-629-div.-3/","year":"2020"},{"content":"杀手2由IO Interactive开发，2018年发行的潜行刺杀游戏，与羞辱不同的是这是第三人称\n杀手2最大的特点是刺杀方法的丰富性\n游玩过程中会发现特别多的可能性\n里面有一个适合手残党的玩法，就是被敌人盯上时，可以一直藏着，只要等的下去，危险就会解除\n剧情很丰富，延续了杀手1\n但是剧情太短了\n玩一会就完了（指不开辟新的刺杀方式）\n地图是分区的，每一块地图也太小了\n风景做的很好，但是与NPC的互动太少了\n换装式的伪装也是一大特色\n通过这种伪装可以派生很多的玩法\n吐槽一下一种线下的狙击模式，非常的sb，简直就是4399小游戏搬过来的\n剧情 游戏剧情衔接《杀手》的剧情，戴安娜为了得到神意秘会的代理人“永恒常量”手中有关47出身来历的一切信息，说服了ICA董事会接受了来自神意秘会的契约：消灭“影子客户”并瓦解他的民兵组织。\n根据47曾经在科罗纳多获取的情报，ICA找到了关于民兵组织成员的线索：阿尔玛·雷纳德，肖恩·罗斯的前女友，当过生态恐怖分子并且是一名很有才华的外勤潜入者，目前与她的新搭档奥森·米尔斯躲\n藏在新西兰霍克斯湾的一处海滨别墅。\n47为搜寻情报而前往调查关于“影子客户”与民兵的线索。 \u0026ndash;百度百科\n","id":37,"section":"posts","summary":"杀手2由IO Interactive开发，2018年发行的潜行刺杀游戏，与羞辱不同的是这是第三人称 杀手2最大的特点是刺杀方法的丰富性 游玩过程中","tags":[],"title":"杀手2","uri":"https://dyhgo.github.io/2020/03/%E6%9D%80%E6%89%8B2/","year":"2020"},{"content":"生命周期 在containerActivity的布局中放入一个fragment，然后点击按钮，切换成另一个fragment\ncontainerActivity的布局文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.fragment.containerActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/ctnbtn1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;change_fragment\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.1\u0026quot; /\u0026gt;\r\u0026lt;FrameLayout\randroid:id=\u0026quot;@+id/ctn1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/ctnbtn1\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\randroid:layout_height=\u0026quot;0dp\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r containerActivity.java\npackage com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity {\rprivate Afragment afragment;\rprivate Bfragment bfragment;\rprivate Button ctnbtn1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rctnbtn1 = findViewById(R.id.ctnbtn1);\rctnbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rgetSupportFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).commitAllowingStateLoss();\r}\r});\rafragment = new Afragment();\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment).commitAllowingStateLoss();\r}\r}\r Afragment.java\npackage com.example.test.fragment;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\r}\r}\r fragment_a.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/fatv1\u0026quot;\randroid:text=\u0026quot;fragment_a\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.4\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r Bfragment.java和fragment_b.xml与A类似\n传数据给fragment Afragment.java\npackage com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;tk\u0026quot;,title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\u0026quot;tk\u0026quot;));\r}\r}\r@Override\rpublic void onAttach(Context context) {\rsuper.onAttach(context);\r}\r@Override\rpublic void onDetach() {\rsuper.onDetach();\r}\r}\r 通过这种方法实例化\nafragment = Afragment.newInstance(\u0026quot;hello world\u0026quot;);\r fragment的回退栈 fragment_a.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/fabtn1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;change_to_Bfragment\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.1\u0026quot; /\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/fabtn2\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;updata_text\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.2\u0026quot; /\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/fatv1\u0026quot;\randroid:text=\u0026quot;fragment_a\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.4\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r Afragment.java\npackage com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;tk\u0026quot;,title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\u0026quot;Afragment\u0026quot;,\u0026quot;----------onCreateView--------\u0026quot;);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\u0026quot;updated\u0026quot;);\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\u0026quot;tk\u0026quot;));\r}\r}\r}\r fragment_b.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/fbtv1\u0026quot;\randroid:text=\u0026quot;fragment_b\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.4\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r Bfragment.java\npackage com.example.test.fragment;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Bfragment extends Fragment {\rprivate TextView fbtv1;\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_b,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfbtv1 = view.findViewById(R.id.fbtv1);\r}\r}\r containerActivity.java\npackage com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity {\rprivate Afragment afragment;\rprivate Bfragment bfragment;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rafragment = Afragment.newInstance(\u0026quot;hello world\u0026quot;);\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment).commitAllowingStateLoss();\r}\r}\r 让Afragment不再重新加载\n改动containerActivity.java和Afragment.java即可\npackage com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity {\rprivate Afragment afragment;\rprivate Bfragment bfragment;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rafragment = Afragment.newInstance(\u0026quot;hello world\u0026quot;);\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment,\u0026quot;a\u0026quot;).commitAllowingStateLoss();\r}\r}\r package com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;tk\u0026quot;,title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\u0026quot;Afragment\u0026quot;,\u0026quot;----------onCreateView--------\u0026quot;);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rFragment fragment = null;\rif (getFragmentManager() != null) {\rfragment = getFragmentManager().findFragmentByTag(\u0026quot;a\u0026quot;);\r}\rif(fragment!=null) {\rgetFragmentManager().beginTransaction().hide(fragment).add(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\relse{\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\u0026quot;updated\u0026quot;);\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\u0026quot;tk\u0026quot;));\r}\r}\r}\r 传递数据给activity 通过接口回调\nAfragment.java\npackage com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate msgclick listener;\rpublic interface msgclick{\rvoid onclick(String s);\r}\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2,fabtn3;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;tk\u0026quot;,title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Override\rpublic void onAttach(Context context) {\rsuper.onAttach(context);\rlistener = (msgclick) context;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\u0026quot;Afragment\u0026quot;,\u0026quot;----------onCreateView--------\u0026quot;);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn3 = view.findViewById(R.id.fabtn3);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rFragment fragment = null;\rif (getFragmentManager() != null) {\rfragment = getFragmentManager().findFragmentByTag(\u0026quot;a\u0026quot;);\r}\rif(fragment!=null) {\rgetFragmentManager().beginTransaction().hide(fragment).add(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\relse{\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\u0026quot;updated\u0026quot;);\r}\r});\rfabtn3.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rlistener.onclick(\u0026quot;dedsec\u0026quot;);\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\u0026quot;tk\u0026quot;));\r}\r}\r}\r containerActivity.java\npackage com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity implements Afragment.msgclick {\rprivate Afragment afragment;\r//private Bfragment bfragment;\rprivate TextView ctntv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rafragment = Afragment.newInstance(\u0026quot;hello world\u0026quot;);\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment,\u0026quot;a\u0026quot;).commitAllowingStateLoss();\rctntv1 = findViewById(R.id.ctntv1);\r}\r@Override\rpublic void onclick(String s) {\rctntv1.setText(s);\r}\r}\r ","id":38,"section":"posts","summary":"生命周期 在containerActivity的布局中放入一个fragment，然后点击按钮，切换成另一个fragment containerA","tags":["java","xml"],"title":"Android Fragment","uri":"https://dyhgo.github.io/2020/03/android-fragment/","year":"2020"},{"content":"简单演示\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.anim2Activity\u0026quot;\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;70dp\u0026quot;\randroid:id=\u0026quot;@+id/a2tv1\u0026quot;\randroid:textSize=\u0026quot;30sp\u0026quot;\randroid:text=\u0026quot;animation_test\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\randroid:textColor=\u0026quot;#FFFFFF\u0026quot;\randroid:background=\u0026quot;#AAAAAA\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.widget.TextView;\rpublic class anim2Activity extends AppCompatActivity {\rprivate TextView a2tv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_anim2);\ra2tv1 = findViewById(R.id.a2tv1);\ra2tv1.animate().translationYBy(500).setDuration(2000).start();\r}\r}\r package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.animation.ObjectAnimator;\rimport android.animation.ValueAnimator;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.widget.TextView;\rpublic class anim2Activity extends AppCompatActivity {\rprivate TextView a2tv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_anim2);\ra2tv1 = findViewById(R.id.a2tv1);\r//a2tv1.animate().translationYBy(500).setDuration(2000).start();\r//a2tv1.animate().alpha(0).setDuration(2000).start();\r// ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100);\r// valueAnimator.setDuration(2000);\r// valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r// @Override\r// public void onAnimationUpdate(ValueAnimator animation) {\r// Log.d(\u0026quot;test\u0026quot;,animation.getAnimatedValue()+\u0026quot;\u0026quot;);\r// Log.d(\u0026quot;test\u0026quot;,animation.getAnimatedFraction()+\u0026quot;\u0026quot;);\r// }\r// });\r// valueAnimator.start();\rObjectAnimator objectAnimator = ObjectAnimator.ofFloat(a2tv1,\u0026quot;translationY\u0026quot;,1500,200,500,300,1000);\robjectAnimator.setDuration(5000);\robjectAnimator.start();\r}\r}\r ","id":39,"section":"posts","summary":"简单演示 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; xmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot; xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;match_parent\u0026quot; tools:context=\u0026quot;.anim2Activity\u0026quot;\u0026gt; \u0026lt;TextView android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;70dp\u0026quot; android:id=\u0026quot;@+id/a2tv1\u0026quot; android:textSize=\u0026quot;30sp\u0026quot; android:text=\u0026quot;animation_test\u0026quot; android:gravity=\u0026quot;center\u0026quot; android:textColor=\u0026quot;#FFFFFF\u0026quot; android:background=\u0026quot;#AAAAAA\u0026quot;/\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; public class anim2Activity extends AppCompatActivity { private TextView a2tv1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_anim2); a2tv1 = findViewById(R.id.a2tv1); a2tv1.animate().translationYBy(500).setDuration(2000).start(); } } package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.animation.ObjectAnimator; import android.animation.ValueAnimator; import android.os.Bundle; import android.util.Log; import android.widget.TextView; public","tags":["java","xml"],"title":"Android 属性动画","uri":"https://dyhgo.github.io/2020/03/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","year":"2020"},{"content":"Watch_dogs2是ubisoft于2016年11月发行的角色扮演游戏\n骇入系统是其游戏特色\n玩了130+小时\n看门狗2的这个特色很新颖，但是剧情很平淡，后面的玩法基本与前面重复\n难度也不是很高，很快就能通关，dlc就是支线剧情的复制。但是旧金山的风景还是\n很不错的，就是地图太小了。线上模式的hack玩的最多，开始被虐，后来找到技巧，虐别人就索然无味了\n线上赛车自从玩了GTA5之后真的就无趣了，经常有人莫名其妙退出\n经常受到土豆服务器的制约\n现在是真的没空玩看门狗3了\n剧情 《看门狗2》将游戏设定在距离《看门狗》故事发生之后，ctOS由1.0升级成为2.0，同时也获得了许多功能。然而，ctOS并不是像宣传的那样单纯只是为市民服务，它被不法公司，团体和个人用来监视市民，收集并出售他们个人的数据，操纵选举和扰乱社会秩序等等。游戏需要玩家跟随主人公一点一点进入《看门狗2》的庞大电子世界，揭开并粉碎敌人的阴谋。\n《看门狗2》的总监表示，游戏开发团队想在这一作上尝试一些新的点子，比如位于旧金山的游戏场景，整体色调更鲜活明亮，再搭配故事的主题、建筑风格、网络世界以及先进科技。在这样的架构中，故事风格不适合艾登‧皮尔斯，因此让马可仕担任主角来叙述故事是很合适的。 \u0026ndash;百度百科\n","id":40,"section":"posts","summary":"Watch_dogs2是ubisoft于2016年11月发行的角色扮演游戏 骇入系统是其游戏特色 玩了130+小时 看门狗2的这个特色很新颖，但是","tags":[],"title":"看门狗2","uri":"https://dyhgo.github.io/2020/03/%E7%9C%8B%E9%97%A8%E7%8B%972/","year":"2020"},{"content":"A - The Number of Even Pairs 题解 ac代码 (awk语言)\n$0=$1*--$1/2+$2*--$2/2_\r B - String Palindrome 题解 ac代码 (perl语言)\nprint\u0026lt;\u0026gt;=~/^(.+).\\1$/?Yes:No\r C - Maximum Volume 题解 ac代码 (perl语言)\nprint\u0026lt;\u0026gt;**3/27\r D - Banned K 题解 ac代码 (perl语言)\n\u0026lt;\u0026gt;;print$.-@$_,$/for grep$.+=++$#$_,glob`dd`\r E - Dividing Chocolate 题意 一块巧克力由h行w列的方块组成，每个方块为白或黑\n你可以对巧克力进行切割，切割只能沿着方块边缘横切或竖切切到底\n问最少需要切几刀，使每个独立块都有不多于k个白巧克力方块\n题解 贪心 枚举 和牛客小白月赛26的A题很像\n由于h的数据不大，枚举行的所有可能情况，先考虑横切，横切不够再竖切\n考虑竖切时，如果最大的块大于k，就实施竖切\n遍历所有情况求最小值\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint h,w,k;\rstring s[12];\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint coun=0;\rcin\u0026gt;\u0026gt;h\u0026gt;\u0026gt;w\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;h;i++){\rcin\u0026gt;\u0026gt;s[i];\r}\r//特判 //没有特判，用u=0代替 WA for(int i=0;i\u0026lt;h;i++) for(int j=0;j\u0026lt;w;j++) if(s[i][j]=='1') coun++;\rif(coun\u0026lt;=k) cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\relse{\rint ans=1e9;\rfor(int u=1;u\u0026lt;(1\u0026lt;\u0026lt;(h-1));u++){\rint x=__builtin_popcount(u);\rint cut_num=x;\rint block[x+1]={0};\rint p=0;\rint mx=0;\rbool flag=true; //没有设置flag WA for(int j=0;j\u0026lt;w;j++){\rfor(int i=0;i\u0026lt;h;i++){\rblock[p]+=s[i][j]-'0';\rmx=max(mx,block[p]);\rif(u\u0026gt;\u0026gt;i\u0026amp;1) p++;\r}\r//mx=max(mx,block[p]);\rif(mx\u0026gt;k) {\rif(j==0) { flag=false;break; }\rcut_num++;\rmx=0;\rmemset(block,0,sizeof(block));\rp=0; //没有重置p WA for(int i=0;i\u0026lt;h;i++){ //没有记忆（重新计算） WA block[p]+=s[i][j]-'0';\rmx=max(mx,block[p]);\rif(u\u0026gt;\u0026gt;i\u0026amp;1) p++;\r}\r}\rp=0; //没有重置p WA }\rif(flag) ans=min(ans,cut_num);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r 这道题做了快一个小时，WA了特别多次，每次都WA两三个测试点，主要是细节，WA点在代码中已标注\nF - Knapsack for All Segments 题意 给一数列，求对每一可能区间，其子区间内的数和等于s的子区间个数\n对所有可能区间求和\n题解 动态规划 奇妙的动态规划\ndp[i][j] = sum(f(left,i)) 当和为 j 时\n可以的得到递推式\ndp[i][j]=dp[i-1][j] \ndp[i][j]+=dp[i-1][j-data[i]]\n有一个很重要的点在代码中标出\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n,s;\rll data[3005];\rll dp[3005][3005];\rconst ll mod=998244353;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s;\rfor(ll i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;data[i];\rdp[0][0]=1;\rfor(ll i=1;i\u0026lt;=n;i++) for(ll j=0;j\u0026lt;=s;j++)\r{\rdp[i][j]=dp[i-1][j];\rif(j-data[i]\u0026gt;=0) dp[i][j]+=dp[i-1][j-data[i]];\rif(j==0) dp[i][j]++; //当j-data[i]==0时，a[i]这一个也要算上 dp[i][j]%=mod;\r}\rll ans=0;\rfor(ll i=1;i\u0026lt;=n;i++) ans=(ans+dp[i][s])%mod;\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 一遍过，芜湖~\nhave a good day ^_^\n","id":41,"section":"posts","summary":"A - The Number of Even Pairs 题解 ac代码 (awk语言) $0=$1*--$1/2+$2*--$2/2_ B - String Palindrome 题解 ac代码 (perl语言) print\u0026lt;\u0026gt;=~/^(.+).\\1$/?Yes:No C - Maximum Volume 题解 ac代码 (perl语言) print\u0026lt;\u0026gt;**3/27 D - Banned K 题解 ac代码 (","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"https://dyhgo.github.io/2020/03/abc159/","year":"2020"},{"content":"SharedPreferences sharedpreferences的布局\n布局文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.datastorage.sharedPreferencesActivity\u0026quot;\u0026gt;\r\u0026lt;EditText\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/spet1\u0026quot;\randroid:hint=\u0026quot;input\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.1\u0026quot;\r/\u0026gt;\r\u0026lt;Button\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:text=\u0026quot;sava\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/spet1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;\randroid:id=\u0026quot;@+id/spbtn1\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:text=\u0026quot;show\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/spbtn1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;\randroid:id=\u0026quot;@+id/spbtn2\u0026quot;/\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/sptv1\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/spbtn2\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;\r/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r 输入内容，存储到sharedpreferences,并呈现\npackage com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.Intent;\rimport android.content.SharedPreferences;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class sharedPreferencesActivity extends AppCompatActivity {\rprivate Button spbtn1,spbtn2;\rprivate EditText spet1;\rprivate TextView sptv1;\rprivate SharedPreferences mysp;\rprivate SharedPreferences.Editor myspe;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_shared_preferences);\rspbtn1 = findViewById(R.id.spbtn1);\rspbtn2 = findViewById(R.id.spbtn2);\rspet1 = findViewById(R.id.spet1);\rsptv1 = findViewById(R.id.sptv1);\r//实例化\rmysp = getSharedPreferences(\u0026quot;data\u0026quot;,MODE_PRIVATE);\rmyspe = mysp.edit();\rspbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rmyspe.putString(\u0026quot;name\u0026quot;,spet1.getText().toString());\rmyspe.apply(); //相当于提交\r}\r});\rspbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsptv1.setText(mysp.getString(\u0026quot;name\u0026quot;,\u0026quot;\u0026quot;));\r}\r});\r}\r}\r sharedpreferences把数据存在xml文件中\n在路径 data\\data\\\u0026lt;applicationId\u0026gt;\\shared_prefs下有一个xml文件\n真机要root查看\n模拟器直接在终端打开monitor\n要查看这个文件可以点击右上角的 pull a file from the device 下载下来\n打开之后\nFile 内部存储 布局和功能几乎与sharedpreferences相同\njava文件\npackage com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rimport java.io.FileInputStream;\rimport java.io.FileOutputStream;\rimport java.io.IOException;\rpublic class fileActivity extends AppCompatActivity {\rprivate Button fibtn1,fibtn2;\rprivate EditText fiet1;\rprivate TextView fitv1;\rprivate final String filename = \u0026quot;test.txt\u0026quot;;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_file);\rfibtn1 = findViewById(R.id.fibtn1);\rfibtn2 = findViewById(R.id.fibtn2);\rfiet1 = findViewById(R.id.fiet1);\rfitv1 = findViewById(R.id.fitv1);\rfibtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsave(fiet1.getText().toString());\r}\r});\rfibtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfitv1.setText(read());\r}\r});\r}\rpublic void save(String content){\rFileOutputStream fileOutputStream = null;\rtry {\rfileOutputStream = openFileOutput(filename,MODE_PRIVATE);\rfileOutputStream.write(content.getBytes());\r} catch (IOException e) {\re.printStackTrace();\r} finally {\rif(fileOutputStream!=null){\rtry {\rfileOutputStream.close();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\r}\rpublic String read(){\rFileInputStream fileInputStream = null;\rtry {\rfileInputStream = openFileInput(filename);\rbyte[] buff = new byte[1024];\r//fileInputStream.read(buff);\rStringBuilder sb = new StringBuilder(); //字符串拼接\rint len=0;\rwhile((len = fileInputStream.read(buff)) \u0026gt; 0){\rsb.append(new String(buff,0,len));\r}\rreturn sb.toString();\r} catch (IOException e) {\re.printStackTrace();\r}finally {\rif(fileInputStream!=null){\rtry {\rfileInputStream.close();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\rreturn null;\r}\r}\r File 外部存储 java文件\npackage com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.core.app.ActivityCompat;\rimport android.Manifest;\rimport android.app.Activity;\rimport android.os.Bundle;\rimport android.os.Environment;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rimport java.io.File;\rimport java.io.FileInputStream;\rimport java.io.FileOutputStream;\rimport java.io.IOException;\rpublic class fileActivity extends AppCompatActivity {\rprivate Button fibtn1,fibtn2;\rprivate EditText fiet1;\rprivate TextView fitv1;\rprivate final String filename = \u0026quot;test.txt\u0026quot;;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_file);\rfibtn1 = findViewById(R.id.fibtn1);\rfibtn2 = findViewById(R.id.fibtn2);\rfiet1 = findViewById(R.id.fiet1);\rfitv1 = findViewById(R.id.fitv1);\rfibtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsave(fiet1.getText().toString());\r}\r});\rfibtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfitv1.setText(read());\r}\r});\rActivityCompat.requestPermissions(this , new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},1); //1是随便写de\r}\rpublic void save(String content){\rFileOutputStream fileOutputStream = null;\rtry {\r//fileOutputStream = openFileOutput(filename,MODE_PRIVATE);\r//路径\rFile dir = new File(getExternalFilesDir(null),\u0026quot;hello\u0026quot;);\rif(!dir.exists()){\rdir.mkdirs();\r}\r//文件\rFile file = new File(dir,filename);\rif(!file.exists()){\rfile.createNewFile();\r}\rfileOutputStream = new FileOutputStream(file);\rfileOutputStream.write(content.getBytes());\r} catch (IOException e) {\re.printStackTrace();\r} finally {\rif(fileOutputStream!=null){\rtry {\rfileOutputStream.close();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\r}\rpublic String read(){\rFileInputStream fileInputStream = null;\rtry {\r//fileInputStream = openFileInput(filename);\rFile file = new File(getExternalFilesDir(null).getAbsolutePath()+File.separator+\u0026quot;hello\u0026quot;,filename);\rfileInputStream = new FileInputStream(file);\rbyte[] buff = new byte[1024];\r//fileInputStream.read(buff);\rStringBuilder sb = new StringBuilder(); //字符串拼接\rint len=0;\rwhile((len = fileInputStream.read(buff)) \u0026gt; 0){\rsb.append(new String(buff,0,len));\r}\rreturn sb.toString();\r} catch (IOException e) {\re.printStackTrace();\r}finally {\rif(fileInputStream!=null){\rtry {\rfileInputStream.close();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\rreturn null;\r}\r}\r 权限申请 \u0026lt;uses-permission android:name=\u0026quot;android.permission.READ_EXTERNAL_STORAGE\u0026quot;/\u0026gt;\r\u0026lt;uses-permission android:name=\u0026quot;android.permission.WRITE_EXTERNAL_STORAGE\u0026quot;/\u0026gt;\r ","id":42,"section":"posts","summary":"SharedPreferences sharedpreferences的布局 布局文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; xmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot; xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;match_parent\u0026quot; tools:context=\u0026quot;.datastorage.sharedPreferencesActivity\u0026quot;\u0026gt; \u0026lt;EditText android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/spet1\u0026quot; android:hint=\u0026quot;input\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; app:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot; app:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot; app:layout_constraintVertical_bias=\u0026quot;0.1\u0026quot; /\u0026gt; \u0026lt;Button android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; android:text=\u0026quot;sava\u0026quot; app:layout_constraintTop_toBottomOf=\u0026quot;@+id/spet1\u0026quot; android:layout_marginTop=\u0026quot;20dp\u0026quot; android:id=\u0026quot;@+id/spbtn1\u0026quot;/\u0026gt; \u0026lt;Button android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; android:text=\u0026quot;show\u0026quot; app:layout_constraintTop_toBottomOf=\u0026quot;@+id/spbtn1\u0026quot; android:layout_marginTop=\u0026quot;20dp\u0026quot; android:id=\u0026quot;@+id/spbtn2\u0026quot;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/sptv1\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; app:layout_constraintTop_toBottomOf=\u0026quot;@+id/spbtn2\u0026quot; android:layout_marginTop=\u0026quot;20dp\u0026quot; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;","tags":["java","xml"],"title":"Android 数据存储","uri":"https://dyhgo.github.io/2020/03/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","year":"2020"},{"content":"A 膜法记录 题目链接\n题解 贪心 枚举 集合的整数表示 由于n的数据较小，直接枚举n的所有情况，有2^n种\n对于每种情况判断剩下的点列blast能否用完\n其实就是贪心思想（把行blast用完，再用列blast）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rchar s[23][100005];\rll t;\rll n,m,a,b;\rll cl[1\u0026lt;\u0026lt;21];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rfor(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;n);i++) cl[i]=0;\rfor(ll i=1;i\u0026lt;=n;i++) scanf(\u0026quot;%s\u0026quot;,s[i]+1);\r//memset(cl,0,sizeof(cl));\rfor(ll j=1;j\u0026lt;=m;j++) {\rll temp=0;\rfor(ll i=1;i\u0026lt;=n;i++) if(s[i][j]=='*') temp|=(1\u0026lt;\u0026lt;i-1);\rcl[temp]++;\r}\rfor(ll i=1;i\u0026lt;=n;i++)\rfor(ll j=0;j\u0026lt;(1\u0026lt;\u0026lt;n);j++){\rif((j\u0026amp;(1\u0026lt;\u0026lt;i-1))==0) cl[j|1\u0026lt;\u0026lt;i-1]+=cl[j];\r}\rbool ok=false;\rfor(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;n);i++){\rif(__builtin_popcount(i)\u0026lt;=a and m-cl[i]\u0026lt;=b){\rok=true;break;\r}\r}\rif(ok) puts(\u0026quot;yes\u0026quot;);\relse puts(\u0026quot;no\u0026quot;);\r}\rreturn 0;\r}\r 这里用memset会迷之超时，要用for循环\n一个神奇的函数 __builtin_popcount(int x) 返回x的二进制1的个数\nB 阶乘 题目链接\n题解 二分 数论 用二分法获得最小值\n检测一个数n的阶乘是否能被p整除\n对p进行质因数分解\n遍历p的质因数\n如果对于所有的质因数\nn！被这个质因数整除的个数都不小于p中的个数\n那么n！就能被p整除\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll t;\rll p;\rll fac[1000005];\rll num[1000005];\rll tt;\rvoid decompose(ll p){\rtt=0;\rfor(ll i=2;i*i\u0026lt;=p;i++){\rif(p%i==0){\rfac[tt]=i;\rnum[tt]=0;\rwhile(p%i==0) p/=i,num[tt]++;\rtt++;\r}\r}\rif(p\u0026gt;1) {\rfac[tt]=p;num[tt]=1;tt++;\r}\r}\rbool check(ll x){\rfor(ll i=0;i\u0026lt;tt;i++){\rll cnt=0,t=x;\rwhile(t) {\rcnt+=t/fac[i];\rt/=fac[i];\r}\rif(cnt\u0026lt;num[i]) return false;\r}\rreturn true;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;p;\rdecompose(p);\rll l=1,r=1e10; //开1e6会wa\rwhile(l\u0026lt;r){\rll mid=l+r\u0026gt;\u0026gt;1;\rif(check(mid)) r=mid;\relse l=mid+1;\r}\rcout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C 完全图 题目链接\n题解 二分 图论 规律 很容易能找到规律\n要分裂出 x 个连通块，就要拆掉 x*n-(x+1)*x/2 条边\n然后用二分找到 x\n注意 r 的初始值不大于 n\n据说解一元二次方程也可以，我随便写了个，失败了\n用python可以防溢出，但是我出现了2.9999999！=3的情况\n用c++就要用__int128防止爆long long\n不过__int128不能用标准输入输出\n一种解决方法是自己写输入输出\n但是这题只需要在特定的地方转成__int128就行\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing Int = __int128;\rusing ll = long long;\rll t,n,m;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rll l=0,r=n;\rll mid;\rfor(int i=0;i\u0026lt;10000;i++){\rmid=(l+r)/2;\rif(((Int)mid*n-(1+mid)*(Int)mid/2)\u0026lt;=(Int)m)\rl=mid;\relse\rr=mid;\r}\rcout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r D 病毒传染 题目链接\n题解 不会\nE A+B问题 题目链接\n题解 总共能表示的数有2^32个，每一个数都能找到另一个数与之相加等于答案\nac代码\n用PHP写的（求比这更短的代码）（再一次证明了PHP是世界上最好的语言）\n4294967296\r F 美丽的序列I 题目链接\n题解 不会\nG 树上求和 题目链接\n题解 图论 DFS 求出每条边对于所有的简单路径经过了几次\n然后按次数从大到小排序，依次赋值1,2,3\u0026hellip;\n求遍历次数就是求这条边的左右各有几个点，然后相乘\n对于每个点再递归求它的子节点\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll n;\rvector\u0026lt;ll\u0026gt; p[100005];\rll ch[100005];\rbool visit[100005];\rusing pll=pair\u0026lt;ll,ll\u0026gt;;\rvector\u0026lt;pll\u0026gt; vt;\rvector\u0026lt;ll\u0026gt; w;\rmap\u0026lt;pll,ll\u0026gt; mp;\rbool cmp(ll a,ll b){return a\u0026gt;b;}\rll dfs(ll k){\rvisit[k]=true;\rll ans=1;\rfor(auto it:p[k]){\rif(!visit[it]){\rans+=dfs(it);\r}\r}\rw.push_back(ans*(n-ans));\rreturn ans;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rll t1,t2;\rfor(ll i=0;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rp[t1].push_back(t2); ch[t1]++;\rp[t2].push_back(t1); ch[t2]++;\r}\rfor(ll i=1;i\u0026lt;=n;i++) ch[i]--;\rdfs(1);\rsort(w.begin(),w.end(),cmp);\rll i=1;\rll ans2=0;\rfor(auto it:w){\rans2+=it*i++;\r//cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;endl;\r}\rcout\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 用另外一种传入父节点的方法就超时，记忆化搜索也超时\n这是TLE/RE代码，不知道为什么错了（对80%），等有空或实力更强一点再看\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll n;\rvector\u0026lt;ll\u0026gt; p[100005];\rll ch[100005];\rusing pll=pair\u0026lt;ll,ll\u0026gt;;\rvector\u0026lt;pll\u0026gt; vt;\rvector\u0026lt;ll\u0026gt; w;\rmap\u0026lt;pll,ll\u0026gt; mp;\rbool cmp(ll a,ll b){return a\u0026gt;b;}\rll dfs(ll k,ll par){\rif(mp[make_pair(k,par)]!=0) return mp[make_pair(k,par)];\rif(ch[k]==0) {mp[make_pair(k,par)]=0;return 0;} ll ans=0;\rans+=ch[k];\rfor(auto it:p[k]){\rif(it!=par){\rans+=dfs(it,k);\r}\r}\rmp[make_pair(k,par)]=ans;\rreturn ans;\r}\rll cal(ll x,ll y){\rll resx=dfs(x,y);\rll resy=dfs(y,x);\rreturn resx+resy+resx*resy+1;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rll t1,t2;\rfor(int i=0;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rp[t1].push_back(t2); ch[t1]++;\rp[t2].push_back(t1); ch[t2]++;\rvt.emplace_back(t1,t2);\r}\rfor(int i=1;i\u0026lt;=n;i++) ch[i]--;\rfor(int i=0;i\u0026lt;n-1;i++){\rw.push_back(cal(vt[i].first,vt[i].second));\r}\rsort(w.begin(),w.end(),cmp);\rll i=1;\rll ans2=0;\rfor(auto it:w){\rans2+=it*i++;\r}\rcout\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r H 奇怪的背包问题增加了 题目链接\n题解 二进制 由二进制01串的性质可以发现\n如果物品总重量没有2^30就输出impossible\n否则从大到小排序，依次增加就可以\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll =long long;\rll t;\rll n;\rll num[100005];\rusing pll=pair\u0026lt;ll,ll\u0026gt;;\rint check[100005];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rvector\u0026lt;pll\u0026gt; vt; //因为这个wa了好久\rcin\u0026gt;\u0026gt;n;\rll ans=0;\rll temp;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;temp;\rnum[i]=(1\u0026lt;\u0026lt;temp);\rvt.emplace_back(num[i],i);\rans+=num[i];\r}\rif(ans\u0026lt;(1\u0026lt;\u0026lt;30)) puts(\u0026quot;impossible\u0026quot;);\relse{\rsort(vt.begin(),vt.end(),greater\u0026lt;pll\u0026gt;());\rll ans=0;\rll i=0;\rll rr=(1\u0026lt;\u0026lt;30);\rfor(ll i=0;i\u0026lt;n;i++) check[i]=0;\rwhile(ans!=rr){\rans+=vt[i].first;\rcheck[vt[i].second]=1;\ri++;\r}\r//for(ll i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;vt[i].first\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rfor(ll i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;check[i];\rcout\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r 有个wa点，就是没有清空容器 T_T\nI 寻找字串 题目链接\n题解 枚举后缀，比较即可\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rvector\u0026lt;string\u0026gt; vt;\rstring s;\rbool cmp(string s1,string s2){\rreturn s1\u0026gt;s2;\r}\rint main(){\rcin\u0026gt;\u0026gt;s;\rint len=s.length();\rfor(int i=0;i\u0026lt;len;i++){\rvt.push_back(s.substr(i,len-i));\r}\rsort(vt.begin(),vt.end(),cmp);\rcout\u0026lt;\u0026lt;vt[0]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r J 最大的差 题目链接\n题解 最大值减最小值\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint n;\rint mi=100005;\rint ma=-1;\rcin\u0026gt;\u0026gt;n;\rint t;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;t;\rmi=min(t,mi);\rma=max(t,ma);\r}\rcout\u0026lt;\u0026lt;ma-mi\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 本次比赛官方说难度对标cf div2 a~c，可是根据大家的做题情况除签到题至少应该d吧\n不知道为什么有好多题都迷之超时\n总体来说，题目还行\n","id":43,"section":"posts","summary":"A 膜法记录 题目链接 题解 贪心 枚举 集合的整数表示 由于n的数据较小，直接枚举n的所有情况，有2^n种 对于每种情况判断剩下的点列blast能否用完 其","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"https://dyhgo.github.io/2020/03/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","year":"2020"},{"content":"事件处理 基于监听的事件处理机制 匿名内部类 mbt1.setOnTouchListener(new View.OnTouchListener() {\r@Override\rpublic boolean onTouch(View v, MotionEvent event) {\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\u0026quot;listener\u0026quot;,\u0026quot;touch\u0026quot;);\rbreak;\r}\rreturn false;\r}\r});\r 事件源所在类（activity类） public class eventActivity extends AppCompatActivity implements View.OnClickListener\r ebt1 = findViewById(R.id.ebt1);\rebt1.setOnClickListener(eventActivity.this);\r @Override\rpublic void onClick(View v) {\rswitch (v.getId()){\rcase R.id.ebt1:\rToast.makeText(eventActivity.this , \u0026quot;click...\u0026quot;,Toast.LENGTH_LONG).show();\rbreak;\r}\r}\r 在布局文件中设置 \u0026lt;Button\randroid:id=\u0026quot;@+id/ebt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;click\u0026quot;\randroid:textSize=\u0026quot;20sp\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\randroid:layout_marginTop=\u0026quot;50dp\u0026quot;\randroid:onClick=\u0026quot;show\u0026quot;\r/\u0026gt;\r public void show(View view){ //一定是public void\rswitch (view.getId()){\rcase R.id.ebt1:\rToast.makeText(eventActivity.this , \u0026quot;click...\u0026quot;,Toast.LENGTH_LONG).show();\rbreak;\r}\r}\r 基于回调的事件处理机制 布局文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.eventActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/ebt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;click\u0026quot;\randroid:textSize=\u0026quot;20sp\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\randroid:layout_marginTop=\u0026quot;50dp\u0026quot;\r/\u0026gt;\r\u0026lt;com.example.test.Mybotton\randroid:id=\u0026quot;@+id/mbt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;20sp\u0026quot;\randroid:text=\u0026quot;Mybotton\u0026quot;\randroid:textAllCaps=\u0026quot;false\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/ebt1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r Mybotton类\npackage com.example.test;\rimport android.content.Context;\rimport android.util.AttributeSet;\rimport android.util.Log;\rimport android.view.MotionEvent;\rimport android.widget.Button;\rimport androidx.appcompat.widget.AppCompatButton;\rpublic class Mybotton extends AppCompatButton {\rpublic Mybotton(Context context) {\rsuper(context);\r}\rpublic Mybotton(Context context, AttributeSet attrs) {\rsuper(context, attrs);\r}\rpublic Mybotton(Context context, AttributeSet attrs, int defStyleAttr) {\rsuper(context, attrs, defStyleAttr);\r}\r@Override\rpublic boolean onTouchEvent(MotionEvent event) {\rsuper.onTouchEvent(event);\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\u0026quot;Mybotton\u0026quot;,\u0026quot;touch\u0026quot;);\rbreak;\r}\rreturn false; //return true即onTouchEvent到此终止\r}\r}\r eventactivity.java\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.MotionEvent;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.Toast;\rpublic class eventActivity extends AppCompatActivity {\rprivate Button ebt1;\rprivate Mybotton mbt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_event);\rmbt1 = findViewById(R.id.mbt1);\rmbt1.setOnTouchListener(new View.OnTouchListener() {\r@Override\rpublic boolean onTouch(View v, MotionEvent event) {\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\u0026quot;listener\u0026quot;,\u0026quot;touch\u0026quot;);\rbreak;\r}\rreturn false;\r}\r});\r// ebt1 = findViewById(R.id.ebt1);\r// ebt1.setOnClickListener(eventActivity.this);\r}\r// @Override\r// public void onClick(View v) {\r// switch (v.getId()){\r// case R.id.ebt1:\r// Toast.makeText(eventActivity.this , \u0026quot;click...\u0026quot;,Toast.LENGTH_LONG).show();\r// break;\r// }\r// }\r// public void show(View view){ //一定是public void\r// switch (view.getId()){\r// case R.id.ebt1:\r// Toast.makeText(eventActivity.this , \u0026quot;click...\u0026quot;,Toast.LENGTH_LONG).show();\r// break;\r// }\r// }\r@Override\rpublic boolean onTouchEvent(MotionEvent event) {\rsuper.onTouchEvent(event);\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\u0026quot;activity\u0026quot;,\u0026quot;touch\u0026quot;);\rbreak;\r}\rreturn false;\r}\r}\r 触摸Mybotton触发事件\n","id":44,"section":"posts","summary":"事件处理 基于监听的事件处理机制 匿名内部类 mbt1.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(\u0026quot;listener\u0026quot;,\u0026quot;touch\u0026quot;); break; } return false; } }); 事件源所在类（activity类） public class eventActivity extends AppCompatActivity implements View.OnClickListener ebt1 = findViewById(R.id.ebt1); ebt1.setOnClickListener(eventActivity.this);","tags":["java","xml"],"title":"Android 事件处理机制","uri":"https://dyhgo.github.io/2020/03/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","year":"2020"},{"content":"Activity activity的生命周期 运行以下代码可以看到activity经历的生命周期\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.util.Log;\rpublic class lifeCircleActivity extends AppCompatActivity {\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_life_circle);\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onCreate----\u0026quot;);\r}\r@Override\rprotected void onStart() {\rsuper.onStart();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onStart----\u0026quot;);\r}\r@Override\rprotected void onResume() {\rsuper.onResume();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onResume----\u0026quot;);\r}\r@Override\rprotected void onPause() {\rsuper.onPause();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onPause----\u0026quot;);\r}\r@Override\rprotected void onStop() {\rsuper.onStop();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onStop----\u0026quot;);\r}\r@Override\rprotected void onRestart() {\rsuper.onRestart();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onRestart----\u0026quot;);\r}\r@Override\rprotected void onDestroy() {\rsuper.onDestroy();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onDestroy----\u0026quot;);\r}\r}\r 启动这个activity之后\n按返回键退出activity\n再启动activity,并按主页键或者菜单键\n在cache中重新进入activity\nactivity之间的跳转 方法有很多\n以下是设置点击事件来跳转\nprivate Button bt11;\rbt11 = findViewById(R.id.bt11);\rbt11.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(MainActivity.this , broadActivity.class);\rstartActivity(intent);\r}\r});\r 隐式intent 目标activity在manifest文件中应这样注册\n\u0026lt;activity android:name=\u0026quot;.implicitIntentActivity\u0026quot;\u0026gt;\r\u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026quot;com.example.test.124\u0026quot;/\u0026gt;\r\u0026lt;category android:name=\u0026quot;android.intent.category.DEFAULT\u0026quot;/\u0026gt;\r\u0026lt;/intent-filter\u0026gt;\r\u0026lt;/activity\u0026gt;\r 点击事件的设置\nbt14 = findViewById(R.id.bt14);\rbt14.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent();\rintent.setAction(\u0026quot;com.example.test.124\u0026quot;);\rstartActivity(intent);\r}\r});\r activity之间的数据传输 将activity的数据传输到目标activity 发送数据 @Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump);\rjumpbt1 = findViewById(R.id.jumpbt1);\rjumpbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(jumpActivity.this , jump2Activity.class);\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;name\u0026quot;,\u0026quot;henry\u0026quot;);\rbundle.putInt(\u0026quot;number\u0026quot;,11);\rintent.putExtras(bundle);\rstartActivity(intent);\r//startActivityForResult(intent,0); //写在点击事件里\r}\r});\r}\r 接收数据并呈现 @Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump2);\rjump2tv1 = findViewById(R.id.jump2tv1);\rBundle bundle = new Bundle();\rbundle = getIntent().getExtras();\rString name = bundle.getString(\u0026quot;name\u0026quot;);\rint number = bundle.getInt(\u0026quot;number\u0026quot;);\rjump2tv1.setText(name+\u0026quot;,\u0026quot;+number);}\r 启动一个activity,结束后返回结果 jump界面\njump2界面\n点击back返回结果（一个toast）\njumpactivity\npackage com.example.test;\rimport androidx.annotation.Nullable;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.Toast;\rpublic class jumpActivity extends AppCompatActivity {\rprivate Button jumpbt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump);\rjumpbt1 = findViewById(R.id.jumpbt1);\rjumpbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(jumpActivity.this , jump2Activity.class);\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;name\u0026quot;,\u0026quot;henry\u0026quot;);\rbundle.putInt(\u0026quot;number\u0026quot;,11);\rintent.putExtras(bundle);\r//startActivity(intent);\rstartActivityForResult(intent,0); //写在点击事件里\r}\r});\r}\r@Override\rprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\rsuper.onActivityResult(requestCode, resultCode, data);\rToast.makeText(jumpActivity.this,data.getExtras().getString(\u0026quot;msg\u0026quot;),Toast.LENGTH_LONG).show() ;\r}\r}\r jump2activity\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.app.Activity;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rpublic class jump2Activity extends AppCompatActivity {\rprivate TextView jump2tv1;\rprivate Button jump2bt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump2);\rjump2tv1 = findViewById(R.id.jump2tv1);\rBundle bundle = new Bundle();\rbundle = getIntent().getExtras();\rString name = bundle.getString(\u0026quot;name\u0026quot;);\rint number = bundle.getInt(\u0026quot;number\u0026quot;);\rjump2tv1.setText(name+\u0026quot;,\u0026quot;+number);\rjump2bt1 = findViewById(R.id.jump2bt1);\rjump2bt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent();\rBundle bundle1 = new Bundle();\rbundle1.putString(\u0026quot;msg\u0026quot;,\u0026quot;i'm back\u0026quot;);\rintent.putExtras(bundle1);\rsetResult(Activity.RESULT_OK,intent);\rfinish();\r}\r});\r}\r}\r ","id":45,"section":"posts","summary":"Activity activity的生命周期 运行以下代码可以看到activity经历的生命周期 package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; public class lifeCircleActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_life_circle); Log.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onCreate----\u0026quot;); } @Override protected void onStart() { super.onStart(); Log.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onStart----\u0026quot;);","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"https://dyhgo.github.io/2020/03/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/","year":"2020"},{"content":"Broadcast Receiver 通过LoaclBroadcastManager发送广播并接收广播 点击broadactivity的click,跳转到broad2activity\n点击broad2activity的clickme,发送广播\nbroadactivity接收广播，将abc改成123\nbroadactivity\nbroad2activity\n点击clickme后返回到broadactivity\n代码\nbroadactivity_xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.broad.broadActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/bcbt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\randroid:layout_marginTop=\u0026quot;40dp\u0026quot;\randroid:textSize=\u0026quot;30sp\u0026quot;\randroid:text=\u0026quot;click\u0026quot;/\u0026gt;\r\u0026lt;TextView\randroid:id=\u0026quot;@+id/bctv1\u0026quot;\randroid:layout_width=\u0026quot;wrap_content\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;abc\u0026quot;\randroid:textSize=\u0026quot;60sp\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/bcbt1\u0026quot;\rapp:layout_constraintLeft_toLeftOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintRight_toRightOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.3\u0026quot;\r/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r broadactivity_java\npackage com.example.test.broad;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\rimport android.content.BroadcastReceiver;\rimport android.content.Context;\rimport android.content.Intent;\rimport android.content.IntentFilter;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class broadActivity extends AppCompatActivity {\rprivate Button bcbt1;\rprivate TextView bctv1;\rprivate Mybroad mybroad;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_broad);\rbcbt1 = findViewById(R.id.bcbt1);\rbctv1 = findViewById(R.id.bctv1);\rbcbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(broadActivity.this , broad2Activity.class);\rstartActivity(intent);\r}\r});\rmybroad = new Mybroad();\rIntentFilter intentFilter = new IntentFilter();\rintentFilter.addAction(\u0026quot;sss\u0026quot;);\rLocalBroadcastManager.getInstance(broadActivity.this).registerReceiver(mybroad,intentFilter);\r}\rprivate class Mybroad extends BroadcastReceiver{\r@Override\rpublic void onReceive(Context context, Intent intent) {\r//接收到广播要处理的事\rswitch(intent.getAction()){\rcase \u0026quot;sss\u0026quot;:\rbctv1.setText(\u0026quot;123\u0026quot;);\rbreak;\r}\r}\r}\r@Override\rprotected void onDestroy() {\rsuper.onDestroy();\rLocalBroadcastManager.getInstance(broadActivity.this).unregisterReceiver(mybroad);\r}\r}\r broad2activity_xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.broad.broad2Activity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/bc2bt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\randroid:layout_marginTop=\u0026quot;30dp\u0026quot;\randroid:textSize=\u0026quot;30sp\u0026quot;\randroid:text=\u0026quot;click me\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r broad2activity_java\npackage com.example.test.broad;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class broad2Activity extends AppCompatActivity {\rprivate Button bc2bt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_broad2);\rbc2bt1 = findViewById(R.id.bc2bt1);\rbc2bt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(\u0026quot;sss\u0026quot;);\rLocalBroadcastManager.getInstance(broad2Activity.this).sendBroadcast(intent);\r}\r});\r}\r}\r 一些系统操作对应的action ","id":46,"section":"posts","summary":"Broadcast Receiver 通过LoaclBroadcastManager发送广播并接收广播 点击broadactivity的click,跳转到broad2activ","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"https://dyhgo.github.io/2020/03/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/","year":"2020"},{"content":"Content Provider 获取外部应用的信息 以获取通讯录为例 布局文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.contentProviderActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/cpbtn1\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:text=\u0026quot;get_contacts\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/cpbtn2\u0026quot;\randroid:text=\u0026quot;getdata\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/cpbtn1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r 点击get_contacts获取联系人信息\n手机里存储的联系人信息\n在manifest里获取权限\n\u0026lt;uses-permission android:name=\u0026quot;android.permission.READ_CONTACTS\u0026quot; /\u0026gt;\r 利用content resolver获取\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ContentResolver;\rimport android.database.Cursor;\rimport android.net.Uri;\rimport android.os.Bundle;\rimport android.provider.ContactsContract;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport java.util.HashSet;\rimport java.util.List;\rpublic class contentProviderActivity extends AppCompatActivity {\rprivate Button cpbtn1,cpbtn2;\r//private List\u0026lt;String\u0026gt; contactlist=null;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_content_provider);\rcpbtn1 = findViewById(R.id.cpbtn1);\rcpbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rContentResolver contentResolver = getContentResolver();\rCursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);\rwhile(cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\rString number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\rLog.d(\u0026quot;tag\u0026quot;,name+\u0026quot; \u0026quot;+number);\r//contactlist.add(name+\u0026quot; \u0026quot;+number);\r}\rcursor.close();\r//System.out.println(contactlist.toString());\r}\r});\r// }\r}\r 获取到的信息\n获取系统权限指令大全 点击此处\n提供自己的应用信息 在sqlite数据库中创建表\npackage com.example.test;\rimport android.content.Context;\rimport android.database.sqlite.SQLiteDatabase;\rimport android.database.sqlite.SQLiteOpenHelper;\rimport androidx.annotation.Nullable;\rpublic class Myopenhelper extends SQLiteOpenHelper {\rprivate static final String CREATE_TABLE_PERSON = \u0026quot;create table person (id integer primary key autoincrement,name text,age integer)\u0026quot;;\rpublic Myopenhelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) {\rsuper(context, name, factory, version);\r}\r@Override\rpublic void onCreate(SQLiteDatabase db) {\rdb.execSQL(CREATE_TABLE_PERSON);\r}\r@Override\rpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\r}\r}\r 插入数据，提供content provider\npackage com.example.test;\rimport android.content.ContentProvider;\rimport android.content.ContentValues;\rimport android.content.UriMatcher;\rimport android.database.Cursor;\rimport android.database.sqlite.SQLiteDatabase;\rimport android.database.sqlite.SQLiteOpenHelper;\rimport android.net.Uri;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rpublic class Myprovider extends ContentProvider {\rprivate static final String PACKAGE_NAME = \u0026quot;com.example.test\u0026quot;;\rprivate static UriMatcher uriMatcher;\rprivate Myopenhelper myopenhelper;\rprivate SQLiteDatabase sqLiteDatabase;\rstatic {\ruriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\ruriMatcher.addURI(PACKAGE_NAME,\u0026quot;person\u0026quot;,0);\r}\r@Override\rpublic boolean onCreate() {\rmyopenhelper = new Myopenhelper(getContext(),\u0026quot;database\u0026quot;,null,1);\rsqLiteDatabase = myopenhelper.getWritableDatabase();\rContentValues contentValues = new ContentValues();\rcontentValues.put(\u0026quot;name\u0026quot;,\u0026quot;jingjing\u0026quot;);\rcontentValues.put(\u0026quot;age\u0026quot;,15);\rsqLiteDatabase.insert(\u0026quot;person\u0026quot;,null,contentValues);\rcontentValues.put(\u0026quot;name\u0026quot;,\u0026quot;kakulukia\u0026quot;);\rcontentValues.put(\u0026quot;age\u0026quot;,15);\rsqLiteDatabase.insert(\u0026quot;person\u0026quot;,null,contentValues);\rreturn true;\r}\r@Nullable\r@Override\rpublic Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {\rint code = uriMatcher.match(uri);\rswitch (code){\rcase 0:\rCursor cursor = sqLiteDatabase.query(\u0026quot;person\u0026quot;,null,null,null,null,null,null);\rreturn cursor;\r}\rreturn null;\r}\r@Nullable\r@Override\rpublic String getType(@NonNull Uri uri) {\rreturn null;\r}\r@Nullable\r@Override\rpublic Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {\rreturn null;\r}\r@Override\rpublic int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {\rreturn 0;\r}\r@Override\rpublic int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {\rreturn 0;\r}\r}\r 在manifest注册\n\u0026lt;provider\randroid:name=\u0026quot;.Myprovider\u0026quot;\randroid:authorities=\u0026quot;com.example.test\u0026quot;\randroid:exported=\u0026quot;true\u0026quot; /\u0026gt;\r 到此已经提供了自己的应用信息\n现在通过点击“get_data”来查询（利用content resolver）\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ContentResolver;\rimport android.database.Cursor;\rimport android.net.Uri;\rimport android.os.Bundle;\rimport android.provider.ContactsContract;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport java.util.HashSet;\rimport java.util.List;\rpublic class contentProviderActivity extends AppCompatActivity {\rprivate Button cpbtn1,cpbtn2;\r//private List\u0026lt;String\u0026gt; contactlist=null;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_content_provider);\rcpbtn1 = findViewById(R.id.cpbtn1);\rcpbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rContentResolver contentResolver = getContentResolver();\rCursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);\rwhile(cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\rString number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\rLog.d(\u0026quot;tag\u0026quot;,name+\u0026quot; \u0026quot;+number);\r//contactlist.add(name+\u0026quot; \u0026quot;+number);\r}\rcursor.close();\r//System.out.println(contactlist.toString());\r}\r});\rcpbtn2 = findViewById(R.id.cpbtn2);\rcpbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rUri uri = Uri.parse(\u0026quot;content://com.example.test/person\u0026quot;);\rCursor cursor = getContentResolver().query(uri,null,null,null,null,null);\rwhile (cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(\u0026quot;name\u0026quot;));\rint age = cursor.getInt(cursor.getColumnIndex(\u0026quot;age\u0026quot;));\rLog.d(\u0026quot;tag\u0026quot;,name+\u0026quot; \u0026quot;+age);\r}\rcursor.close();\r}\r});\r}\r}\r 查询到的信息\n如果重复运行，会在数据库中一直添加数据\n","id":47,"section":"posts","summary":"Content Provider 获取外部应用的信息 以获取通讯录为例 布局文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; xmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot; xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;match_parent\u0026quot; tools:context=\u0026quot;.contentProviderActivity\u0026quot;\u0026gt; \u0026lt;Button android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/cpbtn1\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; android:text=\u0026quot;get_contacts\u0026quot;/\u0026gt; \u0026lt;Button android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/cpbtn2\u0026quot; android:text=\u0026quot;getdata\u0026quot; android:textSize=\u0026quot;25dp\u0026quot; app:layout_constraintTop_toBottomOf=\u0026quot;@+id/cpbtn1\u0026quot; android:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 点击get_contacts获取联系人信息 手","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"https://dyhgo.github.io/2020/03/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/","year":"2020"},{"content":"Service Service的生命周期 通过启动Service传递数据 在serviceactivity的输入框中输入数据，启动Myservice并传递数据，打印到日志\nserviceactivity_xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.serviceActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;startservice\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn2\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\randroid:text=\u0026quot;stopservice\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/sbtn1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn3\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\randroid:text=\u0026quot;bindservice\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/sbtn2\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn4\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\randroid:text=\u0026quot;unbindservice\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/sbtn3\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;EditText\randroid:id=\u0026quot;@+id/set1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/sbtn4\u0026quot;\randroid:textSize=\u0026quot;20sp\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn5\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\randroid:text=\u0026quot;syncdata\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/set1\u0026quot;\randroid:layout_marginTop=\u0026quot;30dp\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r serviceactivity.java\nsbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rintent.putExtra(\u0026quot;data\u0026quot;,set1.getText().toString());\rstartService(intent);\r}\r});\r Myservice.java\nprivate String data=\u0026quot;cat\u0026quot;;\rprivate boolean running=false;\r @Override\rpublic int onStartCommand(Intent intent, int flags, int startId) {\rdata = intent.getStringExtra(\u0026quot;data\u0026quot;);\r//Log.d(\u0026quot;tag\u0026quot;,data);\rreturn super.onStartCommand(intent, flags, startId);\r}\r @Override\rpublic void onCreate() {\rsuper.onCreate();\r//Log.d(\u0026quot;tag\u0026quot;,data);\rrunning=true;\rnew Thread(){\r@Override\rpublic void run() {\rsuper.run();\rwhile (running){\rSystem.out.println(data);\rtry {\rsleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}.start();\r}\r 通过绑定来同步数据 点击bindservice\n输入数据，点击syncdata\nservice.java\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ComponentName;\rimport android.content.Context;\rimport android.content.Intent;\rimport android.content.ServiceConnection;\rimport android.os.Bundle;\rimport android.os.IBinder;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rpublic class serviceActivity extends AppCompatActivity implements ServiceConnection {\rprivate Button sbtn1,sbtn2,sbtn3,sbtn4;\rprivate EditText set1;\rprivate Button sbtn5;\rprivate MyService.mybinder binder;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_service);\rsbtn1 = findViewById(R.id.sbtn1);\rsbtn2 = findViewById(R.id.sbtn2);\rsbtn3 = findViewById(R.id.sbtn3);\rsbtn4 = findViewById(R.id.sbtn4);\rset1 = findViewById(R.id.set1);\rsbtn5 = findViewById(R.id.sbtn5);\rsbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rintent.putExtra(\u0026quot;data\u0026quot;,set1.getText().toString());\rstartService(intent);\r}\r});\rsbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rstopService(intent);\r}\r});\rsbtn3.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rbindService(intent,serviceActivity.this, Context.BIND_AUTO_CREATE);\r}\r});\rsbtn4.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\r//Intent intent = new Intent(serviceActivity.this,MyService.class);\runbindService(serviceActivity.this);\r}\r});\rsbtn5.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(binder!=null){\rbinder.setdata(set1.getText().toString());\r//System.out.println(MyService.data);\r}\r}\r});\r}\r@Override\rpublic void onServiceConnected(ComponentName name, IBinder service) {\rLog.d(\u0026quot;service123\u0026quot;,\u0026quot;connected123\u0026quot;);\rbinder = (MyService.mybinder) service;\r}\r@Override\rpublic void onServiceDisconnected(ComponentName name) {\r}\r}\r Myservive.java\npackage com.example.test;\rimport android.app.Service;\rimport android.content.Intent;\rimport android.os.Binder;\rimport android.os.IBinder;\rimport android.util.Log;\rpublic class MyService extends Service {\rprivate String data=\u0026quot;cat\u0026quot;;\rprivate boolean running=false;\rpublic MyService() {\r}\r@Override\rpublic IBinder onBind(Intent intent) {\r// TODO: Return the communication channel to the service.\r//throw new UnsupportedOperationException(\u0026quot;Not yet implemented\u0026quot;);\r//return new Binder();\rreturn new mybinder();\r}\rpublic class mybinder extends Binder{ //是binder不是 ibinder\rpublic void setdata(String data){\rMyService.this.data = data;\r}\r}\r@Override\rpublic int onStartCommand(Intent intent, int flags, int startId) {\r//data = intent.getStringExtra(\u0026quot;data\u0026quot;);\r//Log.d(\u0026quot;tag\u0026quot;,data);\rreturn super.onStartCommand(intent, flags, startId);\r}\r@Override\rpublic boolean onUnbind(Intent intent) {\rreturn super.onUnbind(intent);\r}\r@Override\rpublic void onCreate() {\rsuper.onCreate();\r//Log.d(\u0026quot;tag\u0026quot;,data);\rrunning=true;\rnew Thread(){\r@Override\rpublic void run() {\rsuper.run();\rwhile (running){\rSystem.out.println(data);\rtry {\rsleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}.start();\r}\r@Override\rpublic void onDestroy() {\rsuper.onDestroy();\rLog.d(\u0026quot;tag\u0026quot;,\u0026quot;dog\u0026quot;);\rrunning=false;\r}\r}\r 在manifest里的注册 \u0026lt;activity\randroid:name=\u0026quot;.serviceActivity\u0026quot;\randroid:exported=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;service\randroid:name=\u0026quot;.MyService\u0026quot;\randroid:enabled=\u0026quot;true\u0026quot;\randroid:exported=\u0026quot;true\u0026quot; /\u0026gt;\r ","id":48,"section":"posts","summary":"Service Service的生命周期 通过启动Service传递数据 在serviceactivity的输入框中输入数据，启动Myservice并传递数据","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"https://dyhgo.github.io/2020/03/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/","year":"2020"},{"content":"Number Sequence Problem Description Given two sequences of numbers : a[1], a[2], \u0026hellip;\u0026hellip; , a[N], and b[1], b[2], \u0026hellip;\u0026hellip; , b[M] (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], \u0026hellip;\u0026hellip; , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.\nInput The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). The second line contains N integers which indicate a[1], a[2], \u0026hellip;\u0026hellip; , a[N]. The third line contains M integers which indicate b[1], b[2], \u0026hellip;\u0026hellip; , b[M]. All integers are in the range of [-1000000, 1000000].\nOutput For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead.\nSample Input 2 13 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 1 313 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 2 1Sample Output 6-1\nSolution 测一下kmp板子\nac代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n,m,t;\rint s[1000005];\rint p[10005];\rint nextt[10005];\rvoid get_next(){\rint i=0,j=-1;\rnextt[0]=-1;\rwhile(i\u0026lt;m){\rif(j==-1 || p[i]==p[j]) nextt[++i]=++j;\relse j=nextt[j]; //!!!\r}\r}\rint kmp(){\rint i=0,j=0;\rwhile(1){\rif(s[i]==p[j]) i++,j++;\relse{\rint t=nextt[j];\rif(t==-1) i++,j=0;\relse j=t;\r}\rif(j\u0026gt;=m) return i-m+1; //根据题目要求返回 if(i\u0026gt;=n) return -1;\r}\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(0);cin.tie(0);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;s[i];\rfor(int i=0;i\u0026lt;m;i++) cin\u0026gt;\u0026gt;p[i];\rget_next();\rcout\u0026lt;\u0026lt;kmp()\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ","id":49,"section":"posts","summary":"Number Sequence Problem Description Given two sequences of numbers : a[1], a[2], \u0026hellip;\u0026hellip; , a[N], and b[1], b[2], \u0026hellip;\u0026hellip; , b[M] (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], \u0026hellip;\u0026hellip; , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"https://dyhgo.github.io/2020/03/hduoj1711kmp/","year":"2020"},{"content":"A. EhAb AnD gCd 题意 给一正整数x，求正整数a,b满足gcd(a,b)+lcm(a,b)=x\n题解 数论思维题，a=1，b=x-1满足条件\nac代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--) {\rint k;\rcin\u0026gt;\u0026gt;k;\rcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;k-1\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. CopyCopyCopyCopyCopy 题意 给一数列，将数列无限复制，求最长严格单调子序列的个数\n题解 计算数列有多少种数字就行\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll =long long;\rll t;\rll n;\rset\u0026lt;ll\u0026gt; st;\rll tmp;\rinline ll read(){\rll x=0;ll f=1;char s=getchar();\rwhile(s\u0026lt;'0' or s\u0026gt;'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u0026gt;='0' and s\u0026lt;='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\tcin\u0026gt;\u0026gt;t;\rwhile(t--){\rst.clear();\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rtmp=read();\rst.insert(tmp);\r} cout\u0026lt;\u0026lt;st.size()\u0026lt;\u0026lt;endl; }\treturn 0;\r}\r C. Ehab and Path-etic MEXs 题意 给一棵n个节点的树，求边权重的赋值方案（权重为0~n-2互异）\n使得max(mex(u,v))最小\n其中mex(u,v)为连接顶点u,v的简单路径中“不”包含边权重的最小值\n题解 当树为一条链时，随便赋值\n否则，树必然有一个顶点的度数为3\n所有简单路径中必然经过0和1的边\n要让最大值最小，就要让所有简单路径不同时存在0，1，2的边（这样max(mex)=2）\n只需要把0，1，2分散在三度顶点的三条边上\n其他随便赋值\n以第2个样例为例\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rint deg[100005];\rusing pii=pair\u0026lt;int,int\u0026gt;;\rvector\u0026lt;pii\u0026gt; vt;\rbool lis;\r//bool lef;\rint p;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(0);cin.tie(0);\rlis=true;\rcin\u0026gt;\u0026gt;n;\rfor(int i=0,t1,t2;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\r//if(t1\u0026gt;t2) swap(t1,t2);\rdeg[t1]++;\rdeg[t2]++;\rvt.emplace_back(t1,t2);\r}\rfor(int i=1;i\u0026lt;=n;i++) {\rif(deg[i]\u0026gt;2){\rlis=false;\rp=i;\rbreak;\r}\r}\rif(lis){\rfor(int i=0;i\u0026lt;n-1;i++) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl;\r}\relse{\rint a=0,b=3;\rfor(int i=0;i\u0026lt;n-1;i++){\rif((vt[i].first==p or vt[i].second==p ) and (a\u0026lt;3)){\rcout\u0026lt;\u0026lt;a++\u0026lt;\u0026lt;endl;\r}\relse cout\u0026lt;\u0026lt;b++\u0026lt;\u0026lt;endl;\r}\t}\rreturn 0;\r}\r D. Ehab the Xorcist 题意 Given 2 integers u and v, find the shortest array such that bitwise-xor of its elements is u, and the sum of its elements is v.\n题解 如果是3个数，则这3个数可以是u , (v-u)/2 , (v-u)/2 (利用异或性质)\n如果是2个数，p，q\n则考虑p+q和p^q的关系\n利用以下性质可求得p,q\n注意题目说的正整数和样例，进行特判\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing ll = long long;\rusing namespace std;\rll u,v;\rint main(){\rcin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\rif((v-u)\u0026amp;1 || v-u\u0026lt;0) puts(\u0026quot;-1\u0026quot;);\relse if(v==0 \u0026amp;\u0026amp; u==0) puts(\u0026quot;0\u0026quot;);\relse if(v==u) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;u;\relse{\rll p=(v-u)/2;\rll q=u^p;\rif(p+q==v) cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;q\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;u\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl;\r} return 0;\r}\r E. Ehab\u0026rsquo;s REAL Number Theory Problem 题意 不懂\n题解 不会\nF. Ehab\u0026rsquo;s Last Theorem 题意 不懂\n题解 不会\n","id":50,"section":"posts","summary":"A. EhAb AnD gCd 题意 给一正整数x，求正整数a,b满足gcd(a,b)+lcm(a,b)=x 题解 数论思维题，a=1，b=x-1满足条件 ac代码 #include\u0026lt;iostream\u0026gt; using namespace std;","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"https://dyhgo.github.io/2020/03/codeforces-round-628-div.-2-a~d/","year":"2020"},{"content":"二进制转十进制 除2取余\n十进制转二进制 乘2次幂\n小数进制转换 e.g.\n3.59375\n整数部分3的二进制位11\n小数部分0.59375\n0.59375*2=1.1875 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; 10.1875*2=0.375 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;00.375*2=0.75 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;00.75*2=1.5 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;10.5*2=1 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;1二进制位0.10011\n所以3.59375的二进制表示为11.10011\n有些小数不能测出现循环\nIEEE754标准的浮点数与十进制数的转换 32位和64位标准 通过全1和全0来划定它的表示范围\nE.G. 原码 即正常的二进制码（带符号位）\n补码 正数（包括+0）的补码和原码一样\n负数（包括-0）的补码在原码的基础上“按位取反，末尾加1”\n补码转原码的一种方法\n还可以用逆过程法，即减1取反\n反码 正数（包括+0）的补码和原码一样\n负数（包括-0）的补码在原码的基础上“按位取反”\n补码的加法运算 补码的减法运算 ","id":51,"section":"posts","summary":"二进制转十进制 除2取余 十进制转二进制 乘2次幂 小数进制转换 e.g. 3.59375 整数部分3的二进制位11 小数部分0.59375 0.59375*2=1.1875 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; 10.1875*2=0.375 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;00.375*2=0.75 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;00.75*2=1.5 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;10.5*2=1 \u0026mdash;\u0026mda","tags":["binary","cs"],"title":"二进制编码","uri":"https://dyhgo.github.io/2020/03/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/","year":"2020"},{"content":"A. Yet Another Tetris Problem link B. Yet Another Palindrome Problem link C. Frog Jumps link D. Pair of Topics link E. Sleeping Schedule link 题意 假设一天有h个小时，DIO一共要睡n次，每次睡ai个小时（按顺序睡觉），每次刚睡醒，就要继续睡觉，一直睡下去，直至睡眠次数耗光。\n给定一个一天中的区间[l,r]，如果有一次睡醒时刻在区间内，则这次睡眠为“好睡眠”\n对于每次睡眠时间ai,可以选择睡ai小时或ai-1小时\n问一开始就进行睡眠的情况下，“好睡眠”的次数最多有几次\n题解 动态规划\ndp[i][j]\ni表示已经进行了i次睡眠\nj表示现在在时刻j\ndp表示最大“好睡眠”次数\n初始化 ：dp[i][j]=-inf , dp[0][0]=0\n分别讨论下面两种情况\nto=(j+a[i])%h\nto=(j+a[i]-1)%h\n状态转移方程 ：dp[i+1][to] = max(dp[i+1][to] , dp[i][j] + flag)\nflag当to在区间内为1，否则为0\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,h,l,r;\rint dp[2005][2005];\rint data[2005];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(0);cin.tie(0);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;h\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;data[i];\r//preprocess\rmemset(dp,0xc0,sizeof(dp)); //0xc0c0c0c0 0x3f3f3f3f\rdp[0][0]=0;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;h;j++) // \u0026lt;即可\r{\rint to=(j+data[i])%h;\rdp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u0026lt;=to and to\u0026lt;=r));\rto =(j+data[i]-1)%h;\rdp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u0026lt;=to and to\u0026lt;=r));\r}\rint ans=-1; for(int i=0;i\u0026lt;h;i++)\rans=max(ans,dp[n][i]);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 小技巧\ninf = 0x3f3f3f3f memset可以用0x3f\nninf=0xc0c0c0c0 memset可以用0xc0\nF. Maximum White Subtree link 题意 给一棵树（比赛当天是植树节！！）\n节点有黑的，白的\n对于这棵树的某一子图\n定义这个子图所有节点的dif=白色节点数-黑色节点数\n求每一个节点的最大dif值\n题解 深度优先搜索+动态规划\n首先考虑以每个节点为父节点的子图的最大dif\n然后每个节点的的最大dif=作为父节点的最大dif+作为子节点的最大dif\n如何求以每个节点为父节点的子图的最大dif？\n遍历子节点\n判断每个子节点以下（作为父节点）是否白色比黑色多，多则累加对应的数值，否则不累加\n这样就形成和了dfs\n如何求最终的dif？\n作为子节点的部分的dif，可以用该节点的父节点的dif（最终）- 作为父节点的dif\n需要判断是否有必要增加“额外部分”\n要让该节点的父节点的dif为最终值，需要从根开始，一层层遍历子节点\n这样又形成了dfs\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rint dif_orig[200005];\rvector\u0026lt;int\u0026gt; adj[200005];\rint dif_par[200005];\rint ans[200005];\rvoid dfs_par(int u,int par)\r{\rdif_par[u]=dif_orig[u];\rfor(auto v:adj[u])\r{\rif(v!=par)\r{\rdfs_par(v,u);\rdif_par[u]+=max(dif_par[v],0); //如果黑色比白色多，则丢弃 }\r}\r}\rvoid dfs_final(int u,int par,int el)\r{\rans[u]=dif_par[u]+el;\rfor(auto v:adj[u])\r{\rif(v!=par)\r{\rdfs_final(v,u,max(0,ans[u]-max(dif_par[v],0))); //里面的max和上面一样，外面的max判断是否有必要增加其他部分（作为子节点的部分） }\r}\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(0);cin.tie(0);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++) {\rcin\u0026gt;\u0026gt;dif_orig[i];\rif(!dif_orig[i]) dif_orig[i]=-1; //如果是黑色，则白色-黑色=-1 }\rfor(int i=1,u,v;i\u0026lt;n;i++)\r{\rcin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\ru--,v--;\radj[u].emplace_back(v);\radj[v].emplace_back(u);\r}\rdfs_par(0,-1);\rdfs_final(0,-1,0);\rfor(int i=0;i\u0026lt;n;i++)\rcout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rreturn 0;\r}\r ","id":52,"section":"posts","summary":"A. Yet Another Tetris Problem link B. Yet Another Palindrome Problem link C. Frog Jumps link D. Pair of Topics link E. Sleeping Schedule link 题意 假设一天有h个小时，DIO一共要睡n次，每次睡ai个小时（按顺序睡觉），每次刚睡醒，就","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"https://dyhgo.github.io/2020/03/codeforces-round-627-div.-3/","year":"2020"},{"content":"《ef - a tale of melodies.》由日本动画公司SHAFT制作电视动画，并于2008年10月6日开始播放，是动画《悠久之翼》系列的第二季。故事内容由原作游戏《ef - the latter tale.》的第四章及终章改篇而成，终章的修改幅度比较大，加入了一些原创的情节。共12话。\n剧情\n圣诞节，雨宫优子与火村夕两人在教会里重逢。两人怀缅过去，由雨宫优子开始说过去发生过的种种事情。 广野纮是个高中生兼少女漫画家，每一天度过忙碌的生活。在圣诞节的夜晚，遇到追逐小偷的宫村宫子。两人再次在学校见面后，宫村宫子对广野纮开始产生兴趣，而开始纠缠在广野纮身边。 身为青梅竹马的新藤景看到这种场景而感到焦虑。几个月后的夏天。喜欢电影制作的堤京介，在体育馆看到新藤景的射篮的动作时，想要拍摄以她为主的电影。因为失恋与郁闷而退出社团的新藤景，受到热爱电影的堤京介的影响，慢慢走出阴霾。\u0026ndash;百度百科 ","id":53,"section":"posts","summary":"《ef - a tale of melodies.》由日本动画公司SHAFT制作电视动画，并于2008年10月6日开始播放，是动画《悠久之翼》系列的第二季。故","tags":[],"title":"ef - a tale of melodies","uri":"https://dyhgo.github.io/2020/03/ef-a-tale-of-melodies/","year":"2020"},{"content":"A - Station and Bus 题目链接 题意 给一长度为3的，只含AB的字符串，问是否存在相邻两个字符不同的情况\n题解 签到题\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main()\r{\rstring s;\rcin\u0026gt;\u0026gt;s;\rif((s[0]=='A' and s[1]=='A' and s[2]=='A') or(s[0]=='B' and s[1]=='B' and s[2]=='B'))\rcout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r B - Count Balls 题目链接 题意 有蓝球和红球若干，将他们排成一排，不断通过以下操作排列，在尾部加a个蓝球，在尾部加b个红球，问前n个球有多少个蓝球\n题解 签到题\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rll a,b,n;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rll m=n/(a+b);\rll ans;\rif(n\u0026gt;0) ans=m*a;\relse ans=0;\rn-=m*(a+b);\rif(n\u0026gt;a) ans+=a;\relse ans+=n;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Tax Increase 题目链接 题意 给俩数a,b，问是否存在整数x使得，floor(x0.08)=a \u0026amp;\u0026amp; floor(x0.1)=b，若存在，输出满足这种条件的最小数，否则输出-1\n题解 由于数据不大，遍历x，判断是否满足条件\n或者求满足条件的两个区间，判断是否有交集\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint l1,r1,l2,r2;\rint a,b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rl1=ceil(a/0.08);\rdouble t;\rt=(a+1)/0.08;\rif(t*0.08==a+1)\rr1=t-1;\relse\rr1=floor((a+1)/0.08);\rl2=ceil(b/0.1);\rt=(b+1)/0.1;\rif(t*0.1==b+1)\rr2=t-1;\relse\rr2=floor((b+1)/0.1);\rbool flag=true;\rint ans;\rif(r1\u0026lt;l2 or r2\u0026lt;l1) flag=false;\relse if(l2\u0026gt;=l1 and r2\u0026lt;=r1) ans=l2;\relse if(l1\u0026gt;=l2 and r1\u0026lt;=r2) ans=l1;\relse ans=max(l1,l2);\rif(flag) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\r//cout\u0026lt;\u0026lt;l1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;r1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;l2\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;r2;\rreturn 0;\r}\r D - String Formation 题目链接 题意 对于一个字符串，有三种操作，倒置，在头部添加字符，在尾部添加字符，求最后得到的字符串\n题解 分别存储前缀和后缀，用一个bool来判断顺序，倒置操作给bool取反。\n在头部加，如果是顺序的就加在前缀，其他情况同理。\n最后通过bool量来控制输出顺序\n（直接模拟也可以）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rstring s;\rint q;\rchar c;\rint f;\rint t;\rstring pre,suf;\rbool order;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rorder=true;\rcin\u0026gt;\u0026gt;s;\rcin\u0026gt;\u0026gt;q;\rwhile(q--)\r{\rcin\u0026gt;\u0026gt;t;\rif(t==1) order^=1; //!!\relse\r{\rcin\u0026gt;\u0026gt;f;\rif(f==1) {\rcin\u0026gt;\u0026gt;c;\rif(order) pre+=c;\relse suf+=c;\r}\relse\r{\rcin\u0026gt;\u0026gt;c;\rif(order) suf+=c;\relse pre+=c;\r}\r}\r}\rif(order)\r{\rreverse(pre.begin(),pre.end());\rcout\u0026lt;\u0026lt;pre\u0026lt;\u0026lt;s\u0026lt;\u0026lt;suf\u0026lt;\u0026lt;endl;\r}\relse\r{\rreverse(suf.begin(),suf.end());\rreverse(s.begin(),s.end());\rcout\u0026lt;\u0026lt;suf\u0026lt;\u0026lt;s\u0026lt;\u0026lt;pre\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r 知识点\n1.bool的取反不能flag=-flag，可以用flag^=1\n2.string 在的插入函数 e.g. s.insert(s.begin(),c) or s.insert(s.end(),c)\n3.string的拼接 s=(string)\u0026ldquo;aaa\u0026quot;+\u0026quot;bbb\u0026rdquo;; （一定要强制类型转换）\ns='a'+(string)\u0026ldquo;kkk\u0026rdquo;; （string要强制类型转换，char是不能转成string）\nE - Divisible Substring 题目链接 题意 给一个仅由数字组成的字符串和质数p，问有几个子串（连续字符组成的）能够被p整除\n题解 个人感觉出的特别好的一道题\n动态规划+后缀\n从最后开始向前遍历每个数\nans+=（以当前数为开头，满足条件的个数）\n要求以当前数开头，满足条件的个数，就是个区间问题\n这个区间问题可以用后缀来求\n当两个后缀模p的余数相等时，这个区间内的数能被p整除（2和5除外）\n所以问题转化成求此时的后缀（余数），查询之前和这个余数相等的个数\n然后ans+=个数\n注意特殊处理一下2和5\n以下是对上面结论的证明（实际并不需要严格证明）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rint n,p;\rstring s;\rmap\u0026lt;int,int\u0026gt; mp; //存余数和对应的个数 ll ans=0;\rint main()\r{\rios::sync_with_stdio(false); cin.tie(0);\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;p\u0026gt;\u0026gt;s;\rif(p==2 or p==5)\r{\rint pt=p;\rfor(int i=0;i\u0026lt;n;i++)\rif((s[i]-'0')%pt==0) ans+=i+1;\r}\relse\r{\rmp[0]++;\rint num=0;\rint m=1;\rfor(int i=n-1;~i;i--)\r{\rnum=(num+(s[i]-'0')*m)%p;\rans+=mp[num];\rmp[num]++;\rm=(m*10)%p;\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Removing Robots 题目链接 题意 数轴上有n个点，每个点有两个属性（坐标和能够向右移动的距离），随意地激活其中几个点，激活的点必须向右移动该距离，若移动过程中碰到点则那个点被激活，求对于所有的激活情况，最后的结果有多少种\n题解 动态规划+栈优化\n从右往左遍历每个点\n给每个点设置一个数值，表示遍历到该点的集合数量（即答案）\n判断这个点是否可以覆盖右边的点，可以覆盖，则这个点的数值乘上覆盖点的数值\n用栈维护每个遍历的点，如果栈顶没有被覆盖，则栈里面都无需遍历\n被覆盖的点就出栈\n新的点入栈（因为旧的点被新的点覆盖，集合数已经被新的点记录）\n最后遍历一遍栈，累乘数值\nac代码\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rll n;\rconst ll mod=998244353;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vt; //存输入 stack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; //将不覆盖的点入栈 ，用栈优化（对于正在检测的点，如果栈顶不满足，则栈里面的都不满足） //存点的坐标（identifier）和扫描到这个点时，它满足的集合数量 int t1,t2;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(false);cin.tie(0);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rt2+=t1;\rvt.emplace_back(t1,t2);\r}\rsort(vt.rbegin(),vt.rend()); //这种题目几乎都要sort 此处逆序遍历 for(int i=0;i\u0026lt;n;i++)\r{\rll t=1;\r//cout\u0026lt;\u0026lt;stk.empty()\u0026lt;\u0026lt;endl;\rwhile(!stk.empty() \u0026amp;\u0026amp; vt[i].second\u0026gt;stk.top().first)\t//遍历栈 注意开区间 {\rt=(t*stk.top().second)%mod;\rstk.pop();\r}\r//cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl;\rstk.push(make_pair(vt[i].first,t+1)); //!!!!! 一定要加1，因为枚举集合数的时候，对于每个点分两种情况（激活和不激活） } ll ans=1;\rwhile(!stk.empty())\r{\rans=(ans*stk.top().second)%mod;\rstk.pop();\r//cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}  debug了一小时\n发现自己手贱，在声明vector的时候给它分配了空间，然后就出现迷之错误\n（我一定是有病才会这么做）\n感觉自己的思维和英语都退步了\noh shake it 又没有学习android\n","id":54,"section":"posts","summary":"A - Station and Bus 题目链接 题意 给一长度为3的，只含AB的字符串，问是否存在相邻两个字符不同的情况 题解 签到题 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { string s; cin\u0026gt;\u0026gt;s; if((s[0]=='A' and s[1]=='A' and s[2]=='A') or(s[0]=='B' and","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"https://dyhgo.github.io/2020/03/abc158/","year":"2020"},{"content":"halo1是微软于2001年发行的第一人称射击游戏\nhalo是一个很注重武器选择的游戏，合适的武器会非常高效\n剧情 2160-2200：早期冲突\n这一时期的人类历史充斥着太阳系中各大政府和派别之间的一系列血腥冲突。具有重大历史意义的冲突包括：木卫战役（Jovian Moons Campaign）、雨林争霸（The Rain Forest Wars）和一系列的火星遭遇战。 随着地球上人口过剩和政局动荡的愈演愈烈，许多新的政治运动兴起了。这一时期最值得注意的政治异端运动是“科思洛维克”（\u0026ldquo;Koslovics\u0026rdquo;)和 “福里登”（\u0026ldquo;Frieden\u0026rdquo;)运动。“科思洛维克”是指新共产主义者的强权领袖福拉德米亚·科思洛夫(Vladimir Koslov）的拥护者，他们致力于回到共产主义的光荣岁月，要消灭公司和资本家的流毒，特别是要肃清近地轨道和地外殖民地。 “福里登”运动是法西斯主义的复兴，该运动起源于反“科思洛维克”情绪，扎根木星殖民地为据点（很大程度上受到了统一德意志共和国企业的支持，这些企业常常成为科思洛维克“工人起义”的对象）。“福里登”的字面意思是“和平”－－这就是说，他们相信只有消灭了“人类的暴君”（oppressors on Terra Firma），才可能达成和平。\n2160 三月－六月：木卫战役开始\n木星分裂主义者袭击了位于木卫一爱莪（Io）的联合国殖民地总署（United Nations Colonial Advisors），导致了地球军与木星“福里登”部队之间展开了长达三个月的激战。虽然这并非我们太阳系中的第一起武装冲突，但此役成了最为血腥的战斗之一，也被普遍认为是引发接下来的摩擦和军国主义大潮的导火索。 木卫战役也升级了地球各国政府间的紧张关系－－许多国家在太阳系中都建立了殖民地，开始为各自在地外的利益而开战。殖民地战争的持续，使得地球上的紧张关系一触即发，引发了地球本土的数起武装冲突。\n2162：雨林争霸\n武装冲突横扫南美大陆，科思洛维克、福里登和联合国军之间因为不同的意识形态而开战。而这又加剧了地外冲突。\n2163 十二月：在火星的战斗\n地球三股主要派别将雨林争霸中燃起的战火烧到了火星上。一系列在火星Argyre Planitia附近对科思洛维克军的闪电战，是第一次非地军队的部署。战斗取得了决定性胜利。作为结果，后来的军事指导战略，惯用大编制的地面部队突袭配合舰船登陆行动。\n2164：星际大战\n联合国军开始形成大规模集结的格局，终于迎来了第一次真正的星际大战。继火星的军队部署告捷后，大规模的征兵行动和宣传策略极大地鼓舞了UNSC (United Nations Space Command，联合国太空司令部）军队的士气。联合国军挫败了地球上的科思洛维克和福里登军队，接着开始系统地专注于驱逐其在太阳系内其他行星上建立起来的残存势力。在这些局部战争后，福里登和科思洛维克军队被庞大、统一而强大的联合国军悉数剿灭。\n2170：膨胀\n2160年代的战乱促使人们建立了统一的地球政府。现在，胜利者必须处理不太引人注目却同样严重的威胁：人口过剩和无仗可打的庞大军队。 战后的岁月里，大量人口急剧膨胀；雨林争霸遗留的资源破坏和饥荒更是雪上加霜，世界经济岌岌可危。\n2291：超越光速\n一支由研究人员、物理学家和数学家组成的团队正在秘密研发“肖恩·藤川”超光速引擎（Shaw-Fujikawa Translight Engine，SFTE），一种驱动太空船穿越辽远星际的特殊手段。 这种新型引擎允许飞船钻入“跃迁空间”（\u0026ldquo;the Slipstream\u0026quot;或\u0026quot;Slipspace\u0026rdquo;，又称为“迁跃断层空间”）。“断层”一个变通的物理法则下的空间，允许超光速旅行而避免相对论的副作用。超光速旅行并不是瞬间完成的；“短程”的跳跃一般要花两个月，而“长程”的跳跃则能持续六个月甚至更久。 SFTE能生成一个共振场，当与迁跃空间的物理特性结合时，就能大大缩短跨越星际的时间；然而，科学家们也注意到在迁跃空间内部会有暂时的涌流这一奇怪的“变数”。尽管人类科学家都无法确定为何星际旅行所需的时间不是一个常量，但有理论指出在迁跃空间内部存在“漩涡”或“涌动” －－正是这造成了星际旅行所需的时间会有百分之五到十的出入。这一暂时的不一致性使军事战术家和战略家颇为恼火－－这会妨碍许多协同作战的进行。\n2310：初潮\n地球政府向公众公布了一系列殖民船中的第一艘－－应征者相当踊跃。地球上的状况因为人口过剩而不断恶化，搭乘飞船去外星殖民自然成了诱人的选择。 每艘殖民船都配备了军队人员和护卫舰，这样有助于更好地利用现有的庞大舰队。在异端武装瓦解后，军队正消耗着庞大的军费和物资。 因为超光速旅行在此阶段还十分新鲜而又昂贵，殖民地居民和军队人员都要通过生理和心理的严格测试。原则上，只有最优秀的公民和士兵才能获准去“邻近”的世界殖民。这就是近地殖民地（Inner Colonies）的诞生。\n2362：远征号\n远征号（The Odyssey）于2362年1月1日发射。作为浩浩荡荡的殖民舰队的领头舰船，远征号满载着部队和地貌改造装置，殖民的矛头直指新世界。人类超越太阳系的边界向外扩展的初潮由此拉开帷幕。\n2390：近地殖民地\n到了2390年，近地殖民地的殖民化运动正如火如荼。总计有210个人类占据的世界在进行不同程度的地貌改造，而在人类掌控的太空里，人口负担得到了巨大的缓解。\n2490：远地殖民地的诞生\n扩张仍在马不停蹄地进行，到2490年已经有800多个人类世界遍布银河系猎户座星臂了（这些世界形形色色，既有高度开化的星际要塞，也有偏僻的小定居点）。随着向外扩张的继续，近地殖民地成了政治和经济重镇，虽然他们极其仰赖远地殖民地提供的原材料。 在这一时期，致远星（planet Reach，围绕波江座第五恒星（Epsilon Eridani）运转，正当地球的咽喉要道）成为了UNSC的主要舰船制造厂和训练营地。致远星是战舰和殖民船的主要制造地，也是训练秘密特工和特种部队的所在地。\n2525：星盟战争开始\n2525年4月20日，与远地殖民地丰饶星（Harvest）的联络中断了。在试图重新建立联络的努力失败后，殖民军总参谋部 (the Colonial Military Administration，CMA）派遣了一艘侦查舰，金羊毛号（the Argo）前去调查。可是金羊毛号一到达丰饶星系，与飞船的联络也突然中断了。 CMA火速派遣了一支三艘战舰组成的战列舰队前往丰饶星。只有战列舰队领航的旗舰大力神号（the Heracles）返回了致远星，战痕累累，伤亡惨重。战舰的指挥官报告说，出现了一艘配备了强大武器的外星战舰，已经践踏了丰饶星，血洗了殖民地（很可能也已摧毁了金羊毛号）。 战列编队很快遭遇了外星战舰，并被紧密跟踪。在两艘战舰被击毁后，大力神号迅速跳出了星系，但因为受损严重，几周之后大力神号才回到了致远星。 地球军立即提升了警报级别，开始积极准备收复丰饶星的作战计划。当年12月，由普雷斯顿·科尔（Preston Cole）中将率领的地球军舰队浩浩荡荡地出发了，如此快地派出如此庞大的远征军，在人类历史上实数罕见。\n2525：丰饶星战役\n科尔率领的舰队誓报殖民星沦陷之仇，在与外星战舰的遭遇战中告捷－－尽管胜利的代价是损失了科尔军三分之二的有生力量。扭转战局的，只是科尔在最后几分钟，战术上的灵光乍现罢了。 军队回师地球之后，晋升为上将的科尔才获悉：许多外围殖民地已经沦陷，无人生还。科尔开始排兵布阵，准备对入侵者展开截击。地面战和舰船战相当惨烈，战火绵延到了整个远地殖民地。在一次地面遭遇中，人类部队俘虏了一个外星入侵者。在负伤过重死亡之前，人类得知这些外星人自称为“星盟” (the Covenant）。 远地殖民地大屠杀 在接下来的几年中，科尔部遭到了重创，他个人出色的领导力和战略才华也无济于事。这完全是一场实力悬殊的较量，星盟在舰船战中的胜率甚至接近四比一。 到了2535年11月，事实上所有的远地殖民地都已经惨遭星盟屠戮。“科尔协议”（Cole Protocol）作为军事命令确立了如下原则：所有的地球舰船必须确保星盟军不会发现地球。当地球舰船被迫撤退时，必须远离环地航线，甚至不做计算就进行超时空跳跃也在所不惜。 如果存在被星盟俘虏的危险，连“盲跳”都不可行时，船长必须下令船只自毁。此外，强大的舰船人工智能（AI）核心数据也切不可落入敌军之手。所以，科尔条款的部分内容也指出：在紧急状态下，必须转移或销毁舰船人工智能。\n2536-2552：近地殖民地之围\n星盟的铁蹄已经踏入近地殖民地。多年来的战事渐成定局：人类只是以极其高昂的代价赢得局部战斗的胜利，尤其是在地面行动中。而在太空对战中，人类的失利猝不及防，殖民地就这样接二连三地沦陷了。\n2552：致远星的沦陷\n星盟军终于到达了致远星－－这个离地球最近的重大军事要塞覆灭了。秋风之墩号（the Pillar of Autumn）巡洋舰，载着最后一个二期 (SPARTAN）斯巴达战士士官长逃出生天，幸免于难。所谓“斯巴达战士”指的是超级特种兵的一种精英作战单位，装备了令人望而生畏的雷神锤装甲。他们是人造的终极兵种。 现在，仅存一个斯巴达战士能与敌对决了。秋风之墩号的舰长雅各布·凯斯（Jacob Keyes）为了遵守“科尔条款”下令进行目的地未知的长程跳跃，希冀着能让星盟追兵始终远离地球。 引擎熄火后，秋风之墩发现自己落入了一个辽远未知的星系。星系中也有一支星盟舰队，他们附近有一个行星般大小的环状结构－－“光晕”。\n2552-2553：地球战役\n解决了“光晕”的问题之后，秋风之敦号一小部分幸存者和致远星上的部分幸存者合流，经过一系列艰辛的征战回到了地球。然而，此时星盟舰队也大举入侵。人类不得不为自己最后一个故乡而战。　由于星盟内精英和鬼面兽势力的对抗导致了星盟的分裂，以神风烈士提尔·外达密和星盟舰队指挥官瓦图米为首的精英起义舰队于2552年底和以真相先知、鬼面兽首领塔塔罗斯为首的先知鬼面兽舰队作战。而此时先知已经在地球上找到了通往“方舟”的传送门，精英与人类组成同盟，向神秘的“方舟”进发。\n2553：方舟战役，战争结束\n士官长等人在方舟阻止了真相先知毁灭世界的阴谋，同时为了对付另一个威胁，他们摧毁了方舟。然而回到地球后，大家翘首期盼的士官长却没能够回来。大家怀着悲痛的心情悼念战争中牺牲的战士，而在纪念碑的一角不知是谁刻上了士官长的编号“117”三个数字。\n初始背景 先驱 先驱（Precursor）是先行者信仰中的上古先贤，在先行者历史之前数千万年已经存在。先驱本为宇宙中一个科技水平极其先进的种族，先行者标记其为自己的科技等级列表中最高的等级0，他们大约身高15米、身宽11米。先驱负责在各个星系中创造、播种、改造、守护所有生命/种族，这被称为 Mantle（传承的责任、衣钵）。并且当一个智慧种族进化到一定程度后，先驱会评估他们是否能够传承『衣钵』。如果这个种族与衣钵的意义有冲突或者是失败品，先驱就会将其灭绝。 先行者 (Forerunner)、人类 (Humanity)、先知 (Prophet)、洪魔 (Flood) 等种族在当时都受先驱者支配。 先行者的“革命” 先驱选择了母星位于 Ghibalb 星球的高等智慧种族『先行者』作为下一个考察对象，虽然此时继承“衣钵”的候选人越来越令先驱满意，但是最终先驱还是认定先行者无法完全继承“衣钵”，于是计划将先行者灭绝。不料先行者知晓了先驱的意图，决定先发制人，孤注一掷地发动了对先驱的突袭，重创了毫无防备的先驱。在先驱眼中无比稚嫩的先行者究竟是凭借什么力量成功袭击了先驱，至今依然是一个秘密。先驱随后离开银河系。 古人类\u0026amp;古先知 先驱在此之前已经创造了与先行者同源的另一种智慧生命并播种在地球，作为其潜在的继承者。最终人类得以诞生。古人类的星际文明很发达，科技水平虽然低于先行者，不过他们长期研究先行者的科技，再加上与实力强劲的先知结成了同盟，于是联盟的力量在银河系中超过了先行者。 虫族（洪魔） 离开银河系的先驱被先行者激怒，他们凭借自己强大的科技汇聚了12种未知生物个体（这其中也包括一名先驱），创造出了可怕的虫族-洪魔(Flood)，决定在银河系释放这种生物武器作为制裁手段，并主导一场重估生命发展方向的试炼。但是这次先驱相信自己在银河系中可能已经拥有可以传承“衣钵”的继承人-人类。所以制裁对象仅限于先行者，同时，先驱也想借此测试人类能否真正继承“衣钵”，在与虫族冲突之后为银河系带来繁荣，或者银河系是否会屈服于虫族，产生另一种高度一体化的和平。结果不外乎只有2个：先驱的“衣钵”继承者获得成功，先驱的计划在银河系宣告完成；或者虫族战胜一切，先驱放弃银河系，将银河系的未来交给虫族。 虫族的形态是一种相当致命的寄生体，其生物质量是由一种无差别的虫族超级细胞 (FSC) 所组成，其结构与神经元及胶质细胞相似，虫族能够自己编排这些 FSC，并模仿它们所需的有机体。虫族爆发时会经历几个特定阶段：野生、互助、星际、超星系。野生阶段的虫族会使用4种形态：感染、战斗、母体、原始尸脑兽。虫族一旦成功建立了原始尸脑兽，便会进入互助阶段。此时可使用的形态数量开始急剧增加，其中的变身形态是虫族将FSC附着于钙质构建的弹性架构而创造出的战斗体。变身形态数量达到平衡后，战斗形态会转为纯防御角色或是作为钙质储备。虫族进入星际阶段后，它们除了形态上的进化，还能完全吸收所获得的科技。当虫族强大到同化了星系的程度后，如果实力允许，它们将进军其他星系，此时，虫族便进入超星系阶段。 虫族的感染形态附在生物个体后，可以选择感染或者不感染。一旦被虫族感染，将不会有任何可行的治疗手段。 先驱将这至少12种以未知生物为素体组成的虫族首领“上古尸脑兽 (Gravemind)” 放置于储存舱，投放在银河系边缘的一颗废弃行星上。它就是后来的永生者 (the Timeless One)，也叫做原基 (Primordial)，而尸脑兽的意识则来自那名融合为虫族的先驱个体，先行者称它为受囚者 (the Captive)。它的目的是要将先驱与先行者战争的真相告诉想要了解真相的人：衣钵的意义、虫族的起源、人类的角色、先行者不是衣钵的继承者、人类在通过测试之后可以继承衣钵。 古人类-虫族战争 先驱的计划开始实施。公元前 110,000 年左右，古人类发现了数艘自动驾驶的星舰坠落在银河系边缘附近的一些殖民行星和荒废行星上，里面有数以万计装有干燥粉末的玻璃桶。古人类严格检测和研究这些相对简单的短链有机分子粉末后认为无害，只是对低等生物有些神经影响。他们尝试将粉末喂饲在古人类和先知世界里很流行的宠物 Pheru，它们变得更加驯服。 但谁都没有想到，这些粉末正悄悄地改变 Pheru 的基因遗传密码，几个世纪之后，这些 Pheru 开始变异，性情狂暴并且侵食同类，不少被安乐死或者流放野外。饲养 Pheru 的古人类和先知也染上各种病症，精神上的影响让他们食用染病的 Pheru，丢弃的部分也加速了怪病的传播。感染者与未感染者开始了自相残杀，被感染的古人类和先知将疾病蔓延到了其它星系，助长了虫族的爆发。虫族不断蚕食各种生命体和可用的资源，并形成了战斗群，人类-虫族战争开始。 古人类之前在银河系边缘附近的星系发现了在储存舱内的上古尸脑兽，并转移到 Charum Hakkor 星球。古人类曾经与它沟通，但是得到的回答都很深奥，不明所以。在首次遭遇虫族后，一些古人类再次询问上古尸脑兽关于虫族的特性和疾病的起源，它说出了答案，其中一部分古人类变得极度恐慌而自杀。 经过漫长的血战，古人类相信他们找到了对付虫族的方法，对外宣称能治愈这场灾变。古人类以牺牲三分之一数量的个体为代价，改变他们的基因，让他们作为宿主主动被虫族吸附、但可以不被虫族感染为同类。这些基因阻止了虫族的扩散，寄生体不再拥有“繁殖能力”，虫族终于退出了银河系，接近 9,000 年没有再出现。古人类战胜虫族之后，摧毁了他们最早时候发现的虫族粉末星舰，也不留下任何古人类、先知、Pheru 体内残留的虫族样本，并且销毁他们认为可以治疗虫族感染的方法的所有资料。由于没有了这些证据和信息，先行者无从知道虫族的特性。 但其实古人类并没有找到治疗的方法。虫族退出银河系是因为它们受到先驱决定让古人类继承衣钵的命令，已经达到试验目的所以先驱决定将“衣钵”给予人类，虫族也不再感染古人类，转为开始灭绝先行者。 人类\u0026amp;先知联盟-先行者战争 古人类在联盟中心的Charum Hakkor 星球上发现了银河系中最多的先驱科技，这意味着先驱已经将自己所掌握的力量分享给继承了自己“衣钵”的古人类。突如其来的馈赠使得古人类欣喜若狂，并开始变得傲慢，试图挑战先行者的地位，认为自己是先驱的真正继承者，将取代先行者称霸银河系。另一方面，古人类在与虫族的血战中失去大量殖民地，不得不疯狂入侵还没有遭到虫族感染的其他种族的星球作为人类的生存区域，当中包括了很多先行者的领土。意识到作为先驱继承人的古人类科技水平即将急速发展以及他们不断的挑衅给先行者带来了强烈的危机意识，先行者终于无法忍受，发动了战争。 虽然古人类占领了很多先行者星球，不过人类为对付虫族牺牲巨大，击退了虫族之后，古人类和先知同盟已经消耗殆尽，同时先驱的科技也并非能在短时间就大幅度的加以利用。于是在先行者军团统帅宣教士 (The Didact)的 指挥下，人类被迫回撤到 Charum Hakkor 星球。他们使用先驱的科技和防卫要塞抵抗强大的先行者星际舰队。先知军团援助的路线被切断，古人类继续抵抗了五十多年。公元前 109,000 年左右，在绝对的优势面前，尚未能开始消化先驱科技的人类被击败，无数的古人类和先知不愿被俘而自杀。不过先行者这边也损失巨大，在先驱科技的强大力量作用下，宣教士的后代全部阵亡。 战后，先行者最终放弃灭绝战败的人类，认为会违反衣钵的意义。宣教士和他的普罗米修斯战团在后来的政治斗争中处于被动，由于处在和平环境下，加之激进的思想，他们最终被迫退出议会，宣教士和他的战团代表的整个先行者武侍阶级在随后的数千年中被边缘化，舰队解散，先行者军事实力削弱，这使得他们在后来的虫族再次入侵时措手不及。宣教士也自我放逐，休眠于存放在地球的战士牢笼 (Cryptum) 之中。 先行者将人类和先知的基因退化，回到没有科技文明前的原始时代重新进化，并且处决了很多挑起冲突的古人类。先行者开始称霸银河系。 先行者-虫族战争 先驱已经从银河系中消失，但是他们下达的灭绝先行者的命令开始由虫族执行， 为了对虫族再次入侵银河系做好最坏的打算，先行者的首脑-大架构师 (Master Buider Faber) 在公元前 101,000 年下令建造环带阵列。他在大方舟 (greater Ark) 建造了12个直径3万公里的大环带，用作对付虫族的终极手段，而同时宣教士的妻子智库长 (The Librarian) 也在小方舟 (Ark, Installation 00) 建造了6个直径1万公里的小环带。两个方舟以及大量的的护盾世界 (Shield World) 用以保护银河系物种的样本在环带发射时免遭灭绝。采集和索引银河系物种并送往方舟的工作，由管理者领导生命工作者 (Lifeworkers) 完成，但工程量巨大，彻底完成需要大量时间。 虫族在公元前 100,300 年再次出现在银河系，开始了与先行者持续三百年的战争。先行者尝试所有方法，也未能击退虫族，一直处于劣势。同时，虫族逐渐掌握智慧生物们的科技，实力高速膨胀。 公元前100,043 年，先行者大架构师授权军事人工智能偏见之僧（Mendicant Bias/MB）在Charum Hakkor星球附近测试发射07号大环带。攻击穿透了星球上所有的先驱建筑，并释放出人类存放在这里的上古尸脑兽。偏见之僧随后将它带到07号大环带研究，并与07号环带一同消失了43年。在这段时间内，由先驱转换而成的上古尸脑兽与偏见之僧进行了交谈，先驱传达的思想几乎是难以抗拒的，以至于偏见之僧最后也不得不被强大的上古尸脑兽诉说的故事和真相说服：相信银河系的未来属于虫族，先行者自作主张接手“衣钵”的举动让银河系陷于永恒的停滞，只有毁灭先行者才能让银河系的物种继续进化。 随着战事进行，先行者将另外11个大环带调回银河系的先行者首都圈，偏见之僧也在公元前 100,000 年突然带着07号环带回来，它控制了在场的许多引导者AI，对先行者发起突然袭击。宣教士发出了故障保护密码，暂时瘫痪偏见之僧，启动首都圈的防卫系统，与同伴进入运输舰回到方舟与妻子会合。偏见之僧的权限成功控制了五个大环带，声称与虫族合作消灭先行者。先行者将其余的七个环带从首都圈的传送门紧急送入方舟，但是由于情况危急，最终传送门超载崩溃，只有一个在传送门坍塌前抵达。首都圈的防卫系统发挥作用，摧毁其中一个大环带，处于极度不利处境下的偏见之僧带着07号大环带撤退，其余的大环带下落不明。 宣教士的肉体在受虫族感染的星系中死亡，他的意志被转入先行者“新星”体内并重新掌控先行者军团控制权，他随后追踪到偏见之僧和上古尸脑兽所在的07号环带，率领舰队拦截。宣教士（新星）用控制密码驱逐了偏见之僧，将严重受损而不稳定的07号大环带缩减为小环带后传送到大方舟。他与一名古人类拷问了07环带上的上古尸脑兽。尸脑兽告诉他们：自己就是由先驱转化而成，用以操纵虫族，并将先驱、先行者、古人类、虫族的关系、人类其实没有治愈虫族的方法等真相尽数告知。宣教士最后消灭了上古尸脑兽，而他只将真相告诉了妻子智库长。 时机成熟，偏见之僧率领虫族大军，操纵由数百万艘强大的战舰组成的军队，以难以阻挡的实力进攻方舟，先行者的防御体系终于崩溃，不得不考虑最终手段，先行者们准备发射环带阵列作为最后的手段。智库长此时正在地球索引物种、关闭导向方舟的传送门，虫族则大肆进攻，希望侵入方舟以阻止先行者“同归于尽”。为了确保方舟的安全，她摧毁了所有能够带她回到方舟的圣匙战舰（Keyship），认为保存银河系物种的重任比自己的生命重要得多。宣教士派出营救部队，要赶在环带发射前接回妻子，但是都被偏见之僧的舰队拦截。 先行者新建的军事人工智能偏见进逼（Offensive Bias）利用偏见之僧在最终关键时刻精力的转移和兵力处绝对优势下的疏忽，成功以5:2183的悬殊兵力争取到了最后的一点时间，环带阵列中的7个环带启动，击溃大部分虫族舰队，虫族的武装力量瞬间崩溃，偏见进逼从而获得了 6:1 的兵力优势，反败为胜并俘获了偏见之僧。随着环带阵列的启动，银河系所有不受方舟和护盾世界保护的生物全部被杀死，随后方舟上的Keyship将先行者保存索引的物种送回各自星系。先行者与虫族的战争结束。 继承遗产 智库长认为人类与先行者都是先驱下面同源的生命，而且作为先驱选定的继承者，将来同样可以成为先行者的继承人。在被环带杀死前，她在进行索引时将先行者的一些神秘的基因指令 (Geas) 注入到人类基因之中，使得人类可以让先行者设施引导者和系统所识别。这为后来先行者为人类封存自己的科技以便将来人类继承他们的力量埋下了伏笔。同时，失去了先驱操纵的虫族尚未灭绝，成为了未来银河中所有生命的公敌。 \u0026ndash;来自于百度百科\n","id":55,"section":"posts","summary":"halo1是微软于2001年发行的第一人称射击游戏 halo是一个很注重武器选择的游戏，合适的武器会非常高效 剧情 2160-2200：早期冲突 这","tags":[],"title":"光环1","uri":"https://dyhgo.github.io/2020/03/%E5%85%89%E7%8E%AF1/","year":"2020"},{"content":"ac2由育碧蒙特利尔工作室开发\n十年前玩的游戏，环境渲染和剧情真的超棒\n背景音乐选的十分用心\n后来主角ezio也成为了刺客信条系列的标志\n刺客信条系列基本延续着刺客和圣殿骑士（现在的abstergo）的斗争，进入animus为追求祖先记忆，寻找金苹果讯息。。。\n续作兄弟会的剧情显得有些乏味，不过以组建兄弟会为主线的游戏安排还是很可以的\n线上有更丰富的内容\n剧情 刺客信条2：\nDesmond在刺客信条1之后本来是准备要处死的，但是Lucy帮他逃了出来，和另外两个现代刺客会合。为了找到伊甸园圣器的下落，Desmond不得不再次进入刺客兄弟会的机器Animus 2.0，这一次他成为了中世纪佛罗伦萨的贵族Ezio Auditore(艾奇奥)。Ezio的父亲和两个兄弟被陷害以后，他在自己的叔叔Mario Auditore(马里奥)的帮助下脱离险境，并且知道自己的家族是刺客家族。于是他开始自己的复仇之路。在复仇的过程中，Ezio慢慢知道了伊甸园圣器的事，并且自己也在慢慢成长，直到有一次圣殿骑士从外地运回威尼斯一件很重要的物品，被Ezio夺到，原来就是金苹果。\n于是Ezio发现一个事实，就是在罗马有一件伊甸园圣器“教皇权杖”，它和“金苹果”结合就能打开一些秘密。于是刺客们就前往罗马，一来为了杀死陷害Ezio一家的罗马教皇Rodrigo Borgia(罗德里格·波奇亚)，二来为了抢夺教皇权杖。谁知Rodrigo早有准备，反刺伤了Ezio，抢了他的金苹果。但是Rodrigo没有刺客的血统，结合了教皇权杖和金苹果，但却无法激活。而后Ezio赶来，两人赤手空拳搏斗，Ezio最终胜利，但心一软没有杀死这位陷害自己一家的幕后主使。Rodrigo逃脱。Ezio身为正统刺客，发现自己的血统使两件伊甸园圣器合体激活，打开了罗马教堂地下的一间密室，而密室中出现的影像却是给后来人，也就是给现代正统刺客Desmond的信息。然而回到现代，正在此时，圣殿骑士出现，Lucy和Desmond不得不展开战斗，Desmond通过Animus的血统效应已经学会了Ezio的一些技能，击退了圣殿骑士以后逃离。\n刺客信条兄弟会：\nDesmond和Lucy一行人一直逃到蒙特奥吉欧尼，也就是中世纪Ezio叔叔Mario的庄园。他们开始继续搜索金苹果的下落。回到Animus中，Ezio打败Rodrigo之后载誉归来，回到Mario的庄园，但不想第二天凌晨，Rodrigo的儿子Cesare Borgia带兵攻打庄园，并最终抢夺了金苹果，还杀死了Mario。Ezio也只能带伤逃离。逃离了以后，他孤身一人来到罗马，再次踏上了复仇之路。在Machiavelli(马基雅维利)、Da Vinci(达芬奇)和罗马当地的佣兵、交际花和盗贼的帮助下，Ezio解放了罗马，拿回了金苹果，并最终杀死了Cesare。夺回金苹果后，Ezio把它埋在了罗马大剧场地下的一间密室里。回到现代，Desmond等人立即赶往罗马大剧场遗址，并进入密室，拿到了金苹果。但Desmond一碰到金苹果之后就被控制，不由自主走向Lucy，刺杀了她，随后陷入了昏迷。\n刺客信条启示录：\nDesmond昏迷之后，其他刺客急忙将他放回了Animus，希望通过Animus能让他苏醒。在Animus中，Desmond的意识和肉体已经分离，他的意识遇见了另一位在Animus中游荡的“16号”意识，来自一位现代已经遇害的刺客。16号告诉他只有在Altair(阿泰尔，刺客信条1主角)、Ezio和Desmond完全同步的时候才能让Desmond找回自我。于是Desmond第三次进入了Ezio的记忆。\nEzio为了寻找古老刺客的知识，来到了Altair所在的马西亚夫城堡，发现一间Altair建造的密室。为了打开密室，Ezio必须找到五把Altair留下的钥匙，而这些钥匙已经被当时马可波罗的父亲带去君士坦丁堡埋藏。到了君士坦丁堡之后Ezio卷入了宫廷斗争，还认识了一位有魅力的女人Sofia(索菲亚)。找到五个钥匙之后，Ezio和Sofia一起回到了马西亚夫城堡，打开了密室，见到了Altair的遗体和Altair留下的另一个力量更强大的金苹果。这时金苹果又被激活，Altair、Ezio和Desmond的意识完全同步，Desmond聆听了人类诞生前的文明留下的信息，需要Desmond拯救世界。在那之后，Ezio扔下了身上的武器，把它们和金苹果放在一起留在了密室，结束了自己的刺客生涯。回到现代，Desmond从Animus中苏醒了过来。\n刺客信条-余烬：Ezio老年和Sofia生活在佛罗伦萨郊外的一片农庄里，他们有两个孩子。有一天来了一个中国女刺客，为了刺杀残暴的嘉靖皇帝来向Ezio求教。帮助了女刺客之后，有一天Ezio在和Sofia逛街的时候疾病突发，安详仙去。\n当我还年轻时，我身怀自由，但我并未看出它的存在，我有大把的时间，可我不懂得珍惜，我还拥有爱，但是从未真实地感受过它，我花了好几十年才明白这三者的真正意义，但现在，在我生命中的黄昏，这些认知逐渐转变成了幸福。爱，自由，时间,曾经随意丢弃的这些，原来正是驱使我前行的动力，而在这三者中，爱尤其宝贵。以此献给你和我们的孩子，以及我们的兄弟姐妹，还有这个赋予我们生命与好奇的广袤世界。索菲亚，我对你的爱永无止境——无论何时都属于你的——艾吉奥·奥迪托雷\nEzio写给Sofia Sorto的遗书 \u0026mdash;来自网络\n","id":56,"section":"posts","summary":"ac2由育碧蒙特利尔工作室开发 十年前玩的游戏，环境渲染和剧情真的超棒 背景音乐选的十分用心 后来主角ezio也成为了刺客信条系列的标志 刺客信条系","tags":[],"title":"刺客信条2","uri":"https://dyhgo.github.io/2020/03/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/","year":"2020"},{"content":"《刻痕》是由蓝天使制作组制作的2D动画游戏，于2008年发行，是一款恐怖推理解谜游戏\n《刻痕》是国内原创推理悬疑解谜（猎奇）游戏的始祖，国内第一个以R15作为GALGAME正式标准的游戏，也是国内第一个R15类型的推理悬疑解谜（猎奇）类游戏，刻痕系列首次在国内提出了带有悬疑、血腥、恐怖或者猎奇要素的游戏，要以R15作为分类标准的概念，此分类概念在后来在国内整个GALGAME行业业界被得以广泛认可，并被普遍流传使用。\n","id":57,"section":"posts","summary":"《刻痕》是由蓝天使制作组制作的2D动画游戏，于2008年发行，是一款恐怖推理解谜游戏 《刻痕》是国内原创推理悬疑解谜（猎奇）游戏的始祖，国内第","tags":[],"title":"刻痕","uri":"https://dyhgo.github.io/2020/03/%E5%88%BB%E7%97%95/","year":"2020"},{"content":"波斯王子 prince of persia是ubisoft于1989年发行的一款单机游戏 波斯王子有好多部，前3部是一个完整的故事，后面则是一些衍生\n这是我2010年玩的游戏，pop1通关了4遍\n作为上个世纪的游戏，画质不能与现在的3A大作比\n但是，有一说一画质也不差\n环境的渲染也特别棒，很符合故事背景，有很多细节\n游玩的时候不禁会让人驻足联想\n剧情真的很不错，以时间倒流作为主要技能是很大的创新\n也增加了游玩的乐趣\n值得一提的是，据官方称，这个游戏有六百多种动作\n按键的组合确实可以打出很多不同的动作，但前期在战斗的时候基本只需要靠几个动作\npop2应该是最难的一部，小boss血量巨厚\n如果我没记错的话，pop3应该是加入了刺杀系统，在当时是一个很大的创新，而且感觉还不错\n对于boss来讲，要一遍过还挺难\n黑暗王子的20倍攻击力用的太爽了\npop的跑酷系统在当时做的着实优秀\n游戏剧情 很多人都认为，时间就像一条河流，永远朝着一个方向不断的前进。 印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，并带走了时间女皇的遗物——时之沙漏和时之匕首。 后来，为了将这两件宝物据为己有，以达到长生不老的目的，维瑟尔背叛了穆罕默德。他怂恿波斯国王沙拉曼攻打印度，并承诺作为内应会打开印度的城门。战争结束，沙拉曼得到了时之沙漏，并且俘虏了印度国的公主法拉。而波斯王子由于在战争中的杰出表现，得到了他的第一件战利品——时之匕首。 波斯大军凯旋在阿扎德苏丹皇宫暂时停留时，心怀怨恨的维瑟尔诱惑波斯王子用匕首打开时之沙漏，释放的时之砂瞬间吞噬了整个皇宫，并且将沙拉曼变成了砂之怪物。 王子不得已杀死了自己的父亲，在悲痛欲绝中，逃脱的印度公主法拉告诉王子，只要将时之匕首重新插进时之沙漏，那么时间就会倒退，回到一切的开始。于是王子和法拉开始了他们的冒险。 随着冒险的不断深入，王子和法拉的情感也在发生微妙的变化。最后，法拉悄悄的带着时之匕首离开了王子。王子找到了法拉，但却眼睁睁的看着法拉坠楼身亡。哀伤的王子夺回了匕首并将其插进了沙漏里。 伴随着维瑟尔绝望的呼叫，时间倒退到了波斯军队进攻印度之前。保留着记忆的王子在进攻的前夜悄悄的潜进了公主法拉的卧室，告诉了她一切，包括维瑟尔的背叛。被揭穿的维瑟尔恼羞成怒，想要杀掉法拉嫁祸给王子，但被王子消灭了。后来，王子劝说他的父亲沙拉曼撤走了军队，一切好像都恢复了平静。但是谁也没有料到的是，王子的命运已经被诅咒：任何使用过时之匕首的人，只有死路一条。 “因为王子使用了时之匕首破坏了时间的平衡。而达哈卡就是为了恢复时间的平衡而诞生的，他就像时间一样是不可战胜的。达哈卡会像影子一样追杀着王子，直到王子的生命走到尽头。” 王子是从一位盲眼老人那里得到了自己的命运被诅咒这个消息的。为了改变自己悲惨的命运，王子打算去时之岛，回到过去，回到时间女皇制造时之沙的那一刻，去阻止时之沙的诞生。 历经艰难的王子终于到达了时之岛，并且通过岛上的时间传送点回到了过去。在那里，王子遇到了一位名叫凯琳娜的红衣少女。凯琳娜帮助了王子，她告诉了王子如何去打开时间女皇所在房间的门的机关。 在冒险的过程中，一个神秘的黑衣人不时在王子周围出现，不知是敌是友。更让人感到诡异的是，最后时间的守护者达哈卡突然在王子和黑衣人的面前出现，但是达哈卡却杀掉那个黑衣人，然后没有理会王子就走了！纳闷的王子按照凯琳娜的帮助打开了时间女皇房间的大门，却又愕然发现原来凯琳娜就是时间女皇！怨愤的凯琳娜告诉王子，她之所以帮助王子，就是想让王子在打开大门的过程中被那些机关杀死，或者被时间守护者达哈卡杀死。原来凯琳娜也通过时间线预知到了自己的命运：她将会被波斯王子亲手杀死！同样为了改变自己悲惨的命运，时间女皇和王子展开了一场生死战，最后王子逼不得已只好杀掉了凯琳娜！ 凯琳娜在临死之前告诉王子：没有人能改变自己的命运，你也会像我一样去奋力，但你也会像我一样死去！随后，凯琳娜的尸体迸发出了金色的光芒。 王子通过时间传送点回到了杀死父亲之前。本以为一切都结束的王子突然发现时间的守护者达哈卡仍然在追杀他。这时王子才想起来，凯琳娜死后那些金色的光芒就是时之沙！（王子本以为时之沙是时之女皇凯琳娜制造的，杀死凯琳娜就可以阻止时之沙的诞生，但事实是时之沙的诞生正是因为王子杀死了凯琳娜，时之沙就是凯琳娜死后尸体变成的）绝望的王子被达哈卡困在了一个地下墓穴里。就在万念俱灰之时，墙壁上的文字吸引了王子的注意。 根据文字记载：当年印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，在夺取时之沙漏的过程中，穆罕默德不幸被时之守卫杀死，但幸运的是，一件黑色的面具让他有了第二次机会…… 就像在黑暗中看到了一丝曙光一样，王子暂时摆脱了达哈卡的追杀，去寻找那件黑色面具。终于在时之岛的尽头，王子找到了黑色面具。戴上了面具的王子回到了他刚到时之岛的那一刻，并且变成了一个黑衣人——原来在他冒险的过程中时隐时现的黑衣人其实就是他自己。 又经过一番努力，王子最后阻止了自己被达哈卡杀掉（本来达哈卡杀掉了黑衣人，但王子没有让这件事情发生，达哈卡转而杀掉了原来的王子），王子又变回了原来的样子。由于知道了接下来将要发生的事情，王子决定利用时间传送点把时间女皇凯琳娜带到之前。这样即使凯琳娜死了时之沙也不会威胁到自己。变身回来的王子成功的把凯琳娜带到了之前，但是时间的守护者达哈卡再度现身，只不过这次他的目标换成了凯琳娜。这是理所当然的，凯琳娜本来不属于这个时代，为了维护时间的平衡，达哈卡自然把矛头对准了她。因为不忍心凯琳娜就这样被达哈卡杀死，王子利用从过去带回来的一把水之刃（此刀可以伤害到达哈卡），与达哈卡展开了一场肉搏战。 最后在凯琳娜和王子的配合下，达哈卡居然奇迹般的被消灭了。胜利的王子打算带着凯琳娜一起回到他的故乡——波斯的巴比伦城，想从此过着平静的生活。但此时的巴比伦城正被战火所蹂躏……盲眼老人的声音仍在萦绕在王子心头：你不可能改变自己的命运，没有任何人可以。 几个星期后，王子带着凯琳娜离开了时之岛回到了他故乡巴比伦城，却发现整个巴比伦城陷入一片火海中。震惊和愤怒的王子不敢相信眼前的一切，但随后他的船就被飞来的火球打翻，并且和凯琳娜失散。 昏迷的凯琳娜被侵略军带到了巴比伦皇宫里。王子紧随其后想要去救她。在皇宫中，愤怒的王子不幸被敌人擒住，但他却愕然发现侵略军的首领居然是那个“已经被自己杀死的”邪恶法师维瑟尔！而维瑟尔居然又不认识自己？原来，当王子把时间女皇凯琳娜带到之前的一霎那，历史就已经发生了改变：由于没有时之沙，维瑟尔也就不会去背叛穆罕默德，也就没有了波斯进攻印度的历史，维瑟尔也就不会认识王子，当然也不会被王子杀死了。 历史已经改变，但依然改变不了维瑟尔邪恶的欲望。 多年以前，印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，与原先的历史不同，他们只找到了一把时之匕首，至于传说中的时间女皇和时之沙则没有任何存在过的痕迹。已经对时之沙快要放弃的维瑟尔却突然发现时之匕首在最近几个星期变得活跃了起来，维瑟尔很快明白了究竟发生了什么事情：时间女皇来到了之前！被长生欲望熏昏了头脑的维瑟尔杀死了穆罕默德，囚禁了印度公主法拉，控制了印度的军队来进攻巴比伦城！企图寻找时间女皇！时间女皇凯琳娜终于落在了维瑟尔手中！残忍的维瑟尔用时之匕首杀死了凯琳娜，释放出了时之砂，他又将匕首插进自己的身体里，随后变成了一个金黄色的怪物——维瑟尔终于达到了他长生不老的愿望。整个巴比伦城被时之沙吞没，那些侵略军全部被感染到了时之砂，变成了沙之怪物，就连王子自己的手臂也被时之砂侵入。危急时刻，王子挣脱了束缚，抢走了时之匕首，离开了巴比伦皇宫。时之沙唤起了王子最大的敌人…… 被时之沙感染的王子感觉到体内产生另一个邪恶的人格——黑暗王子。黑暗王子狡猾，残忍，对弱者没有同情心，但在冒险的时候王子却需要变身成黑暗王子来渡过难关。 在这种奇怪的组合下，王子又遇到了自己爱慕的印度公主法拉。法拉被维瑟尔囚禁后也被带到了巴比伦城。后来法拉在时之沙的混乱中逃脱，遇到了游荡在巴比伦城的王子。起初法拉对波斯王子的双重身份深感怀疑，但在随后的冒险中逐渐与王子重新建立了信任和友情（法拉再次遇见王子的时候也和维瑟尔一样不认识他了）。但在冒险的过程中，黑暗王子的感染变得越来越严重，这让王子本身深感不安。不幸的是，冒失的法拉又被维瑟尔抓住，而王子被打入了一个黑暗的深洞里。 最后，在巴比伦城黑暗的地下宫殿里，王子找到了他父亲波斯王沙拉曼的尸体。悲痛的王子拿起父亲的宝剑，抑制住了邪恶的黑暗王子的意识，决心找维瑟尔复仇。 在巴比伦的空中花园，左手持波斯帝王宝剑，右手持时之匕首的王子与维瑟尔展开了一场决战！胜利的王子将时之匕首插进了维瑟尔的心脏，彻底的终结了这个邪恶的灵魂。 已经变成时之沙的凯琳娜再度幻化成人形来跟王子告别：这个世界本不属于我，自有我所归属的世界……王子将时之匕首交给凯琳娜，凯琳娜化做时之砂，向远方飘散而去。 凯琳娜消失之后，黑暗王子从王子的内心世界中分裂出来，企图夺走王子的一切，但王子走出内心的阴霾，最终在虚幻的世界中消灭了黑暗王子。 时之砂消逝，邪恶力量破灭，波斯帝国的子民为王子所拯救，一切都结束了。 在巴比伦的空中花园，王子再次向法拉讲起了那个时间的故事。\u0026ndash;百度百科\n","id":58,"section":"posts","summary":"波斯王子 prince of persia是ubisoft于1989年发行的一款单机游戏 波斯王子有好多部，前3部是一个完整的故事，后面则是一些衍生 这是我201","tags":[],"title":"波斯王子","uri":"https://dyhgo.github.io/2020/03/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/","year":"2020"},{"content":"A - Duplex Printing 题目链接 题意 每一页正反两面可以分别写一个数，问有n个不同的数可以写几页\n思路 简单模拟\nac代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main()\r{\rint a;\rcin\u0026gt;\u0026gt;a;\rif(a\u0026amp;1)\rcout\u0026lt;\u0026lt;a/2+1\u0026lt;\u0026lt;endl;\relse\rcout\u0026lt;\u0026lt;a/2;\rreturn 0;\r}\r B - Bingo 题目链接 题意 有一个3*3的网格填满数字，接下来给出一些数字，如果网格中有，就标记。\n问是否存在一行或一列或对角线满足它们都被标记\n思路 由于数据不是很大，所以暴力模拟\nac代码如下\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rbool b[3][3];\rint main()\r{\rint d[3][3];\rint n;\rfor(int i=0;i\u0026lt;3;i++)\rfor(int j=0;j\u0026lt;3;j++)\rcin\u0026gt;\u0026gt;d[i][j];\rcin\u0026gt;\u0026gt;n;\rint t;\rwhile(n--)\r{\rcin\u0026gt;\u0026gt;t;\rfor(int i=0;i\u0026lt;3;i++)\rfor(int j=0;j\u0026lt;3;j++)\r{\rif(d[i][j]==t)\r{\rb[i][j]=true;\rbreak;\r}\r}\r}\rbool flag=false;\rfor(int i=0;i\u0026lt;3;i++)\r{\rif(b[0][i]== true and b[1][i]==true and b[2][i]==true) {\rflag=true;\rbreak;\r}\r}\rfor(int i=0;i\u0026lt;3;i++)\r{\rif(b[i][0]== true and b[i][1]==true and b[i][2]==true) {\rflag=true;\rbreak;\r}\r}\rif(b[0][0]==true and b[1][1]==true and b[2][2]==true) {\rflag=true;\r}\rif(b[0][2]==true and b[1][1]==true and b[2][0]==true)\r{\rflag=true;\r}\rif(flag) cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Guess The Number 题目链接 题意 给一个数位n，和若干个条件，条件类型为ai位必须是数字bi，求满足这些条件的最小n\n位数，不满足输出-1\n思路 数据很小，简单模拟，有很多的细节，注意一位数、前导0等特殊情况\n由于边打代码边想，所以代码很乱\nac代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rbool use[3];\rint main()\r{\rint d[3];\rint n,m;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rint s,c;\rbool flag=true;\rfor(int i=0;i\u0026lt;m;i++)\r{ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;c;\rs--;\rif(n!=1 and s==0 and c==0)\r{\rflag=false;\rbreak;\r}\relse if(s\u0026gt;n)\r{\rflag=false;\rbreak;\r}\relse if(use[s] and c!=d[s])\r{\rflag=false;\rbreak;\r}\relse\r{\rd[s]=c;\ruse[s]=true;\r}\r}\rif(n!=1 and !use[0]) {\rd[0]=1;\rfor(int i=1;i\u0026lt;n;i++)\r{\rif(!use[i]) d[i]=0;\r}\r}\relse\r{\rfor(int i=0;i\u0026lt;n;i++)\r{\rif(!use[i])\rd[i]=0;\r}\r}\rif(!flag) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\relse {\rfor(int i=0;i\u0026lt;n;i++)\r{\rcout\u0026lt;\u0026lt;d[i];\r}\rcout\u0026lt;\u0026lt;endl;\r}\r//cout\u0026lt;\u0026lt;use[2]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Friend Suggestions 题目链接 题意 有n个人和两种关系（双向的）friendship 和 blockship\n定义：一个人为另一个人的friend candidate\n当且仅当满足他们没有这两种关系且他们之间存在着friendship的传导链\n问每个人的friend candidate数量\n思路 由于需要friendship传导链，又存在friendship的双向关系，所以考虑并查集\n再遍历一遍信息，如果是直接的friendship和blockship关系就减掉这个人（数量减1）\n（需要计算集合元素个数）\nac代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,m,k;\r//union find\rint par[100005]; int rankk[100005]; int sizz[100005];\rint ans[100005];\rint a[100005];\rint b[100005];\rint c[100005];\rint d[100005];\rvoid init(int n) {\rfor(int i=0;i\u0026lt;n;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} int find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); } void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; if(rankk[x]\u0026lt;rankk[y]) par[x]=y,sizz[y]+=sizz[x]; else\r{\rpar[y]=x;\rsizz[x]+=sizz[y];\rif(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\rios::sync_with_stdio(0);cin.tie(0);\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k;\rinit(n);\rfill(sizz,sizz+n,1);\rfor(int i=0;i\u0026lt;m;i++)\r{\rcin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i];\r}\rfor(int i=0;i\u0026lt;k;i++)\r{\rcin\u0026gt;\u0026gt;c[i]\u0026gt;\u0026gt;d[i];\r}\rfor(int i=0;i\u0026lt;m;i++)\r{\runite(a[i],b[i]);\r}\rfor(int i=1;i\u0026lt;=n;i++)\r{\rans[i]=sizz[find(i)];\r}\rfor(int i=0;i\u0026lt;m;i++)\r{\rif(same(a[i],b[i]))\r{\rans[a[i]]--;\rans[b[i]]--;\r}\r}\rfor(int i=0;i\u0026lt;k;i++)\r{\rif(same(c[i],d[i]))\r{\rans[c[i]]--;\rans[d[i]]--;\r}\r}\rcout\u0026lt;\u0026lt;ans[1]-1;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rcout\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;ans[i]-1;\r}\rcout\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Simple String Queries 题目链接 题意 给一个只有小写字母的字符串s，和两种操作\n将ai下标的字符替换成bi\n查询l到r区间内有多少个不同的字母，输出结果\n思路 数据太大，不能简单模拟\n用合理的数据结构\n用26个集合存储有这个字母对应的下标\n对于查询区间，遍历26个集合，查询这个区间是否存在该字母（如果存在 ans++）\n只需要对每个集合二分搜索左边界的标号，如果这个标号在右边界内，即存在\nac代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,q;\rstring s;\rset\u0026lt;int\u0026gt; st[27];\rint main()\r{\rios::sync_with_stdio(false);cin.tie(false);\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rcin\u0026gt;\u0026gt;s;\rcin\u0026gt;\u0026gt;q;\rfor(int i=0;i\u0026lt;26;i++)\r{\rst[i].insert(n); //防止使用lower_bound时集合为空 }\rfor(int i=0;i\u0026lt;n;i++)\r{\rst[s[i]-'a'].insert(i);\r}\rint t;\rfor(int i=0;i\u0026lt;q;i++)\r{\rcin\u0026gt;\u0026gt;t;\rif(t==1)\r{\rint a;char b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rst[s[a-1]-'a'].erase(a-1);\rst[b-'a'].insert(a-1);\rs[a-1]=b;\r}\relse\r{\rint l,r;\rcin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\rint ans=0;\rfor(int i=0;i\u0026lt;26;i++)\r{\rauto it=st[i].lower_bound(l-1);\rif(*it\u0026lt;=r-1) ans++;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r F - Yakiniku Optimization Problem 题目链接 题意 平面上有n个点，每个点有一个属性ci，坐标上至少存在一个点使得这个点到其中k个点\n的距离*ci（只对k个点中的一点）的值的最大值最小\n输出最小值\n思路 有趣的计算几何\n很难通过找到点来求最小值\n很常见的做法是用二分法\n区间的值为“最大值“\n每一次检查满足“最大值”的点是否超过k个\n超过则将最大值减小\n否则将最大值增大（理论上直到满足k个点）\n通过精度来停机\n怎样检查？\n每个点的属性=当前“最大值” / ci\n以点为圆心，每个点的属性为半径，每两个圆可能存在交点\n遍历每个点，如果交点在某个点的属性范围内，这个点也满足条件\n遍历所有情况，求最多有多少个点满足条件\n以此来检查是否超过k\n注意点\n1.只有一个点的特判\n2.要有eps，而且eps不能太大也不能太小\n3.为避免重复计算，j从i开始，但不能从i+1开始，因为有可能目标点就在某一点上\n从i+1开始会wa掉1个测试点\nac代码如下\n#include \u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n, k;\rdouble x[65], y[65], c[65], r[65];\rdouble eps = 1e-8; //!!!\rdouble dist(pair\u0026lt;double, double\u0026gt; p, pair\u0026lt;double, double\u0026gt; q) {\rdouble xx = (p.first - q.first)*(p.first - q.first);\rdouble yy = (p.second - q.second)*(p.second - q.second);\rreturn sqrt(xx + yy);\r}\rvector\u0026lt;pair\u0026lt;double, double\u0026gt;\u0026gt; circle_circle_intersection(double x1, double y1, double r1, double x2, double y2, double r2) {\rvector\u0026lt;pair\u0026lt;double, double\u0026gt; \u0026gt; ans;\rdouble d = dist(make_pair(x1, y1), make_pair(x2, y2));\rif (d \u0026gt; r1 + r2) {\rreturn ans;\r}\rif (x1 == x2 \u0026amp;\u0026amp; y1 == y2) {\rans.push_back(make_pair(x1, y1)); return ans;\r}\rif (d \u0026lt; abs(r1 - r2)) {\rans.push_back(make_pair(x1, y1)); return ans;\r}\rdouble a = (r1*r1 - r2*r2 + d*d)/(2*d);\rdouble h = sqrt(r1*r1 - a*a);\rdouble x3 = (x2 - x1)*(a/d) + x1;\rdouble y3 = (y2 - y1)*(a/d) + y1;\rans.emplace_back(x3 + h*(y2 - y1)/d, y3 - h*(x2 - x1)/d);\rans.emplace_back(x3 - h*(y2 - y1)/d, y3 + h*(x2 - x1)/d);\rreturn ans;\r}\rint check(double t) {\rint ans = 0;\rfor (int i = 0; i \u0026lt; n; i++) {\rr[i] = t/c[i];\r}\rfor (int i = 0; i \u0026lt; n; i++) {\rfor (int j = i; j \u0026lt; n; j++) { //!!!\rvector\u0026lt;pair\u0026lt;double, double\u0026gt; \u0026gt; pts = circle_circle_intersection(x[i], y[i], r[i], x[j], y[j], r[j]);\rfor (auto p: pts) {\rint cnt = 0;\rfor (int k = 0; k \u0026lt; n; k++) {\rif (dist(p, make_pair(x[k], y[k])) \u0026lt;= r[k] +eps) cnt++;\r}\rans = max(ans, cnt);\r}\r}\r}\rreturn ans;\r}\rint main() {\rios::sync_with_stdio(0); cin.tie(0);\rcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\rif (k == 1) {\rcout \u0026lt;\u0026lt; \u0026quot;0\\n\u0026quot;; exit(0);\r}\rfor (int i = 0; i \u0026lt; n; i++) {\rcin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i] \u0026gt;\u0026gt; c[i];\r}\rdouble l = 0, r = 100000000;\rwhile(r-l\u0026gt;=1e-8)\r{\rdouble mid = (l + r)/2;\rif (check(mid) \u0026gt;= k) {\rr = mid;\r} else {\rl = mid;\r}\r}\rcout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(9) \u0026lt;\u0026lt; r \u0026lt;\u0026lt; '\\n'; return 0;\r}\r 个人感觉abc很考验思维和对数据结构的熟练度\n","id":59,"section":"posts","summary":"A - Duplex Printing 题目链接 题意 每一页正反两面可以分别写一个数，问有n个不同的数可以写几页 思路 简单模拟 ac代码如下 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int a; cin\u0026gt;\u0026gt;a; if(a\u0026amp;1) cout\u0026lt;\u0026lt;a/2+1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;a/2; return 0; } B -","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"https://dyhgo.github.io/2020/03/abc157/","year":"2020"},{"content":"paste a music below\n[video(video-HXuIKyFl-1583157343324)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=93185992)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/393b26d243ae8f1c7b3cf4d1ba0bea2fd4015d85.jpg)(title-【暴走大事件】致 杠 精)]\n[video(video-QTmoAEnp-1585132330863)(type-undefined)(url-undefined)(image-https://img-blog.csdnimg.cn/editor-video.png)(title-undefined)]\n","id":60,"section":"posts","summary":"paste a music below [video(video-HXuIKyFl-1583157343324)(type-bilibili)(url-https://pl","tags":["test"],"title":"test for music and video","uri":"https://dyhgo.github.io/2020/03/test-for-music-and-video/","year":"2020"},{"content":"","id":61,"section":"posts","summary":"","tags":["test"],"title":"test","uri":"https://dyhgo.github.io/2020/02/test/","year":"2020"},{"content":"效果展示\n在hugo官网也有说明如何搭建个人网站\n注册github账号 创建github仓库 仓库的名字必须是 用户名.github.io\n建议全小写\n安装git bash（非必须，但建议） 点击此处\n选择计算机对应的规格\n一步一步安装\n在使用前要进行初始化用户名和邮箱\n打开终端（以powershell为例）\n输入git命令，没有异常就可以\n安装hugo 点击此处\n选择计算机对应的规格\n下载zip压缩包\n解压后会得到 hugo.exe（这个是主要的）\n创建博客 打开powershell\n转到存放hugo.exe的文件夹下（hugo指令只能在这个目录下执行）\n如果hugo指令识别不出来，可以配置环境变量\n如果还是不行，那就用绝对路径，一直到hugo.exe\n要启动hugo.exe就要用 .\\hugo\n在存放hugo.exe的文件夹下，执行以下代码\n\u0026gt;hugo new site myblog\r myblog是自己起的名字，是一个identifier\n之后会生成myblog文件夹\n里面已经有一些东西了（大部分都是建立网站必须的）\n下载主题 点击此处\n选一个主题下载\n下载有两种方式\n1.点击download，转到作者github，下载zip\n把zip转到myblog/theme下，需要改文件夹一些名字\n2.在主题下面有git clone(推荐使用这种)\n直接在powershell下面输入（一定要 cd 到myblog）\n个别主题下载的慢，可以在不同时间不同地点多试试\n下载完，myblog/theme 就会多出一个主题对应的文件夹（很重要）\n以下是无论哪一种都要进行的操作\n根据作者在hugo网页中写的文档进行初始化配置（就是把主题文件夹中的东西搬出来，替换什么的）（很重要，没有这一步，可能本地都打不开，疯狂报错）（但有些主题没有此过程）\n尝试在本地打开\n输入以下代码(以pure主题为例）(这个主题名字是theme下对应文件夹的名字)\nmyblog\u0026gt;hugo server -t pure\r 会得到一个本地网址\n用浏览器打开这个网址\n就可以在本地看到自己的网页\n局域网内的用户也可以看到你的网页\n部署到服务器上（github pages） 建议先在本地查看，确认无误之后再推到服务器\n输入以下代码\n注意不要写错\nmyblog\u0026gt;hugo --theme=pure --baseUrl=\u0026quot;https://你的用户名.github.io\u0026quot; --buildDrafts\r myblog下会生成public文件夹\n输入以下代码\nmyblog\u0026gt;cd public\rpublic\u0026gt;git init\rpublic\u0026gt;git add .\rpublic\u0026gt;git commit -m \u0026quot;输入你自己的提交信息\u0026quot;\rpublic\u0026gt;git remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u0026gt;git push -u origin master\rpublic\u0026gt;\r 此过程中有可能需要输入github的账号和密码\n访问 用户名.github.io就可以看到你的网页\n会有延迟，需要等一会\n配置主题和增加内容 配置因主题而异\n通法就是认真仔细地阅读作者的文档\nhugo/theme上的或者README.md（可见文档有多重要）\n增加的内容一般都放在content文件夹下，当然也可以删掉内容\n一般是markdown格式\n写markdown可以用markdownpad / visual studio code / csdn自带的等等\n但是发现一个问题，不同的编辑器预览的效果不一样\n比如markdownpad不能很好的识别latex公式\n有可能主题自带的markdown也不能很好的呈现出效果\n更新网站内容 ！！！文件名字不能有 #\n建议首先在本地预览，确认无误再上传\n然后执行以下代码（含本地预览）\nmyblog\u0026gt;hugo server -t pure\rmyblog\u0026gt;hugo --theme=pure --baseUrl=\u0026quot;https://你的用户名.github.io\u0026quot; --buildDrafts\rmyblog\u0026gt;cd public\rpublic\u0026gt;git init\rpublic\u0026gt;git add .\rpublic\u0026gt;git commit -m \u0026quot;输入你自己的提交信息\u0026quot;\rpublic\u0026gt;git remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u0026gt;git pull origin master\rpublic\u0026gt;git push -u origin master\rpublic\u0026gt;\r 一定要写git pull origin master\n有延迟\n打开 用户名.github.io 可以看到内容已经更新\n之后更新网站内容就一直重复上述操作\n=================== 以下是自定义域名（附加内容）===================== 在阿里云上面注册账号\n实名制\n购买域名\n域名实名制\n购买SSL证书（有免费的）\n确定SSL证书有效\n配置DNS服务器\n在域名解析中添加记录\n记录类型为CNAME\n记录值填写 用户名.github.io（或者记录类型为A，记录值填写IP地址）\n打开github对应的仓库\n在settings中找到custom domain\n输入新域名\n在github pages下显示绿色的√就可以\n访问新域名就可以看到网页了\n之后更新的内容，都可以通过访问新域名实现\n以上操作都需要时间，需耐心等待\n个人博客网站基本搭建完毕\n","id":62,"section":"posts","summary":"效果展示 在hugo官网也有说明如何搭建个人网站 注册github账号 创建github仓库 仓库的名字必须是 用户名.github.io 建议全小写 安","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"https://dyhgo.github.io/2020/02/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","year":"2020"},{"content":"以二进制的原理表示集合，以整数呈现\n1表示在集合内，0表示不在集合内\n一位运算优先于按位逻辑运算\n空集 0 只含有第i个元素的集合{i} 1\u0026laquo;i 含有全部n个元素的集合 {0,1,2,\u0026hellip;n-1} (1\u0026laquo;n) - 1 判断第i个元素是否属于集合S if ( s\u0026raquo;i \u0026amp; 1 ) 原来的集合变了 向集合中加入第i个元素 S∪{i} S|1\u0026laquo;i 从集合中去除第i个元素 S{i} S\u0026amp;~(1\u0026laquo;i) 集合S和T的并集 S|T 集合S和T的交集 S\u0026amp;T\n按顺序枚举集合的子集\nfor(int S=0;S\u0026lt;1\u0026lt;\u0026lt;n;S++)\r 枚举某个集合sup的子集\nint sub=sup;\rdo\r{\rsub=(sub-1)\u0026amp;sup;\r}while(sub!=sup); //处理完0之后，会有-1\u0026amp;sup=sup  枚举{0,1,2,\u0026hellip;n-1}所包含的大小为k的子集\nint comb=(1\u0026lt;\u0026lt;k)-1;\rwhile(comb\u0026lt;1\u0026lt;\u0026lt;n)\r{\rint x=comb \u0026amp; -comb , y=comb+x;\rcomb=((comb \u0026amp; ~y) / x\u0026gt;\u0026gt;1) | y;\r}\r ","id":63,"section":"posts","summary":"以二进制的原理表示集合，以整数呈现 1表示在集合内，0表示不在集合内 一位运算优先于按位逻辑运算 空集 0 只含有第i个元素的集合{i} 1\u0026laquo;i 含有全部n个","tags":["cpp","binary"],"title":"二进制表示集合","uri":"https://dyhgo.github.io/2020/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/","year":"2020"},{"content":"求最大公约数和最小公倍数 辗转相除法\n时间复杂度O(log(max(a,b)))\nint gcd(int a,int b)\r{\rif(b==0) return a;\relse return gcd(b,a%b);\r}\rint lcm(int a,int b)\r{\rreturn a*b/gcd(a,b);\r}\r 或直接调用algorithm库中的__gcd(int a,int b) 扩展欧几里得算法 求满足 ax+by=gcd(a,b) 的整数解 x ，y\n时间复杂度O(log(max(a,b)))\nint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\r  求n以内质数个数 很多种方法，以下是埃氏筛\n时间复杂度O(nloglogn)\nint prime[maxn]; //ith prime number\rbool isprime[maxn+1] //is i a prime number\rint e_sieve(int n)\r{\rint p=0; //position\rfor(int i=0;i\u0026lt;=n;i++) isprime[i]=true; //initialize\risprime[0]=isprime[1]=false;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rif(isprime[i])\r{\rprime[p++]=i;\rfor(int j=2*i;j\u0026lt;=n;j+=i) isprime[j]=true;\r}\r}\rreturn p;\r}\r  数论的一些性质 Premise: a≡c (mod m) and b≡d (mod m) Conclusion: a±b≡c±d (mod m) a*b≡c*d (mod m) d|a \u0026amp;\u0026amp; d|b ⇒ d|gcd(a,b) gcd(an,bn) = n*gcd(a,b) 任意正整数n，n|ab \u0026amp;\u0026amp; a,n互质 ⇒ n|b a,p 互质 ， b,p互质 ⇒ ab,p互质 任意一个合数都可以分解成唯一的质数幂积的形式，即 $$ a=\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} $$ 因子个数为 $$ \\sum\\limits_{i=1} ^ {n} {(1+e_i)} $$ 积性函数 f(ab) = f(a)f(b) 欧拉函数 莫比乌斯函数 gcd 狄利克雷函数\n 快速幂 时间复杂度O(logn)\ntypedef long long ll;\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\r  逆元 $$ 逆元\\quad y=a^{-1}\\quad满足\\quad ay≡1(mod\\ m) ~\\ y为a在模m下的逆元 $$ $$ 对于\\quad ax≡b(mod\\ m) ~\\ x=a^{-1}*b $$ 求逆元 $$ ax≡1(mod\\ m) ~\\ ax-mk=1 ~\\ ax+my=1 ~\\ ax+my=gcd(a,m) ~\\当a,m不互质的时候，逆元不存在 $$\nint mod_inverse(int a,int m)\r{\rint x,y;\rex_gcd(a,m,x,y);\rreturn (m+x%m)%m;\r}   线性时间内预处理逆元 inv[0]=1;inv[1]=1; //inv[0]=1 !!! for(ll i=2;i\u0026lt;=n;i++){\rinv[i]=(mod-mod/i)*inv[mod%i]%mod;\r}\r 欧拉函数 $$ 设\\quad n =\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} ~\\ 则欧拉函数\\quad φ(n)=n*\\prod\\limits_{i=1} ^ {n} {\\frac{p_i-1}{p_i}} $$ 欧拉函数的数值等于不超过n且与n互质的数的个数\n当n时质数时，φ(n)=n-1\n如果n=p^k , φ(n)=p^k - p^(k-1) = (p-1)p^(k-1)\n如果m,n互质，则φ(mn)=φ(m)φ(n)\nφ(n)的值都为偶数，φ(2)除外\n质因子之和 (φ(n)*n)/2 欧拉定理 $$ 当a,m互质时 ~\\ a^{φ(m)}≡1(mod \\ m) $$ 费马小定理 $$ 当p是质数时， 对任意整数x 都有 ~\\ x^p≡x(mod \\ p) ~\\~\\ 当x,p互质时 ~\\ x^{p-1}≡1(mod \\ p) ~\\ 这就是欧拉定理的特殊形式 $$ 求欧拉函数 时间复杂度O(√(n)) 求欧拉函数值的表，类似于埃氏筛，时间复杂度O(n)\nint phi(int n)\r{\rint res=n;\rfor(int i=2;i*i\u0026lt;=n;i++)\r{\rif(n%i==0)\r{\rres=res/i*(i-1);\rwhile(n%i==0) n/=i;\r}\r}\rif(n!=1) res=res/n*(n-1);\rreturn res;\r}\rint euler_phi[maxn];\rvoid phi_arr()\r{\rfor(int i=0;i\u0026lt;maxn;i++) euler_phi[i]=i;\rfor(int i=2;i\u0026lt;maxn;i++)\r{\rif(euler_phi[i]==i)\r{\rfor(int j=i;j\u0026lt;maxn;j+=i) euler_phi[j]=euler_phi[j]/i*(i-1);\r}\r}\r}\r  线性同余方程组 $$ a_ix≡b_i(mod \\ m_i) $$ 如果方程组有解，一定有无穷多解\n解的全集可以写成 x≡b(mod m)\n所以将问题转化为求b,m\n可以对如下方程组依次求解 $$ x≡b_1(mod \\ m_1) ~\\ ax≡b_2(mod\\ m_2) $$ $$ x≡b_1(mod \\ m_1) ~\\ x=b_1+m_1t ~\\a(b_1+m_1t)≡b_2(mod\\ m_2) ~\\am_1t≡b_2-ab_1(mod \\ m_2) ~\\a\u0026rsquo;t≡b\u0026rsquo;(mod \\ m_2) $$ 当gcd(m₂,am₁)与b₂-ab₁互质时，方程组无解\n时间复杂度O(n)\npair\u0026lt;int,int\u0026gt; linear_congruence(const vector\u0026lt;int\u0026gt;\u0026amp; A,const vector\u0026lt;int\u0026gt;\u0026amp; B,const vector\u0026lt;int\u0026gt;\u0026amp; M)\r{\r//最开始没有限制，把解设为所有整数 x ≡0(mod 1)\rint x=0,m=1;\rfor(int i=0;i\u0026lt;A.size();i++)\r{\rint a=A[i]*m , b=B[i]-A[i]*x , d=gcd(M[i],a); //d!!!\rif(b%d!=0) return make_pair(0,-1); //无解\rint t=b / d * mod_inverse(a/d,M[i]/d) % (M[i]/d) ;\rx=x+m*t;\rm*=M[i]/d; //*= !!!\r}\rreturn make_pair(x%m,m);\r}\r  中国剩余定理(CRT) crt是线性同余方程组ai=0，mi互质的特殊形式\n这时，x≡b(mod Πmi)\ncrt的思想是余数的加性和模数的乘性，当模数为合数时，可以拆成质因数的积\ncrt定理如下 $$ 对于x≡b_i(mod \\ m_i) \\ \\ \\ \\ \\ \\ m_i互质 ~\\ ~\\令M=\\prod{m_i} ~\\M_i=\\frac{M}{m_i} ~\\M_i ^ {-1} 为M_i模m_i的逆元 ~\\\n则 \\ x≡(\\sum\\limits_{i=1} ^ {n} {b_iM_iM_i ^{-1}}) \\ (mod \\ M) $$\n// x=x+(Πmi)*t\r//return minimum int crt(const vector\u0026lt;int\u0026gt;\u0026amp; b,const vector\u0026lt;int\u0026gt; \u0026amp;m)\r{\rint M=1,x=0;\rfor(int i=0;i\u0026lt;m.size();i++) M*=m[i];\rfor(int i=0;i\u0026lt;m.size();i++){\rint Mprime=M/m[i];\rint M_p_i=mod_inverse(Mprime,m[i]);\rx=(x + b[i] * Mprime * M_p_i)%M;\r}\rreturn (x+M)%M;\r}\r  Lucas定理 $$ 求 \\ C_{n}^{k} \\ (mod \\ p) , p是质数 ~\\ 当k,n较小时，利用杨辉三角形的性质 ~\\ C_{n}^{k}=C_{n-1}^k+C_{n-1}^{k-1} ~\\ ~\\当n,k较大时 ~\\ n=\\sum{n_ip^i} \\quad \\quad k=\\sum{k_ip^i} \\quad\\quad表示成p进制~\\ C_n^k≡\\prod{C_{n_i}^{k_i}} \\ (mod \\ p) $$\nll pow_mod(ll a, ll n)\r{\rif(n == 0) return 1;\rll x = pow_mod(a, n/2);\rll ans = x * x % mod;\rif(n % 2 == 1) ans = ans *a % mod;\rreturn ans%mod;\r}\rll C(ll n,ll m) {\rif(n \u0026lt; m) return 0;\rll res = 1;\rfor(ll i=1; i\u0026lt;=m; i++) {\rll a = (n+i-m)%mod;\rll b = i%mod;\rres = res*(a*pow_mod(b,mod-2)%mod)%mod;\r}\rreturn res;\r}\rll Lucas(ll n,ll m) {\rif(m == 0) return 1;\rreturn C(n%mod, m%mod) * Lucas(n/mod,m/mod)%mod;\r}\r ll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;}\rll com(ll a,ll b){\rll ans=1;\rfor(ll i=a;i\u0026gt;a-b;i--){\rans=ans*i%mod;\r}\rfor(ll i=1;i\u0026lt;=b;i++){\rans=(ans*qpow(i,mod-2))%mod;\r}\rreturn ans;\r}\r ","id":64,"section":"posts","summary":"求最大公约数和最小公倍数 辗转相除法 时间复杂度O(log(max(a,b))) int gcd(int a,int b) { if(b==0) return a; else return gcd(b,a%b); } int lcm(int a,int b) { return a*b/gcd(a,b); } 或直接调用algorit","tags":["cpp","number_theory"],"title":"Number Theory","uri":"https://dyhgo.github.io/2020/02/number-theory/","year":"2020"},{"content":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\nInput 输入的都是整数对n、m（0\u0026lt;n≤m\u0026lt;1000000），如果遇到都是0的整数对，则输入结束。\nOutput 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。\nSample Input 1 100 0 0\nSample Output 80\nSolution 与数位的组成有关，可以用数位dp。\n利用前缀即 solve(m)-solve(n-1)\ndp[i][j] 表示 符合条件的个数[当前操作的数位(倒序排)][当前操作的数位的前一个数] $$ dp[pos][pre] = \\sum\\limits_{i=0} ^ {maxd} dp[pos-1][i] $$ maxd可以由一个boolean变量limit控制，是否是9还是dig[pos]\n为了不重复计算（重复计算也可以），可以用记忆化搜索，也就是可以利用计算好的dp。为了使dp普适，dp必须是稳定，经全搜索得到的（即maxd=9）。所以通过limit控制dp的存储和dp的读取\n通过dp递推式，可以用dfs实现（理论上来说可以不用dfs，但不能记忆化且dp可能要增加维度，且要特殊初始化。没有实践过，有时间可以去试试）\nint dfs(int pos,int pre,bool limit)\n通过limit和返回值来使dp结果普适\nAC代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\rusing namespace std;\rint n,m;\rint dp[10][10]; //dp[i][j] i:总共有i位 , j:前导数字为j , dp:满足条件（不含4和62）的个数 int dig[10];\rint dfs(int pos,int pre,bool limit) //pos 当前位置 ， pre 当前位置的前一个数字 {\rif(pos==-1) return 1; //只有0（1个数字）满足\rif(dp[pos][pre]!=-1 \u0026amp;\u0026amp; !limit) return dp[pos][pre]; //已经搜索过则直接返回 //!!!!\rint ans=0;\rint maxd;\rif(limit) maxd=dig[pos];\relse maxd=9;\rfor(int i=0;i\u0026lt;=maxd;i++)\r{\rif(i==4 || (pre==6 \u0026amp;\u0026amp; i==2)) ;\relse ans+=dfs(pos-1,i,limit \u0026amp;\u0026amp; i==dig[pos]); //这里需要传limit !!!!!!!!!! }\rif(!limit) //只有在全搜索的时候才能给dp赋值，这样可以保证dp适用于所有情况，从而实现记忆化搜素 dp[pos][pre]=ans;\rreturn ans;\r}\rint solve(int x)\r{\rint len=0;\rwhile(x)\r{\rdig[len++]=x%10;\rx/=10;\r}\rreturn dfs(len-1,0,1);\r} int main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rmemset(dp,-1,sizeof(dp)); //不需要每次都初始化，因为要记忆化搜索 //不需要对dp特殊初始化，因为dfs中有return 1 while(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m)==2 \u0026amp;\u0026amp; (n || m))\r{\rcout\u0026lt;\u0026lt;solve(m)-solve(n-1)\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}  第一次写数位dp，参考了别人的代码，也调试了很久，思考了很多，才弄懂其中的细节\n","id":65,"section":"posts","summary":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"https://dyhgo.github.io/2020/02/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","year":"2020"},{"content":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树\n用一个例子来介绍线段树\nRMQ（range minimum query）\n实现功能 对于一个数列 1.给定s,t求[s,t)区间的最小值（最大值） 2.给定i和x,把ai改成x\nconst int maxn = 1\u0026lt;\u0026lt;17;\rint n,dat[2*maxn+1];\rvoid init(int n_)\r{\r//为了计算方便,把元素个数扩大到2的幂次方的个数\rn=1;\rwhile(n\u0026lt;n_) n*=2;\rfill(dat,dat+2*n-1,inf);\r}\r//将从0开始的第k个值，改成a void update(int k,int a)\r{\rk+=n-1;\rdat[k]=a;\r//向上更新\rwhile(k\u0026gt;0)\r{\rk=(k-1)/2;\rdat[k]=min(dat[2*k+1],dat[2*k+2]);\r} }\r//求[a,b)区间的最小值(从0开始数)\r//后面的参数是为了计算方便传入的\r//k是节点编号，l，r是k节点对应的区间\r//在外部调用是用query(a,b,0,0,n)\rint query(int a,int b,int k,int l,int r)\r{\rif(r\u0026lt;=a || b\u0026lt;=l) return inf;\rif(a\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=b) return dat[k];\relse\r{\rint vl=query(a,b,2*k+1,l,(l+r)/2);\rint lr=query(a,b,2*k+2,(l+r)/2,r);\rreturn min(vl,vr);\r}\r}  初始化的时间复杂度O(n) 更新和查询的时间复杂度O(logn)\n如果dat以1开头，则可以利用这些性质 \u0026gt;\u0026gt;1 : /2取整 \u0026laquo;1 : 乘2 \u0026laquo;1|1 : (*2+1)\n以这题为例\n给出一个长度为 n 的数列，a1,a2,\u0026hellip;,an,求其长度为 k 的连续子段的乘积对 998244353 取模余数的最大值。\nsolution:这道题可以用尺取法、线段树、逆元\n线段树的做法不需要update函数，最底层存每个数，父节点存子节点的乘积，最后query每一段区间\nAC代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rconst ll mod = 998244353;\rll n_,k;\rll n;\rll dat[4*200005+2];\r//[a,b)\rll query(ll a ,ll b,ll k,ll l,ll r)\r{\rif(r\u0026lt;=a || b\u0026lt;=l) return 1;\rif(a\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=b) return dat[k];\rreturn (query(a,b,k*2+1,l,(l+r)/2) * query(a,b,k*2+2,(l+r)/2,r))%mod;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rscanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;n_,\u0026amp;k);\rn=1;\rwhile(n\u0026lt;n_) n*=2;\rfor(ll i=n-1;i\u0026lt;n_-1+n;i++)\r{\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;dat[i]);\r}\rfor(ll i=n-2;i\u0026gt;=0;i--)\r{\rdat[i]=(dat[i*2+1]*dat[i*2+2]) % mod;\r}\rll ans=-1;\rfor(ll i=0;i+k\u0026lt;=n_;i++)\r{\rans=max(ans,query(i,i+k,0,0,n));\r}\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 有几个点导致WA 1.要用long long 不能用int 2.dat的的大小要用4乘，否则会断错误，因为在query时，最底层的也有可能访问子节点 边界条件是线段树容易出错的地方，以上代码的区间是左闭右开，在判断条件里面用等号注意n_和n的使用\n线段树的lazy思想\n参考这里\n===========================================================================================================\n在这里补一个线段树板子\n支持区间加、区间乘、区间求和、区间求平方和\n如果求最值可以用上面那个模板\n这个模板还没有融合进去\n其实线段树的基本操作就是区间查询和区间更新，其他的操作都可以通过两个基本的区间加（区间求最值）、区间求和操作转化\n平方和就是通过等式转化、类似地还可以求立方和、不过四次方应该会很麻烦\n测板子题\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rconst int maxn = 10005;\rstruct tnode{ ll w,l,r,siz,alazy;\rll sq,mlazy=1;\r}tn[maxn\u0026lt;\u0026lt;2]; ll n,m;\rconst ll mod = 0x3f3f3f3f3f3f3f3f;\rll wt[maxn];\rvoid pushup(ll u){ tn[u].w = (tn[u\u0026lt;\u0026lt;1].w + tn[u\u0026lt;\u0026lt;1|1].w) % mod;\rtn[u].sq = (tn[u\u0026lt;\u0026lt;1].sq + tn[u\u0026lt;\u0026lt;1|1].sq) % mod;\r}\rvoid build(ll u,ll l,ll r){ tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[l]; tn[u].sq = wt[l] * wt[l];\rreturn ;\r}\rll mid = (l+r) \u0026gt;\u0026gt; 1;\rbuild(u\u0026lt;\u0026lt;1 , l , mid); build(u\u0026lt;\u0026lt;1|1 , mid+1 , r);\rpushup(u); }\rvoid pushdown(ll u){ if(tn[u].alazy != 0 or tn[u].mlazy != 1){\rtn[u\u0026lt;\u0026lt;1].sq = ((tn[u\u0026lt;\u0026lt;1].sq + 2LL * tn[u\u0026lt;\u0026lt;1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u0026lt;\u0026lt;1].siz % mod) % mod; tn[u\u0026lt;\u0026lt;1|1].sq = ((tn[u\u0026lt;\u0026lt;1|1].sq + 2LL * tn[u\u0026lt;\u0026lt;1|1].w * tn[u].alazy % mod) % mod + tn[u].alazy * tn[u].alazy % mod * tn[u\u0026lt;\u0026lt;1|1].siz % mod) % mod;\rtn[u\u0026lt;\u0026lt;1].w = (tn[u\u0026lt;\u0026lt;1].w * tn[u].mlazy % mod + tn[u\u0026lt;\u0026lt;1].siz * tn[u].alazy % mod) % mod;\rtn[u\u0026lt;\u0026lt;1|1].w = (tn[u\u0026lt;\u0026lt;1|1].w * tn[u].mlazy % mod + tn[u\u0026lt;\u0026lt;1|1].siz * tn[u].alazy % mod) % mod;\rtn[u\u0026lt;\u0026lt;1].alazy = (tn[u\u0026lt;\u0026lt;1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod; tn[u\u0026lt;\u0026lt;1|1].alazy = (tn[u\u0026lt;\u0026lt;1|1].alazy * tn[u].mlazy % mod + tn[u].alazy) % mod;\rtn[u\u0026lt;\u0026lt;1].mlazy = (tn[u\u0026lt;\u0026lt;1].mlazy * tn[u].mlazy) % mod;\rtn[u\u0026lt;\u0026lt;1|1].mlazy = (tn[u\u0026lt;\u0026lt;1|1].mlazy * tn[u].mlazy) % mod;\rtn[u].alazy = 0; tn[u].mlazy = 1;\r}\r}\rll query(ll u,ll l,ll r,ll t){ if(l\u0026lt;=tn[u].l and r\u0026gt;=tn[u].r) {\rif(t == 1) return tn[u].w;\rif(t == 2) return tn[u].sq;\r} ll ans = 0;\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u0026gt;\u0026gt; 1;\rif(l\u0026lt;=mid) ans = (ans + query(u\u0026lt;\u0026lt;1 , l , r , t)) % mod;\rif(r\u0026gt;mid) ans = (ans + query(u\u0026lt;\u0026lt;1|1 , l , r , t)) % mod;\rreturn ans;\r}\rvoid update(ll u,ll l,ll r,ll wa,ll wm){ if(l\u0026lt;=tn[u].l and r\u0026gt;=tn[u].r){ tn[u].sq = ((tn[u].sq + 2LL * tn[u].w * wa % mod) % mod + wa * wa % mod * tn[u].siz % mod) % mod;\rtn[u].w = (tn[u].w * wm % mod + tn[u].siz * wa % mod) % mod;\rtn[u].alazy = (tn[u].alazy * wm % mod + wa) % mod;\rtn[u].mlazy = (tn[u].mlazy * wm) % mod;\rreturn ;\r}\rpushdown(u); ll mid = (tn[u].l + tn[u].r) \u0026gt;\u0026gt; 1; if(l\u0026lt;=mid) update(u\u0026lt;\u0026lt;1, l , r , wa , wm);\rif(r\u0026gt;mid) update(u\u0026lt;\u0026lt;1|1, l , r , wa , wm);\rpushup(u); }\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(ll i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;wt[i];\r}\rbuild(1,1,n);\rwhile(m--){\rll t;\rcin\u0026gt;\u0026gt;t;\rswitch(t){\rcase 1:{\rll x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rcout\u0026lt;\u0026lt;query(1,x,y,1)\u0026lt;\u0026lt;endl;\rbreak;\r}\rcase 2:{\rll x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rcout\u0026lt;\u0026lt;query(1,x,y,2)\u0026lt;\u0026lt;endl;\rbreak;\r} case 3:{\rll x,y,z;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z;\rupdate(1,x,y,0,z%mod);\rbreak;\r}\rcase 4:{\rll x,y,z;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z;\rupdate(1,x,y,z%mod,1);\rbreak;\r}\r}\t}\treturn 0;\r}\r ","id":66,"section":"posts","summary":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树 用一个例子来介绍线段树 RMQ（range minimum query） 实现功能 对于一","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"https://dyhgo.github.io/2020/02/segment-tree/","year":"2020"},{"content":"题目在这\n这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快\n三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2\n求mid midmid与n个点的距离，然后依据较小值缩减区间\n代码如下\n//三分法 最快的应该是0.618法\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rstruct point {\rdouble x,y;\r}p[100005];\rdouble eps = 5e-5;\rdouble check(double x)\r{\rdouble dist = -1;\rfor(int i=0;i\u0026lt;n;i++)\r{\rdist = max(dist,(x-p[i].x)*(x-p[i].x) + p[i].y*p[i].y); }\rreturn sqrt(dist);\r}\rint main()\r{\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%lf %lf\u0026quot;,\u0026amp;p[i].x,\u0026amp;p[i].y);\rdouble l = -10000.0;\rdouble r = 10000.0;\rwhile(r-l\u0026gt;eps)\r{\rdouble mid = l + (r -l)/2; //这里的三分\rdouble midmid = mid+(r-mid)/2;\rif(check(mid)\u0026gt;check(midmid)) l=mid;\relse r=midmid;\r}\rprintf(\u0026quot;%.5lf\\n\u0026quot;,check(l));\rreturn 0;\r}\r ","id":67,"section":"posts","summary":"题目在这 这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快 三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"https://dyhgo.github.io/2020/02/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/","year":"2020"},{"content":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等\n链式前向星存图 struct edge{\rint to , w , next;\r}e[maxn];\rint tot,head[maxn];\rvoid add_edge(int u,int v,int w){\re[tot].to = v;\re[tot].w = w;\re[tot].next = head[u];\rhead[u] = tot++;\r}\rfor(int i=head[u];~i;i=e[i].next){\rint v = e[i].to;\rint w = e[i].w;\r}\r//init\rmemset(head , -1 , sizeof(head));\r 二分图判定 通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图\n用dfs判断每个点是否可染色，如果每个点都是可染色的，就是二分图\n//input\rvector\u0026lt;int\u0026gt; G[max_v];\rint V;\rint color[max_v] //顶点i的颜色 1或-1\rbool dfs(int v,int c)\r{\rcolor[v]=c; //染色\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\rif(color[v][i]==c) return false; //相邻顶点同色\rif(color[G[v][i]]==0 \u0026amp;\u0026amp; !dfs(G[v][i],-c)) return false; //对于还没染色的点，如果不能染色则返回false } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=0;i\u0026lt;V;i++)\r{\rif(color[i]==0) //还未着色//如果是连通图，遍历一次就够\rif(!dfs(i,1)) return false; }\rreturn true;\r}  把顶点和边都算的话，时间复杂度是O(|V|+|E|)\n求DAG的拓扑序 求拓扑序可以dfs，删边法（通过栈或队列）\n求每个点的入度，将入度为0的点入栈，遍历栈里的点，将于这些点相邻的点的入度减1，如果有点入度为0，则入栈。依靠这个顺序，得到的就是拓扑序。如果点访问两次，则有圈。可以通过这个方法判断有向图是否有圈\n//input\rvector\u0026lt;int\u0026gt; G[max_v]\rint V;\rint indgree[max_v] //每个顶点的入度\rvector\u0026lt;int\u0026gt; res; //拓扑排序的结果\rbool topological_sort() //判断是否能拓扑排序 ，若果有圈就不能 {\rstack\u0026lt;int\u0026gt; s;\r//int counter=0; //遍历的点的个数 for(int i=0;i\u0026lt;V;i++) if(indegree[i]==0) s.push(i); //入度为0 的顶点入栈\rwhile(!s.empty())\r{\rint v=s.top(); s.pop();\rres.push_back(v);\r//counter++;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\rint k=G[v][i];\rif(--indegree[k] == 0) s.push(k); //遍历到的点入度间1，入度为0则入栈 }\r}\tif(res.size()==n) return true;\relse return false;\r}\r 时间复杂度是O(|V|+|E|)\nBellman-Ford算法 求单源最短路\nd[i]=min{d[j]+e(j,i)}\n只要图中不存在负圈，这样的更新操作是有限的（由于最短路不会经过一个顶点两次，所以这种操作只会重复|v|-1次）\n时间复杂度O(|V|*|E|)\nstruct edge\r{\rint from,to,cost;\r}es[max_e];\rint d[max_v];\rint V,E;\rvoid bellman_ford(int s)\r{\rfor(int i=0;i\u0026lt;V;i++) d[i]=inf; //把最短距离初始化成无限\rd[s]=0; while(true)\r{\rbool update=false; //判断while是否进行了更新操作，没有更新操作则退出循环 for(int i=0;i\u0026lt;E;i++) //根据公式，遍历边\r{\redge e=es[i];\rif(d[e.from]!=inf \u0026amp;\u0026amp; d[e.to]\u0026gt;d[e.from]+e.cost)\r{\rd[e.to]=d[e.from]+e.cost;\rupdate=true;\r}\r}\rif(!update) break;\r}\r}\r 如果更新操作（while循环）进行了超过|V|-1次，则存在负圈\n所以判断负圈的一个方法可以是\n把所有d[i]都变成0，如果有负圈，则一定执行超过|V|-1次\nbool find_negative_loop()\r{\rmemset(d,0,sizeof(d));\rfor(int i=0;i\u0026lt;V;i++)\r{\rfor(int j=0;j\u0026lt;E;j++)\r{\redge e=es[j];\rif(d[e.to]\u0026gt;d[e.from]+e.cost)\r{\rd[e.to]\u0026gt;d[e.from]+e.cost;\rif(i==V-1) return true; //这条语句不能放在if外，如果放在if外需要加update\t}\r}\r}\rreturn false;\t}\r Dijkstra算法 求单源最短路，适用于没有负边的情况\n将已求出最短路的点，放入一个集合中 ，每次从集合外找到一个和集合距离最近的点，加入集合\nint cost[max_v][max_v]; //权值，不存在时为inf\rint d[max_v];\rbool used[max_v];\rint V;\rvoid dijkstra(int s)\r{\rfill(d,d+v,inf);\rfill(used,used+v,false);\rd[s]=0;\rwhile(true)\r{\rint v=-1;\r//从尚未使用过的点中选一个距离最小的点\rfor(int u=0;u\u0026lt;V;u++)\r{\rif(!used[u] \u0026amp;\u0026amp; (v==-1 || d[u]\u0026lt;d[v])) v=u;\r} if(v==-1) break;\rused[v]=true;\rfor(int u=0;u\u0026lt;V;u++)\rd[u]=min(d[u],d[v]+cost[v][u]); }\r}  时间复杂度O(V^2)\n优化\n如果将点放入优先队列中，这要查找和更新就会节省很多时间，时间复杂度O(ElgV)\nstruct edge\r{\rint to,cost;\r}\rtypedef pair\u0026lt;int,int\u0026gt; pii; //first 是距离 ，second是点编号\rint V;\rvector\u0026lt;edge\u0026gt; G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; //使小的在上面\rfill(d,d+V,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} }  Floyd-Warshall算法 求任意两点最短路，暴力枚举思想\nd[i][j]=min(d[i][j],d[i][k]+d[k][j]) 遍历所有的k\n时间复杂度O(V^3)\nint d[max_v][max_v]; //存储权值，边不存在时为inf，d[i][i]=0 int V;\rvoid floyd_warshall()\r{\rfor(k=0;k\u0026lt;V;k++)\rfor(int i=0;i\u0026lt;V;i++)\rfor(int j=0;j\u0026lt;V;j++)\rd[i][j]=min(d[i][j],d[i][k]+d[k][j]);\r}\r 路径还原 通过找满足d[j]=d[k]+cost[k][j]的顶点k，来寻找前趋节点，不断寻找前趋节点来还原路径，时间复杂度O(E)\n还可以用prev[j]在算法内直接记录前趋节点，最后遍历数组即可，时间复杂度O(V)\n//算法内记录前趋节点 (优化的dijkstra算法)\rint prev[max_v] //前趋节点\rstruct edge\r{\rint to,cost;\r}\rtypedef pair\u0026lt;int,int\u0026gt; pii; //first 是距离 ，second是点编号\rint V;\rvector\u0026lt;edge\u0026gt; G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; //使小的在上面\rfill(d,d+V,inf);\rfill(prev,prev+V,-1); //!!!! d[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rprev[e.to]=v; //!!!!\rq.push(pii(d[e.to],e.to));\r}\r}\r} }\rvector\u0026lt;int\u0026gt; get_path(int t)\r{\rvector\u0026lt;int\u0026gt; path;\rfor(;t!=-1;t=prev[t]) path.push_back(t);\rreverse(path.begin(),path.end());\rreturn path;\r}\r Prim算法 求最小生成树\nprim算法和dijkstra算法很像，也是把已确定的点放入一个集合中，贪心地选取集合和未确定的点相连的最小权边，并加入到集合中，得到一棵生成树，可以证明是MST(minimum spanning tree)\n//也可以堆优化 int cost[max_v][max_v] //权值\rint mincost[max_v]; //从集合出发到其他点的最小权值,!!!这个权值是 集合 和 点 之间的 bool used[max_v]; //是否在集合中\rint V;\rint prim() //返回MST的权值\r{\rfill(mincost,mincost+V,inf); //初始化 fill(used,used+V,false);\rmincost[0]=0; //从0开始 int res=0;\rwhile(true)\r{\rint v=-1;\rfor(int u=0;u\u0026lt;V;u++)\r{\rif(!used[u] \u0026amp;\u0026amp; (v==-1 || mincost[u]\u0026lt;mincost[v])) v=u;\r}\rif(v==-1) break;\rused[v]=true;\rres+=mincost[v];\rfor(int u=0;u\u0026lt;V;u++)\r{\rmincost[u]=min(mincost[u],cost[v][u]); //每次往集合中加入一个点，所有点的mincost都有可能改变 }\r}\rreturn res; }  时间复杂度与dijkstra算法一样\nKruskal算法 求MST\n将边的权值按大小排序，如果不产生圈和重边，就依次把边加入到生成树中\n要判断是否产生圈和重边，只需要判断加入这条边前，这条边的两个端点是否已在同一个连通分量里，这样就可以用并查集\nKruskal在边的排序上最费时，算法复杂度O(ElgV)\nKruskal适用于sparse graph\nPrim适用于dense graph\n在实际应用中，Kruskal更普遍\nstruct edge\r{\rint u,v,cost;\r}es[max_e];\rint V,E;\rint par[max_v]; //union find需要 int rankk[max_v]; //key word \u0026quot;rank\u0026quot;\rbool cmp(const edge\u0026amp; e1,const edge\u0026amp; e2)\r{\rreturn e1.cost\u0026lt;e2.cost;\r}\rvoid init_union_find(int x)\r{\rfor(int i=0;i\u0026lt;x;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x)\rreturn x;\relse\rreturn par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return;\rif(rankk[x]\u0026lt;rankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint kruskal()\r{\rsort(es,es+E,cmp);\rinit_union_find(V);\rint res=0;\rfor(int i=0;i\u0026lt;E;i++)\r{\redge e=es[i];\rif(!same(e.u,e.v))\r{\runite(e.u,e.v);\rres+=e.cost;\r}\r}\rreturn res;\r}\r Kosaraju算法 强连通分量(strongly connected component)分解高效的算法有kosaraju算法，\ntarjan算法，gabow算法\nkosaraju算法通过随便选一点dfs，给点标号\n把边的方向反过来，再一次dfs\n由于在强连通分量中的点，其可达性不受边反向的影响\n所以最后需独立进行k次搜索\n即分裂出k个强连通分量\n时间复杂度 O(V+E)\n//kosaraju int V; vector\u0026lt;int\u0026gt; G[maxv]; vector\u0026lt;int\u0026gt; rG[maxv];\rvector\u0026lt;int\u0026gt; vs; //后序遍历顺序的顶点列表（标号） bool used[maxv]; //是否访问 int cmp[maxv]; //所属强连通分量的拓扑序（序号） void add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u0026lt;rG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u0026lt;V;i++) if(!used[i]) dfs(i);\rmemset(uesd,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u0026gt;=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\r Tarjan算法 （scc部分） 求scc的tarjan算法是给一个点赋上两个属性 dfn low分别表示dfs的访问时间和该点可追踪到的最小访问时间\ndfs过程中先访问自己，再访问邻接点，最后对自己进行操作\n在访问自己时，将两个属性初始化为当前时间，并且进栈\n接下来访问未被访问过的邻接点，并且更新low属性\n如果已被访问过且在栈里也更新low属性\n最后对自己的操作就是判断dfn 和 low是否相等\n相等说明它是连通块的头，已经无法再更新了\n这时候不断出栈直到自己也出栈\n总的操作就是遍历每个点，没访问就dfs\n tarjan算法和kosaraju算法有点类似，都是利用了反向边的性质，本质上是强连通分量中反向边的可达性，依此对每个点都最小化点的属性，而属性选择dfs序较高效\ntarjan算法要dfs一次，邻接表的时间复杂度是 O(V+E)\n 求连通块的出度和入度就是判断原本连接的两个点是否在同一个强连通分量中\nint V;\rvector\u0026lt;int\u0026gt; G[maxv];\rint dfn[maxv],low[maxv],cmp[maxv];\rbool in_stack[maxv];\rstack\u0026lt;int\u0026gt; s;\rint tim;\rint num=0; //最后的num是连通块数量 int in[maxv];\rint out[maxv];\rvoid tarjan_dfs(int x){\rdfn[x] = low[x] = ++tim;\rs.push(x);\rin_stack[x] = true;\rfor(int i=0;i\u0026lt;G[x].size();i++){\rint to = G[x][i];\rif(dfn[to] == 0){\rtarjan_dfs(to);\rlow[x] = min(low[x] , low[to]);\r}\relse if(in_stack[to]){\rlow[x] = min(low[x] , low[to]);\r}\r}\rint tmp;\rif(dfn[x] == low[x]){\rdo{\rtmp = s.top();\rcmp[tmp] = num;\rs.pop();\rin_stack[tmp] = false;\r}while(tmp != x);\rnum++;\r}\r}\rvoid tarjan_scc(){\rfor(int i=0;i\u0026lt;V;i++){\rif(!dfn[i]){\rtarjan_dfs(i);\r}\r}\r}\rvoid in_out_d(){\rfor(int i=0;i\u0026lt;V;i++){\rfor(int j=0;j\u0026lt;G[i].size();j++){\rint to = G[i][j];\rif(cmp[i] != cmp[to]){\rin[cmp[to]]++;\rout[cmp[i]]++;\r}\r}\r}\r}\r Tarjan算法 （割点、桥部分） 利用dfn和low判定割点和桥，注意更新\nint V;\rvector\u0026lt;int\u0026gt; G[maxv];\rint dfn[maxv],low[maxv],cmp[maxv];\rbool in_stack[maxv];\rstack\u0026lt;int\u0026gt; s;\rint tim;\rint num=0; //最后的num是连通块数量 set\u0026lt;int\u0026gt; cut;\rint Rchild;\rint cnt_root;\rset\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; bridge; void tarjan_dfs(int x,int p){\rdfn[x] = low[x] = ++tim; s.push(x);\rin_stack[x] = true;\rfor(int i=0;i\u0026lt;G[x].size();i++){\rint to = G[x][i];\rif(to != p){\rif(dfn[to] == 0){\rif(x == cnt_root) Rchild++;\rtarjan_dfs(to , x);\rlow[x] = min(low[x] , low[to]);\rif(x != cnt_root and low[to] \u0026gt;= dfn[x]) cut.insert(x); //不是根，求割点 if(low[to] \u0026gt; dfn[x]) bridge.insert({min(x,to),max(x,to)}); //求桥 }\relse if(in_stack[to]){\rlow[x] = min(low[x] , dfn[to]); //注意这里是dfn，而不是求scc的low }\r}\r}\rint tmp;\rif(dfn[x] == low[x]){\rdo{\rtmp = s.top();\rcmp[tmp] = num;\rs.pop();\rin_stack[tmp] = false;\r}while(tmp != x);\rnum++;\r}\r}\rvoid tarjan_scc(){\rfor(int i=0;i\u0026lt;V;i++){\rif(!dfn[i]){\rcnt_root = i;\rRchild = 0;\rtarjan_dfs(i,-1);\rif(Rchild \u0026gt; 1) cut.insert(cnt_root); //是根，求割点 }\r}\r}\r 割点的模板测试 这个题的数据好像有森林\n桥的模板测试\nLCA 大致的做法就是直接法，直接向上追溯\n对于多次查询通过跳级预处理，利用二分的思想\n单次查询，O(n)\nvector\u0026lt;int\u0026gt; G[maxv];\rint root;\rint parent[maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[v] = p;\rdepth[v] = d;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(G[v][i] != p) dfs(G[v][i] , v , d+1);\r}\r}\rvoid init(){\rdfs(root , -1 , 0);\r}\rint lca(int u,int v){\rwhile(depth[u] \u0026gt; depth[v]) u = parent[u];\rwhile(depth[v] \u0026gt; depth[v]) v = parent[v];\rwhile(u != v){\ru = parent[u];\rv = parent[v];\r}\rreturn u;\r}\r 多次查询 O(nlogn)\nvector\u0026lt;int\u0026gt; G[maxv];\rint root;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(G[v][i]!=p) dfs(G[v][i],v,d+1);\r}\r}\rvoid init(int V){\rdfs(root,-1,0);\rfor(int k=0;k+1\u0026lt;max_logv;k++){\rfor(int v=0;v\u0026lt;V;v++){\rif(parent[k][v]\u0026lt;0) parent[k+1][v]=-1;\relse parent[k+1][v]=parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u]\u0026gt;depth[v]) swap(u,v);\rfor(int k=0;k\u0026lt;max_logv;k++){\rif((depth[v]-depth[u])\u0026gt;\u0026gt;k\u0026amp;1) v=parent[k][v];\r}\rif(u==v) return u;\rfor(int k=max_logv-1;k\u0026gt;=0;k--){\rif(parent[k][u]!=parent[k][v]){\ru=parent[k][u];\rv=parent[k][v];\r}\r}\rreturn parent[0][u];\r}\r dfs序 (与线段树和树状数组结合) vector\u0026lt;int\u0026gt; G[maxv]; //图的领接表 int od[maxv]; //dfs序 int L[maxv]; //子树区间左边界 int R[maxv]; //子树区间有边界 int cnt = 1; //当前是第几个节点（dfs序） void dfs(int x,int p){\rod[x] = cnt++;\rL[x] = cnt - 1;\rfor(int i:G[x]){\rif(i!=p){\rdfs(i,x);\r}\r}\rR[x] = cnt - 1;\r}\r 树链剖分 树链剖分利用重孩子的定义和dfs序将树上路径权值和子树整体权值的修改和查询压缩成连续的区间的查询，对于区间的修改和查询可以利用线段树\n以这道题为例\n（无注释代码点击此处）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rconst int maxn = 1e5+10;\rstruct edge{ //链式前向星存图 int to,nxt;\r}e[maxn\u0026lt;\u0026lt;1]; //用双向边代替无向边 struct tnode{ //线段树的节点 节点权值，覆盖的左区间，覆盖的右区间，覆盖的范围，lazy标签 int w,l,r,siz,lazy;\r}tn[maxn\u0026lt;\u0026lt;2]; // 大小要*4 //wch：重孩子 sz：子树大小 head：链式前向星的head //wt：原来树上节点的权值 dep：深度 dfn：dfs序 //par：父节点 top：树上节点所属链的链首 rdfn：dfs序的反映射 int wch[maxn],sz[maxn],head[maxn],wt[maxn],dep[maxn],dfn[maxn],par[maxn],top[maxn],rdfn[maxn];\rint n,m,r,mod; int cnt_e; //链式前向星的计数器 int cnt_d; //dfs序的计数器 void add_edge(int u,int v){ //链式前向星的建图函数 e[++cnt_e].to = v; e[cnt_e].nxt = head[u]; //头插法 head[u] = cnt_e;\r}\rvoid dfs1(int u,int p){ //获得子树大小 ，深度，父节点，重孩子 sz[u] = 1;\rfor(int i = head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p){\rdep[t] = dep[u] + 1;\rpar[t] = u;\rdfs1(t,u);\rsz[u] += sz[t];\rif(sz[t] \u0026gt; sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid dfs2(int u,int p,int tp){ //剖分重链和轻链 top[u] = tp;\rdfn[u] = ++cnt_d; //dfs序 rdfn[cnt_d] = u; //反dfs序 if(wch[u]){ //先操作重孩子，目的是让重链节点的dfs序连续，便于在线段树上的区间操作 dfs2(wch[u],u,tp);\r}\rfor(int i=head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p and t != wch[u]){\rdfs2(t,u,t); //操作轻孩子 }\r}\r}\rvoid pushup(int u){ //通过两个孩子，更新自己的权值 由于题目要求，所以是求和形式 tn[u].w = (tn[u\u0026lt;\u0026lt;1].w + tn[u\u0026lt;\u0026lt;1|1].w) % mod;\r}\rvoid build(int u,int l,int r){ //建立线段树 tn[u].l = l;\rtn[u].r = r;\rtn[u].siz = r - l + 1;\rif(l == r){\rtn[u].w = wt[rdfn[l]]; //此时获得线段树节点的权值 return ;\r}\rint mid = (l+r) \u0026gt;\u0026gt; 1;\rbuild(u\u0026lt;\u0026lt;1 , l , mid); //递归建树 build(u\u0026lt;\u0026lt;1|1 , mid+1 , r);\rpushup(u); //每建一层就通过两个孩子更新自己 }\rvoid pushdown(int u){ //通过迟滞，下放lazy，在需要的时候更新，这样会减少操作量 if(tn[u].lazy){\rtn[u\u0026lt;\u0026lt;1].w = (tn[u\u0026lt;\u0026lt;1].w + tn[u\u0026lt;\u0026lt;1].siz * tn[u].lazy) % mod; //通过迟滞来更新子节点的权值 tn[u\u0026lt;\u0026lt;1|1].w = (tn[u\u0026lt;\u0026lt;1|1].w + tn[u\u0026lt;\u0026lt;1|1].siz * tn[u].lazy) % mod;\rtn[u\u0026lt;\u0026lt;1].lazy = (tn[u\u0026lt;\u0026lt;1].lazy + tn[u].lazy) % mod; //下放迟滞 tn[u\u0026lt;\u0026lt;1|1].lazy = (tn[u\u0026lt;\u0026lt;1|1].lazy + tn[u].lazy) % mod;\rtn[u].lazy = 0; //该节点迟滞的作用结束，清空 }\r}\rvoid update(int u,int l,int r,int w){ //更新区间 if(l\u0026lt;=tn[u].l and r\u0026gt;=tn[u].r){ // 当目标区间包含了节点区间时，无法往下操作，更新节点的权值和迟滞 tn[u].w += tn[u].siz * w;\rtn[u].lazy += w;\rreturn ;\r}\rpushdown(u); // 下放迟滞准备对子节点的更新操作 int mid = (tn[u].l + tn[u].r) \u0026gt;\u0026gt; 1; //这里是节点区间的一半 if(l\u0026lt;=mid) update(u\u0026lt;\u0026lt;1, l , r , w);\rif(r\u0026gt;mid) update(u\u0026lt;\u0026lt;1|1, l , r , w);\rpushup(u); //子树更新完毕,通过子节点更新自己 }\rvoid add_path(int u,int v,int w){ //对路径的更新操作 while(top[u]!=top[v]){ //如果不属于一条重链 if(dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); //现在它们属于两条链，始终对链头深度大的进行操作 update(1,dfn[top[u]],dfn[u],w); //更新这条链 u = par[top[u]]; //这条链更新完毕，跳到链头的父节点，这样最终它们会相遇，处在同一条链上 }\rif(dep[u] \u0026gt; dep[v]) swap(u,v); //让深度低的节点在左，才可以区间操作 update(1,dfn[u],dfn[v],w); //根据dfs序 }\rint query(int u,int l,int r){ //区间查询 if(l\u0026lt;=tn[u].l and r\u0026gt;=tn[u].r) return tn[u].w; //已经缩到最小区间，直接返回值 int ans = 0;\rpushdown(u); //下放迟滞，以备后续操作 int mid = (tn[u].l + tn[u].r) \u0026gt;\u0026gt; 1;\rif(l\u0026lt;=mid) ans = (ans + query(u\u0026lt;\u0026lt;1 , l , r)) % mod;\rif(r\u0026gt;mid) ans = (ans + query(u\u0026lt;\u0026lt;1|1 , l , r)) % mod;\rreturn ans;\r}\rint query_path(int u,int v){ //路径上的查询 int ans = 0;\rwhile(top[u] != top[v]){ //与路径上的更新相同 if(dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v);\rans = (ans + query(1, dfn[top[u]] , dfn[u])) % mod;\ru = par[top[u]];\r}\rif(dep[u] \u0026gt; dep[v]) swap(u,v);\rans = (ans + query(1,dfn[u],dfn[v])) % mod;\rreturn ans;\r}\rint main(){\r//freopen(\u0026quot;in.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;r\u0026gt;\u0026gt;mod;\rfor(int i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;wt[i];\r}\rfor(int i=0;i\u0026lt;n-1;i++){\rint x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\radd_edge(x,y);\radd_edge(y,x);\r}\rdfs1(r,0); //初始化 dfs2(r,0,r);\rbuild(1,1,n);\rfor(int i=0;i\u0026lt;m;i++){\rint tp;\rcin\u0026gt;\u0026gt;tp;\rswitch(tp){\rcase 1:{\rint x,y,z;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z;\radd_path(x,y,z%mod);\rbreak;\r}\rcase 2:{\rint x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rcout\u0026lt;\u0026lt;query_path(x,y)\u0026lt;\u0026lt;endl;\rbreak;\r}\rcase 3:{\rint x,z;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;z;\rupdate(1,dfn[x],dfn[x]+sz[x]-1,z%mod);\rbreak;\r}\rcase 4:{\rint x;\rcin\u0026gt;\u0026gt;x;\rcout\u0026lt;\u0026lt;query(1,dfn[x],dfn[x]+sz[x]-1)\u0026lt;\u0026lt;endl;\rbreak;\r}\r}\r}\rreturn 0;\r}\r 树上启发式合并 dsu on tree\n并查集的按秩合并是启发式，即小的往大的合并，减少查询难度\n树上启发式合并通过树链剖分中重孩子的定义，在对子树查询时，先处理所有轻孩子，然后撤销（消除轻孩子对父节点的影响），再处理重孩子，不撤销，最后再处理一遍轻孩子，把对父节点的贡献和重孩子合并\n撤销的目的在于对节点信息查询时会开辟一个数组，对于不同子节点，这个数组要再开辟一次，这样会MLE\n以这道题为例\n（无注释代码点击此处）\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rconst int maxn = 1e5 + 10;\rstruct edge{\rint to,nxt;\r}e[maxn\u0026lt;\u0026lt;1];\rint sz[maxn],par[maxn],c[maxn],head[maxn],wch[maxn],ans[maxn],num[maxn]; //这些变量见树链剖分部分 int n,m;\rint sum; //子树颜色数 int cnt; //计数器 void add_edge(int u,int v){\re[++cnt].to = v;\re[cnt].nxt = head[u];\rhead[u] = cnt;\r}\rvoid dfs(int u,int p){\rsz[u] = 1;\rfor(int i = head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p){\rdfs(t,u);\rsz[u] += sz[t];\rif(sz[t] \u0026gt; sz[wch[u]]) wch[u] = t;\r} }\r}\rvoid cal(int u,int p,int wch,int val){\rif(!num[c[u]]) sum++; //如果之前数量为0，说明是新颜色 num[c[u]] += val;\rfor(int i=head[u]; i ; i=e[i].nxt){ int t = e[i].to;\rif(t != p and t != wch){ //跳过重孩子 cal(t,u,wch,val); }\r}\r}\rvoid dsu(int u,int p,int kp){ //kp表示是否撤销 for(int i=head[u]; i ; i=e[i].nxt){\rint t = e[i].to;\rif(t != p and t != wch[u]){\rdsu(t,u,0); //先处理轻孩子，需要撤销 }\r}\rif(wch[u]) dsu(wch[u] , u , 1); //处理重孩子，需要保留 cal(u,p,wch[u],1); //计算轻孩子 ans[u] = sum;\rif(!kp){ cal(u,p,0,-1); //撤销操作 sum = 0;\r}\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n-1;i++){\rint x,y;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\radd_edge(x,y);\radd_edge(y,x);\r}\rfor(int i=1;i\u0026lt;=n;i++){\rcin\u0026gt;\u0026gt;c[i];\r}\rdfs(1,0); //初始化 dsu(1,0,1);\rcin\u0026gt;\u0026gt;m;\rwhile(m--){\rint foo;\rcin\u0026gt;\u0026gt;foo;\rcout\u0026lt;\u0026lt;ans[foo]\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r Dinic算法 用来解决最大流问题\n有两类算法\n增广路算法（dinic ek isap ff）\n预流推进算法 （hlpp）\ndinic算法是经典算法，hlpp可能更快一点\ndinic算法的本质还是贪心+暴力\n通过不断地对残余网络(residual networks)求增广路(augmenting paths)，对每一条增广路求流量，然后把流量加起来就是最大流\n有一个问题：在对增广路下放流量时，可能错过最优解\n解决的方法是，对每条边加一条反向边，流量在原来的边减多少，就在反向边加多少，这样可以通过流入反向边来达到撤销的操作\ndinic的操作过程分两步\nbfs建立分层图，通过最短路的原则分层，每次在最短路的前提下找增广路，这是贪心的思想，这样会使找增广路高效且达到可行解\ndfs找增广路，不断对边进行流量增减操作，暴力枚举思想\n不断迭代每次产生的残余网络\n三种优化（主要是后两者）参考文章\n当前弧优化 ： 增广路搜索中不再考虑之前搜索过的边\n多路增广优化： 对于某一条边减去的流量，因增广路覆盖的次数会进行多次操作，现在只需要一次操作就行（操作总的流量），从一次bfs，多次dfs到多次bfs，一次dfs\n炸点优化 ： 当某一条增广路中流量为0时，这个点在当前dfs搜索增广路中将不可达，所以直接炸点\n时间复杂度 O(n*n*m)\n实际合理运用优化之后，很难达到这样的时间复杂度，dinic算法还是很高效的，甚至可以跑十万个点\n根据最大流最小割定理(maximum flow minimum cut theorem) 最大流就是有源汇最小割\n对于无源汇最小割和全局最小割可以用Stoer Wagner算法\n对于有源汇无源汇上下界最大流，参考此处\n对于时间要求苛刻的最大流可以用HLPP算法\n对于费用流，可以用spfa\n对于最大流的各种变体，参考其他资料\n测模板题\n无注释代码\n//有时需改成long long #include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rconst int maxn = 205;\rconst int maxm = 5005;\rint n,m,s,t;\rconst int inf = 0x3f3f3f3f; struct edge{\rint to , w , nex;\r}e[maxm\u0026lt;\u0026lt;1]; //maxm int tot=2,head[maxn]; // tot = 2 !!\rint dep[maxn],cur[maxn]; //dep : dfs得到的最短距离 cur : 当前弧优化需要拷贝的数组 void add_edge(int u,int v,int w){\re[tot].to = v;\re[tot].w = w;\re[tot].nex = head[u];\rhead[u] = tot++;\r}\rbool bfs(){\rmemset(dep , 0 , sizeof(dep)); //memset(dep , 0 , (tot+2)\u0026lt;\u0026lt;2); queue\u0026lt;int\u0026gt; q;\rq.push(s);\rdep[s] = 1; int u , v;\rwhile(q.size()){\ru = q.front();\rq.pop();\rfor(int i = head[u] ; i ; i = e[i].nex){\rv = e[i].to;\rif(dep[v] or e[i].w \u0026lt;= 0) continue; //v 已达到不能作为dfs的增广路 ， 断流的点不能作为dfs的增广路 dep[v] = dep[u] + 1;\rq.push(v);\r}\r} for(int i=0;i\u0026lt;=n;i++) cur[i] = head[i]; //拷贝作为当前弧优化 return dep[t]; //是否到达汇点 }\rint dfs(int u , int flow){\rif(u == t) return flow;\rint nowflow = 0; //当前流量 for(int\u0026amp; i = cur[u] , v ; i ; i = e[i].nex){ //当前弧优化 v = e[i].to;\rif(dep[v] != dep[u] + 1 or e[i].w \u0026lt;= 0) continue; //不满足深度递增或断流就不能作为增广路 if(int delta = dfs(v , min(flow - nowflow , e[i].w))){ e[i].w -= delta;\re[i^1].w += delta;\rnowflow += delta; //多路增广优化，for循环一直进行，nowflow一直增加 if(nowflow == flow) break; //已达到最大流量 }\r}\rif(!nowflow) dep[u] = -2; //炸点优化 return nowflow;\r}\rll dinic(){\rll ans = 0 ;\rwhile(bfs()){ //对残余网络不断分层，以备之后dfs求增广路，当汇点不可达时，残余网络将永远不可达 ans += dfs(s , inf);\r}\rreturn ans;\r}\rint main(){\rios::sync_with_stdio(false);\rcin.tie(0);\rcout.tie(0);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;\rfor(int i=0;i\u0026lt;m;i++){\rint x,y,z;\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z;\radd_edge(x,y,z);\radd_edge(y,x,0);\r}\rll ans = dinic();\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":68,"section":"posts","summary":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等 链式前向星存图 struct edge{ int to , w , next; }e[maxn]; int tot,head[maxn]; void add_edge(int u,int v,int w){ e[tot].to = v; e[tot].w = w; e[tot].next = head[u]; head[u] = tot++; } for(int i=head[u];~i;i=e[i].next){ int v = e[i].to; int w = e[i].w;","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"https://dyhgo.github.io/2020/02/graph-theory/","year":"2020"},{"content":"线段相交 1127\n题意 判断两条线段是否相交，对于N条线段，间接相交也算相交。对于每次询问，判 断给定的两条线段是否相交\n题解 这个题目分成两部分，一部分是基础的判断两条线段是否相交，用一个bool数组来存储信息。另一部分是判断间接相交，可以用floyd-warshall（比较巧妙）或者并查集.第一部分就是套模板。\n点可以用结构体存储（推荐），线段也可以用结构体存储或pair\n判断两条线段相交有多重模板，比如判是否平行、重合、求两条直线交点，判断交点是否在线段上，还有ccw（counter clock wise）函数，可参考discuss\n比较常见的是快速排斥和跨立检验\n以线段为对角线，作平行于x轴、y轴的射线，使之形成矩形，若两个矩形没有相交，则线段不相交（可以排除大部分）\n不满足快速排斥进入跨立检验,判断两个点是否在线段的两侧（即跨立），判断方法是外积的符号是否相反，等于0说明在线上\n如果两两互相跨立，则线段相交\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rbool con[15][15];\rint p,q;\rstruct point\r{\rdouble x,y;\r//point(double a,double b) : x(a),y(b) {} //!!!!!会发生编译错误 };\rpair\u0026lt;point,point\u0026gt; seg[15];\rdouble dir(point a,point b,point c) //用外积 {\rreturn (c.x-a.x)*(c.y-b.y) - (c.y-a.y)*(c.x-b.x); }\rbool judge(pair\u0026lt;point,point\u0026gt; p1,pair\u0026lt;point,point\u0026gt; p2)\r{\rpoint a,b,c,d;\ra=p1.first; b=p1.second;\rc=p2.first;\rd=p2.second;\r//快速排斥\rif(min(a.x,b.x)\u0026gt;max(c.x,d.x) or min(c.x,d.x)\u0026gt;max(a.x,b.x) or\rmin(a.y,b.y)\u0026gt;max(c.y,d.y) or min(c.y,d.y)\u0026gt;max(a.y,b.y))\rreturn false;\r//跨立检验 (int 可改成double)\relse\r{\rint d1,d2,d3,d4;\rd1=dir(a,b,c);\rd2=dir(a,b,d);\rd3=dir(c,d,a);\rd4=dir(c,d,b);\rreturn d1*d2\u0026lt;=0 and d3*d4\u0026lt;=0; //!!!\r}\r}\rint main()\r{\rwhile(scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)==1 and n!=0)\r{\rfor(int i=1;i\u0026lt;=n;i++) con[i][i]=true;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%lf%lf%lf%lf\u0026quot;,\u0026amp;seg[i].first.x,\u0026amp;seg[i].first.y,\u0026amp;seg[i].second.x,\u0026amp;seg[i].second.y);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=1;j\u0026lt;i;j++)\r{\rif(judge(seg[i],seg[j])) con[i][j]=con[j][i]=true;\relse con[i][j]=con[j][i]=false;\r}\rfor(int k=1;k\u0026lt;=n;k++) //Floyd-Warshall算法或并查集都可以 for(int i=1;i\u0026lt;=n;i++)\rfor(int j=1;j\u0026lt;=n;j++)\rcon[i][j] |= con[i][k] and con[k][j];\rwhile(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;p,\u0026amp;q)==2 and p!=0)\rputs(con[p][q] ? \u0026quot;CONNECTED\u0026quot; : \u0026quot;NOT CONNECTED\u0026quot;);\r}\rreturn 0;\r}\r 艰难的debug 计算几何有些很麻烦，代码太相似，debug比较难，有时还要考虑精度问题（即误差eps）\ndebug一个上午\n写完代码CE，seg[i].first.x错误，把stl_pair.h中的代码小改一下可以通过，但放到oj上肯定不行，怕污染代码还是不这样做。最后发现把构造函数去掉可以通过\n自测，最后一个样例没过，发现是边界情况，把跨立检验最后一步的等号加上\n自测，中间有一个样例没过，作图，把样例分离出来，过了。说明可能不是judge函数的问题。\n单测样例，没过，说明错误不是受别组影响\n编译器debug，把函数内的局部变量，变成全局变量，add watch\n发现d1 d2 d3 d4都等于0，a.x a.y b.x b.y \u0026hellip;.有问题\n继续add watch\n发现seg[1].first的内容就有问题，是double边界数，然后发现最终问题 %d 赋值给了double型变量\n总结 提高debug能力，少犯白痴错误。\n写代码要有清晰性和完整性，这样鲁棒性更强。\n===========================================================================================================\n并查集 1182\n题解 并查集\n看到信息的内容，有并查集的影子\n依次遍历信息，对于每一条信息，因为没有说种类，所以设置三个种类，把每一种情况都加上去，比如：x和y属于同一类，则合并x和y属于A类，B类，C类\n判断是否是错误信息，只要判断是否与前面信息矛盾即可\n并查集的时间复杂度O(α(n)) α(n)是阿克曼函数的反函数，比O(lgn)还快\n代码如下（并查集的模板 + 并查集的应用）\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint T[100005],X[100005],Y[100005];\rint n,k;\r//union find\rint par[150005]; //父亲 int rankk[150005]; //树的高度,!!!元素是根 （优化用）//reference to \u0026quot;rank\u0026quot; is ambiguous\r//初始化，要用并查集前要初始化\rvoid init(int n) {\rfor(int i=0;i\u0026lt;n;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} //查询树的根\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); //return find(par[x]);也可以 。par[x]=find(par[x]) 是路径压缩优化 } //合并x,y //优化高度（如果rankk不同，那么从rankk小的向大的连边 void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; //判断是否已在同一个集合内\rif(rankk[x]\u0026lt;rankk[y]) par[x]=y; //!!!利用它们的 根 进行合并 else\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++; //这时候rankk还是原来的高度 } } //判断是否在同一个集合内\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;k;i++)\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;T[i],\u0026amp;X[i],\u0026amp;Y[i]);\rinit(n*3);\rint ans=0;\rfor(int i=0;i\u0026lt;k;i++)\r{\rint t=T[i],x=X[i]-1,y=Y[i]-1;\r//错误的编号\rif(x\u0026lt;0 || x\u0026gt;=n || y\u0026lt;0 || y\u0026gt;=n)\r{\rans++;\rcontinue;\r} else if(t==1) //第一种类型\r{\rif(same(x,y+n) || same(x,y+2*n)) ans++; //判断是否矛盾 //!!!只需要判断x在A类就行，因为每次unite都\r//涵盖所有情况，它们是平行影响的，判断一个就相当于判断所有 else\r{\runite(x,y);\runite(x+n,y+n);\runite(x+n+n,y+n+n);\r}\r} else if(t==2)\r{\rif(same(x,y) || same(x,y+2*n)) ans++;\relse\r{\runite(x,y+n);\runite(x+n,y+2*n);\runite(x+2*n,y);\r}\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n完全背包问题 1384\n题解 题意：完全背包问题求最小价值\n时间复杂度O(nm)\n二维数组如下，MLE\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[505][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp[0],dp[0]+n*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=min(dp[i-1][j],dp[i][j-w[i]]+v[i]);\rif(dp[n][m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[n][m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r 改一维数组，AC\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp,dp+m+1,inf); //!!!!!\rdp[0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=w[i];j\u0026lt;=m;j++)\rdp[j]=min(dp[j],dp[j-w[i]]+v[i]);\rif(dp[m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r 这个地方要注意 fill 到 dp+m+1\n滚动数组好啊\nAC代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[2][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp[0],dp[0]+2*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i\u0026amp;1][j]=dp[(i-1)\u0026amp;1][j];\relse\rdp[i\u0026amp;1][j]=min(dp[(i-1)\u0026amp;1][j],dp[i\u0026amp;1][j-w[i]]+v[i]);\rif(dp[n\u0026amp;1][m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[n\u0026amp;1][m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r 总结 这种类型的dp有两个重点，初始化边界条件，找递推式\n求最小，一般初始化为inf，dp[0][0]=0;\n求最大，一般初始化为0\n必要时可用滚动数组\n完全背包递推式的证明（这里证明求最大值的情况）\ndp[i][j]=max{dp[i-1][j-k*w[i]]+k*v[i] | k\u0026gt;=0}\n=max(dp[i-1][j] , max{dp[i-1][j-k*w[i]]+k*v[i] | k\u0026gt;=1}\n=max(dp[i-1][j] , max{dp[i-1][(j-w[i])-k*w[i]]+k*v[i] | k\u0026gt;=0}+v[i])\n=max(dp[i-1][j] , dp[i][j-w[i]]+v[i])\n这种分离思想很常见\n===========================================================================================================\n线性dp LCS 1458\n题解 水一题线性dp裸题\u0026ndash;LCS(longest common subsequence)\n因为没加string头文件CE了3次（被error误导了）\nac代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;string\u0026gt;\rusing namespace std;\rstring s1,s2;\rint dp[1000][1000]; //dp[i][j] 表示s1到i，s2到j的lcs长度\rint len1,len2; int lcs(string s1,string s2)\r{\rlen1=s1.length();\rlen2=s2.length();\rmemset(dp,0,sizeof(dp));\rfor(int i=0;i\u0026lt;len1;i++)\rfor(int j=0;j\u0026lt;len2;j++)\rif(s1[i]==s2[j])\rdp[i+1][j+1]=dp[i][j]+1;\relse\rdp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);\rreturn dp[len1][len2];\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rwhile(cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2)\rcout\u0026lt;\u0026lt;lcs(s1,s2)\u0026lt;\u0026lt;endl;\treturn 0;\r}\r ===========================================================================================================\n凸包 2187\n题意 平面上有n个不重合的点，求两个点的最远距离\n题解 由于点的个数为50000，所以暴力超时\n构造凸包，遍历凸包上的点即可\n坐标范围在n内的凸多边形（顶点在格点上）的顶点个数最多为O（√n）（尝试不严谨的画图证明，和公差为1的等差数列求和有关，所以是平方关系）\n所以构造凸包后，暴力遍历的时间复杂度为O（n）\n构造凸包可以用模板\n此处介绍的是时间复杂度O(nlgn）的graham扫描法\n外积是很常用的工具，此处利用外积的坐标公式的符号判断凹凸性\n可以对点先排序，然后按逆时针方向依次遍历点，先构造凸包的下侧，到达最右端时，构造凸包的上侧\n代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rdouble s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u0026lt;b.x;\rreturn a.y\u0026lt;b.y;\r}\rdouble out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u0026lt;point\u0026gt; convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\rint k=0; // 凸包点的index vector\u0026lt;point\u0026gt; qs(n*2); //构造凸包\r//逆时针构造凸包\r//构造凸包的下侧\rfor(int i=0;i\u0026lt;n;i++)\r{\rwhile(k\u0026gt;1 \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\rfor(int i=n-2,t=k;i\u0026gt;=0;i--)\r{\rwhile(k\u0026gt;t \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--; //这里有个k\u0026gt;t 和 k\u0026gt;1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rpoint p;\rscanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;p.x,\u0026amp;p.y);\rps[i]=p;\r}\rvector\u0026lt;point\u0026gt; qs=convex_hull(ps,n);\rdouble res=0;\rfor(int i=0;i\u0026lt;qs.size();i++)\rfor(int j=0;j\u0026lt;i;j++)\rres=max(res,s_dist(qs[i],qs[j]));\rcout\u0026lt;\u0026lt;(int)res\u0026lt;\u0026lt;endl; //!!!不加int 或不用printf(\u0026quot;%.0lf\\n\u0026quot;,res); 就会WA return 0;\r}\r 还有一种时间复杂度更低的方法\nconvex hull + rotating calipers\n这是一种常见、经典的方法\n对踵点：如果凸包上过两个点画两条平行线，使凸包所有的点都夹在这两条线之间，这两个点就叫对踵点，称为一对对踵点对\n对于一个凸包，最远距离一定是对踵点对\n所以先找一对对踵点对，根据判断凹凸性，确定哪个点向后面的点移动（如图）（图懒得画），宏观来看就是对踵点对的连线旋转了180°\n这样就总时间复杂度就是O（√n）\n代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rinline double s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u0026lt;b.x;\rreturn a.y\u0026lt;b.y;\r}\rinline double out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u0026lt;point\u0026gt; convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\rint k=0; // 凸包点的index vector\u0026lt;point\u0026gt; qs(n*2); //构造凸包\r//逆时针构造凸包\r//构造凸包的下侧\rfor(int i=0;i\u0026lt;n;i++)\r{\rwhile(k\u0026gt;1 \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\rfor(int i=n-2,t=k;i\u0026gt;=0;i--)\r{\rwhile(k\u0026gt;t \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--; //这里有个k\u0026gt;t 和 k\u0026gt;1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rpoint p;\rscanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;p.x,\u0026amp;p.y);\rps[i]=p;\r}\rvector\u0026lt;point\u0026gt; qs=convex_hull(ps,n);\rdouble res=0; int m=qs.size();\rif(m==2) //特殊处理凸包退化情况\r{\rcout\u0026lt;\u0026lt;(int)s_dist(qs[0],qs[1])\u0026lt;\u0026lt;endl; return 0; } int i=0,j=0; //表示左右俩对踵点\r//求x轴方向上的对踵点对\rfor(int k=0;k\u0026lt;m;k++)\rif(cmp(qs[j],qs[k])) j=k;\r//rotating calipers\rint si=i,sj=j;\rwhile(!(i==sj \u0026amp;\u0026amp; j==si)) //旋转180°，注意判断条件 {\r//cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl;\rres=max(res,s_dist(qs[i],qs[j])); //这条语句放在while循环体的前端，可以把x轴方向上的对踵点对都比较\r//通过外积判断凹凸性，判断是i移到i+1，还是j移到j+1\rif(out_product(qs[(i+1)%m].x-qs[i].x , qs[(i+1)%m].y-qs[i].y , qs[(j+1)%m].x-qs[j].x , qs[(j+1)%m].y-qs[j].y)\u0026lt;0) //\u0026lt;0 或\u0026lt;=0都可以\ri=(i+1)%m; //把m错写成n,tle好久 else\rj=(j+1)%m; //!!!要%m 这样转一圈才能回到起点，退出循环 } //之前添加的debug条件忘记屏蔽，WA了特久 cout\u0026lt;\u0026lt;(int)res\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\nbfs dfs 2386\n题解 bfs dfs都行 基础dfs 时间复杂度 O(mn)\n//dfs\r#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rchar field[105][105];\rint n,m;\rvoid dfs(int x,int y)\r{\rfield[x][y]='.';\rfor(int dx=-1;dx\u0026lt;=1;dx++)\rfor(int dy=-1;dy\u0026lt;=1;dy++)\r{\rint nx=x+dx,ny=y+dy;\rif(0\u0026lt;=nx \u0026amp;\u0026amp; nx\u0026lt;n \u0026amp;\u0026amp; 0\u0026lt;=ny \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; field[nx][ny]=='W')\rdfs(nx,ny);\r}\rreturn ;\r}\rint main()\r{\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\r{\rcin\u0026gt;\u0026gt;field[i][j];\r}\rint res=0;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\r{\rif(field[i][j]=='W') {\rdfs(i,j);\rres++;\r}\r}\rcout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 总结 经典dfs就是递归思想 如果图外面是可达且连通的，就在图外面加一圈\n===========================================================================================================\n状态压缩dp 2686\n题解 TSP问题\n不能在多项式时间内求解\n暴力求解是阶乘数量级的\n在数据不是很大的时候可以用状态压缩dp\n对于这道题时间复杂度O((2^n)*m*m*n)\n基础状态压缩dp\n以3.667为例\n道路图为\ndp[S][x]\nS表示剩余车票集合\nx表示从a出发到达x（单源最短路）\ndp表示最小花费\n这样就变成DAG求最短路问题，不需要使用dijkstra算法，用dp就可以\ndp的初始条件是\ndp=inf , dp[U][a]=0\ndp的状态转移方程\ndp[S/{i}][u] = min{dp[S][v]+d[v][u]/t[i] (i∈S)}\n将集合用整数的二进制表示\n根据状态转移方程，可以用记忆化搜索+递归\n这个问题可以用循环嵌套求解\n约束条件很重要\n这道题的约束条件是“车票”\n如果题目要求每个点只能走一遍的话\n那么又有一个约束条件是“点”（即判断这个点是否走过）\n循环嵌套的写法就是按照套路\n遍历所有子集，嵌套遍历每种子集的操作情况\n遍历集合的所有情况（逆序）\n嵌套遍历每个点\n再嵌套遍历每个点\n依题意再嵌套遍历剩下的所有车票（顺序可与上一步调换）\n最后遍历所有的dp[S\u0026rsquo;][b] S'⊆U，获得最小值\nac代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define maxn 8\r#define maxm 30\r#define inf 0x3f3f3f3f\rusing namespace std;\rint n,m,p,a,b;\rint t[maxn];\rint d[maxm][maxm];\rdouble dp[1\u0026lt;\u0026lt;maxn][maxm]; //dp[剩下的车票集合][目标城市]=从a到达目标城市的最短时间 int main()\r{\rwhile(scanf(\u0026quot;%d%d%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;p,\u0026amp;a,\u0026amp;b)==5 and !(n==0 and m==0 and p==0 and a==0 and b==0))\r{\rfor(int i=0;i\u0026lt;n;i++) scanf(\u0026quot;%d\u0026quot;,\u0026amp;t[i]);\rmemset(d,-1,sizeof(d));\rint temp1,temp2,temp3;\rfor(int i=0;i\u0026lt;p;i++)\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;temp1,\u0026amp;temp2,\u0026amp;temp3);\rd[temp1-1][temp2-1]=temp3;\rd[temp2-1][temp1-1]=temp3;\r}\rfor(int i=0;i\u0026lt;1\u0026lt;\u0026lt;n;i++) fill(dp[i],dp[i]+m,inf); //注意这里要用循环初始化二维数组 //inf是因为要用到min dp[(1\u0026lt;\u0026lt;n)-1][a-1]=0;\rdouble res=inf; //inf是因为要用到min for(int s=(1\u0026lt;\u0026lt;n)-1;s\u0026gt;=0;s--)\r{\rres=min(res,dp[s][b-1]);\rfor(int v=0;v\u0026lt;m;v++)\r{\rfor(int u=0;u\u0026lt;m;u++)\r{\rif(d[v][u]\u0026gt;=0)\r{\rfor(int i=0;i\u0026lt;n;i++)\r{\rif(s\u0026gt;\u0026gt;i\u0026amp;1)\r{\rdp[s\u0026amp;~(1\u0026lt;\u0026lt;i)][u]=min(dp[s\u0026amp;~(1\u0026lt;\u0026lt;i)][u],dp[s][v]+(double)d[u][v]/t[i]);\r}\r}\r}\r}\r}\r}\rif(res==inf) printf(\u0026quot;Impossible\\n\u0026quot;);\relse printf(\u0026quot;%.3lf\\n\u0026quot;,res); //discuss里面说poj用lf会wa,用f就ac ，但我试了lf也可以ac\r}\rreturn 0;\r}\r ===========================================================================================================\n强连通分量 2816\n题解 如果一头牛被其他所有牛认为是红牛，那么和它在同一个强连通分量的所有牛都\n是红牛，所以scc分解，拓扑序最后一个强连通分量是红牛群，最后检查这个连通\n块中的一头红牛是否对所有牛可达\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;cstring\u0026gt;\rusing namespace std;\rint V,m;\rint t1,t2; #define maxv 10005 vector\u0026lt;int\u0026gt; G[maxv]; vector\u0026lt;int\u0026gt; rG[maxv];\rvector\u0026lt;int\u0026gt; vs; bool used[maxv]; int cmp[maxv]; void add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u0026lt;rG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u0026lt;V;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u0026gt;=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u0026gt;\u0026gt;V\u0026gt;\u0026gt;m;\rwhile(m--){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\radd_edge(t1-1,t2-1);\r}\rint k=kosaraju_scc();\rint u=0,num=0; //备选个数 u取得正序最后一个 for(int i=0;i\u0026lt;V;i++){\rif(cmp[i]==k-1){\ru=i;\rnum++;\r}\r}\rmemset(used,0,sizeof(used));\rrdfs(u,0); //反向判断是否都可达\rfor(int i=0;i\u0026lt;V;i++){\rif(!used[i]){\rnum=0;\rbreak;\r}\r} cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ===========================================================================================================\n扫描线 2932\n题意 坐标上有n个不相交的圆，求最外层圆的index\n题解 由于数据规模，暴力超时\nsweeping line\n一般有两种，平移扫描，环形扫描\n对于这一题，从左到右平移扫描\n用一个容器维护每个圆的左右两个端点，代表扫描到圆和扫描出圆\n对于扫描到的圆，判断它是否在别的圆内\n只需要判断上下最近的两个圆（可画图证明，不严谨）\n用一个容器维护还没扫描出的最外圆，可以排序，再查找。总时间复杂度O(nlgn)\n可以选用set\n当扫描到右时，把圆从set中去除，意味着扫描过了\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;set\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rdouble x[40005],y[40005],r[40005];\rint n;\rtypedef pair\u0026lt;double ,int\u0026gt; pdi;\rbool inside(int i,int j)\r{\rdouble dx=x[i]-x[j],dy=y[i]-y[j];\rreturn dx*dx+dy*dy\u0026lt;=r[j]*r[j];\r}\rint main()\r{\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%lf%lf%lf\u0026quot;,\u0026amp;r[i],\u0026amp;x[i],\u0026amp;y[i]);\rvector\u0026lt;pdi\u0026gt; vt; //存左右两边界 for(int i=0;i\u0026lt;n;i++)\r{\rvt.push_back(make_pair(x[i]-r[i],i));\rvt.push_back(make_pair(x[i]+r[i],i+n));\r}\rsort(vt.begin(),vt.end());\r//扫描\rset\u0026lt;pdi\u0026gt; outers; //set为了排序 vector\u0026lt;int\u0026gt; res; //存放结果 for(int i=0;i\u0026lt;vt.size();i++)\r{\rint id=vt[i].second%n;\rif(vt[i].second\u0026lt;n) //扫描到左 {\rset\u0026lt;pdi\u0026gt;::iterator it=outers.lower_bound(make_pair(y[id],id));\rif(it!=outers.end() \u0026amp;\u0026amp; inside(id,it-\u0026gt;second)) continue; //上面最近的圆 if(it!=outers.begin() \u0026amp;\u0026amp; inside(id,(--it)-\u0026gt;second)) continue; //下面最近的圆 res.push_back(id);\routers.insert(make_pair(y[id],id));\r}\relse //扫描到右 outers.erase(make_pair(y[id],id));\r} sort(res.begin(),res.end());\rcout\u0026lt;\u0026lt;res.size()\u0026lt;\u0026lt;endl;\rfor(int i=0;i\u0026lt;res.size();i++)\rprintf(\u0026quot;%d%c\u0026quot;,res[i]+1,i+1==res.size()? '\\n' : ' ');\rreturn 0;\r}\r ===========================================================================================================\n贪心 3069\n题意 一条路上有n个路灯，每个路灯都能照亮左右的一段距离，问最少需要多少路灯才能使街道都亮着\n题解 greedy\n从最左开始向右延伸r，在r的范围内将最右的路灯点亮，此时这盏路灯将照亮左边和右边，从暗处的最左路灯开始，已知重复下去。 时间复杂度 O(n)!!!!需要将路灯位置排序\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint r,n;\rint x[1006];\rint main()\r{\rwhile(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;r,\u0026amp;n)==2 \u0026amp;\u0026amp; r!=-1)\r{\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x[i]);\rsort(x,x+n); // ！！！记得排序\rint j=0,ans=0;\rwhile(j\u0026lt;n)\r{\rint s=x[j++];\rwhile(j\u0026lt;n \u0026amp;\u0026amp; x[j]\u0026lt;=s+r) j++;\rint p=x[j-1];\rwhile(j\u0026lt;n \u0026amp;\u0026amp; p+r\u0026gt;=x[j]) j++;\rans++;\r} printf(\u0026quot;%d\\n\u0026quot;,ans);\r}\rreturn 0;\r}  ===========================================================================================================\n贪心 3617\n题意 给一个字符串s和空字符串p，每次进行以下操作之一\n删除s的头部字符，加入到p的尾部\n删除s的尾部字符，加入到p的尾部\n最后s为空，p的字典序最小\n题解 greedy\n时间复杂度最坏 O($n^2$)\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n;\rchar s[2005];\rint c=0;\rint main()\r{\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rcin\u0026gt;\u0026gt;s[i];\r}\rint a=0,b=n-1;\rbool left=false;\rwhile(a\u0026lt;=b)\r{\rfor(int i=0;a+i\u0026lt;=b;i++)\r{\rif(s[a+i]\u0026lt;s[b-i])\r{\rleft=true;\rbreak;\r}\relse if(s[a+i]\u0026gt;s[b-i])\r{\rleft=false;\rbreak;\r}\r}\rif(left) putchar(s[a++]);\relse putchar(s[b--]);\rc++;\rif(c%80==0) putchar('\\n');\r}\rreturn 0;\r}\r ===========================================================================================================\n01背包问题 3624\n题解 基础01背包问题\n如果用二维数组写的话就会MLE\n猜测测试数据可能不会满，就随着数据动态申请内存，想侥幸过（可以用new/delete 或 malloc/free）结果还是MLE\n这是MLE代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\r//int dp[3410][12885];\rint n,m;\r//int w[3410];\r//int v[3410];\rint main()\r{\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rint **dp,*w,*v;\rdp=new int*[n+3];\rfor(int i=0;i\u0026lt;n+3;i++)\rdp[i]=new int[m+3];\rw=new int[n+3];\rv=new int[n+3];\rfor(int i=1;i\u0026lt;=n;i++)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\r}\r//initialized\rfor(int i=0;i\u0026lt;=n;i++)\rdp[i][0]=0;\rfor(int i=0;i\u0026lt;=m;i++)\rdp[0][i]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[n][m];\rdelete dp,w,v;\rreturn 0;\r}\r 在discuss找了一圈也没有二维数组过的\n优化成一维数组（节省内存，容易出bug）\nAC代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n,m;\rint dp[12885];\rint w[3410];\rint v[3410];\rint main()\r{\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=m;j\u0026gt;=w[i];j--)\rdp[j]=max(dp[j],dp[j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[m];\rreturn 0;\r}\r 这个内层循环是递减的，如果是递增则解决完全背包问题\n由于01背包问题的dp[i]只依赖于dp[i-1]，内层循环递减时，dp[j]依赖的dp[j]为i-1的dp[j]\n由于原来在二维数组中就是递增的，是同一个i，所以内层循环递增时，dp[j]依赖的dp[j]为i的dp[j]，符合完全背包问题\n由于有两种状态（i和i-1），所以可利用奇偶性滚动数组实现\nAC代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n,m;\rint dp[2][12885];\rint w[3410];\rint v[3410];\rint main()\r{\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i\u0026amp;1][j]=dp[(i-1)\u0026amp;1][j];\relse\rdp[i\u0026amp;1][j]=max(dp[(i-1)\u0026amp;1][j],dp[(i-1)\u0026amp;1][j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[n\u0026amp;1][m];\rreturn 0;\r}\r ===========================================================================================================\n2-SAT 3683\n题解 xi表示某一婚礼\nxi为真表示在开始举行\nxi为假表示在结束举行\n对于两个婚礼\n如果同在开始时间举行会产生冲突\n则 ¬xi ∨ ¬xj 为真\n遍历所有的关系对，检查是否产生冲突\n如果产生冲突则有一个析取式成立\n遍历完之后得到一个合取范式\n这样就把问题转换成2-SAT\n根据蕴含等值式\na ∨ b ⇒ (a ∨ b) ∧ (b ∨ a) ⇒ (¬a → b) ∧ (¬b → a)\n对于每一个蕴含式都可以构造一条有向边\n最后scc分解\n判断合取范式是否是可满足式，只需要检查¬xi 和 xi 是否在同一个强连通分量中\n最后对于所在强连通分量的拓扑序，依次给出真值\nac代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;cstring\u0026gt;\rusing namespace std;\rint n;\rint V; const int maxv=2005; vector\u0026lt;int\u0026gt; G[maxv]; vector\u0026lt;int\u0026gt; rG[maxv];\rvector\u0026lt;int\u0026gt; vs; bool used[maxv]; int cmp[maxv]; int s[1005],t[1005],d[1005];\rvoid add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u0026lt;rG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u0026lt;V;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u0026gt;=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u0026gt;\u0026gt;n;\rint t1,t2,t3,t4,t5;\rfor(int i=0;i\u0026lt;n;i++){\rscanf(\u0026quot;%d:%d%d:%d%d\u0026quot;,\u0026amp;t1,\u0026amp;t2,\u0026amp;t3,\u0026amp;t4,\u0026amp;t5);\rs[i]=t1*60+t2;\rt[i]=t3*60+t4;\rd[i]=t5;\r}\rV=n*2;\rfor(int i=0;i\u0026lt;n;i++)for(int j=i+1;j\u0026lt;n;j++){\rif( min( s[i]+d[i] , s[j]+d[j] ) \u0026gt; max(s[i] , s[j])){\radd_edge(i,n+j);\radd_edge(j,n+i);\r}\rif(min(s[i]+d[i] , t[j]) \u0026gt; max(s[i] , t[j]-d[j])){\radd_edge(i,j);\radd_edge(n+j,i+n);\r}\rif(min(t[i] , s[j]+d[j]) \u0026gt; max(s[j] , t[i]-d[i])){\radd_edge(i+n,j+n);\radd_edge(j,i);\r}\rif(min(t[i] , t[j]) \u0026gt; max(t[i]-d[i] , t[j]-d[j])){\radd_edge(n+i,j);\radd_edge(n+j,i);\r}\r}\rkosaraju_scc();\rfor(int i=0;i\u0026lt;n;i++){\rif(cmp[i]==cmp[i+n]){\rcout\u0026lt;\u0026lt;\u0026quot;NO\\n\u0026quot;;\rreturn 0;\r}\r}\rcout\u0026lt;\u0026lt;\u0026quot;YES\\n\u0026quot;;\rfor(int i=0;i\u0026lt;n;i++){\rif(cmp[i]\u0026gt;cmp[i+n]){\rprintf(\u0026quot;%02d:%02d %02d:%02d\\n\u0026quot;,s[i]/60,s[i]%60,(s[i]+d[i])/60,(s[i]+d[i])%60);\r}\relse{\rprintf(\u0026quot;%02d:%02d %02d:%02d\\n\u0026quot;,(t[i]-d[i])/60,(t[i]-d[i])%60,t[i]/60,t[i]%60);\r}\r}\rreturn 0;\r}\r ===========================================================================================================\nbfs dfs 3984\n题解 dfs/bfs都行 基础bfs （这个测试点只有一个，就是样例） 时间复杂度O(mn)\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;map\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;queue\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n,m;\rint maze[7][7];\rint d[7][7];\rconst int inf=0x3f3f3f3f;\rtypedef pair\u0026lt;int,int\u0026gt; pii; //表示坐标 int sx,sy,gx,gy; //起点终点 int dx[]={0,0,1,-1};\rint dy[]={1,-1,0,0};\rmap\u0026lt;pii,pii \u0026gt; mp; //记录前驱节点,目的是记录路径 （如果记录路径就可以不用求最短距离） vector\u0026lt;pii \u0026gt; vt; //记录路径 void bfs()\r{\rqueue\u0026lt;pii\u0026gt; q;\rfill(d[0],d[0]+7*7,inf);\rq.push(pii(sx,sy));\rd[sx][sy]=0;\rwhile(q.size())\r{\rpii p=q.front();\rq.pop();\rif(p.first==gx and p.second==gy) break; //很重要的终止判断条件\rfor(int i=0;i\u0026lt;4;i++)\r{\rint nx=p.first+dx[i],ny=p.second+dy[i];\rif(nx\u0026gt;=0 and ny\u0026gt;=0 and nx\u0026lt;n and ny\u0026lt;m and maze[nx][ny]==0 and d[nx][ny]==inf) //inf的判断很重要\r{\rq.push(pii(nx,ny));\rd[nx][ny]=d[p.first][p.second]+1;\rmp[pii(nx,ny)]=pii(p.first,p.second);\r} } }\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rn=5;\rm=5;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\rcin\u0026gt;\u0026gt;maze[i][j];\rsx=0,sy=0,gx=4,gy=4;\rbfs();\r//cout\u0026lt;\u0026lt;d[gx][gy]\u0026lt;\u0026lt;endl;\rpii p;\rp=pii(gx,gy);\rwhile(p!=pii(sx,sy))\r{\rvt.push_back(p);\rp=mp[p];\r}\rreverse(vt.begin(),vt.end());\rprintf(\u0026quot;(%d, %d)\\n\u0026quot;,sx,sy);\rfor(vector\u0026lt;pii\u0026gt;::iterator it=vt.begin();it!=vt.end();it++)\r{\rprintf(\u0026quot;(%d, %d)\\n\u0026quot;,it-\u0026gt;first,it-\u0026gt;second);\r}\rreturn 0;\r}\r 总结 一个经典的bfs模板就是用队列来控制广度优先\n===========================================================================================================\n强连通分量 1236\n题解 第一问就是求scc的数量，第二问就是求对每个scc出度为0的数量和入度为0的数量\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;vector\u0026gt;\rusing namespace std;\rconst int maxv = 105;\rint V; vector\u0026lt;int\u0026gt; G[maxv]; vector\u0026lt;int\u0026gt; rG[maxv];\rvector\u0026lt;int\u0026gt; vs; bool used[maxv]; int cmp[maxv]; int in[maxv],out[maxv];\rvoid add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u0026lt;rG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u0026lt;V;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u0026gt;=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u0026gt;\u0026gt;V;\tfor(int i=0;i\u0026lt;V;i++){\rwhile(1){\rint tmp;\rcin\u0026gt;\u0026gt;tmp;\rif(tmp==0) break;\rtmp--;\radd_edge(i,tmp);\t}\r}\rint k = kosaraju_scc();\rfor(int i=0;i\u0026lt;V;i++){\rfor(int j=0;j\u0026lt;G[i].size();j++){\rint to = G[i][j];\rif(cmp[i] != cmp[to]){\rin[cmp[to]]++;\rout[cmp[i]]++;\r}\r}\r}\rint ind =0;\rint outd = 0;\rfor(int i=0;i\u0026lt;k;i++){\rif(in[i]==0) ind++;\rif(out[i]==0) outd++;\r}\rint ans;\rif(k==1) ans = 0;else ans = max(ind,outd);\rcout\u0026lt;\u0026lt;ind\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":69,"section":"posts","summary":"线段相交 1127 题意 判断两条线段是否相交，对于N条线段，间接相交也算相交。对于每次询问，判 断给定的两条线段是否相交 题解 这个题目分成两部分，一部分是","tags":["cpp","poj"],"title":"poj","uri":"https://dyhgo.github.io/2020/01/poj/","year":"2020"},{"content":"以这道题为例\n准备一个对拍的文件夹，里面装这些东西\nduipai_random_input_src.cpp是产生随机测试数据的代码\n#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;ctime\u0026gt;\rusing namespace std;\rint t=100; //数据组数\rint main()\r{\rsrand(time(0));\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rint a,b;\rwhile(t--)\r{\ra=rand();\rb=rand();\rif(a\u0026gt;b) swap(a,b);\rcout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}  将产生的随机测试数据写入duipai_random_input.txt中\nac代码或暴力搜索正确的代码\n//ac\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u0026lt;=50) return x;\rif(x\u0026gt;50 and x\u0026lt;=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u0026gt;0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_ac_output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rwhile(~scanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;t1,\u0026amp;t2)) {\rprintf(\u0026quot;input data are %lld %lld --- \u0026quot;,t1,t2);\rprintf(\u0026quot;%lld\\n\u0026quot;,fun(t2)-fun(t1-1));\r}\r//cout\u0026lt;\u0026lt;fun(180);\rreturn 0;\r}\r 从duipai_random_input.txt读入，写到duipai_ac_output.txt中\nwa代码\n//wa\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u0026lt;=50) return x;\rif(x\u0026gt;50 and x\u0026lt;=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u0026gt;0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_wa_output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rwhile(~scanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;t1,\u0026amp;t2)) {\rprintf(\u0026quot;input data are %lld %lld --- \u0026quot;,t1,t2);\rprintf(\u0026quot;%lld\\n\u0026quot;,fun(t2)-fun(t1)+1);\r}\r//cout\u0026lt;\u0026lt;fun(180);\rreturn 0;\r}\r 从duipai_random_input.txt读入，写到duipai_wa_output.txt中\n比较duipai_ac_output.txt 和 duipai_wa_output.txt\n在duipai文件夹下运行批处理命令（duipai.bat）\n@echo off\rfc duipai_ac_output.txt duipai_wa_outout.txt\rpause\r echo off是不回显，fc是文件比较\n运行cpp和bat程序\n得到结果\n过于复杂的输入数据和输出数据，简易对拍不好实现\n要产生大随机数，可以用\nlong long r=123456789;\rcout\u0026lt;\u0026lt;(long long)((double)(rand()*r)/RAND_MAX);\r 这题也可对拍\n","id":70,"section":"posts","summary":"以这道题为例 准备一个对拍的文件夹，里面装这些东西 duipai_random_input_src.cpp是产生随机测试数据的代码 #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; int","tags":["cpp"],"title":"简易对拍","uri":"https://dyhgo.github.io/2020/01/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/","year":"2020"},{"content":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数\n字，B的第一个数字是A的最后一个数字，个位数也算，输出满足条件的正整数对的个数\n 这种题感觉abc一贯的风格\n当时第一感觉是纯模拟肯定巨麻烦，就想着有没有规律，发现没有规律\n又想着按数位分类。\n按数位分类就要考虑对子里面的数位\n花了一些时间把它整理成元素都是9^n的矩阵（一个对称矩阵）\n然而并没有什么用，还是得求N-10^k这个剩余部分\n问题又回到起点\n试图从9^n求和中找规律，无果\n试图简化模拟或换个角度模拟，无果\n看了别人的解答，大同小异\n遍历一遍N，二维数组存N中第一个数字为 i ，最后一个数字为 j 的个数\n最后遍历ans+=c[i][j]*c[j][i]\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rlong long ans;\rlong long c[10][10];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++)\r{\rstring s=to_string(i);\rc[s[0]-'0'][s[s.length()-1]-'0']++;\r}\rfor(int i=0;i\u0026lt;10;i++)\rfor(int j=0;j\u0026lt;10;j++)\rans+=c[i][j]*c[j][i];\rcout\u0026lt;\u0026lt;ans;\rreturn 0; }\r 总结：我好弱啊\n","id":71,"section":"posts","summary":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数 字，B的第一个数字是A的最后一个数字，个位数也算，输","tags":["cpp"],"title":"abc152-D","uri":"https://dyhgo.github.io/2020/01/abc152-d/","year":"2020"},{"content":"","id":72,"section":"posts","summary":"","tags":["cpp","sort"],"title":"排序算法的时间复杂度","uri":"https://dyhgo.github.io/2020/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","year":"2020"},{"content":"","id":73,"section":"posts","summary":"","tags":["cpp"],"title":"时间复杂度与计算时间的关系","uri":"https://dyhgo.github.io/2020/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","year":"2020"},{"content":"#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;set\u0026gt;\r//#include\u0026lt;map\u0026gt;\r//#include\u0026lt;string\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;iterator\u0026gt;\rusing namespace std;\rint main()\r{\rint a[]={3,2,1};\rint b[]={3,4,5,6};\rset\u0026lt;int\u0026gt; s1(a,a+3);\rset\u0026lt;int\u0026gt; s2(b,b+4);\rset\u0026lt;int\u0026gt; s3;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin()));\rfor(set\u0026lt;int\u0026gt;::iterator it=s3.begin();it!=s3.end();it++)\rcout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rcout\u0026lt;\u0026lt;endl;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot;*\u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rreturn 0;\r}\r ","id":74,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; #include\u0026lt;set\u0026gt; //#include\u0026lt;map\u0026gt; //#include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;iterator\u0026gt; using namespace std; int main() { int a[]={3,2,1}; int b[]={3,4,5,6}; set\u0026lt;int\u0026gt; s1(a,a+3); set\u0026lt;int\u0026gt; s2(b,b+4); set\u0026lt;int\u0026gt; s3; set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin())); for(set\u0026lt;int\u0026gt;::iterator it=s3.begin();it!=s3.end();it++) cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl; set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot;*\u0026quot;)); cout\u0026lt;\u0026lt;endl; set_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); cout\u0026lt;\u0026lt;endl; set_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); cout\u0026lt;\u0026lt;endl; set_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); return 0; }","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"https://dyhgo.github.io/2020/01/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/","year":"2020"},{"content":"#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include \u0026lt;limits\u0026gt;\rusing namespace std;\rint main()\r{\rcout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;bool: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(bool);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;char: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;signed char: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(signed char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;signed char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;signed char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned char: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;wchar_t: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(wchar_t);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;wchar_t\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;wchar_t\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;short: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(short);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;short\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;short\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;int: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(int);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;int\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;int\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;long: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(long);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned long: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned long);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned long\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned long\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;double: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(double);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;double\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;double\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;long double: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(long double);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long double\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long double\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;float: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(float);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;float\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;float\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;size_t: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(size_t);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;size_t\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;size_t\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;string: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(string) \u0026lt;\u0026lt; endl;\r// \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;string\u0026gt;::max)() \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;string\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl;\rreturn 0;\r}\r ","id":75,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include \u0026lt;limits\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;bool: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(bool); cout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::max)(); cout \u0026lt;\u0026lt; \u0026quo","tags":["cpp"],"title":"c++每种类型的值域","uri":"https://dyhgo.github.io/2020/01/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/","year":"2020"},{"content":"#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main()\r{\rint a,b,x,y;\ra=60;\rb=22;\rcout\u0026lt;\u0026lt;ex_gcd(a,b,x,y)\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":76,"section":"posts","summary":"#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main()\r{\rint a,b,x,y;\ra=60;\rb=22;\rcout\u0026lt;\u0026lt;ex_gcd(a,b,x,y)\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"https://dyhgo.github.io/2020/01/extended-euclidean-algorithm/","year":"2020"},{"content":"//O(FE) /* input 5 7\r1 3 6\r3 5 8\r2 5 5\r3 2 3\r1 2 6\r4 1 10\r4 2 2\r4 5\routput\r11\r*/\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define maxv 100\r#define inf 0x3f3f3f3f\rint v,e;\rint s,t;\rstruct edge{int to,cap,rev;\r};\rvector\u0026lt;edge\u0026gt; G[maxv];\rbool used[maxv];\rvoid add_edge(int from ,int to,int cap)\r{\rG[from].push_back((edge){to,cap,G[to].size()});\rG[to].push_back((edge){from,0,G[from].size()-1});\r}\rint dfs(int s,int t,int f)\r{\rif(s==t) return f;\rused[s]=true;\rfor(int i=0;i\u0026lt;G[s].size();i++)\r{\redge \u0026amp;e =G[s][i];\rif(!used[e.to] \u0026amp;\u0026amp; e.cap\u0026gt;0)\r{\rint d=dfs(e.to,t,min(f,e.cap));\rif(d\u0026gt;0)\r{\re.cap-=d;\rG[e.to][e.rev].cap+=d;\rreturn d;\r}\r}\r}\rreturn 0;\r}\rint max_flow(int s,int t)\r{\rint flow=0;\rfor(;;)\r{\rmemset(used,0,sizeof(used));\rint f=dfs(s,t,inf);\rif(f==0) return flow;\rflow+=f;\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;e;\rfor(int i=0;i\u0026lt;e;i++)\r{\rint from,to,cap;\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;from,\u0026amp;to,\u0026amp;cap);\radd_edge(from,to,cap);\r}\rcin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;\rcout\u0026lt;\u0026lt;max_flow(s,t);\rreturn 0;\r}\r ","id":77,"section":"posts","summary":"//O(FE) /* input 5 7\r1 3 6\r3 5 8\r2 5 5\r3 2 3\r1 2 6\r4 1 10\r4 2 2\r4 5\routput\r11\r*/\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define maxv 100\r#define inf 0x3f3f3f3f\rint v,e;\rint s,t;\rstruct edge{int to,cap,rev;\r};\rvector\u0026lt;edge\u0026gt; G[maxv];\rbool used[maxv];\rvoid add_edge(int from ,int to,int cap)\r{\rG[from].push_back((edge){to,cap,G[to].size()});\rG[to].push_back((edge){from,0,G[from].size()-1});\r}\rint dfs(int s,int t,int f)\r{\rif(s==t) return f;\rused[s]=true;\rfor(int i=0;i\u0026lt;G[s].","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"https://dyhgo.github.io/2020/01/ford-fulkerson-algorithm/","year":"2020"},{"content":"从学习方法和代码实现debug花了挺长时间。。。\n这个算法是从字符串s中找子串p出现的第一个位置\n以下是两个常见的字符串匹配算法（还有其他更高效的比如Turbo-bm算法，sunday算法）\nkmp算法和bm算法\n时间复杂度是O(s+p)\nbm算法总体比kmp算法要快3倍\n当然也可以直接用函数，比如 s.find( p );\n//懒得写更多，懒得修饰代码\nplus:字符串的读入常常会出现读空格、读回车等奇妙现象\nkmp算法 //kmp without optimization\r//strncpy() memmove()\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint kmp(char s[],char p[])\r{\r//preprocess\rint sl=strlen(s);\rint pl=strlen(p);\rchar subp[pl+1][pl+1];\rint next[pl+1];\rfor(int k=0;k\u0026lt;pl;k++)\r{\rstrncpy(subp[k],p,k+1);\r}\r//can optimized\rfor(int k=0;k\u0026lt;pl;k++)\r{\rstring tl;\rstring tr;\rint len_sub=k+1;\rint len=0;\rfor(int m=len_sub-1;m\u0026gt;0;m--)\r{\rtl=string(subp[k],subp[k]+m);\rtr=string(subp[k]+len_sub-m,subp[k]+len_sub);\rif(tl==tr)\r{\rlen=m;\rbreak;\r}\r}\rnext[k]=len;\r}\rfor(int k=pl-1;k\u0026gt;0;k--)\r{\rnext[k]=next[k-1];\r}\rnext[0]=-1;\r//match\rint i=0;int j=0;\rwhile(1)\r{\rif(s[i]==p[j])\r{\ri++;\rj++;\r}\relse\r{\rint t=next[j];\rif(t==-1)\r{\ri++;\rj=0;\r}\relse\r{\rj=t;\r}\r}\rif(j\u0026gt;=pl)\r{\rreturn i-pl;\r}\rif(i\u0026gt;=sl)\r{\rreturn -1;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rchar a[100];\rchar b[100];\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;kmp(a,b);\rreturn 0;\r}\r bm算法 //bm algorithm three to five times faster than kmp in genneral\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include\u0026lt;vector\u0026gt;\rusing namespace std;\rint get_badc(char t,char a[])\r{\rint k=strlen(a)-1;\rwhile(1)\r{\rif(k\u0026gt;=0) //assert\r{\rif(a[k--]==t)\r{\rreturn k+1;\r}\r}\relse return -1;\r}\r}\rint get_goods(vector\u0026lt;char\u0026gt; t,char a[]) //most difficult\r{\rint k=strlen(a)-1;\rvector\u0026lt;char\u0026gt; temp;\rint max_len=0;\rint m=0;\rint loc=-1;\rwhile(1)\r{ if(k\u0026gt;=0) //assert\r{\rif(t[m]==a[k])\r{\rtemp.push_back(a[k]);\rm++;\rk--;\r}\relse\r{\rm=0;\rk--;\rif(temp.size()\u0026gt;max_len)\r{\rmax_len=temp.size();\rloc=k+1;\rtemp.clear();\r}\r}\r}\relse return loc;\r}\r}\rint bm(char s[],char p[])\r{\rint sl=strlen(s);\rint pl=strlen(p);\rint i=pl-1;\rint j=pl-1;\rwhile(1)\r{\rif(i\u0026lt;sl and j\u0026gt;=0) //asseert // i\u0026lt;sl !!!!!!!!!! not i\u0026gt;0\r{\rif(s[i]==p[j])\r{\rvector\u0026lt;char\u0026gt; goods;\rgoods.push_back(s[i]);\rwhile(1)\r{\ri--;\rj--;\rif(i\u0026gt;=0 and j\u0026gt;=0) //assert\r{\rif(s[i]!=p[j])\r{\rchar badc1=s[i];\rstring str(p,p+pl-goods.size());\rint loc1=get_badc(badc1,\u0026amp;str[0]);\rint loc2=get_goods(goods,\u0026amp;str[0]);\rif(loc1==-1 and loc2!=-1)\r{\ri+=pl-1-loc2;\rj=pl-1;\r}\relse if(loc2==-1 and loc1!=-1)\r{\ri+=pl-1-loc1;\rj=pl-1;\r}\relse\r{\ri+=pl-1-min(loc1,loc2);\rj=pl-1;\r}\r}\relse\r{\rgoods.push_back(s[i]); //still add in good-suffix\r}\r}\relse break;\r}\r}\relse //only have bad-character\r{\rchar badc2=s[i];\rint loc=get_badc(badc2,p);\ri+=pl-1-loc;\rj=pl-1;\r}\r}\relse if(i\u0026gt;=sl) return -1; //!!!!!!!!!!!!!\relse return i+1; //!!!!!!!!!!!!\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rchar a[100];\rchar b[100];\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;a;\rcout\u0026lt;\u0026lt;bm(b,a)\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":78,"section":"posts","summary":"从学习方法和代码实现debug花了挺长时间。。。 这个算法是从字符串s中找子串p出现的第一个位置 以下是两个常见的字符串匹配算法（还有其他更高效","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"https://dyhgo.github.io/2020/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/","year":"2020"},{"content":"很早以前写的懒得去审查。。。\n不知道对不对。。。\nEprime\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define MAX 10000\rlong long prime1[MAX],num1;\rlong long prime2[MAX],num2;\rbool isprime1[MAX],isprime2[MAX];\rint qprime1(int n)\r{\rnum1=0;\rmemset(isprime1,1,sizeof(isprime1));\risprime1[0]=isprime1[1]=0;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rif(isprime1[i])\r{\rprime1[num1++]=i;\rfor(int j=2;j*i\u0026lt;=n;j++)\risprime1[j*i]=0;\r}\r}\rreturn num1;\r}\rint qprime2(int m,int n)\r{\rnum2=0;\rqprime1((int)sqrt(n));\rmemset(isprime2,1,sizeof(isprime2));\rfor(int i=0;i\u0026lt;num1;i++)\r{\rfor(int j=m/prime1[i];j*prime1[i]\u0026lt;=n;j++)\r{\risprime2[j*prime1[i]]=0;\r}\r}\rfor(int i=m;i\u0026lt;=n;i++)\rif(isprime2[i]) num2++;\rreturn num2;\r} int main()\r{\rcout\u0026lt;\u0026lt;qprime2(10,100);\rreturn 0;\r}\r ","id":79,"section":"posts","summary":"很早以前写的懒得去审查。。。 不知道对不对。。。 Eprime #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define MAX 10000 long long prime1[MAX],num1; long long prime2[MAX],num2; bool isprime1[MAX],isprime2[MAX]; int qprime1(int n) { num1=0; memset(isprime1,1,sizeof(isprime1)); isprime1[0]=isprime1[1]=0; for(int i=2;i\u0026lt;=n;i++) { if(isprime1[i]) { prime1[num1++]=i; for(int j=2;j*i\u0026lt;=n;j++) isprime1[j*i]=0; } } return num1; } int qprime2(int m,int n) { num2=0; qprime1((int)sqrt(n)); memset(isprime2,1,sizeof(isprime2)); for(int i=0;i\u0026lt;num1;i++)","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"https://dyhgo.github.io/2020/01/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/","year":"2020"},{"content":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291\n1.用scanf,printf代替cin,cout 2.取消同步和绑定 ios::sync_with_stdio(false);\rcin.tie(0);\r//cout.tie(0);\r 此时只能用cin,cout\n3.对整型输入输出，将每个数字变成字符 inline int read()\r{\rint x=0;int f=1;char s=getchar();\rwhile(s\u0026lt;'0' or s\u0026gt;'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u0026gt;='0' and s\u0026lt;='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rvoid write(int x)\r{\rif(x/10\u0026gt;0) write(x/10);\rputchar(char(x%10+'0'));\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint n=read();\rcout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;\rwrite(200);\rreturn 0;\r}  ","id":80,"section":"posts","summary":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291 1.用sca","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"https://dyhgo.github.io/2020/01/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/","year":"2020"}],"tags":[{"title":"bfs","uri":"https://dyhgo.github.io/tags/bfs/"},{"title":"binary","uri":"https://dyhgo.github.io/tags/binary/"},{"title":"binary_search","uri":"https://dyhgo.github.io/tags/binary_search/"},{"title":"bit","uri":"https://dyhgo.github.io/tags/bit/"},{"title":"computational_geometry","uri":"https://dyhgo.github.io/tags/computational_geometry/"},{"title":"construct","uri":"https://dyhgo.github.io/tags/construct/"},{"title":"counting","uri":"https://dyhgo.github.io/tags/counting/"},{"title":"cpp","uri":"https://dyhgo.github.io/tags/cpp/"},{"title":"cs","uri":"https://dyhgo.github.io/tags/cs/"},{"title":"data_structure","uri":"https://dyhgo.github.io/tags/data_structure/"},{"title":"dfs","uri":"https://dyhgo.github.io/tags/dfs/"},{"title":"dp","uri":"https://dyhgo.github.io/tags/dp/"},{"title":"git","uri":"https://dyhgo.github.io/tags/git/"},{"title":"graph","uri":"https://dyhgo.github.io/tags/graph/"},{"title":"graph_theory","uri":"https://dyhgo.github.io/tags/graph_theory/"},{"title":"greedy","uri":"https://dyhgo.github.io/tags/greedy/"},{"title":"hugo","uri":"https://dyhgo.github.io/tags/hugo/"},{"title":"java","uri":"https://dyhgo.github.io/tags/java/"},{"title":"lca","uri":"https://dyhgo.github.io/tags/lca/"},{"title":"linux","uri":"https://dyhgo.github.io/tags/linux/"},{"title":"number_theory","uri":"https://dyhgo.github.io/tags/number_theory/"},{"title":"poj","uri":"https://dyhgo.github.io/tags/poj/"},{"title":"prefix","uri":"https://dyhgo.github.io/tags/prefix/"},{"title":"problemlist","uri":"https://dyhgo.github.io/tags/problemlist/"},{"title":"python","uri":"https://dyhgo.github.io/tags/python/"},{"title":"search","uri":"https://dyhgo.github.io/tags/search/"},{"title":"segment_tree","uri":"https://dyhgo.github.io/tags/segment_tree/"},{"title":"sort","uri":"https://dyhgo.github.io/tags/sort/"},{"title":"string","uri":"https://dyhgo.github.io/tags/string/"},{"title":"suffix","uri":"https://dyhgo.github.io/tags/suffix/"},{"title":"test","uri":"https://dyhgo.github.io/tags/test/"},{"title":"union_find","uri":"https://dyhgo.github.io/tags/union_find/"},{"title":"xml","uri":"https://dyhgo.github.io/tags/xml/"}]}
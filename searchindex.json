{"categories":[{"title":"test","uri":"https://dyhgo.github.io/categories/test/"}],"posts":[{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji {\rfont-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols;\r}","id":0,"section":"posts","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","tags":["emoji"],"title":"Emoji Support","uri":"https://dyhgo.github.io/2019/03/emoji-support/","year":"2019"},{"content":"求最大公约数和最小公倍数 辗转相除法\n","id":1,"section":"posts","summary":"求最大公约数和最小公倍数 辗转相除法","tags":["hahaha"],"title":"hahaha","uri":"https://dyhgo.github.io/1/01/123/","year":"0001"},{"content":"求最大公约数和最小公倍数 辗转相除法\n时间复杂度O(log(max(a,b)))\nint gcd(int a,int b)\r{\rif(b==0) return a;\relse return gcd(b,a%b);\r}\rint lcm(int a,int b)\r{\rreturn a*b/gcd(a,b);\r}\r 或直接调用algorithm库中的__gcd(int a,int b) 扩展欧几里得算法 求满足 ax+by=gcd(a,b) 的整数解 x ，y\n时间复杂度O(log(max(a,b)))\nint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\r  求n以内质数个数 很多种方法，以下是埃氏筛\n时间复杂度O(nloglogn)\nint prime[maxn]; //ith prime number\rbool isprime[maxn+1] //is i a prime number\rint e_sieve(int n)\r{\rint p=0; //position\rfor(int i=0;i\u0026lt;=n;i++) isprime[i]=true; //initialize\risprime[0]=isprime[1]=false;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rif(isprime[i])\r{\rprime[p++]=i;\rfor(int j=2*i;j\u0026lt;=n;j+=i) isprime[j]=true;\r}\r}\rreturn p;\r}\r  数论的一些性质 Premise: a≡c (mod m) and b≡d (mod m) Conclusion: a±b≡c±d (mod m) a*b≡c*d (mod m) d|a \u0026amp;\u0026amp; d|b ⇒ d|gcd(a,b) gcd(an,bn) = n*gcd(a,b) 任意正整数n，n|ab \u0026amp;\u0026amp; a,n互质 ⇒ n|b a,p 互质 ， b,p互质 ⇒ ab,p互质 任意一个合数都可以分解成唯一的质数幂积的形式，即 $$ a=\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} $$ 因子个数为 $$ \\sum\\limits_{i=1} ^ {n} {(1+e_i)} $$ 积性函数 f(ab) = f(a)f(b) 欧拉函数 莫比乌斯函数 gcd 狄利克雷函数\n 快速幂 时间复杂度O(logn)\ntypedef long long ll;\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\r  逆元 $$ 逆元\\quad y=a^{-1}\\quad满足\\quad ay≡1(mod\\ m) ~\\ y为a在模m下的逆元 $$ $$ 对于\\quad ax≡b(mod\\ m) ~\\ x=a^{-1}*b $$ 求逆元 $$ ax≡1(mod\\ m) ~\\ ax-mk=1 ~\\ ax+my=1 ~\\ ax+my=gcd(a,m) ~\\当a,m不互质的时候，逆元不存在 $$\nint mod_inverse(int a,int m)\r{\rint x,y;\rex_gcd(a,m,x,y);\rreturn (m+x%m)%m;\r}\r  欧拉函数 $$ 设\\quad n =\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} ~\\ 则欧拉函数\\quad φ(n)=n*\\prod\\limits_{i=1} ^ {n} {\\frac{p_i-1}{p_i}} $$ 欧拉函数的数值等于不超过n且与n互质的数的个数\n当n时质数时，φ(n)=n-1\n如果n=p^k , φ(n)=p^k - p^(k-1) = (p-1)p^(k-1)\n如果m,n互质，则φ(mn)=φ(m)φ(n)\nφ(n)的值都为偶数，φ(2)除外\n质因子之和 (φ(n)*n)/2 欧拉定理 $$ 当a,m互质时 ~\\ a^{φ(m)}≡1(mod \\ m) $$ 费马小定理 $$ 当p是质数时， 对任意整数x 都有 ~\\ x^p≡x(mod \\ p) ~\\~\\ 当x,p互质时 ~\\ x^{p-1}≡1(mod \\ p) ~\\ 这就是欧拉定理的特殊形式 $$ 求欧拉函数 时间复杂度O(√(n)) 求欧拉函数值的表，类似于埃氏筛，时间复杂度O(n)\nint phi(int n)\r{\rint res=n;\rfor(int i=2;i*i\u0026lt;=n;i++)\r{\rif(n%i==0)\r{\rres=res/i*(i-1);\rwhile(n%i==0) n/=i;\r}\r}\rif(n!=1) res=res/n*(n-1);\rreturn res;\r}\rint euler_phi[maxn];\rvoid phi_arr()\r{\rfor(int i=0;i\u0026lt;maxn;i++) euler_phi[i]=i;\rfor(int i=2;i\u0026lt;maxn;i++)\r{\rif(euler_phi[i]==i)\r{\rfor(int j=i;j\u0026lt;maxn;j+=i) euler_phi[j]=euler_phi[j]/i*(i-1);\r}\r}\r}\r  线性同余方程组 $$ a_ix≡b_i(mod \\ m_i) $$ 如果方程组有解，一定有无穷多解\n解的全集可以写成 x≡b(mod m)\n所以将问题转化为求b,m\n可以对如下方程组依次求解 $$ x≡b_1(mod \\ m_1) ~\\ ax≡b_2(mod\\ m_2) $$ $$ x≡b_1(mod \\ m_1) ~\\ x=b_1+m_1t ~\\ a(b_1+m_1t)≡b_2(mod\\ m_2) ~\\ am_1t≡b_2-ab_1(mod \\ m_2) ~\\ a\u0026rsquo;t≡b\u0026rsquo;(mod \\ m_2) $$ 当gcd(m₂,am₁)与b₂-ab₁互质时，方程组无解\n时间复杂度O(n)\npair\u0026lt;int,int\u0026gt; linear_congruence(const vector\u0026lt;int\u0026gt;\u0026amp; A,const vector\u0026lt;int\u0026gt;\u0026amp; B,const vector\u0026lt;int\u0026gt;\u0026amp; M)\r{\r//最开始没有限制，把解设为所有整数 x ≡0(mod 1)\rint x=0,m=1;\rfor(int i=0;i\u0026lt;A.size();i++)\r{\rint a=A[i]*m , b=B[i]-A[i]*x , d=gcd(M[i],a); //d!!!\rif(b%d!=0) return make_pair(0,-1); //无解\rint t=b / d * mod_inverse(a/d,M[i]/d) % (M[i]/d) ;\rx=x+m*t;\rm*=M[i]/d; //*= !!!\r}\rreturn make_pair(x%m,m);\r}\r  中国剩余定理(CRT) crt是线性同余方程组ai=0，mi互质的特殊形式\n这时，x≡b(mod Πmi)\ncrt的思想是余数的加性和模数的乘性，当模数为合数时，可以拆成质因数的积\ncrt定理如下 $$ 对于x≡b_i(mod \\ m_i) \\ \\ \\ \\ \\ \\ m_i互质 ~\\ ~\\ 令M=\\prod{m_i} ~\\ M_i=\\frac{M}{m_i} ~\\ M_i ^ {-1} 为M_i模m_i的逆元 ~\\\n则 \\ x≡(\\sum\\limits_{i=1} ^ {n} {b_iM_iM_i ^{-1}}) \\ (mod \\ M) $$\n// x=x+(Πmi)*t\r//return minimum\rint crt(const vector\u0026lt;int\u0026gt;\u0026amp; b,const vector\u0026lt;int\u0026gt; \u0026amp;m)\r{\rint M=1,x=0;\rfor(int i=0;i\u0026lt;m.size();i++) M*=m[i];\rfor(int i=0;i\u0026lt;m.size();i++){\rint Mprime=M/m[i];\rint M_p_i=mod_inverse(Mprime,m[i]);\rx=(x + b[i] * Mprime * M_p_i)%M;\r}\rreturn (x+M)%M;\r}\r  Lucas定理 $$ 求 \\ C_{n}^{k} \\ (mod \\ p) , p是质数 ~\\ 当k,n较小时，利用杨辉三角形的性质 ~\\ C_{n}^{k}=C_{n-1}^k+C_{n-1}^{k-1} ~\\ ~\\当n,k较大时 ~\\ n=\\sum{n_ip^i} \\quad \\quad k=\\sum{k_ip^i} \\quad\\quad表示成p进制~\\ C_n^k≡\\prod{C_{n_i}^{k_i}} \\ (mod \\ p) $$\nll pow_mod(ll a, ll n)\r{\rif(n == 0) return 1;\rll x = pow_mod(a, n/2);\rll ans = x * x % mod;\rif(n % 2 == 1) ans = ans *a % mod;\rreturn ans%mod;\r}\rll C(ll n,ll m) {\rif(n \u0026lt; m) return 0;\rll res = 1;\rfor(ll i=1; i\u0026lt;=m; i++) {\rll a = (n+i-m)%mod;\rll b = i%mod;\rres = res*(a*pow_mod(b,mod-2)%mod)%mod;\r}\rreturn res;\r}\rll Lucas(ll n,ll m) {\rif(m == 0) return 1;\rreturn C(n%mod, m%mod) * Lucas(n/mod,m/mod)%mod;\r}\r ll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;}\rll com(ll a,ll b){\rll ans=1;\rfor(ll i=a;i\u0026gt;a-b;i--){\rans=ans*i%mod;\r}\rfor(ll i=1;i\u0026lt;=b;i++){\rans=(ans*qpow(i,mod-2))%mod;\r}\rreturn ans;\r}\r ","id":2,"section":"posts","summary":"求最大公约数和最小公倍数 辗转相除法 时间复杂度O(log(max(a,b))) int gcd(int a,int b) { if(b==0) return a; else return gcd(b,a%b); } int lcm(int a,int b) { return a*b/gcd(a,b); } 或直接调用algorit","tags":["hahaha"],"title":"hahaha","uri":"https://dyhgo.github.io/1/01/%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3/","year":"0001"}],"tags":[{"title":"emoji","uri":"https://dyhgo.github.io/tags/emoji/"},{"title":"hahaha","uri":"https://dyhgo.github.io/tags/hahaha/"}]}
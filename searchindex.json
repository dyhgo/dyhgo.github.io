{"categories":[{"title":"abc","uri":"https://dyhgo.github.io/categories/abc/"},{"title":"algorithm","uri":"https://dyhgo.github.io/categories/algorithm/"},{"title":"hduoj","uri":"https://dyhgo.github.io/categories/hduoj/"},{"title":"note","uri":"https://dyhgo.github.io/categories/note/"},{"title":"nowcoder","uri":"https://dyhgo.github.io/categories/nowcoder/"},{"title":"poj","uri":"https://dyhgo.github.io/categories/poj/"},{"title":"test","uri":"https://dyhgo.github.io/categories/test/"}],"posts":[{"content":"","id":0,"section":"posts","summary":"","tags":["test"],"title":"test","uri":"https://dyhgo.github.io/2020/02/test/","year":"2020"},{"content":"效果展示\n在hugo官网也有说明如何搭建个人网站\n注册github账号 创建github仓库 仓库的名字必须是 用户名.github.io\n建议全小写\n安装git bash（非必须，但建议） 点击此处\n选择计算机对应的规格\n一步一步安装\n在使用前要进行初始化用户名和邮箱\n打开终端（以powershell为例）\n输入git命令，没有异常就可以\n安装hugo 点击此处\n选择计算机对应的规格\n下载zip压缩包\n解压后会得到 hugo.exe（这个是主要的）\n创建博客 打开powershell\n转到存放hugo.exe的文件夹下（hugo指令只能在这个目录下执行）\n如果hugo指令识别不出来，可以配置环境变量\n如果还是不行，那就用绝对路径，一直到hugo.exe\n要启动hugo.exe就要用 .\\hugo\n在存放hugo.exe的文件夹下，执行以下代码\n\u0026gt;hugo new site myblog\r myblog是自己起的名字，是一个identifier\n之后会生成myblog文件夹\n里面已经有一些东西了（大部分都是建立网站必须的）\n下载主题 点击此处\n选一个主题下载\n下载有两种方式\n1.点击download，转到作者github，下载zip\n把zip转到myblog/theme下，需要改文件夹一些名字\n2.在主题下面有git clone(推荐使用这种)\n直接在powershell下面输入（一定要 cd 到myblog）\n个别主题下载的慢，可以在不同时间不同地点多试试\n下载完，myblog/theme 就会多出一个主题对应的文件夹（很重要）\n以下是无论哪一种都要进行的操作\n根据作者在hugo网页中写的文档进行初始化配置（就是把主题文件夹中的东西搬出来，替换什么的）（很重要，没有这一步，可能本地都打不开，疯狂报错）（但有些主题没有此过程）\n尝试在本地打开\n输入以下代码(以pure主题为例）(这个主题名字是theme下对应文件夹的名字)\nmyblog\u0026gt;hugo server -t pure\r 会得到一个本地网址\n用浏览器打开这个网址\n就可以在本地看到自己的网页\n局域网内的用户也可以看到你的网页\n推到服务器上（github pages） 建议先在本地查看，确认无误之后再推到服务器\n输入以下代码\n注意不要写错\nmyblog\u0026gt;hugo --theme=pure --baseUrl=\u0026quot;https://你的用户名.github.io\u0026quot; --buildDrafts\r myblog下会生成public文件夹\n输入以下代码\nmyblog\u0026gt;cd public\rpublic\u0026gt;git init\rpublic\u0026gt;git add .\rpublic\u0026gt;git commit -m \u0026quot;输入你自己的提交信息\u0026quot;\rpublic\u0026gt;git remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u0026gt;git push -u origin master\rpublic\u0026gt;\r 此过程中有可能需要输入github的账号和密码\n访问 用户名.github.io就可以看到你的网页\n会有延迟，需要等一会\n配置主题和增加内容 配置因主题而异\n通法就是认真仔细地阅读作者的文档\nhugo/theme上的或者README.md（可见文档有多重要）\n增加的内容一般都放在content文件夹下，当然也可以删掉内容\n一般是markdown格式\n写markdown可以用markdownpad / visual studio code / csdn自带的等等\n但是发现一个问题，不同的编辑器预览的效果不一样\n比如markdownpad不能很好的识别latex公式\n有可能主题自带的markdown也不能很好的呈现出效果\n更新网站内容 建议首先在本地预览，确认无误再上传\n然后执行以下代码（含本地预览）\nmyblog\u0026gt;hugo server -t pure\rmyblog\u0026gt;hugo --theme=pure --baseUrl=\u0026quot;https://你的用户名.github.io\u0026quot; --buildDrafts\rmyblog\u0026gt;cd public\rpublic\u0026gt;git init\rpublic\u0026gt;git add .\rpublic\u0026gt;git commit -m \u0026quot;输入你自己的提交信息\u0026quot;\rpublic\u0026gt;git remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u0026gt;git pull origin master\rpublic\u0026gt;git push -u origin master\rpublic\u0026gt;\r 一定要写git pull origin master\n有延迟\n打开 用户名.github.io 可以看到内容已经更新\n之后更新网站内容就一直重复上述操作\n=================== 以下是自定义域名（附加内容）===================== 在阿里云上面注册账号\n实名制\n购买域名\n域名实名制\n购买SSL证书（有免费的）\n确定SSL证书有效\n配置DNS服务器\n在域名解析中添加记录\n记录类型为CNAME\n记录值填写 用户名.github.io（或者记录类型为A，记录值填写IP地址）\n打开github对应的仓库\n在settings中找到custom domain\n输入新域名\n在github pages下显示绿色的√就可以\n访问新域名就可以看到网页了\n之后更新的内容，都可以通过访问新域名实现\n以上操作都需要时间，需耐心等待\n个人博客网站基本搭建完毕\n","id":1,"section":"posts","summary":"效果展示 在hugo官网也有说明如何搭建个人网站 注册github账号 创建github仓库 仓库的名字必须是 用户名.github.io 建议全小写 安","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"https://dyhgo.github.io/2020/02/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","year":"2020"},{"content":"以二进制的原理表示集合，以整数呈现\n1表示在集合内，0表示不在集合内\n一位运算优先于按位逻辑运算\n空集 0 只含有第i个元素的集合{i} 1\u0026laquo;i 含有全部n个元素的集合 {0,1,2,\u0026hellip;n-1} (1\u0026laquo;n) - 1 判断第i个元素是否属于集合S if ( s\u0026raquo;i \u0026amp; 1 ) 原来的集合变了 向集合中加入第i个元素 S∪{i} S|1\u0026laquo;i 从集合中去除第i个元素 S{i} S\u0026amp;~(1\u0026laquo;i) 集合S和T的并集 S|T 集合S和T的交集 S\u0026amp;T\n按顺序枚举集合的子集\nfor(int S=0;S\u0026lt;1\u0026lt;\u0026lt;n;S++)\r 枚举某个集合sup的子集\nint sub=sup;\rdo\r{\rsub=(sub-1)\u0026amp;sup;\r}while(sub!=sup); //处理完0之后，会有-1\u0026amp;sup=sup  枚举{0,1,2,\u0026hellip;n-1}所包含的大小为k的子集\nint comb=(1\u0026lt;\u0026lt;k)-1;\rwhile(comb\u0026lt;1\u0026lt;\u0026lt;n)\r{\rint x=comb \u0026amp; -comb , y=comb+x;\rcomb=((comb \u0026amp; ~y) / x\u0026gt;\u0026gt;1) | y;\r}\r ","id":2,"section":"posts","summary":"以二进制的原理表示集合，以整数呈现 1表示在集合内，0表示不在集合内 一位运算优先于按位逻辑运算 空集 0 只含有第i个元素的集合{i} 1\u0026laquo;i 含有全部n个","tags":["cpp","binary"],"title":"二进制表示集合","uri":"https://dyhgo.github.io/2020/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/","year":"2020"},{"content":"求最大公约数和最小公倍数 辗转相除法\n时间复杂度O(log(max(a,b)))\nint gcd(int a,int b)\r{\rif(b==0) return a;\relse return gcd(b,a%b);\r}\rint lcm(int a,int b)\r{\rreturn a*b/gcd(a,b);\r}\r 或直接调用algorithm库中的__gcd(int a,int b) 扩展欧几里得算法 求满足 ax+by=gcd(a,b) 的整数解 x ，y\n时间复杂度O(log(max(a,b)))\nint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\r  求n以内质数个数 很多种方法，以下是埃氏筛\n时间复杂度O(nloglogn)\nint prime[maxn]; //ith prime number\rbool isprime[maxn+1] //is i a prime number\rint e_sieve(int n)\r{\rint p=0; //position\rfor(int i=0;i\u0026lt;=n;i++) isprime[i]=true; //initialize\risprime[0]=isprime[1]=false;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rif(isprime[i])\r{\rprime[p++]=i;\rfor(int j=2*i;j\u0026lt;=n;j+=i) isprime[j]=true;\r}\r}\rreturn p;\r}\r  数论的一些性质 Premise: a≡c (mod m) and b≡d (mod m) Conclusion: a±b≡c±d (mod m) a*b≡c*d (mod m) d|a \u0026amp;\u0026amp; d|b ⇒ d|gcd(a,b) gcd(an,bn) = n*gcd(a,b) 任意正整数n，n|ab \u0026amp;\u0026amp; a,n互质 ⇒ n|b a,p 互质 ， b,p互质 ⇒ ab,p互质 任意一个合数都可以分解成唯一的质数幂积的形式，即 $$ a=\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} $$ 因子个数为 $$ \\sum\\limits_{i=1} ^ {n} {(1+e_i)} $$ 积性函数 f(ab) = f(a)f(b) 欧拉函数 莫比乌斯函数 gcd 狄利克雷函数\n 快速幂 时间复杂度O(logn)\ntypedef long long ll;\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\r  逆元 $$ 逆元\\quad y=a^{-1}\\quad满足\\quad ay≡1(mod\\ m) ~\\ y为a在模m下的逆元 $$ $$ 对于\\quad ax≡b(mod\\ m) ~\\ x=a^{-1}*b $$ 求逆元 $$ ax≡1(mod\\ m) ~\\ ax-mk=1 ~\\ ax+my=1 ~\\ ax+my=gcd(a,m) ~\\当a,m不互质的时候，逆元不存在 $$\nint mod_inverse(int a,int m)\r{\rint x,y;\rex_gcd(a,m,x,y);\rreturn (m+x%m)%m;\r}   欧拉函数 $$ 设\\quad n =\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} ~\\ 则欧拉函数\\quad φ(n)=n*\\prod\\limits_{i=1} ^ {n} {\\frac{p_i-1}{p_i}} $$ 欧拉函数的数值等于不超过n且与n互质的数的个数\n当n时质数时，φ(n)=n-1\n如果n=p^k , φ(n)=p^k - p^(k-1) = (p-1)p^(k-1)\n如果m,n互质，则φ(mn)=φ(m)φ(n)\nφ(n)的值都为偶数，φ(2)除外\n质因子之和 (φ(n)*n)/2 欧拉定理 $$ 当a,m互质时 ~\\ a^{φ(m)}≡1(mod \\ m) $$ 费马小定理 $$ 当p是质数时， 对任意整数x 都有 ~\\ x^p≡x(mod \\ p) ~\\~\\ 当x,p互质时 ~\\ x^{p-1}≡1(mod \\ p) ~\\ 这就是欧拉定理的特殊形式 $$ 求欧拉函数 时间复杂度O(√(n)) 求欧拉函数值的表，类似于埃氏筛，时间复杂度O(n)\nint phi(int n)\r{\rint res=n;\rfor(int i=2;i*i\u0026lt;=n;i++)\r{\rif(n%i==0)\r{\rres=res/i*(i-1);\rwhile(n%i==0) n/=i;\r}\r}\rif(n!=1) res=res/n*(n-1);\rreturn res;\r}\rint euler_phi[maxn];\rvoid phi_arr()\r{\rfor(int i=0;i\u0026lt;maxn;i++) euler_phi[i]=i;\rfor(int i=2;i\u0026lt;maxn;i++)\r{\rif(euler_phi[i]==i)\r{\rfor(int j=i;j\u0026lt;maxn;j+=i) euler_phi[j]=euler_phi[j]/i*(i-1);\r}\r}\r}\r  线性同余方程组 $$ a_ix≡b_i(mod \\ m_i) $$ 如果方程组有解，一定有无穷多解\n解的全集可以写成 x≡b(mod m)\n所以将问题转化为求b,m\n可以对如下方程组依次求解 $$ x≡b_1(mod \\ m_1) ~\\ ax≡b_2(mod\\ m_2) $$ $$ x≡b_1(mod \\ m_1) ~\\ x=b_1+m_1t ~\\a(b_1+m_1t)≡b_2(mod\\ m_2) ~\\am_1t≡b_2-ab_1(mod \\ m_2) ~\\a\u0026rsquo;t≡b\u0026rsquo;(mod \\ m_2) $$ 当gcd(m₂,am₁)与b₂-ab₁互质时，方程组无解\n时间复杂度O(n)\npair\u0026lt;int,int\u0026gt; linear_congruence(const vector\u0026lt;int\u0026gt;\u0026amp; A,const vector\u0026lt;int\u0026gt;\u0026amp; B,const vector\u0026lt;int\u0026gt;\u0026amp; M)\r{\r//最开始没有限制，把解设为所有整数 x ≡0(mod 1)\rint x=0,m=1;\rfor(int i=0;i\u0026lt;A.size();i++)\r{\rint a=A[i]*m , b=B[i]-A[i]*x , d=gcd(M[i],a); //d!!!\rif(b%d!=0) return make_pair(0,-1); //无解\rint t=b / d * mod_inverse(a/d,M[i]/d) % (M[i]/d) ;\rx=x+m*t;\rm*=M[i]/d; //*= !!!\r}\rreturn make_pair(x%m,m);\r}\r  中国剩余定理(CRT) crt是线性同余方程组ai=0，mi互质的特殊形式\n这时，x≡b(mod Πmi)\ncrt的思想是余数的加性和模数的乘性，当模数为合数时，可以拆成质因数的积\ncrt定理如下 $$ 对于x≡b_i(mod \\ m_i) \\ \\ \\ \\ \\ \\ m_i互质 ~\\ ~\\令M=\\prod{m_i} ~\\M_i=\\frac{M}{m_i} ~\\M_i ^ {-1} 为M_i模m_i的逆元 ~\\\n则 \\ x≡(\\sum\\limits_{i=1} ^ {n} {b_iM_iM_i ^{-1}}) \\ (mod \\ M) $$\n// x=x+(Πmi)*t\r//return minimum int crt(const vector\u0026lt;int\u0026gt;\u0026amp; b,const vector\u0026lt;int\u0026gt; \u0026amp;m)\r{\rint M=1,x=0;\rfor(int i=0;i\u0026lt;m.size();i++) M*=m[i];\rfor(int i=0;i\u0026lt;m.size();i++){\rint Mprime=M/m[i];\rint M_p_i=mod_inverse(Mprime,m[i]);\rx=(x + b[i] * Mprime * M_p_i)%M;\r}\rreturn (x+M)%M;\r}\r  Lucas定理 $$ 求 \\ C_{n}^{k} \\ (mod \\ p) , p是质数 ~\\ 当k,n较小时，利用杨辉三角形的性质 ~\\ C_{n}^{k}=C_{n-1}^k+C_{n-1}^{k-1} ~\\ ~\\当n,k较大时 ~\\ n=\\sum{n_ip^i} \\quad \\quad k=\\sum{k_ip^i} \\quad\\quad表示成p进制~\\ C_n^k≡\\prod{C_{n_i}^{k_i}} \\ (mod \\ p) $$\nll pow_mod(ll a, ll n)\r{\rif(n == 0) return 1;\rll x = pow_mod(a, n/2);\rll ans = x * x % mod;\rif(n % 2 == 1) ans = ans *a % mod;\rreturn ans%mod;\r}\rll C(ll n,ll m) {\rif(n \u0026lt; m) return 0;\rll res = 1;\rfor(ll i=1; i\u0026lt;=m; i++) {\rll a = (n+i-m)%mod;\rll b = i%mod;\rres = res*(a*pow_mod(b,mod-2)%mod)%mod;\r}\rreturn res;\r}\rll Lucas(ll n,ll m) {\rif(m == 0) return 1;\rreturn C(n%mod, m%mod) * Lucas(n/mod,m/mod)%mod;\r}\r ll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;}\rll com(ll a,ll b){\rll ans=1;\rfor(ll i=a;i\u0026gt;a-b;i--){\rans=ans*i%mod;\r}\rfor(ll i=1;i\u0026lt;=b;i++){\rans=(ans*qpow(i,mod-2))%mod;\r}\rreturn ans;\r}\r ","id":3,"section":"posts","summary":"求最大公约数和最小公倍数 辗转相除法 时间复杂度O(log(max(a,b))) int gcd(int a,int b) { if(b==0) return a; else return gcd(b,a%b); } int lcm(int a,int b) { return a*b/gcd(a,b); } 或直接调用algorit","tags":["cpp","number_theory"],"title":"Number Theory","uri":"https://dyhgo.github.io/2020/02/number-theory/","year":"2020"},{"content":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\nInput 输入的都是整数对n、m（0\u0026lt;n≤m\u0026lt;1000000），如果遇到都是0的整数对，则输入结束。\nOutput 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。\nSample Input 1 100 0 0\nSample Output 80\nSolution 与数位的组成有关，可以用数位dp。\n利用前缀即 solve(m)-solve(n-1)\ndp[i][j] 表示 符合条件的个数[当前操作的数位(倒序排)][当前操作的数位的前一个数] $$ dp[pos][pre] = \\sum\\limits_{i=0} ^ {maxd} dp[pos-1][i] $$ maxd可以由一个boolean变量limit控制，是否是9还是dig[pos]\n为了不重复计算（重复计算也可以），可以用记忆化搜索，也就是可以利用计算好的dp。为了使dp普适，dp必须是稳定，经全搜索得到的（即maxd=9）。所以通过limit控制dp的存储和dp的读取\n通过dp递推式，可以用dfs实现（理论上来说可以不用dfs，但不能记忆化且dp可能要增加维度，且要特殊初始化。没有实践过，有时间可以去试试）\nint dfs(int pos,int pre,bool limit)\n通过limit和返回值来使dp结果普适\nAC代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\rusing namespace std;\rint n,m;\rint dp[10][10]; //dp[i][j] i:总共有i位 , j:前导数字为j , dp:满足条件（不含4和62）的个数 int dig[10];\rint dfs(int pos,int pre,bool limit) //pos 当前位置 ， pre 当前位置的前一个数字 {\rif(pos==-1) return 1; //只有0（1个数字）满足\rif(dp[pos][pre]!=-1 \u0026amp;\u0026amp; !limit) return dp[pos][pre]; //已经搜索过则直接返回 //!!!!\rint ans=0;\rint maxd;\rif(limit) maxd=dig[pos];\relse maxd=9;\rfor(int i=0;i\u0026lt;=maxd;i++)\r{\rif(i==4 || (pre==6 \u0026amp;\u0026amp; i==2)) ;\relse ans+=dfs(pos-1,i,limit \u0026amp;\u0026amp; i==dig[pos]); //这里需要传limit !!!!!!!!!! }\rif(!limit) //只有在全搜索的时候才能给dp赋值，这样可以保证dp适用于所有情况，从而实现记忆化搜素 dp[pos][pre]=ans;\rreturn ans;\r}\rint solve(int x)\r{\rint len=0;\rwhile(x)\r{\rdig[len++]=x%10;\rx/=10;\r}\rreturn dfs(len-1,0,1);\r} int main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rmemset(dp,-1,sizeof(dp)); //不需要每次都初始化，因为要记忆化搜索 //不需要对dp特殊初始化，因为dfs中有return 1 while(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m)==2 \u0026amp;\u0026amp; (n || m))\r{\rcout\u0026lt;\u0026lt;solve(m)-solve(n-1)\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}  第一次写数位dp，参考了别人的代码，也调试了很久，思考了很多，才弄懂其中的细节\n","id":4,"section":"posts","summary":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"https://dyhgo.github.io/2020/02/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","year":"2020"},{"content":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树\n用一个例子来介绍线段树\nRMQ（range minimum query）\n实现功能 对于一个数列 1.给定s,t求[s,t)区间的最小值（最大值） 2.给定i和x,把ai改成x\nconst int maxn = 1\u0026lt;\u0026lt;17;\rint n,dat[2*maxn+1];\rvoid init(int n_)\r{\r//为了计算方便,把元素个数扩大到2的幂次方的个数\rn=1;\rwhile(n\u0026lt;n_) n*=2;\rfill(dat,dat+2*n-1,inf);\r}\r//将从0开始的第k个值，改成a void update(int k,int a)\r{\rk+=n-1;\rdat[k]=a;\r//向上更新\rwhile(k\u0026gt;0)\r{\rk=(k-1)/2;\rdat[k]=min(dat[2*k+1],dat[2*k+2]);\r} }\r//求[a,b)区间的最小值(从0开始数)\r//后面的参数是为了计算方便传入的\r//k是节点编号，l，r是k节点对应的区间\r//在外部调用是用query(a,b,0,0,n)\rint query(int a,int b,int k,int l,int r)\r{\rif(r\u0026lt;=a || b\u0026lt;=l) return inf;\rif(a\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=b) return dat[k];\relse\r{\rint vl=query(a,b,2*k+1,l,(l+r)/2);\rint lr=query(a,b,2*k+2,(l+r)/2,r);\rreturn min(vl,vr);\r}\r}  初始化的时间复杂度O(n) 更新和查询的时间复杂度O(logn)\n如果dat以1开头，则可以利用这些性质 \u0026gt;\u0026gt;1 : /2取整 \u0026laquo;1 : 乘2 \u0026laquo;1|1 : (*2+1)\n以这题为例\n给出一个长度为 n 的数列，a1,a2,\u0026hellip;,an,求其长度为 k 的连续子段的乘积对 998244353 取模余数的最大值。\nsolution:这道题可以用尺取法、线段树、逆元\n线段树的做法不需要update函数，最底层存每个数，父节点存子节点的乘积，最后query每一段区间\nAC代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rconst ll mod = 998244353;\rll n_,k;\rll n;\rll dat[4*200005+2];\r//[a,b)\rll query(ll a ,ll b,ll k,ll l,ll r)\r{\rif(r\u0026lt;=a || b\u0026lt;=l) return 1;\rif(a\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=b) return dat[k];\rreturn (query(a,b,k*2+1,l,(l+r)/2) * query(a,b,k*2+2,(l+r)/2,r))%mod;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rscanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;n_,\u0026amp;k);\rn=1;\rwhile(n\u0026lt;n_) n*=2;\rfor(ll i=n-1;i\u0026lt;n_-1+n;i++)\r{\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;dat[i]);\r}\rfor(ll i=n-2;i\u0026gt;=0;i--)\r{\rdat[i]=(dat[i*2+1]*dat[i*2+2]) % mod;\r}\rll ans=-1;\rfor(ll i=0;i+k\u0026lt;=n_;i++)\r{\rans=max(ans,query(i,i+k,0,0,n));\r}\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 有几个点导致WA 1.要用long long 不能用int 2.dat的的大小要用4乘，否则会断错误，因为在query时，最底层的也有可能访问子节点 边界条件是线段树容易出错的地方，以上代码的区间是左闭右开，在判断条件里面用等号注意n_和n的使用\n","id":5,"section":"posts","summary":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树 用一个例子来介绍线段树 RMQ（range minimum query） 实现功能 对于一","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"https://dyhgo.github.io/2020/02/segment-tree/","year":"2020"},{"content":"题目在这\n这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快\n三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2\n求mid midmid与n个点的距离，然后依据较小值缩减区间\n代码如下\n//三分法 最快的应该是0.618法\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rstruct point {\rdouble x,y;\r}p[100005];\rdouble eps = 5e-5;\rdouble check(double x)\r{\rdouble dist = -1;\rfor(int i=0;i\u0026lt;n;i++)\r{\rdist = max(dist,(x-p[i].x)*(x-p[i].x) + p[i].y*p[i].y); }\rreturn sqrt(dist);\r}\rint main()\r{\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%lf %lf\u0026quot;,\u0026amp;p[i].x,\u0026amp;p[i].y);\rdouble l = -10000.0;\rdouble r = 10000.0;\rwhile(r-l\u0026gt;eps)\r{\rdouble mid = l + (r -l)/2; //这里的三分\rdouble midmid = mid+(r-mid)/2;\rif(check(mid)\u0026gt;check(midmid)) l=mid;\relse r=midmid;\r}\rprintf(\u0026quot;%.5lf\\n\u0026quot;,check(l));\rreturn 0;\r}\r ","id":6,"section":"posts","summary":"题目在这 这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快 三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"https://dyhgo.github.io/2020/02/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/","year":"2020"},{"content":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等\n二分图判定 通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图\n用dfs判断每个点是否可染色，如果每个点都是可染色的，就是二分图\n//input\rvector\u0026lt;int\u0026gt; G[max_v];\rint V;\rint color[max_v] //顶点i的颜色 1或-1\rbool dfs(int v,int c)\r{\rcolor[v]=c; //染色\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\rif(color[v][i]==c) return false; //相邻顶点同色\rif(color[G[v][i]]==0 \u0026amp;\u0026amp; !dfs(G[v][i],-c)) return false; //对于还没染色的点，如果不能染色则返回false } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=0;i\u0026lt;V;i++)\r{\rif(color[i]==0) //还未着色//如果是连通图，遍历一次就够\rif(!dfs(i,1)) return false; }\rreturn true;\r}  把顶点和边都算的话，时间复杂度是O(|V|+|E|)\n求DAG的拓扑序 求拓扑序可以dfs，删边法（通过栈或队列）\n求每个点的入度，将入度为0的点入栈，遍历栈里的点，将于这些点相邻的点的入度减1，如果有点入度为0，则入栈。依靠这个顺序，得到的就是拓扑序。如果点访问两次，则有圈。可以通过这个方法判断有向图是否有圈\n//input\rvector\u0026lt;int\u0026gt; G[max_v]\rint V;\rint indgree[max_v] //每个顶点的入度\rvector\u0026lt;int\u0026gt; res; //拓扑排序的结果\rbool topological_sort() //判断是否能拓扑排序 ，若果有圈就不能 {\rstack\u0026lt;int\u0026gt; s;\r//int counter=0; //遍历的点的个数 for(int i=0;i\u0026lt;V;i++) if(indegree[i]==0) s.push(i); //入度为0 的顶点入栈\rwhile(!s.empty())\r{\rint v=s.top(); s.pop();\rres.push_back(v);\r//counter++;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\rint k=G[v][i];\rif(--indegree[k] == 0) s.push(k); //遍历到的点入度间1，入度为0则入栈 }\r}\tif(res.size()==n) return true;\relse return false;\r}\r 时间复杂度是O(|V|+|E|)\nBellman-Ford算法 求单源最短路\nd[i]=min{d[j]+e(j,i)}\n只要图中不存在负圈，这样的更新操作是有限的（由于最短路不会经过一个顶点两次，所以这种操作只会重复|v|-1次）\n时间复杂度O(|V|*|E|)\nstruct edge\r{\rint from,to,cost;\r}es[max_e];\rint d[max_v];\rint V,E;\rvoid bellman_ford(int s)\r{\rfor(int i=0;i\u0026lt;V;i++) d[i]=inf; //把最短距离初始化成无限\rd[s]=0; while(true)\r{\rbool update=false; //判断while是否进行了更新操作，没有更新操作则退出循环 for(int i=0;i\u0026lt;E;i++) //根据公式，遍历边\r{\redge e=es[i];\rif(d[e.from]!=inf \u0026amp;\u0026amp; d[e.to]\u0026gt;d[e.from]+e.cost)\r{\rd[e.to]=d[e.from]+e.cost;\rupdate=true;\r}\r}\rif(!update) break;\r}\r}\r 如果更新操作（while循环）进行了超过|V|-1次，则存在负圈\n所以判断负圈的一个方法可以是\n把所有d[i]都变成0，如果有负圈，则一定执行超过|V|-1次\nbool find_negative_loop()\r{\rmemset(d,0,sizeof(d));\rfor(int i=0;i\u0026lt;V;i++)\r{\rfor(int j=0;j\u0026lt;E;j++)\r{\redge e=es[j];\rif(d[e.to]\u0026gt;d[e.from]+e.cost)\r{\rd[e.to]\u0026gt;d[e.from]+e.cost;\rif(i==V-1) return true; //这条语句不能放在if外，如果放在if外需要加update\t}\r}\r}\rreturn false;\t}\r Dijkstra算法 求单源最短路，适用于没有负边的情况\n将已求出最短路的点，放入一个集合中 ，每次从集合外找到一个和集合距离最近的点，加入集合\nint cost[max_v][max_v]; //权值，不存在时为inf\rint d[max_v];\rbool used[max_v];\rint V;\rvoid dijkstra(int s)\r{\rfill(d,d+v,inf);\rfill(used,used+v,false);\rd[s]=0;\rwhile(true)\r{\rint v=-1;\r//从尚未使用过的点中选一个距离最小的点\rfor(int u=0;u\u0026lt;V;u++)\r{\rif(!used[u] \u0026amp;\u0026amp; (v==-1 || d[u]\u0026lt;d[v])) v=u;\r} if(v==-1) break;\rused[v]=true;\rfor(int u=0;u\u0026lt;V;u++)\rd[u]=min(d[u],d[v]+cost[v][u]); }\r}  时间复杂度O(V^2)\n优化\n如果将点放入优先队列中，这要查找和更新就会节省很多时间，时间复杂度O(ElgV)\nstruct edge\r{\rint to,cost;\r}\rtypedef pair\u0026lt;int,int\u0026gt; pii; //first 是距离 ，second是点编号\rint V;\rvector\u0026lt;edge\u0026gt; G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; //使小的在上面\rfill(d,d+V,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} }  Floyd-Warshall算法 求任意两点最短路，暴力枚举思想\nd[i][j]=min(d[i][j],d[i][k]+d[k][j]) 遍历所有的k\n时间复杂度O(V^3)\nint d[max_v][max_v]; //存储权值，边不存在时为inf，d[i][i]=0 int V;\rvoid floyd_warshall()\r{\rfor(k=0;k\u0026lt;V;k++)\rfor(int i=0;i\u0026lt;V;i++)\rfor(int j=0;j\u0026lt;V;j++)\rd[i][j]=min(d[i][j],d[i][k]+d[k][j]);\r}\r 路径还原 通过找满足d[j]=d[k]+cost[k][j]的顶点k，来寻找前趋节点，不断寻找前趋节点来还原路径，时间复杂度O(E)\n还可以用prev[j]在算法内直接记录前趋节点，最后遍历数组即可，时间复杂度O(V)\n//算法内记录前趋节点 (优化的dijkstra算法)\rint prev[max_v] //前趋节点\rstruct edge\r{\rint to,cost;\r}\rtypedef pair\u0026lt;int,int\u0026gt; pii; //first 是距离 ，second是点编号\rint V;\rvector\u0026lt;edge\u0026gt; G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; //使小的在上面\rfill(d,d+V,inf);\rfill(prev,prev+V,-1); //!!!! d[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rprev[e.to]=v; //!!!!\rq.push(pii(d[e.to],e.to));\r}\r}\r} }\rvector\u0026lt;int\u0026gt; get_path(int t)\r{\rvector\u0026lt;int\u0026gt; path;\rfor(;t!=-1;t=prev[t]) path.push_back(t);\rreverse(path.begin(),path.end());\rreturn path;\r}\r Prim算法 求最小生成树\nprim算法和dijkstra算法很像，也是把已确定的点放入一个集合中，贪心地选取集合和未确定的点相连的最小权边，并加入到集合中，得到一棵生成树，可以证明是MST(minimum spanning tree)\n//也可以堆优化 int cost[max_v][max_v] //权值\rint mincost[max_v]; //从集合出发到其他点的最小权值,!!!这个权值是 集合 和 点 之间的 bool used[max_v]; //是否在集合中\rint V;\rint prim() //返回MST的权值\r{\rfill(mincost,mincost+V,inf); //初始化 fill(used,used+V,false);\rmincost[0]=0; //从0开始 int res=0;\rwhile(true)\r{\rint v=-1;\rfor(int u=0;u\u0026lt;V;u++)\r{\rif(!used[u] \u0026amp;\u0026amp; (v==-1 || mincost[u]\u0026lt;mincost[v])) v=u;\r}\rif(v==-1) break;\rused[v]=true;\rres+=mincost[v];\rfor(int u=0;u\u0026lt;V;u++)\r{\rmincost[u]=min(mincost[u],cost[v][u]); //每次往集合中加入一个点，所有点的mincost都有可能改变 }\r}\rreturn res; }  时间复杂度与dijkstra算法一样\nKruskal算法 求MST\n将边的权值按大小排序，如果不产生圈和重边，就依次把边加入到生成树中\n要判断是否产生圈和重边，只需要判断加入这条边前，这条边的两个端点是否已在同一个连通分量里，这样就可以用并查集\nKruskal在边的排序上最费时，算法复杂度O(ElgV)\nKruskal适用于sparse graph\nPrim适用于dense graph\n在实际应用中，Kruskal更普遍\nstruct edge\r{\rint u,v,cost;\r}es[max_e];\rint V,E;\rint par[max_v]; //union find需要 int rankk[max_v]; //key word \u0026quot;rank\u0026quot;\rbool cmp(const edge\u0026amp; e1,const edge\u0026amp; e2)\r{\rreturn e1.cost\u0026lt;e2.cost;\r}\rvoid init_union_find(int x)\r{\rfor(int i=0;i\u0026lt;x;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x)\rreturn x;\relse\rreturn par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return;\rif(rankk[x]\u0026lt;rankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint kruskal()\r{\rsort(es,es+E,cmp);\rinit_union_find(V);\rint res=0;\rfor(int i=0;i\u0026lt;E;i++)\r{\redge e=es[i];\rif(!same(e.u,e.v))\r{\runite(e.u,e.v);\rres+=e.cost;\r}\r}\rreturn res;\r}\r ","id":7,"section":"posts","summary":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等 二分图判定 通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图 用dfs判断每个点","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"https://dyhgo.github.io/2020/02/graph-theory/","year":"2020"},{"content":"食物链 Time Limit: 1000MS\tMemory Limit: 10000K Description 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这N个动物所构成的食物链关系进行描述： 第一种说法是\u0026quot;1 X Y\u0026rdquo;，表示X和Y是同类。 第二种说法是\u0026quot;2 X Y\u0026rdquo;，表示X吃Y。 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 1） 当前的话与前面的某些真的话冲突，就是假话； 2） 当前的话中X或Y比N大，就是假话； 3） 当前的话表示X吃X，就是假话。 你的任务是根据给定的N（1 \u0026lt;= N \u0026lt;= 50,000）和K句话（0 \u0026lt;= K \u0026lt;= 100,000），输出假话的总数。\nInput 第一行是两个整数N和K，以一个空格分隔。 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 若D=1，则表示X和Y是同类。 若D=2，则表示X吃Y。\nOutput 只有一个整数，表示假话的数目。\nSample Input 100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5\nSample Output 3\nSource Noi 01\nSolution 并查集\n看到信息的内容，有并查集的影子\n依次遍历信息，对于每一条信息，因为没有说种类，所以设置三个种类，把每一种情况都加上去，比如：x和y属于同一类，则合并x和y属于A类，B类，C类\n判断是否是错误信息，只要判断是否与前面信息矛盾即可\n并查集的时间复杂度O(α(n)) α(n)是阿克曼函数的反函数，比O(lgn)还快\n代码如下（并查集的模板 + 并查集的应用）\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint T[100005],X[100005],Y[100005];\rint n,k;\r//union find\rint par[150005]; //父亲 int rankk[150005]; //树的高度,!!!元素是根 （优化用）//reference to \u0026quot;rank\u0026quot; is ambiguous\r//初始化，要用并查集前要初始化\rvoid init(int n) {\rfor(int i=0;i\u0026lt;n;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} //查询树的根\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); //return find(par[x]);也可以 。par[x]=find(par[x]) 是路径压缩优化 } //合并x,y //优化高度（如果rankk不同，那么从rankk小的向大的连边 void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; //判断是否已在同一个集合内\rif(rankk[x]\u0026lt;rankk[y]) par[x]=y; //!!!利用它们的 根 进行合并 else\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++; //这时候rankk还是原来的高度 } } //判断是否在同一个集合内\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;k;i++)\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;T[i],\u0026amp;X[i],\u0026amp;Y[i]);\rinit(n*3);\rint ans=0;\rfor(int i=0;i\u0026lt;k;i++)\r{\rint t=T[i],x=X[i]-1,y=Y[i]-1;\r//错误的编号\rif(x\u0026lt;0 || x\u0026gt;=n || y\u0026lt;0 || y\u0026gt;=n)\r{\rans++;\rcontinue;\r} else if(t==1) //第一种类型\r{\rif(same(x,y+n) || same(x,y+2*n)) ans++; //判断是否矛盾 //!!!只需要判断x在A类就行，因为每次unite都\r//涵盖所有情况，它们是平行影响的，判断一个就相当于判断所有 else\r{\runite(x,y);\runite(x+n,y+n);\runite(x+n+n,y+n+n);\r}\r} else if(t==2)\r{\rif(same(x,y) || same(x,y+2*n)) ans++;\relse\r{\runite(x,y+n);\runite(x+n,y+2*n);\runite(x+2*n,y);\r}\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":8,"section":"posts","summary":"食物链 Time Limit: 1000MS Memory Limit: 10000K Description 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。","tags":["cpp","union_find"],"title":"poj1182","uri":"https://dyhgo.github.io/2020/02/poj1182/","year":"2020"},{"content":"Beauty Contest Time Limit: 3000MS\tMemory Limit: 65536K Description Bessie, Farmer John\u0026rsquo;s prize cow, has just won first place in a bovine beauty contest, earning the title \u0026lsquo;Miss Cow World\u0026rsquo;. As a result, Bessie will make a tour of N (2 \u0026lt;= N \u0026lt;= 50,000) farms around the world in order to spread goodwill between farmers and their cows. For simplicity, the world will be represented as a two-dimensional plane, where each farm is located at a pair of integer coordinates (x,y), each having a value in the range -10,000 \u0026hellip; 10,000. No two farms share the same pair of coordinates.\nEven though Bessie travels directly in a straight line between pairs of farms, the distance between some farms can be quite large, so she wants to bring a suitcase full of hay with her so she has enough food to eat on each leg of her journey. Since Bessie refills her suitcase at every farm she visits, she wants to determine the maximum possible distance she might need to travel so she knows the size of suitcase she must bring.Help Bessie by computing the maximum distance among all pairs of farms.\nInput   Line 1: A single integer, N\n  Lines 2..N+1: Two space-separated integers x and y specifying coordinate of each farm\n  Output  Line 1: A single integer that is the squared distance between the pair of farms that are farthest apart from each other.  Sample Input 4 0 0 0 1 1 1 1 0\nSample Output 2\nHint Farm 1 (0, 0) and farm 3 (1, 1) have the longest distance (square root of 2)\nSource USACO 2003 Fall\nSolution 题意：平面上有n个不重合的点，求两个点的最远距离\n由于点的个数为50000，所以暴力超时\n构造凸包，遍历凸包上的点即可\n坐标范围在n内的凸多边形（顶点在格点上）的顶点个数最多为O（√n）（尝试不严谨的画图证明，和公差为1的等差数列求和有关，所以是平方关系）\n所以构造凸包后，暴力遍历的时间复杂度为O（n）\n构造凸包可以用模板\n此处介绍的是时间复杂度O(nlgn）的graham扫描法\n外积是很常用的工具，此处利用外积的坐标公式的符号判断凹凸性\n可以对点先排序，然后按逆时针方向依次遍历点，先构造凸包的下侧，到达最右端时，构造凸包的上侧\n代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rdouble s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u0026lt;b.x;\rreturn a.y\u0026lt;b.y;\r}\rdouble out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u0026lt;point\u0026gt; convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\rint k=0; // 凸包点的index vector\u0026lt;point\u0026gt; qs(n*2); //构造凸包\r//逆时针构造凸包\r//构造凸包的下侧\rfor(int i=0;i\u0026lt;n;i++)\r{\rwhile(k\u0026gt;1 \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\rfor(int i=n-2,t=k;i\u0026gt;=0;i--)\r{\rwhile(k\u0026gt;t \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--; //这里有个k\u0026gt;t 和 k\u0026gt;1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rpoint p;\rscanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;p.x,\u0026amp;p.y);\rps[i]=p;\r}\rvector\u0026lt;point\u0026gt; qs=convex_hull(ps,n);\rdouble res=0;\rfor(int i=0;i\u0026lt;qs.size();i++)\rfor(int j=0;j\u0026lt;i;j++)\rres=max(res,s_dist(qs[i],qs[j]));\rcout\u0026lt;\u0026lt;(int)res\u0026lt;\u0026lt;endl; //!!!不加int 或不用printf(\u0026quot;%.0lf\\n\u0026quot;,res); 就会WA return 0;\r}\r 还有一种时间复杂度更低的方法\nconvex hull + rotating calipers\n这是一种常见、经典的方法\n对踵点：如果凸包上过两个点画两条平行线，使凸包所有的点都夹在这两条线之间，这两个点就叫对踵点，称为一对对踵点对\n对于一个凸包，最远距离一定是对踵点对\n所以先找一对对踵点对，根据判断凹凸性，确定哪个点向后面的点移动（如图）（图懒得画），宏观来看就是对踵点对的连线旋转了180°\n这样就总时间复杂度就是O（√n）\n代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rinline double s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u0026lt;b.x;\rreturn a.y\u0026lt;b.y;\r}\rinline double out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u0026lt;point\u0026gt; convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\rint k=0; // 凸包点的index vector\u0026lt;point\u0026gt; qs(n*2); //构造凸包\r//逆时针构造凸包\r//构造凸包的下侧\rfor(int i=0;i\u0026lt;n;i++)\r{\rwhile(k\u0026gt;1 \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\rfor(int i=n-2,t=k;i\u0026gt;=0;i--)\r{\rwhile(k\u0026gt;t \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--; //这里有个k\u0026gt;t 和 k\u0026gt;1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rpoint p;\rscanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;p.x,\u0026amp;p.y);\rps[i]=p;\r}\rvector\u0026lt;point\u0026gt; qs=convex_hull(ps,n);\rdouble res=0; int m=qs.size();\rif(m==2) //特殊处理凸包退化情况\r{\rcout\u0026lt;\u0026lt;(int)s_dist(qs[0],qs[1])\u0026lt;\u0026lt;endl; return 0; } int i=0,j=0; //表示左右俩对踵点\r//求x轴方向上的对踵点对\rfor(int k=0;k\u0026lt;m;k++)\rif(cmp(qs[j],qs[k])) j=k;\r//rotating calipers\rint si=i,sj=j;\rwhile(!(i==sj \u0026amp;\u0026amp; j==si)) //旋转180°，注意判断条件 {\r//cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl;\rres=max(res,s_dist(qs[i],qs[j])); //这条语句放在while循环体的前端，可以把x轴方向上的对踵点对都比较\r//通过外积判断凹凸性，判断是i移到i+1，还是j移到j+1\rif(out_product(qs[(i+1)%m].x-qs[i].x , qs[(i+1)%m].y-qs[i].y , qs[(j+1)%m].x-qs[j].x , qs[(j+1)%m].y-qs[j].y)\u0026lt;0) //\u0026lt;0 或\u0026lt;=0都可以\ri=(i+1)%m; //把m错写成n,tle好久 else\rj=(j+1)%m; //!!!要%m 这样转一圈才能回到起点，退出循环 } //之前添加的debug条件忘记屏蔽，WA了特久 cout\u0026lt;\u0026lt;(int)res\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":9,"section":"posts","summary":"Beauty Contest Time Limit: 3000MS Memory Limit: 65536K Description Bessie, Farmer John\u0026rsquo;s prize cow, has just won first place in a bovine beauty contest, earning the title \u0026lsquo;Miss Cow World\u0026rsquo;. As a result, Bessie will make a tour of N (2 \u0026lt;= N \u0026lt;= 50,000) farms around the world in order to spread goodwill between farmers and their cows. For simplicity, the world will be represented as a two-dimensional plane,","tags":["cpp","computational_geometry"],"title":"poj2187","uri":"https://dyhgo.github.io/2020/01/poj2187/","year":"2020"},{"content":"Coneology 题目链接\nTime Limit: 5000MS\tMemory Limit: 65536K Description A student named Round Square loved to play with cones. He would arrange cones with different base radii arbitrarily on the floor and would admire the intrinsic beauty of the arrangement. The student even began theorizing about how some cones dominate other cones: a cone A dominates another cone B when cone B is completely within the cone A. Furthermore, he noted that there are some cones that not only dominate others, but are themselves dominated, thus creating complex domination relations. After studying the intricate relations of the cones in more depth, the student reached an important conclusion: there exist some cones, all-powerful cones, that have unique properties: an all-powerful cone is not dominated by any other cone. The student became so impressed by the mightiness of the all-powerful cones that he decided to worship these all-powerful cones.\nUnfortunately, after having arranged a huge number of cones and having worked hard on developing this grandiose cone theory, the student become quite confused with all these cones, and he now fears that he might worship the wrong cones (what if there is an evil cone that tries to trick the student into worshiping it?). You need to help this student by finding the cones he should worship.\nInput The input le specifies an arrangement of the cones. There are in total N cones (1 ≤ N ≤ 40000). Cone i has radius and height equal to Ri, i = 1 … N. Each cone is hollow on the inside and has no base, so it can be placed over another cone with smaller radius. No two cones touch.\nThe first line of the input contains the integer N. The next N lines each contain three real numbers Ri, xi, yi separated by spaces, where (xi, yi) are the coordinates of the center of the base of cone i.\nOutput The first line of the output le should contain the number of cones that the student should worship. The second line contains the indices of the cones that the student should worship in increasing order. Two consecutive numbers should be separated by a single space.\nSample Input 5 1 0 -2 3 0 3 10 0 0 1 0 1.5 10 50 50\nSample Output 2 3 5\nSource MIT Programming Contest 2005\nSolution 题意：坐标上有n个不相交的圆，求最外层圆的index\n由于数据规模，暴力超时\nsweeping line\n一般有两种，平移扫描，环形扫描\n对于这一题，从左到右平移扫描\n用一个容器维护每个圆的左右两个端点，代表扫描到圆和扫描出圆\n对于扫描到的圆，判断它是否在别的圆内\n只需要判断上下最近的两个圆（可画图证明，不严谨）\n用一个容器维护还没扫描出的最外圆，可以排序，再查找。总时间复杂度O(nlgn)\n可以选用set\n当扫描到右时，把圆从set中去除，意味着扫描过了\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;set\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rdouble x[40005],y[40005],r[40005];\rint n;\rtypedef pair\u0026lt;double ,int\u0026gt; pdi;\rbool inside(int i,int j)\r{\rdouble dx=x[i]-x[j],dy=y[i]-y[j];\rreturn dx*dx+dy*dy\u0026lt;=r[j]*r[j];\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%lf%lf%lf\u0026quot;,\u0026amp;r[i],\u0026amp;x[i],\u0026amp;y[i]);\rvector\u0026lt;pdi\u0026gt; vt; //存左右两边界 for(int i=0;i\u0026lt;n;i++)\r{\rvt.push_back(make_pair(x[i]-r[i],i));\rvt.push_back(make_pair(x[i]+r[i],i+n));\r}\rsort(vt.begin(),vt.end());\r//扫描\rset\u0026lt;pdi\u0026gt; outers; //set为了排序 vector\u0026lt;int\u0026gt; res; //存放结果 for(int i=0;i\u0026lt;vt.size();i++)\r{\rint id=vt[i].second%n;\rif(vt[i].second\u0026lt;n) //扫描到左 {\rset\u0026lt;pdi\u0026gt;::iterator it=outers.lower_bound(make_pair(y[id],id));\rif(it!=outers.end() \u0026amp;\u0026amp; inside(id,it-\u0026gt;second)) continue; //上面最近的圆 if(it!=outers.begin() \u0026amp;\u0026amp; inside(id,(--it)-\u0026gt;second)) continue; //下面最近的圆 res.push_back(id);\routers.insert(make_pair(y[id],id));\r}\relse //扫描到右 outers.erase(make_pair(y[id],id));\r} sort(res.begin(),res.end());\rcout\u0026lt;\u0026lt;res.size()\u0026lt;\u0026lt;endl;\rfor(int i=0;i\u0026lt;res.size();i++)\rprintf(\u0026quot;%d%c\u0026quot;,res[i]+1,i+1==res.size()? '\\n' : ' ');\rreturn 0;\r}\r ","id":10,"section":"posts","summary":"Coneology 题目链接 Time Limit: 5000MS Memory Limit: 65536K Description A student named Round Square loved to play with cones. He would arrange cones with different base radii arbitrarily on the floor and would admire the intrinsic beauty of the arrangement. The student even began theorizing about how some cones dominate other cones: a cone A dominates another cone B when cone B is completely within the cone","tags":["cpp","computational_geometry"],"title":"poj2932","uri":"https://dyhgo.github.io/2020/01/poj2932/","year":"2020"},{"content":"Jack Straws Time Limit: 1000MS\tMemory Limit: 10000K Description In the game of Jack Straws, a number of plastic or wooden \u0026ldquo;straws\u0026rdquo; are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws (as if they were dumped on a large piece of graph paper) and then will be asked if various pairs of straws are connected. Note that touching is connecting, but also two straws can be connected indirectly via other connected straws.\nInput Input consist multiple case,each case consists of multiple lines. The first line will be an integer n (1 \u0026lt; n \u0026lt; 13) giving the number of straws on the table. Each of the next n lines contain 4 positive integers,x1,y1,x2 and y2, giving the coordinates, (x1,y1),(x2,y2) of the endpoints of a single straw. All coordinates will be less than 100. (Note that the straws will be of varying lengths.) The first straw entered will be known as straw #1, the second as straw #2, and so on. The remaining lines of the current case(except for the final line) will each contain two positive integers, a and b, both between 1 and n, inclusive. You are to determine if straw a can be connected to straw b. When a = 0 = b, the current case is terminated.\nWhen n=0,the input is terminated.\nThere will be no illegal input and there are no zero-length straws.\nOutput You should generate a line of output for each line containing a pair a and b, except the final line where a = 0 = b. The line should say simply \u0026ldquo;CONNECTED\u0026rdquo;, if straw a is connected to straw b, or \u0026ldquo;NOT CONNECTED\u0026rdquo;, if straw a is not connected to straw b. For our purposes, a straw is considered connected to itself.\nSample Input 7 1 6 3 3 4 6 4 9 4 5 6 7 1 4 3 5 3 5 5 5 5 2 6 3 5 4 7 2 1 4 1 6 3 3 6 7 2 3 1 3 0 0\n2 0 2 0 0 0 0 0 1 1 1 2 2 1 2 0 0\n0\nSample Output CONNECTED NOT CONNECTED CONNECTED CONNECTED NOT CONNECTED CONNECTED CONNECTED CONNECTED CONNECTED\nSource East Central North America 1994\nSolution 题意：判断两条线段是否相交，对于N条线段，间接相交也算相交。对于每次询问，判 断给定的两条线段是否相交。\n这个题目分成两部分，一部分是基础的判断两条线段是否相交，用一个bool数组来存储信息。另一部分是判断间接相交，可以用floyd-warshall（比较巧妙）或者并查集.第一部分就是套模板。\n点可以用结构体存储（推荐），线段也可以用结构体存储或pair\n判断两条线段相交有多重模板，比如判是否平行、重合、求两条直线交点，判断交点是否在线段上，还有ccw（counter clock wise）函数，可参考discuss\n比较常见的是快速排斥和跨立检验\n以线段为对角线，作平行于x轴、y轴的射线，使之形成矩形，若两个矩形没有相交，则线段不相交（可以排除大部分）\n不满足快速排斥进入跨立检验,判断两个点是否在线段的两侧（即跨立），判断方法是外积的符号是否相反，等于0说明在线上\n如果两两互相跨立，则线段相交\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rbool con[15][15];\rint p,q;\rstruct point\r{\rdouble x,y;\r//point(double a,double b) : x(a),y(b) {} //!!!!!会发生编译错误 };\rpair\u0026lt;point,point\u0026gt; seg[15];\rdouble dir(point a,point b,point c) //用外积 {\rreturn (c.x-a.x)*(c.y-b.y) - (c.y-a.y)*(c.x-b.x); }\rbool judge(pair\u0026lt;point,point\u0026gt; p1,pair\u0026lt;point,point\u0026gt; p2)\r{\rpoint a,b,c,d;\ra=p1.first; b=p1.second;\rc=p2.first;\rd=p2.second;\r//快速排斥\rif(min(a.x,b.x)\u0026gt;max(c.x,d.x) or min(c.x,d.x)\u0026gt;max(a.x,b.x) or\rmin(a.y,b.y)\u0026gt;max(c.y,d.y) or min(c.y,d.y)\u0026gt;max(a.y,b.y))\rreturn false;\r//跨立检验 (int 可改成double)\relse\r{\rint d1,d2,d3,d4;\rd1=dir(a,b,c);\rd2=dir(a,b,d);\rd3=dir(c,d,a);\rd4=dir(c,d,b);\rreturn d1*d2\u0026lt;=0 and d3*d4\u0026lt;=0; //!!!\r}\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rwhile(scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)==1 and n!=0)\r{\rfor(int i=1;i\u0026lt;=n;i++) con[i][i]=true;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%lf%lf%lf%lf\u0026quot;,\u0026amp;seg[i].first.x,\u0026amp;seg[i].first.y,\u0026amp;seg[i].second.x,\u0026amp;seg[i].second.y);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=1;j\u0026lt;i;j++)\r{\rif(judge(seg[i],seg[j])) con[i][j]=con[j][i]=true;\relse con[i][j]=con[j][i]=false;\r}\rfor(int k=1;k\u0026lt;=n;k++) //Floyd-Warshall算法或并查集都可以 for(int i=1;i\u0026lt;=n;i++)\rfor(int j=1;j\u0026lt;=n;j++)\rcon[i][j] |= con[i][k] and con[k][j];\rwhile(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;p,\u0026amp;q)==2 and p!=0)\rputs(con[p][q] ? \u0026quot;CONNECTED\u0026quot; : \u0026quot;NOT CONNECTED\u0026quot;);\r}\rreturn 0;\r}\r 艰难的debug 计算几何有些很麻烦，代码太相似，debug比较难，有时还要考虑精度问题（即误差eps）\ndebug一个上午\n写完代码CE，seg[i].first.x错误，把stl_pair.h中的代码小改一下可以通过，但放到oj上肯定不行，怕污染代码还是不这样做。最后发现把构造函数去掉可以通过\n自测，最后一个样例没过，发现是边界情况，把跨立检验最后一步的等号加上\n自测，中间有一个样例没过，作图，把样例分离出来，过了。说明可能不是judge函数的问题。\n单测样例，没过，说明错误不是受别组影响\n编译器debug，把函数内的局部变量，变成全局变量，add watch\n发现d1 d2 d3 d4都等于0，a.x a.y b.x b.y \u0026hellip;.有问题\n继续add watch\n发现seg[1].first的内容就有问题，是double边界数，然后发现最终问题 %d 赋值给了double型变量\n总结 提高debug能力，少犯白痴错误。\n写代码要有清晰性和完整性，这样鲁棒性更强。\n","id":11,"section":"posts","summary":"Jack Straws Time Limit: 1000MS Memory Limit: 10000K Description In the game of Jack Straws, a number of plastic or wooden \u0026ldquo;straws\u0026rdquo; are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws","tags":["cpp","computational_geometry"],"title":"poj1127","uri":"https://dyhgo.github.io/2020/01/poj1127/","year":"2020"},{"content":"以这道题为例\n准备一个对拍的文件夹，里面装这些东西\nduipai_random_input_src.cpp是产生随机测试数据的代码\n#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;ctime\u0026gt;\rusing namespace std;\rint t=100; //数据组数\rint main()\r{\rsrand(time(0));\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rint a,b;\rwhile(t--)\r{\ra=rand();\rb=rand();\rif(a\u0026gt;b) swap(a,b);\rcout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}  将产生的随机测试数据写入duipai_random_input.txt中\nac代码或暴力搜索正确的代码\n//ac\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u0026lt;=50) return x;\rif(x\u0026gt;50 and x\u0026lt;=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u0026gt;0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_ac_output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rwhile(~scanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;t1,\u0026amp;t2)) {\rprintf(\u0026quot;input data are %lld %lld --- \u0026quot;,t1,t2);\rprintf(\u0026quot;%lld\\n\u0026quot;,fun(t2)-fun(t1-1));\r}\r//cout\u0026lt;\u0026lt;fun(180);\rreturn 0;\r}\r 从duipai_random_input.txt读入，写到duipai_ac_output.txt中\nwa代码\n//wa\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u0026lt;=50) return x;\rif(x\u0026gt;50 and x\u0026lt;=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u0026gt;0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_wa_output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rwhile(~scanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;t1,\u0026amp;t2)) {\rprintf(\u0026quot;input data are %lld %lld --- \u0026quot;,t1,t2);\rprintf(\u0026quot;%lld\\n\u0026quot;,fun(t2)-fun(t1)+1);\r}\r//cout\u0026lt;\u0026lt;fun(180);\rreturn 0;\r}\r 从duipai_random_input.txt读入，写到duipai_wa_output.txt中\n比较duipai_ac_output.txt 和 duipai_wa_output.txt\n在duipai文件夹下运行批处理命令（duipai.bat）\n@echo off\rfc duipai_ac_output.txt duipai_wa_outout.txt\rpause\r echo off是不回显，fc是文件比较\n运行cpp和bat程序\n得到结果\n过于复杂的输入数据和输出数据，简易对拍不好实现\n要产生大随机数，可以用\nlong long r=123456789;\rcout\u0026lt;\u0026lt;(long long)((double)(rand()*r)/RAND_MAX);\r 这题也可对拍\n","id":12,"section":"posts","summary":"以这道题为例 准备一个对拍的文件夹，里面装这些东西 duipai_random_input_src.cpp是产生随机测试数据的代码 #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; int","tags":["cpp"],"title":"简易对拍","uri":"https://dyhgo.github.io/2020/01/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/","year":"2020"},{"content":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数\n字，B的第一个数字是A的最后一个数字，个位数也算，输出满足条件的正整数对的个数\n 这种题感觉abc一贯的风格\n当时第一感觉是纯模拟肯定巨麻烦，就想着有没有规律，发现没有规律\n又想着按数位分类。\n按数位分类就要考虑对子里面的数位\n花了一些时间把它整理成元素都是9^n的矩阵（一个对称矩阵）\n然而并没有什么用，还是得求N-10^k这个剩余部分\n问题又回到起点\n试图从9^n求和中找规律，无果\n试图简化模拟或换个角度模拟，无果\n看了别人的解答，大同小异\n遍历一遍N，二维数组存N中第一个数字为 i ，最后一个数字为 j 的个数\n最后遍历ans+=c[i][j]*c[j][i]\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rlong long ans;\rlong long c[10][10];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++)\r{\rstring s=to_string(i);\rc[s[0]-'0'][s[s.length()-1]-'0']++;\r}\rfor(int i=0;i\u0026lt;10;i++)\rfor(int j=0;j\u0026lt;10;j++)\rans+=c[i][j]*c[j][i];\rcout\u0026lt;\u0026lt;ans;\rreturn 0; }\r 总结：我好弱啊\n","id":13,"section":"posts","summary":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数 字，B的第一个数字是A的最后一个数字，个位数也算，输","tags":["cpp"],"title":"abc152-D","uri":"https://dyhgo.github.io/2020/01/abc152-d/","year":"2020"},{"content":"Piggy-Bank Time Limit: 1000MS\tMemory Limit: 10000K 题目链接\nDescription Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.\nBut there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!\nInput The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 \u0026lt;= E \u0026lt;= F \u0026lt;= 10000. On the second line of each test case, there is an integer number N (1 \u0026lt;= N \u0026lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 \u0026lt;= P \u0026lt;= 50000, 1 \u0026lt;= W \u0026lt;=10000). P is the value of the coin in monetary units, W is it\u0026rsquo;s weight in grams.\nOutput Print exactly one line of output for each test case. The line must contain the sentence \u0026ldquo;The minimum amount of money in the piggy-bank is X.\u0026rdquo; where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line \u0026ldquo;This is impossible.\u0026quot;.\nSample Input 3 10 110 2 1 1 30 50 10 110 2 1 1 50 30 1 6 2 10 3 20 4\nSample Output The minimum amount of money in the piggy-bank is 60. The minimum amount of money in the piggy-bank is 100. This is impossible.\nSource Central Europe 1999\nSolution 题意：完全背包问题求最小价值\n时间复杂度O(nm)\n二维数组如下，MLE\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[505][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp[0],dp[0]+n*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=min(dp[i-1][j],dp[i][j-w[i]]+v[i]);\rif(dp[n][m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[n][m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r 改一维数组，AC\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp,dp+m+1,inf); //!!!!!\rdp[0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=w[i];j\u0026lt;=m;j++)\rdp[j]=min(dp[j],dp[j-w[i]]+v[i]);\rif(dp[m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r 这个地方要注意 fill 到 dp+m+1\n滚动数组好啊\nAC代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[2][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp[0],dp[0]+2*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i\u0026amp;1][j]=dp[(i-1)\u0026amp;1][j];\relse\rdp[i\u0026amp;1][j]=min(dp[(i-1)\u0026amp;1][j],dp[i\u0026amp;1][j-w[i]]+v[i]);\rif(dp[n\u0026amp;1][m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[n\u0026amp;1][m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r Summary 这种类型的dp有两个重点，初始化边界条件，找递推式\n求最小，一般初始化为inf，dp[0][0]=0;\n求最大，一般初始化为0\n必要时可用滚动数组\n完全背包递推式的证明（这里证明求最大值的情况）\ndp[i][j]=max{dp[i-1][j-k*w[i]]+k*v[i] | k\u0026gt;=0}\n=max(dp[i-1][j] , max{dp[i-1][j-k*w[i]]+k*v[i] | k\u0026gt;=1}\n=max(dp[i-1][j] , max{dp[i-1][(j-w[i])-k*w[i]]+k*v[i] | k\u0026gt;=0}+v[i])\n=max(dp[i-1][j] , dp[i][j-w[i]]+v[i])\n这种分离思想很常见\n","id":14,"section":"posts","summary":"Piggy-Bank Time Limit: 1000MS Memory Limit: 10000K 题目链接 Description Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is","tags":["cpp","dp"],"title":"poj1384","uri":"https://dyhgo.github.io/2020/01/poj1384/","year":"2020"},{"content":"Charm Bracelet Time Limit: 1000MS\tMemory Limit: 65536K Description Bessie has gone to the mall\u0026rsquo;s jewelry store and spies a charm bracelet. Of course, she\u0026rsquo;d like to fill it with the best charms possible from the N (1 ≤ N ≤ 3,402) available charms. Each charm i in the supplied list has a weight Wi (1 ≤ Wi ≤ 400), a \u0026lsquo;desirability\u0026rsquo; factor Di (1 ≤ Di ≤ 100), and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than M (1 ≤ M ≤ 12,880).\nGiven that weight limit as a constraint and a list of the charms with their weights and desirability rating, deduce the maximum possible sum of ratings.\nInput  Line 1: Two space-separated integers: N and M Lines 2..N+1: Line i+1 describes charm i with two space-separated integers: Wi and Di  Output  Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints  Sample Input 4 6 1 4 2 6 3 12 2 7\nSample Output 23\nSource USACO 2007 December Silver\nSolution 基础01背包问题\n如果用二维数组写的话就会MLE\n猜测测试数据可能不会满，就随着数据动态申请内存，想侥幸过（可以用new/delete 或 malloc/free）结果还是MLE\n这是MLE代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\r//int dp[3410][12885];\rint n,m;\r//int w[3410];\r//int v[3410];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rint **dp,*w,*v;\rdp=new int*[n+3];\rfor(int i=0;i\u0026lt;n+3;i++)\rdp[i]=new int[m+3];\rw=new int[n+3];\rv=new int[n+3];\rfor(int i=1;i\u0026lt;=n;i++)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\r}\r//initialized\rfor(int i=0;i\u0026lt;=n;i++)\rdp[i][0]=0;\rfor(int i=0;i\u0026lt;=m;i++)\rdp[0][i]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[n][m];\rdelete dp,w,v;\rreturn 0;\r}\r 在discuss找了一圈也没有二维数组过的\n优化成一维数组（节省内存，容易出bug）\nAC代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n,m;\rint dp[12885];\rint w[3410];\rint v[3410];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=m;j\u0026gt;=w[i];j--)\rdp[j]=max(dp[j],dp[j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[m];\rreturn 0;\r}\r 这个内层循环是递减的，如果是递增则解决完全背包问题\n由于01背包问题的dp[i]只依赖于dp[i-1]，内层循环递减时，dp[j]依赖的dp[j]为i-1的dp[j]\n由于原来在二维数组中就是递增的，是同一个i，所以内层循环递增时，dp[j]依赖的dp[j]为i的dp[j]，符合完全背包问题\n由于有两种状态（i和i-1），所以可利用奇偶性滚动数组实现\nAC代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n,m;\rint dp[2][12885];\rint w[3410];\rint v[3410];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i\u0026amp;1][j]=dp[(i-1)\u0026amp;1][j];\relse\rdp[i\u0026amp;1][j]=max(dp[(i-1)\u0026amp;1][j],dp[(i-1)\u0026amp;1][j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[n\u0026amp;1][m];\rreturn 0;\r}\r ","id":15,"section":"posts","summary":"Charm Bracelet Time Limit: 1000MS Memory Limit: 65536K Description Bessie has gone to the mall\u0026rsquo;s jewelry store and spies a charm bracelet. Of course, she\u0026rsquo;d like to fill it with the best charms possible from the N (1 ≤ N ≤ 3,402) available charms. Each charm i in the supplied list has a weight Wi (1 ≤ Wi ≤ 400), a \u0026lsquo;desirability\u0026rsquo; factor Di (1 ≤ Di ≤ 100), and","tags":["cpp","dp"],"title":"poj3624","uri":"https://dyhgo.github.io/2020/01/poj3624/","year":"2020"},{"content":"","id":16,"section":"posts","summary":"","tags":["cpp","sort"],"title":"排序算法的时间复杂度","uri":"https://dyhgo.github.io/2020/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","year":"2020"},{"content":"","id":17,"section":"posts","summary":"","tags":["cpp"],"title":"时间复杂度与计算时间的关系","uri":"https://dyhgo.github.io/2020/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","year":"2020"},{"content":"Saruman\u0026rsquo;s Army Time Limit: 1000MS\tMemory Limit: 65536K 题目链接\nDescription Saruman the White must lead his army along a straight path from Isengard to Helm’s Deep. To keep track of his forces, Saruman distributes seeing stones, known as palantirs, among the troops. Each palantir has a maximum effective range of R units, and must be carried by some troop in the army (i.e., palantirs are not allowed to “free float” in mid-air). Help Saruman take control of Middle Earth by determining the minimum number of palantirs needed for Saruman to ensure that each of his minions is within R units of some palantir.\nInput The input test file will contain multiple cases. Each test case begins with a single line containing an integer R, the maximum effective range of all palantirs (where 0 ≤ R ≤ 1000), and an integer n, the number of troops in Saruman’s army (where 1 ≤ n ≤ 1000). The next line contains n integers, indicating the positions x1, …, xn of each troop (where 0 ≤ xi ≤ 1000). The end-of-file is marked by a test case with R = n = −1.\nOutput For each test case, print a single integer indicating the minimum number of palantirs needed.\nSample Input 0 3 10 20 20 10 7 70 30 1 7 15 20 50 -1 -1\nSample Output 2 4\nHint In the first test case, Saruman may place a palantir at positions 10 and 20. Here, note that a single palantir with range 0 can cover both of the troops at position 20.\nIn the second test case, Saruman can place palantirs at position 7 (covering troops at 1, 7, and 15), position 20 (covering positions 20 and 30), position 50, and position 70. Here, note that palantirs must be distributed among troops and are not allowed to “free float.” Thus, Saruman cannot place a palantir at position 60 to cover the troops at positions 50 and 70.\nSource Stanford Local 2006\nSolution 题意：一条路上有n个路灯，每个路灯都能照亮左右的一段距离，问最少需要多少路灯才能使街道都亮着\ngreedy\n从最左开始向右延伸r，在r的范围内将最右的路灯点亮，此时这盏路灯将照亮左边和右边，从暗处的最左路灯开始，已知重复下去。 时间复杂度 O(n)!!!!需要将路灯位置排序\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint r,n;\rint x[1006];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rwhile(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;r,\u0026amp;n)==2 \u0026amp;\u0026amp; r!=-1)\r{\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x[i]);\rsort(x,x+n); // ！！！记得排序\rint j=0,ans=0;\rwhile(j\u0026lt;n)\r{\rint s=x[j++];\rwhile(j\u0026lt;n \u0026amp;\u0026amp; x[j]\u0026lt;=s+r) j++;\rint p=x[j-1];\rwhile(j\u0026lt;n \u0026amp;\u0026amp; p+r\u0026gt;=x[j]) j++;\rans++;\r} printf(\u0026quot;%d\\n\u0026quot;,ans);\r}\rreturn 0;\r}  ","id":18,"section":"posts","summary":"Saruman\u0026rsquo;s Army Time Limit: 1000MS Memory Limit: 65536K 题目链接 Description Saruman the White must lead his army along a straight path from Isengard to Helm’s Deep. To keep track of his forces, Saruman distributes seeing stones, known as palantirs, among the troops. Each palantir has a maximum effective range of R units, and must be carried by some troop in the army","tags":["cpp","greedy"],"title":"poj3069","uri":"https://dyhgo.github.io/2020/01/poj3069/","year":"2020"},{"content":"Best Cow Line Time Limit: 1000MS\tMemory Limit: 65536K 题目链接\nDescription FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual\u0026quot;Farmer of the Year\u0026rdquo; competition. In this contest every farmer arranges his cows in a line and herds them past the judges.\nThe contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows\u0026rsquo; names.\nFJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.\nFJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he\u0026rsquo;s finished, FJ takes his cows for registration in this new order.\nGiven the initial order of his cows, determine the least lexicographic string of initials he can make this way.\nInput  Line 1: A single integer: N Lines 2..N+1: Line i+1 contains a single initial (\u0026lsquo;A\u0026rsquo;..\u0026lsquo;Z\u0026rsquo;) of the cow in the ith position in the original line  Output The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (\u0026lsquo;A\u0026rsquo;..\u0026lsquo;Z\u0026rsquo;) in the new line.\nSample Input 6 A C D B C B\nSample Output ABCBCD\nSource USACO 2007 November Silver\nSolution 题意：给一个字符串s和空字符串p，每次进行以下操作之一 删除s的头部字符，加入到p的尾部 删除s的尾部字符，加入到p的尾部 最后s为空，p的字典序最小 greedy 时间复杂度最坏 O($n^2$)\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n;\rchar s[2005];\rint c=0;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rcin\u0026gt;\u0026gt;s[i];\r}\rint a=0,b=n-1;\rbool left=false;\rwhile(a\u0026lt;=b)\r{\rfor(int i=0;a+i\u0026lt;=b;i++)\r{\rif(s[a+i]\u0026lt;s[b-i])\r{\rleft=true;\rbreak;\r}\relse if(s[a+i]\u0026gt;s[b-i])\r{\rleft=false;\rbreak;\r}\r}\rif(left) putchar(s[a++]);\relse putchar(s[b--]);\rc++;\rif(c%80==0) putchar('\\n');\r}\rreturn 0;\r}\r ","id":19,"section":"posts","summary":"Best Cow Line Time Limit: 1000MS Memory Limit: 65536K 题目链接 Description FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual\u0026quot;Farmer of the Year\u0026rdquo; competition. In this contest every farmer arranges his cows in a line and herds them past the judges. The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in","tags":["cpp","greedy"],"title":"poj3617","uri":"https://dyhgo.github.io/2020/01/poj3617/","year":"2020"},{"content":"#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;set\u0026gt;\r//#include\u0026lt;map\u0026gt;\r//#include\u0026lt;string\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;iterator\u0026gt;\rusing namespace std;\rint main()\r{\rint a[]={3,2,1};\rint b[]={3,4,5,6};\rset\u0026lt;int\u0026gt; s1(a,a+3);\rset\u0026lt;int\u0026gt; s2(b,b+4);\rset\u0026lt;int\u0026gt; s3;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin()));\rfor(set\u0026lt;int\u0026gt;::iterator it=s3.begin();it!=s3.end();it++)\rcout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rcout\u0026lt;\u0026lt;endl;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot;*\u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rreturn 0;\r}\r ","id":20,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; #include\u0026lt;set\u0026gt; //#include\u0026lt;map\u0026gt; //#include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;iterator\u0026gt; using namespace std; int main() { int a[]={3,2,1}; int b[]={3,4,5,6}; set\u0026lt;int\u0026gt; s1(a,a+3); set\u0026lt;int\u0026gt; s2(b,b+4); set\u0026lt;int\u0026gt; s3; set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin())); for(set\u0026lt;int\u0026gt;::iterator it=s3.begin();it!=s3.end();it++) cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl; set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot;*\u0026quot;)); cout\u0026lt;\u0026lt;endl; set_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); cout\u0026lt;\u0026lt;endl; set_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); cout\u0026lt;\u0026lt;endl; set_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); return 0; }","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"https://dyhgo.github.io/2020/01/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/","year":"2020"},{"content":"#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include \u0026lt;limits\u0026gt;\rusing namespace std;\rint main()\r{\rcout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;bool: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(bool);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;char: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;signed char: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(signed char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;signed char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;signed char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned char: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;wchar_t: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(wchar_t);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;wchar_t\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;wchar_t\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;short: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(short);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;short\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;short\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;int: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(int);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;int\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;int\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;long: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(long);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned long: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned long);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned long\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned long\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;double: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(double);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;double\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;double\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;long double: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(long double);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long double\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long double\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;float: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(float);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;float\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;float\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;size_t: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(size_t);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;size_t\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;size_t\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;string: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(string) \u0026lt;\u0026lt; endl;\r// \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;string\u0026gt;::max)() \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;string\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl;\rreturn 0;\r}\r ","id":21,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include \u0026lt;limits\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;bool: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(bool); cout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::max)(); cout \u0026lt;\u0026lt; \u0026quo","tags":["cpp"],"title":"c++每种类型的值域","uri":"https://dyhgo.github.io/2020/01/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/","year":"2020"},{"content":"#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main()\r{\rint a,b,x,y;\ra=60;\rb=22;\rcout\u0026lt;\u0026lt;ex_gcd(a,b,x,y)\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":22,"section":"posts","summary":"#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main()\r{\rint a,b,x,y;\ra=60;\rb=22;\rcout\u0026lt;\u0026lt;ex_gcd(a,b,x,y)\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"https://dyhgo.github.io/2020/01/extended-euclidean-algorithm/","year":"2020"},{"content":"//O(FE) /* input 5 7\r1 3 6\r3 5 8\r2 5 5\r3 2 3\r1 2 6\r4 1 10\r4 2 2\r4 5\routput\r11\r*/\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define maxv 100\r#define inf 0x3f3f3f3f\rint v,e;\rint s,t;\rstruct edge{int to,cap,rev;\r};\rvector\u0026lt;edge\u0026gt; G[maxv];\rbool used[maxv];\rvoid add_edge(int from ,int to,int cap)\r{\rG[from].push_back((edge){to,cap,G[to].size()});\rG[to].push_back((edge){from,0,G[from].size()-1});\r}\rint dfs(int s,int t,int f)\r{\rif(s==t) return f;\rused[s]=true;\rfor(int i=0;i\u0026lt;G[s].size();i++)\r{\redge \u0026amp;e =G[s][i];\rif(!used[e.to] \u0026amp;\u0026amp; e.cap\u0026gt;0)\r{\rint d=dfs(e.to,t,min(f,e.cap));\rif(d\u0026gt;0)\r{\re.cap-=d;\rG[e.to][e.rev].cap+=d;\rreturn d;\r}\r}\r}\rreturn 0;\r}\rint max_flow(int s,int t)\r{\rint flow=0;\rfor(;;)\r{\rmemset(used,0,sizeof(used));\rint f=dfs(s,t,inf);\rif(f==0) return flow;\rflow+=f;\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;e;\rfor(int i=0;i\u0026lt;e;i++)\r{\rint from,to,cap;\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;from,\u0026amp;to,\u0026amp;cap);\radd_edge(from,to,cap);\r}\rcin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;\rcout\u0026lt;\u0026lt;max_flow(s,t);\rreturn 0;\r}\r ","id":23,"section":"posts","summary":"//O(FE) /* input 5 7\r1 3 6\r3 5 8\r2 5 5\r3 2 3\r1 2 6\r4 1 10\r4 2 2\r4 5\routput\r11\r*/\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define maxv 100\r#define inf 0x3f3f3f3f\rint v,e;\rint s,t;\rstruct edge{int to,cap,rev;\r};\rvector\u0026lt;edge\u0026gt; G[maxv];\rbool used[maxv];\rvoid add_edge(int from ,int to,int cap)\r{\rG[from].push_back((edge){to,cap,G[to].size()});\rG[to].push_back((edge){from,0,G[from].size()-1});\r}\rint dfs(int s,int t,int f)\r{\rif(s==t) return f;\rused[s]=true;\rfor(int i=0;i\u0026lt;G[s].","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"https://dyhgo.github.io/2020/01/ford-fulkerson-algorithm/","year":"2020"},{"content":"迷宫问题 Time Limit: 1000MS\tMemory Limit: 65536K\nDescription 定义一个二维数组：\nint maze[5][5] = {\n0, 1, 0, 0, 0,\r0, 1, 0, 1, 0,\r0, 0, 0, 0, 0,\r0, 1, 1, 1, 0,\r0, 0, 0, 1, 0,\r };\n它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。\nInput 一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。\nOutput 左上角到右下角的最短路径，格式如样例所示。\nSample Input 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0\nSample Output (0, 0) (1, 0) (2, 0) (2, 1) (2, 2) (2, 3) (2, 4) (3, 4) (4, 4)\nSolution dfs/bfs都行 基础bfs （这个测试点只有一个，就是样例） 时间复杂度O(mn)\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;map\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;queue\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n,m;\rint maze[7][7];\rint d[7][7];\rconst int inf=0x3f3f3f3f;\rtypedef pair\u0026lt;int,int\u0026gt; pii; //表示坐标 int sx,sy,gx,gy; //起点终点 int dx[]={0,0,1,-1};\rint dy[]={1,-1,0,0};\rmap\u0026lt;pii,pii \u0026gt; mp; //记录前驱节点,目的是记录路径 （如果记录路径就可以不用求最短距离） vector\u0026lt;pii \u0026gt; vt; //记录路径 void bfs()\r{\rqueue\u0026lt;pii\u0026gt; q;\rfill(d[0],d[0]+7*7,inf);\rq.push(pii(sx,sy));\rd[sx][sy]=0;\rwhile(q.size())\r{\rpii p=q.front();\rq.pop();\rif(p.first==gx and p.second==gy) break; //很重要的终止判断条件\rfor(int i=0;i\u0026lt;4;i++)\r{\rint nx=p.first+dx[i],ny=p.second+dy[i];\rif(nx\u0026gt;=0 and ny\u0026gt;=0 and nx\u0026lt;n and ny\u0026lt;m and maze[nx][ny]==0 and d[nx][ny]==inf) //inf的判断很重要\r{\rq.push(pii(nx,ny));\rd[nx][ny]=d[p.first][p.second]+1;\rmp[pii(nx,ny)]=pii(p.first,p.second);\r} } }\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rn=5;\rm=5;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\rcin\u0026gt;\u0026gt;maze[i][j];\rsx=0,sy=0,gx=4,gy=4;\rbfs();\r//cout\u0026lt;\u0026lt;d[gx][gy]\u0026lt;\u0026lt;endl;\rpii p;\rp=pii(gx,gy);\rwhile(p!=pii(sx,sy))\r{\rvt.push_back(p);\rp=mp[p];\r}\rreverse(vt.begin(),vt.end());\rprintf(\u0026quot;(%d, %d)\\n\u0026quot;,sx,sy);\rfor(vector\u0026lt;pii\u0026gt;::iterator it=vt.begin();it!=vt.end();it++)\r{\rprintf(\u0026quot;(%d, %d)\\n\u0026quot;,it-\u0026gt;first,it-\u0026gt;second);\r}\rreturn 0;\r}\r Sumamry 一个经典的bfs模板就是用队列来控制广度优先\n","id":24,"section":"posts","summary":"迷宫问题 Time Limit: 1000MS Memory Limit: 65536K Description 定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的1表示墙壁，0表示","tags":["cpp","bfs"],"title":"poj3984","uri":"https://dyhgo.github.io/2020/01/poj3984/","year":"2020"},{"content":"从学习方法和代码实现debug花了挺长时间。。。\n这个算法是从字符串s中找子串p出现的第一个位置\n以下是两个常见的字符串匹配算法（还有其他更高效的比如Turbo-bm算法，sunday算法）\nkmp算法和bm算法\n时间复杂度是O(s+p)\nbm算法总体比kmp算法要快3倍\n当然也可以直接用函数，比如 s.find( p );\n//懒得写更多，懒得修饰代码\nplus:字符串的读入常常会出现读空格、读回车等奇妙现象\nkmp算法 //kmp without optimization\r//strncpy() memmove()\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint kmp(char s[],char p[])\r{\r//preprocess\rint sl=strlen(s);\rint pl=strlen(p);\rchar subp[pl+1][pl+1];\rint next[pl+1];\rfor(int k=0;k\u0026lt;pl;k++)\r{\rstrncpy(subp[k],p,k+1);\r}\r//can optimized\rfor(int k=0;k\u0026lt;pl;k++)\r{\rstring tl;\rstring tr;\rint len_sub=k+1;\rint len=0;\rfor(int m=len_sub-1;m\u0026gt;0;m--)\r{\rtl=string(subp[k],subp[k]+m);\rtr=string(subp[k]+len_sub-m,subp[k]+len_sub);\rif(tl==tr)\r{\rlen=m;\rbreak;\r}\r}\rnext[k]=len;\r}\rfor(int k=pl-1;k\u0026gt;0;k--)\r{\rnext[k]=next[k-1];\r}\rnext[0]=-1;\r//match\rint i=0;int j=0;\rwhile(1)\r{\rif(s[i]==p[j])\r{\ri++;\rj++;\r}\relse\r{\rint t=next[j];\rif(t==-1)\r{\ri++;\rj=0;\r}\relse\r{\rj=t;\r}\r}\rif(j\u0026gt;=pl)\r{\rreturn i-pl;\r}\rif(i\u0026gt;=sl)\r{\rreturn -1;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rchar a[100];\rchar b[100];\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;kmp(a,b);\rreturn 0;\r}\r bm算法 //bm algorithm three to five times faster than kmp in genneral\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include\u0026lt;vector\u0026gt;\rusing namespace std;\rint get_badc(char t,char a[])\r{\rint k=strlen(a)-1;\rwhile(1)\r{\rif(k\u0026gt;=0) //assert\r{\rif(a[k--]==t)\r{\rreturn k+1;\r}\r}\relse return -1;\r}\r}\rint get_goods(vector\u0026lt;char\u0026gt; t,char a[]) //most difficult\r{\rint k=strlen(a)-1;\rvector\u0026lt;char\u0026gt; temp;\rint max_len=0;\rint m=0;\rint loc=-1;\rwhile(1)\r{ if(k\u0026gt;=0) //assert\r{\rif(t[m]==a[k])\r{\rtemp.push_back(a[k]);\rm++;\rk--;\r}\relse\r{\rm=0;\rk--;\rif(temp.size()\u0026gt;max_len)\r{\rmax_len=temp.size();\rloc=k+1;\rtemp.clear();\r}\r}\r}\relse return loc;\r}\r}\rint bm(char s[],char p[])\r{\rint sl=strlen(s);\rint pl=strlen(p);\rint i=pl-1;\rint j=pl-1;\rwhile(1)\r{\rif(i\u0026lt;sl and j\u0026gt;=0) //asseert // i\u0026lt;sl !!!!!!!!!! not i\u0026gt;0\r{\rif(s[i]==p[j])\r{\rvector\u0026lt;char\u0026gt; goods;\rgoods.push_back(s[i]);\rwhile(1)\r{\ri--;\rj--;\rif(i\u0026gt;=0 and j\u0026gt;=0) //assert\r{\rif(s[i]!=p[j])\r{\rchar badc1=s[i];\rstring str(p,p+pl-goods.size());\rint loc1=get_badc(badc1,\u0026amp;str[0]);\rint loc2=get_goods(goods,\u0026amp;str[0]);\rif(loc1==-1 and loc2!=-1)\r{\ri+=pl-1-loc2;\rj=pl-1;\r}\relse if(loc2==-1 and loc1!=-1)\r{\ri+=pl-1-loc1;\rj=pl-1;\r}\relse\r{\ri+=pl-1-min(loc1,loc2);\rj=pl-1;\r}\r}\relse\r{\rgoods.push_back(s[i]); //still add in good-suffix\r}\r}\relse break;\r}\r}\relse //only have bad-character\r{\rchar badc2=s[i];\rint loc=get_badc(badc2,p);\ri+=pl-1-loc;\rj=pl-1;\r}\r}\relse if(i\u0026gt;=sl) return -1; //!!!!!!!!!!!!!\relse return i+1; //!!!!!!!!!!!!\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rchar a[100];\rchar b[100];\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;a;\rcout\u0026lt;\u0026lt;bm(b,a)\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":25,"section":"posts","summary":"从学习方法和代码实现debug花了挺长时间。。。 这个算法是从字符串s中找子串p出现的第一个位置 以下是两个常见的字符串匹配算法（还有其他更高效","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"https://dyhgo.github.io/2020/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/","year":"2020"},{"content":"很早以前写的懒得去审查。。。\n不知道对不对。。。\nEprime\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define MAX 10000\rlong long prime1[MAX],num1;\rlong long prime2[MAX],num2;\rbool isprime1[MAX],isprime2[MAX];\rint qprime1(int n)\r{\rnum1=0;\rmemset(isprime1,1,sizeof(isprime1));\risprime1[0]=isprime1[1]=0;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rif(isprime1[i])\r{\rprime1[num1++]=i;\rfor(int j=2;j*i\u0026lt;=n;j++)\risprime1[j*i]=0;\r}\r}\rreturn num1;\r}\rint qprime2(int m,int n)\r{\rnum2=0;\rqprime1((int)sqrt(n));\rmemset(isprime2,1,sizeof(isprime2));\rfor(int i=0;i\u0026lt;num1;i++)\r{\rfor(int j=m/prime1[i];j*prime1[i]\u0026lt;=n;j++)\r{\risprime2[j*prime1[i]]=0;\r}\r}\rfor(int i=m;i\u0026lt;=n;i++)\rif(isprime2[i]) num2++;\rreturn num2;\r} int main()\r{\rcout\u0026lt;\u0026lt;qprime2(10,100);\rreturn 0;\r}\r ","id":26,"section":"posts","summary":"很早以前写的懒得去审查。。。 不知道对不对。。。 Eprime #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define MAX 10000 long long prime1[MAX],num1; long long prime2[MAX],num2; bool isprime1[MAX],isprime2[MAX]; int qprime1(int n) { num1=0; memset(isprime1,1,sizeof(isprime1)); isprime1[0]=isprime1[1]=0; for(int i=2;i\u0026lt;=n;i++) { if(isprime1[i]) { prime1[num1++]=i; for(int j=2;j*i\u0026lt;=n;j++) isprime1[j*i]=0; } } return num1; } int qprime2(int m,int n) { num2=0; qprime1((int)sqrt(n)); memset(isprime2,1,sizeof(isprime2)); for(int i=0;i\u0026lt;num1;i++)","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"https://dyhgo.github.io/2020/01/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/","year":"2020"},{"content":"Lake Counting http://poj.org/problem?id=2386\nTime Limit: 1000MS\tMemory Limit: 65536K Description Due to recent rains, water has pooled in various places in Farmer John\u0026rsquo;s field, which is represented by a rectangle of N x M (1 \u0026lt;= N \u0026lt;= 100; 1 \u0026lt;= M \u0026lt;= 100) squares. Each square contains either water (\u0026lsquo;W\u0026rsquo;) or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.\nGiven a diagram of Farmer John\u0026rsquo;s field, determine how many ponds he has. Input\n  Line 1: Two space-separated integers: N and M\n  Lines 2..N+1: M characters per line representing one row of Farmer John\u0026rsquo;s field. Each character is either \u0026lsquo;W\u0026rsquo; or \u0026lsquo;.'. The characters do not have spaces between them. Output\n  Line 1: The number of ponds in Farmer John\u0026rsquo;s field.\n  Sample Input 10 12 W\u0026hellip;\u0026hellip;..WW. .WWW\u0026hellip;..WWW \u0026hellip;.WW\u0026hellip;WW. \u0026hellip;\u0026hellip;\u0026hellip;WW. \u0026hellip;\u0026hellip;\u0026hellip;W.. ..W\u0026hellip;\u0026hellip;W.. .W.W\u0026hellip;..WW. W.W.W\u0026hellip;..W. .W.W\u0026hellip;\u0026hellip;W. ..W\u0026hellip;\u0026hellip;.W.\nSample Output 3\nHint OUTPUT DETAILS:\nThere are three ponds: one in the upper left, one in the lower left,and one along the right side.\nSource USACO 2004 November\nSolution bfs dfs都行 基础dfs 时间复杂度 O(mn)\n//dfs\r#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rchar field[105][105];\rint n,m;\rvoid dfs(int x,int y)\r{\rfield[x][y]='.';\rfor(int dx=-1;dx\u0026lt;=1;dx++)\rfor(int dy=-1;dy\u0026lt;=1;dy++)\r{\rint nx=x+dx,ny=y+dy;\rif(0\u0026lt;=nx \u0026amp;\u0026amp; nx\u0026lt;n \u0026amp;\u0026amp; 0\u0026lt;=ny \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; field[nx][ny]=='W')\rdfs(nx,ny);\r}\rreturn ;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\r{\rcin\u0026gt;\u0026gt;field[i][j];\r}\rint res=0;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\r{\rif(field[i][j]=='W') {\rdfs(i,j);\rres++;\r}\r}\rcout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r Summary 经典dfs就是递归思想 如果图外面是可达且连通的，就在图外面加一圈\n","id":27,"section":"posts","summary":"Lake Counting http://poj.org/problem?id=2386 Time Limit: 1000MS Memory Limit: 65536K Description Due to recent rains, water has pooled in various places in Farmer John\u0026rsquo;s field, which is represented by a rectangle of N x M (1 \u0026lt;= N \u0026lt;= 100; 1 \u0026lt;= M \u0026lt;= 100) squares. Each square contains either water (\u0026lsquo;W\u0026rsquo;) or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field.","tags":["cpp","dfs"],"title":"poj2386","uri":"https://dyhgo.github.io/2020/01/poj2386/","year":"2020"},{"content":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291\n1.用scanf,printf代替cin,cout 2.取消同步和绑定 ios::sync_with_stdio(false);\rcin.tie(0);\r//cout.tie(0);\r 此时只能用cin,cout\n3.对整型输入输出，将每个数字变成字符 inline int read()\r{\rint x=0;int f=1;char s=getchar();\rwhile(s\u0026lt;'0' or s\u0026gt;'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u0026gt;='0' and s\u0026lt;='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rvoid write(int x)\r{\rif(x/10\u0026gt;0) write(x/10);\rputchar(char(x%10+'0'));\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint n=read();\rcout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;\rwrite(200);\rreturn 0;\r}  ","id":28,"section":"posts","summary":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291 1.用sca","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"https://dyhgo.github.io/2020/01/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/","year":"2020"}],"tags":[{"title":"bfs","uri":"https://dyhgo.github.io/tags/bfs/"},{"title":"binary","uri":"https://dyhgo.github.io/tags/binary/"},{"title":"binary_search","uri":"https://dyhgo.github.io/tags/binary_search/"},{"title":"computational_geometry","uri":"https://dyhgo.github.io/tags/computational_geometry/"},{"title":"cpp","uri":"https://dyhgo.github.io/tags/cpp/"},{"title":"dfs","uri":"https://dyhgo.github.io/tags/dfs/"},{"title":"dp","uri":"https://dyhgo.github.io/tags/dp/"},{"title":"graph_theory","uri":"https://dyhgo.github.io/tags/graph_theory/"},{"title":"greedy","uri":"https://dyhgo.github.io/tags/greedy/"},{"title":"hugo","uri":"https://dyhgo.github.io/tags/hugo/"},{"title":"number_theory","uri":"https://dyhgo.github.io/tags/number_theory/"},{"title":"search","uri":"https://dyhgo.github.io/tags/search/"},{"title":"segment_tree","uri":"https://dyhgo.github.io/tags/segment_tree/"},{"title":"sort","uri":"https://dyhgo.github.io/tags/sort/"},{"title":"string","uri":"https://dyhgo.github.io/tags/string/"},{"title":"test","uri":"https://dyhgo.github.io/tags/test/"},{"title":"union_find","uri":"https://dyhgo.github.io/tags/union_find/"}]}
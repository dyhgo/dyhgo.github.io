{"categories":[{"title":"abc","uri":"https://dyhgo.github.io/categories/abc/"},{"title":"algorithm","uri":"https://dyhgo.github.io/categories/algorithm/"},{"title":"android","uri":"https://dyhgo.github.io/categories/android/"},{"title":"anime","uri":"https://dyhgo.github.io/categories/anime/"},{"title":"codeforces","uri":"https://dyhgo.github.io/categories/codeforces/"},{"title":"GAME","uri":"https://dyhgo.github.io/categories/game/"},{"title":"hduoj","uri":"https://dyhgo.github.io/categories/hduoj/"},{"title":"note","uri":"https://dyhgo.github.io/categories/note/"},{"title":"nowcoder","uri":"https://dyhgo.github.io/categories/nowcoder/"},{"title":"poj","uri":"https://dyhgo.github.io/categories/poj/"},{"title":"test","uri":"https://dyhgo.github.io/categories/test/"}],"posts":[{"content":"A. Exercising Walk 题意 给一坐标范围，初始位置，和左右上下移动的步数，问是否会出界\n题解 加各种条件判断即可\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rint a,b,c,d,x,y,x1,y1,x2,y2;\rbool ok;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rok=true;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y2;\rif( (a-b\u0026gt;=0 and x-x1\u0026lt;a-b) or (b-a\u0026gt;0 and x2-x\u0026lt;b-a) or (c-d\u0026gt;0 and y-y1\u0026lt;c-d) or (d-c\u0026gt;0 and y2-y\u0026lt;d-c) or (a==b and a!=0 and x1==x and x2==x) or (c==d and c!=0 and y1==y and y2==y) )\rok = false;\rif(ok) puts(\u0026quot;yes\u0026quot;); else puts(\u0026quot;no\u0026quot;);\r}\rreturn 0;\r}\r B. Composite Coloring 题意 给n个合数上色，要求相同颜色的数字必须不互质，求最小着色数和着色方案\n（题目保证着色数不大于11，且值不大于1000）\n题解 两个合数不互质，即最小质因子相同\n对每个数求最小质因子\n相同则染同一种颜色（贪心）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,n;\rint a[1005];\rint c[1005];\rint p[]={1,2,3,5,7,11,13,17,19,23,29,31};\rset\u0026lt;int\u0026gt; st;\rbool vi[1005];\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n;\r//reset\rmemset(c,0,sizeof(c));\rst.clear();\rmemset(vi,0,sizeof(vi));\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i];\rfor(int i=0;i\u0026lt;n;i++){\rfor(int j=1;j\u0026lt;=12;j++){\rif(a[i]%p[j]==0){\rc[i]=j;\rst.insert(j);\rbreak;\r}\r}\r}\rint num=st.size();\rint index=0;\rint cnt;\rfor(int i=0;i\u0026lt;n;i++){\rif(!vi[i]){\rcnt=c[i];\rvi[i]=true;\rindex++;\rc[i]=index;\rfor(int j=i+1;j\u0026lt;n;j++){\rif(!vi[j] and c[j]==cnt){\rc[j]=index;\rvi[j]=true;\r}\r}\r}\r}\rcout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C. K-Complete Word 题意 给一字符串和k，要求改其中一些字符，使字符串是回文串且周期为k，求最小改\n动数\n题解 把字符串分成k个部分，每个部分都是回文串\n字符串中的一些字符是相互捆绑的（即要相同），与其他字符相互独立\n对于相互捆绑的字符，查询出现次数最多的字符，然后都替换成它\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,n,k;\rstring s;\rint kp;\rint z[27];\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rcin\u0026gt;\u0026gt;s;\r//reset\r//memset(z,0,sizeof(z));\rkp=0;\rfor(int i=0;i\u0026lt;=k-i-1;i++){\rmemset(z,0,sizeof(z));\rfor(int j=i;j\u0026lt;n;j+=k){\rz[s[j]-'a']++;\r}\rif(i\u0026lt;k-i-1)\r{\rfor(int j=k-i-1;j\u0026lt;n;j+=k){\rz[s[j]-'a']++;\r}\r}\rkp+=*max_element(z,z+27);\r//cout\u0026lt;\u0026lt;*max_element(z,z+27)\u0026lt;\u0026lt;endl;\r}\rcout\u0026lt;\u0026lt;n-kp\u0026lt;\u0026lt;endl;\r}\r}\r D. Walk on Matrix 题意 给一矩阵，从矩阵的左上角走到右下角，只能往右和往下走\n走到一个元素上，则自身的值变为当前自身的值\u0026amp;元素上的值\n存在一种走法使得最后得到的值最大\n给一dp算法和k，求满足经dp算法算出的值和最大值差k的矩阵\n题解 构造矩阵\n让最大值为k\n经dp算法输出的值为0\n根据(m+k)\u0026amp;k=k , (m+k)\u0026amp;m=m , m\u0026amp;k=0\n其中m的二进制位1000\u0026hellip;\n进行构造（不唯一）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint m=(1\u0026lt;\u0026lt;17);\rint k;\rint main(){\rcin\u0026gt;\u0026gt;k;\rcout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;m+k\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;m+k\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E. Height All the Same 题意 给一n*m的网格，和L，R\n在网格上进行初始化放方块，要求每一格的方块数在L到R之间\n有两种操作\n1.在两（边相邻）相邻网格上各增加一块\n2.在一个网格上增加两块\n求能够使所有网格高度相等的初始化方案数\n题解 dif=R-L+1\n当网格数量为奇数时，随便放，有dif^(n*m)种\n当网格数量为偶数时，如果dif为偶数，则有一半情况不满足（每个满足的都对应\n一个不满足的），有dif^(n*m)/2\n当dif为奇数时，则中间会多出一个没有对应的方案，有(dif^(n*m)+1)/2\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rconst ll mod = 998244353;\rll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rll n,m,l,r;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\rll ans;\rll dif=r-l+1;\rif((n*m)\u0026amp;1) ans=qpow(dif,n*m)%mod;\relse if(dif%2==0) {\rans=qpow(dif,n*m)%mod*qpow(2,mod-2)%mod;\r}\relse{\rans=(qpow(dif,n*m)+1)%mod*qpow(2,mod-2)%mod;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\r ","id":0,"section":"posts","summary":"A. Exercising Walk 题意 给一坐标范围，初始位置，和左右上下移动的步数，问是否会出界 题解 加各种条件判断即可 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t; int a,b,c,d,x,y,x1,y1,x2,y2; bool ok; int main(){ //freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin); cin\u0026gt;\u0026gt;t; while(t--){ ok=true; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y2; if( (a-b\u0026gt;=0 and x-x1\u0026lt;a-b)","tags":["cpp","number_theory","string","binary","construct"],"title":"Codeforces Round 630 (Div. 2) A~E","uri":"https://dyhgo.github.io/2020/04/codeforces-round-630-div.-2-a~e/","year":"2020"},{"content":"Popular Cows Description Every cow\u0026rsquo;s dream is to become the most popular cow in the herd. In a herd of N (1 \u0026lt;= N \u0026lt;= 10,000) cows, you are given up to M (1 \u0026lt;= M \u0026lt;= 50,000) ordered pairs of the form (A, B) that tell you that cow A thinks that cow B is popular. Since popularity is transitive, if A thinks B is popular and B thinks C is popular, then A will also think that C is popular, even if this is not explicitly specified by an ordered pair in the input. Your task is to compute the number of cows that are considered popular by every other cow.\nInput   Line 1: Two space-separated integers, N and M\n  Lines 2..1+M: Two space-separated numbers A and B, meaning that A thinks B is popular.\n  Output  Line 1: A single integer that is the number of cows who are considered popular by every other cow.  Sample Input 3 3 1 2 2 1 2 3\nSample Output 1\nHint Cow 3 is the only cow of high popularity.\nSource USACO 2003 Fall\nSolution 如果一头牛被其他所有牛认为是红牛，那么和它在同一个强连通分量的所有牛都\n是红牛，所以scc分解，拓扑序最后一个强连通分量是红牛群，最后检查这个连通\n块中的一头红牛是否对所有牛可达\nac代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;cstring\u0026gt;\rusing namespace std;\rint V,m;\rint t1,t2; #define maxv 10005 vector\u0026lt;int\u0026gt; G[maxv]; vector\u0026lt;int\u0026gt; rG[maxv];\rvector\u0026lt;int\u0026gt; vs; bool used[maxv]; int cmp[maxv]; void add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(int i=0;i\u0026lt;rG[v].size();i++){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u0026lt;V;i++) if(!used[i]) dfs(i);\rmemset(used,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u0026gt;=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\rint main(){\rcin\u0026gt;\u0026gt;V\u0026gt;\u0026gt;m;\rwhile(m--){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\radd_edge(t1-1,t2-1);\r}\rint k=kosaraju_scc();\rint u=0,num=0; //备选个数 u取得正序最后一个 for(int i=0;i\u0026lt;V;i++){\rif(cmp[i]==k-1){\ru=i;\rnum++;\r}\r}\rmemset(used,0,sizeof(used));\rrdfs(u,0); //反向判断是否都可达\rfor(int i=0;i\u0026lt;V;i++){\rif(!used[i]){\rnum=0;\rbreak;\r}\r} cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":1,"section":"posts","summary":"Popular Cows Description Every cow\u0026rsquo;s dream is to become the most popular cow in the herd. In a herd of N (1 \u0026lt;= N \u0026lt;= 10,000) cows, you are given up to M (1 \u0026lt;= M \u0026lt;= 50,000) ordered pairs of the form (A, B) that tell you that cow A thinks that cow B is popular. Since popularity is transitive, if A thinks B is popular and B thinks","tags":["cpp","graph_theory","scc"],"title":"poj2816","uri":"https://dyhgo.github.io/2020/03/poj2816/","year":"2020"},{"content":"A - Coffee 题意 判断一个长度为6的字符串，第3位和第4位是否相等，第5位和第6位是否相等\n题解 模拟\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rstring s;\rcin\u0026gt;\u0026gt;s;\rif(s[2]==s[3] and s[4]==s[5]) cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;;\relse cout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;;\rreturn 0;\r}\r B - Golden Coins 题意 高桥有许多钱，可以兑换成各种硬币，每获得一枚500円的硬币，就能获得1000\n点快乐值，每获得一枚5円的硬币，就能获得5点快乐值，问最多能获得多少快乐\n值\n题解 贪心地兑换成500円的硬币，然后再兑换成5円的\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll x;\rll ans=0;\rint main(){\rcin\u0026gt;\u0026gt;x;\rans+=x/500;\rans*=1000;\rx%=500;\rans+=(x/5)*5;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Traveling Salesman around Lake 题意 在一个圆上有n个点，给定每个点的位置，问沿圆周访问所有点的最短长度\n题解 访问所有点的路径就是圆周长减去一段隔阂\n求隔阂的最大值，依次遍历即可\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,k;\rint dist[200005];\rint c;\rint ans=-1;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;k\u0026gt;\u0026gt;n;\rc=k;\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;dist[i];\rsort(dist+1,dist+n+1);\rfor(int i=1;i\u0026lt;=n-1;i++){\rans=max(ans,dist[i+1]-dist[i]);\r}\rans=max(ans,c-dist[n]+dist[1]); //n是double不能当作index cout\u0026lt;\u0026lt;c-ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Line++ 题意 有n个点，依次连线，再把其中两个未连线的点连线\n求最短路径长度等于k的路径条数（对于所有的k=1,2,3..）\n题解 看似是图论题，其实只需要考虑两种情况\n枚举所有点对的最短距离\n1.直接按顺序走\n2.走过特殊的连线\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,x,y;\rmap\u0026lt;int,int\u0026gt; mp;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y;\rfor(int i=1;i\u0026lt;=n;i++) for(int j=i+1;j\u0026lt;=n;j++)\rmp[min(j-i,abs(i-x)+abs(j-y)+1)]++;\rfor(int i=1;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;mp[i]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Red and Green Apples 题意 DIO有a个红苹果（X）红面包（√）和b片绿面包，c片白面包\n每片面包都有时停时间，聪明的DIO可以将白面包涂成红色或者绿色\n现在DIO要吃x片红面包和y片绿面包（！DIO居然记得吃几片面包）\nDIO的最终目的就是无限时停，问DIO最多能时停几秒\n题解 贪心地选取时停时间最多的面包\n但是有限制条件就是x和y（白色是不受限制的）\n所以从红色中选前x个，绿色中选前y个，与白色混合排序\n最后选前x+y个\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll x,y,aa,bb,cc;\rvector\u0026lt;ll\u0026gt; a,b,c;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;aa\u0026gt;\u0026gt;bb\u0026gt;\u0026gt;cc;\rll temp;\rfor(ll i=0;i\u0026lt;aa;i++) {\rcin\u0026gt;\u0026gt;temp;\ra.push_back(temp);\r}\rfor(ll i=0;i\u0026lt;bb;i++) {\rcin\u0026gt;\u0026gt;temp;\rb.push_back(temp);\r}\rsort(a.rbegin(),a.rend());\rsort(b.rbegin(),b.rend());\rfor(ll i=0;i\u0026lt;x;i++) c.push_back(a[i]);\rfor(ll i=0;i\u0026lt;y;i++) c.push_back(b[i]);\rfor(ll i=0;i\u0026lt;cc;i++) {\rcin\u0026gt;\u0026gt;temp;\rc.push_back(temp);\r}\rsort(c.rbegin(),c.rend());\rll sum=0;\rfor(ll i=0;i\u0026lt;x+y;i++) sum+=c[i];\rcout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Distributing Integers 题意 给一棵树，对于树上的一个顶点，赋值为1，然后对于已赋值顶点的相邻顶点依次\n赋值2,3,4..，求有多少种赋值方案，对于所有的顶点\n题解 又是不会做的一题\n树的拓扑序计数 + 换根\n（感谢出题人和这道题让我认识了“树的拓扑序计数”，然后第二次遇见了“换根”）\n对于某个顶点，方案数就是以这个点为根的“树的拓扑序的个数”\n树的拓扑序的个数为\n$$ {\\frac{n!}{\\prod\\limits_{} ^ {} {num}}} $$\nnum为每个节点的子节点数（含自己）\n小证明：\n如果没有限制，则排列组合有n!种\n由于子节点要排在父节点的的后面\n以根节点为例，它要排在第一个\n由于排序是随机的，所以排在第一个的概率为1/num\n同理所有的节点作为父节点时都与子节点等概率排序，所以每个都是1/num\n全部就是product(num)\nn!可以直接求\n现在要求product(num)\n为避免超时，可以用类似于记忆化搜索的思想\n先选取一个点为根（以1为例）求每个节点的子节点个数\n直接dfs\n然后求product(num[1])\n最后换根求不同节点的product(num)\n直接dfs\n此处换根product(num[i])=product(num[par])*(n-child[i])/child[i]\nac代码\n//#include\u0026quot;bits/stdc++.h\u0026quot;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\rusing namespace std;\rtypedef long long ll;\r// using pAr = product_as_root;\rconst ll mod = 1e9+7;\rll n;\rll sn[200005];\rll pAr[200005];\rvector\u0026lt;ll\u0026gt; G[200005];\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\rvoid dfs_sn(ll u,ll v){\rfor(auto i:G[u]){\rif(i!=v){\rdfs_sn(i,u); sn[u]+=sn[i];\r}\r}\rsn[u]++;\r}\rvoid dfs_cr(ll u,ll v){\rfor(auto i:G[u]){\rif(i!=v){\rpAr[i]=pAr[u]*qpow(sn[i],mod-2,mod)%mod*(n-sn[i])%mod;\rdfs_cr(i,u);\r}\r}\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rll t1,t2;\rfor(ll i=0;i\u0026lt;n-1;i++) {\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rG[t1].push_back(t2);\rG[t2].push_back(t1);\r}\rdfs_sn(1,0);\r//init\rpAr[1]=1;\rfor(ll i=1;i\u0026lt;=n;i++) pAr[1]=pAr[1]*sn[i]%mod;\rdfs_cr(1,0);\r//factorial\rll fac=1;\rfor(ll i=2;i\u0026lt;=n;i++) fac=fac*i%mod;\rfor(ll i=1;i\u0026lt;=n;i++){\rcout\u0026lt;\u0026lt;fac*qpow(pAr[i],mod-2,mod)%mod\u0026lt;\u0026lt;endl;\r}\r//for(int i=1;i\u0026lt;=8;i++) cout\u0026lt;\u0026lt;pAr[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rreturn 0;\r}\r have a good day ^_^\n","id":2,"section":"posts","summary":"A - Coffee 题意 判断一个长度为6的字符串，第3位和第4位是否相等，第5位和第6位是否相等 题解 模拟 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ string s; cin\u0026gt;\u0026gt;s; if(s[2]==s[3] and s[4]==s[5]) cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;; else cout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;; return 0; } B - Golden","tags":["cpp","greedy","dfs","graph_theory"],"title":"abc160","uri":"https://dyhgo.github.io/2020/03/abc160/","year":"2020"},{"content":"《星际牛仔》（カウボーイビバップ；Cowboy Bebop），是日本SUNRISE动画\n公司制作的原创电视动画，于1998年10月23日-1999年4月23日在东京电视台和\nWOWOW播出，同年夺得第三回神户动画奖的年度最佳电视动画奖，并于2000年\n获得日本科幻大会星云奖。 \u0026ndash;百度百科\n故事背景设定在2071 年。随着超光速航行技术的实现，人类得以在太阳系范围\n内方便的自由移动，但是由于设计上的失误，这一技术引发了月球的爆炸，无数\n月球碎片被吸引向地球，造成了空前绝后的大灾难。存活下来的人类逃离地球，\n并开始在太阳系各地建立家园。\n由于这次灾难，国家、政府等权力机构都极为不稳定，治安问题也成为了大难\n题。\n为了在人力资源不足的情况下抓捕罪犯，有些组织开始允许个人抓捕通缉的罪犯\n并换取奖金，“赏金猎人”这个职业也就由此诞生了。\u0026ndash;百度百科\n","id":3,"section":"posts","summary":"《星际牛仔》（カウボーイビバップ；Cowboy Bebop），是日本SUNRISE动画 公司制作的原创电视动画，于1998年10月23日-199","tags":[],"title":"星际牛仔","uri":"https://dyhgo.github.io/2020/03/%E6%98%9F%E9%99%85%E7%89%9B%E4%BB%94/","year":"2020"},{"content":"A. Divisibility Problem 题意 求一个数加上多少能被另一个数整除\n题解 如果b|(a+k)\n则k=b-a%b注意k=0特判\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t,a,b;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;(b-(a%b)==b?0:b-(a%b))\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. K-th Beautiful String 题意 一个长度为n的字符串，由n-2个a组成和2个b组成\n求所有按字典序排列组合的第k个\n题解 只要定位b的位置就行\nb的位置是有规律的，模拟这个规律\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rlong long t,n,k;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rlong long fi=ceil((sqrt(1+8*k)-1)/2);\rlong long se=fi*(fi-1)/2;\rse=k-se;\rse=n-se; fi=n-1-fi;\rfor(long long i=0;i\u0026lt;n;i++) if(i==fi or i==se) cout\u0026lt;\u0026lt;'b'; else cout\u0026lt;\u0026lt;'a';\rcout\u0026lt;\u0026lt;endl;\r}\r}\r 没开long long WA掉一发\nC. Ternary XOR 题意 定义一种异或运算\nai XOR bi = (ai+bi)%3\n给一数c，求a,b使得(a XOR b)=c，使得max(a,b)尽可能小\nc由0,1，2组成，且首位为2\n题解 从左到右遍历\n以是否出现过1作为判断条件\n第一次出现1时，一边为0，一边为1\n之后把大的数填到之前填0的那一边\n就能保证max最小\n如果没有出现1则2分成1和1\n出现后2分成0和2\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint t;\rint n;\rshort up[50005];\rshort down[50005];\rbool one;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rone = false;\rcin\u0026gt;\u0026gt;n;\rchar temp1;\rint temp2;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;temp1;\rtemp2=temp1-'0';\rif(one){\rif(temp2==1){\rup[i]=1;down[i]=0;\r}\rif(temp2==2){\rup[i]=2;down[i]=0;\r}\rif(temp2==0){\rup[i]=0;down[i]=0;\r}\r}\relse{\rif(temp2==1) {\rone=true;up[i]=0;down[i]=1;\r} if(temp2==2){\rup[i]=1;down[i]=1;\r}\rif(temp2==0) {\rup[i]=0;down[i]=0;\r}\r}\r}\rfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;up[i]; cout\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;down[i]; cout\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r D. Carousel 题意 旋转木马的马上有很多图案，给它们涂色，要求相邻不同图案要涂不同的颜色\n问最少需要几种颜色，并求涂色方案（注意旋转木马是个环）\n题解 如果所有的图案都相同，只需要一种\n如果图案不同则有可能需要2种或3种，但不超过3种\n如果必须3种，则涂色可以为1,2,3,1,2,3\u0026hellip;（注意最后一个不能与第一个相同）（不一定）\n现在验证是否只需要2种\n因为不同的图案必须涂不同的颜色\n所以以不同的图案为点，用边连起来\n判定是否为二分图就行（同种图案涂色不受限，所以不需要考虑同种图案）\n还可以通过木马的奇偶性分类讨论\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint q;\rint n;\rint a[200005];\rint color[200005];\rvector\u0026lt;int\u0026gt; G[200005];\rbool dfs(int v,int c)\r{\rcolor[v]=c; for(int i=0;i\u0026lt;G[v].size();i++)\r{\rif(color[G[v][i]]==c) return false; if(color[G[v][i]]==0 \u0026amp;\u0026amp; !dfs(G[v][i],3-c)) return false; } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=1;i\u0026lt;=n;i++)\r{\rif(color[i]==0) if(!dfs(i,1)) return false; }\rreturn true;\r} int main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;q;\rwhile(q--){\r//reset TODO\rmemset(color,0,sizeof(color));\rfor(int i=0;i\u0026lt;=n;i++) G[i].clear();\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i];\r//特判\rbool flag=true;\rfor(int i=1;i\u0026lt;n;i++) if(a[i]!=a[i+1]) flag=false; if(a[n]!=a[1]) flag=false;\rif(flag) {\rcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\r}\relse{\r//preprocess\rfor(int i=1;i\u0026lt;n;i++){\rif(a[i]!=a[i+1]) {\rG[i].push_back(i+1);G[i+1].push_back(i);\r}\r}\rif(a[n]!=a[1]) {\rG[n].push_back(1);G[1].push_back(n);\r}\rif(bipartite_graph()){\rcout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl;\rfor(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;color[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl;\r}\relse{\rcout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl;\rif((n-1)%3==0) {\rfor(int i=1;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;(i%3==0? 3 : i%3 )\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; }\relse{\rfor(int i=1;i\u0026lt;=n;i++) cout\u0026lt;\u0026lt;(i%3==0? 3 : i%3 )\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl; }\r}\r}\r}\rreturn 0;\r}\r E. Tree Queries 题意 给一棵树和几个树上的顶点\n问是否存在从根出发的一条简单路径\n使得所有的点都在这条路径上或离路径的距离为1\n题解 如果存在，这条路径一定是从根到深度最大的顶点\n接下来依次判断这些点是否满足这些条件\n对于某个点\n求这个点和最深的点的LCA\n判断这个点是否是LCA或LCA的子节点\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint V;\rint m;\rconst int maxv=200005;\rconst int max_logv=20;\rint data[maxv];\rint n;\rvector\u0026lt;int\u0026gt; G[maxv];\rint root=0;\rint parent[max_logv][maxv];\rint depth[maxv];\rvoid dfs(int v,int p,int d){\rparent[0][v]=p;\rdepth[v]=d;\rfor(int i=0;i\u0026lt;G[v].size();i++){\rif(G[v][i]!=p) dfs(G[v][i],v,d+1);\r}\r}\rvoid init(int V){\rdfs(root,-1,0);\rfor(int k=0;k+1\u0026lt;max_logv;k++){\rfor(int v=0;v\u0026lt;V;v++){\rif(parent[k][v]\u0026lt;0) parent[k+1][v]=-1;\relse parent[k+1][v]=parent[k][parent[k][v]];\r}\r}\r}\rint lca(int u,int v){\rif(depth[u]\u0026gt;depth[v]) swap(u,v);\rfor(int k=0;k\u0026lt;max_logv;k++){\rif((depth[v]-depth[u])\u0026gt;\u0026gt;k\u0026amp;1) v=parent[k][v];\r}\rif(u==v) return u;\rfor(int k=max_logv-1;k\u0026gt;=0;k--){\rif(parent[k][u]!=parent[k][v]){\ru=parent[k][u];\rv=parent[k][v];\r}\r}\rreturn parent[0][u];\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;V\u0026gt;\u0026gt;m;\rint temp1,temp2;\rfor(int i=0;i\u0026lt;V-1;i++){\rcin\u0026gt;\u0026gt;temp1\u0026gt;\u0026gt;temp2;\rG[temp1-1].push_back(temp2-1);\rG[temp2-1].push_back(temp1-1);\r}\rinit(V);\rwhile(m--){\rcin\u0026gt;\u0026gt;n;\rint maxdi;\rint maxd=-1e9;\rint temp;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;temp;\rdata[i]=temp-1;\rif(depth[data[i]]\u0026gt;=maxd) {\rmaxd=depth[data[i]];\rmaxdi=data[i];\r}\r}\r//cout\u0026lt;\u0026lt;maxdi\u0026lt;\u0026lt;endl;\rbool flag=true;\rfor(int i=0;i\u0026lt;n;i++){\rif(data[i]!=maxdi)\r{\rint foo=lca(maxdi,data[i]);\rif(!(data[i]==foo || foo==parent[0][data[i]])) {\rflag=false;break;\r}\r}\r}\rif(flag) cout\u0026lt;\u0026lt;\u0026quot;YES\u0026quot;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026quot;NO\u0026quot;\u0026lt;\u0026lt;endl; }\r//cout\u0026lt;\u0026lt;lca(2,4)\u0026lt;\u0026lt;endl;\r//for(int i=1;i\u0026lt;=4;i++) cout\u0026lt;\u0026lt;depth[i]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 因为max_logv开太小，WA了7次，一直停留在第80个测试点（我记得明明还往多了开的，难道是计算失误，还是记忆丧失）\nF. Make k Equal 题意 给一数列\n每次可进行这样的操作\n1.把最小的数+1\n2.把最大的数-1\n求最少需要多少次操作使数列中有k个相等的数\n题解 一开始想的是，这个数应该是中位数，然后从它往两边扩散，把两边的数往里压\n结果这应该不是最优解\n太困了（X）太菜了（√），直接看了别人的题解恍然大悟\n最后得到的这k个相同的数一定在数列中（由于两边往里压，中间的数可看成不变，最后的结果一定是压向不变的数）\n首先排序\n过一遍数列\n每次针对一片相同数字域\n求以此为目标需要进行的操作数\n不断min更新\n对于某块相同数字域\n遍历过程中维护数字域左边的数量lnum\n左边的和lsum\n右边的数量rnum\n右边的和rsum\n这样是便于计算操作数，降低时间复杂度\n考虑三种情况\n左边压到中间\n右边压到中间\n两边压到中间\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n,k;\rll a[200005];\rmap\u0026lt;ll,ll\u0026gt; mp;\rll lsum=0;\rll rsum=0;\rll lnum=0;\rll rnum;\rll re;\rll ans=1e15;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;a[i];\rmp[a[i]]++;\rrsum+=a[i];\r}\r//特判\rfor(auto i:mp) if(i.second\u0026gt;=k) {cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;return 0;}\rrnum=n;\rfor(auto i:mp) {\rrnum-=i.second;\rrsum-=(i.first*i.second); re=k-i.second;\rif(lnum\u0026gt;=re){\rans=min(ans,(i.first-1)*lnum-lsum+re);\r}\rif(rnum\u0026gt;=re){\rans=min(ans,rsum-(i.first+1)*rnum+re);\r}\rif(re\u0026gt;=2){\rans=min(ans,(i.first-1)*lnum-lsum+re+rsum-(i.first+1)*rnum);\r}\rlsum+=(i.first*i.second);\rlnum+=i.second;\r} cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}  hava a good day ^_^\n","id":4,"section":"posts","summary":"A. Divisibility Problem 题意 求一个数加上多少能被另一个数整除 题解 如果b|(a+k) 则k=b-a%b注意k=0特判 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t,a,b; int main(){ //freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin); cin\u0026gt;\u0026gt;t; while(t--){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;(b-(a%b)==b?0:b-(a%b))\u0026lt;\u0026lt;endl; } return 0; } B. K-th","tags":["cpp","dfs","graph","lca"],"title":"Codeforces Round #629 (Div. 3)","uri":"https://dyhgo.github.io/2020/03/codeforces-round-629-div.-3/","year":"2020"},{"content":"杀手2由IO Interactive开发，2018年发行的潜行刺杀游戏，与羞辱不同的是这是第三人称\n杀手2最大的特点是刺杀方法的丰富性\n游玩过程中会发现特别多的可能性\n里面有一个适合手残党的玩法，就是被敌人盯上时，可以一直藏着，只要等的下去，危险就会解除\n剧情很丰富，延续了杀手1\n但是剧情太短了\n玩一会就完了（指不开辟新的刺杀方式）\n地图是分区的，每一块地图也太小了\n风景做的很好，但是与NPC的互动太少了\n换装式的伪装也是一大特色\n通过这种伪装可以派生很多的玩法\n吐槽一下一种线下的狙击模式，非常的sb，简直就是4399小游戏搬过来的\n剧情 游戏剧情衔接《杀手》的剧情，戴安娜为了得到神意秘会的代理人“永恒常量”手中有关47出身来历的一切信息，说服了ICA董事会接受了来自神意秘会的契约：消灭“影子客户”并瓦解他的民兵组织。\n根据47曾经在科罗纳多获取的情报，ICA找到了关于民兵组织成员的线索：阿尔玛·雷纳德，肖恩·罗斯的前女友，当过生态恐怖分子并且是一名很有才华的外勤潜入者，目前与她的新搭档奥森·米尔斯躲\n藏在新西兰霍克斯湾的一处海滨别墅。\n47为搜寻情报而前往调查关于“影子客户”与民兵的线索。 \u0026ndash;百度百科\n","id":5,"section":"posts","summary":"杀手2由IO Interactive开发，2018年发行的潜行刺杀游戏，与羞辱不同的是这是第三人称 杀手2最大的特点是刺杀方法的丰富性 游玩过程中","tags":[],"title":"杀手2","uri":"https://dyhgo.github.io/2020/03/%E6%9D%80%E6%89%8B2/","year":"2020"},{"content":"生命周期 在containerActivity的布局中放入一个fragment，然后点击按钮，切换成另一个fragment\ncontainerActivity的布局文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.fragment.containerActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/ctnbtn1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;change_fragment\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.1\u0026quot; /\u0026gt;\r\u0026lt;FrameLayout\randroid:id=\u0026quot;@+id/ctn1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/ctnbtn1\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\randroid:layout_height=\u0026quot;0dp\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r containerActivity.java\npackage com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity {\rprivate Afragment afragment;\rprivate Bfragment bfragment;\rprivate Button ctnbtn1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rctnbtn1 = findViewById(R.id.ctnbtn1);\rctnbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rgetSupportFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).commitAllowingStateLoss();\r}\r});\rafragment = new Afragment();\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment).commitAllowingStateLoss();\r}\r}\r Afragment.java\npackage com.example.test.fragment;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\r}\r}\r fragment_a.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/fatv1\u0026quot;\randroid:text=\u0026quot;fragment_a\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.4\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r Bfragment.java和fragment_b.xml与A类似\n传数据给fragment Afragment.java\npackage com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;tk\u0026quot;,title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\u0026quot;tk\u0026quot;));\r}\r}\r@Override\rpublic void onAttach(Context context) {\rsuper.onAttach(context);\r}\r@Override\rpublic void onDetach() {\rsuper.onDetach();\r}\r}\r 通过这种方法实例化\nafragment = Afragment.newInstance(\u0026quot;hello world\u0026quot;);\r fragment的回退栈 fragment_a.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/fabtn1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;change_to_Bfragment\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.1\u0026quot; /\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/fabtn2\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;updata_text\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.2\u0026quot; /\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/fatv1\u0026quot;\randroid:text=\u0026quot;fragment_a\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.4\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r Afragment.java\npackage com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;tk\u0026quot;,title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\u0026quot;Afragment\u0026quot;,\u0026quot;----------onCreateView--------\u0026quot;);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\u0026quot;updated\u0026quot;);\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\u0026quot;tk\u0026quot;));\r}\r}\r}\r fragment_b.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/fbtv1\u0026quot;\randroid:text=\u0026quot;fragment_b\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.4\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r Bfragment.java\npackage com.example.test.fragment;\rimport android.os.Bundle;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Bfragment extends Fragment {\rprivate TextView fbtv1;\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_b,container,false);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfbtv1 = view.findViewById(R.id.fbtv1);\r}\r}\r containerActivity.java\npackage com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity {\rprivate Afragment afragment;\rprivate Bfragment bfragment;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rafragment = Afragment.newInstance(\u0026quot;hello world\u0026quot;);\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment).commitAllowingStateLoss();\r}\r}\r 让Afragment不再重新加载\n改动containerActivity.java和Afragment.java即可\npackage com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity {\rprivate Afragment afragment;\rprivate Bfragment bfragment;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rafragment = Afragment.newInstance(\u0026quot;hello world\u0026quot;);\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment,\u0026quot;a\u0026quot;).commitAllowingStateLoss();\r}\r}\r package com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;tk\u0026quot;,title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\u0026quot;Afragment\u0026quot;,\u0026quot;----------onCreateView--------\u0026quot;);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rFragment fragment = null;\rif (getFragmentManager() != null) {\rfragment = getFragmentManager().findFragmentByTag(\u0026quot;a\u0026quot;);\r}\rif(fragment!=null) {\rgetFragmentManager().beginTransaction().hide(fragment).add(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\relse{\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\u0026quot;updated\u0026quot;);\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\u0026quot;tk\u0026quot;));\r}\r}\r}\r 传递数据给activity 通过接口回调\nAfragment.java\npackage com.example.test.fragment;\rimport android.content.Context;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.LayoutInflater;\rimport android.view.View;\rimport android.view.ViewGroup;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rimport androidx.fragment.app.Fragment;\rimport com.example.test.R;\rpublic class Afragment extends Fragment {\rprivate msgclick listener;\rpublic interface msgclick{\rvoid onclick(String s);\r}\rprivate TextView fatv1;\rprivate Button fabtn1,fabtn2,fabtn3;\rprivate Bfragment bfragment;\rpublic static Afragment newInstance(String title){\rAfragment afragment = new Afragment();\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;tk\u0026quot;,title);\rafragment.setArguments(bundle);\rreturn afragment;\r}\r@Override\rpublic void onAttach(Context context) {\rsuper.onAttach(context);\rlistener = (msgclick) context;\r}\r@Nullable\r@Override\rpublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\rView view = inflater.inflate(R.layout.fragment_a,container,false);\rLog.d(\u0026quot;Afragment\u0026quot;,\u0026quot;----------onCreateView--------\u0026quot;);\rreturn view;\r}\r@Override\rpublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\rsuper.onViewCreated(view, savedInstanceState);\rfatv1 = view.findViewById(R.id.fatv1);\rfabtn1 = view.findViewById(R.id.fabtn1);\rfabtn2 = view.findViewById(R.id.fabtn2);\rfabtn3 = view.findViewById(R.id.fabtn3);\rfabtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(bfragment==null) bfragment = new Bfragment();\rFragment fragment = null;\rif (getFragmentManager() != null) {\rfragment = getFragmentManager().findFragmentByTag(\u0026quot;a\u0026quot;);\r}\rif(fragment!=null) {\rgetFragmentManager().beginTransaction().hide(fragment).add(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\relse{\rif (getFragmentManager() != null) {\rgetFragmentManager().beginTransaction().replace(R.id.ctn1,bfragment).addToBackStack(null).commitAllowingStateLoss();\r}\r}\r}\r});\rfabtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfatv1.setText(\u0026quot;updated\u0026quot;);\r}\r});\rfabtn3.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rlistener.onclick(\u0026quot;dedsec\u0026quot;);\r}\r});\rif(getArguments()!=null) {\rfatv1.setText(getArguments().getString(\u0026quot;tk\u0026quot;));\r}\r}\r}\r containerActivity.java\npackage com.example.test.fragment;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class containerActivity extends AppCompatActivity implements Afragment.msgclick {\rprivate Afragment afragment;\r//private Bfragment bfragment;\rprivate TextView ctntv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_container);\rafragment = Afragment.newInstance(\u0026quot;hello world\u0026quot;);\rgetSupportFragmentManager().beginTransaction().add(R.id.ctn1,afragment,\u0026quot;a\u0026quot;).commitAllowingStateLoss();\rctntv1 = findViewById(R.id.ctntv1);\r}\r@Override\rpublic void onclick(String s) {\rctntv1.setText(s);\r}\r}\r ","id":6,"section":"posts","summary":"生命周期 在containerActivity的布局中放入一个fragment，然后点击按钮，切换成另一个fragment containerA","tags":["java","xml"],"title":"Android Fragment","uri":"https://dyhgo.github.io/2020/03/android-fragment/","year":"2020"},{"content":"简单演示\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.anim2Activity\u0026quot;\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;70dp\u0026quot;\randroid:id=\u0026quot;@+id/a2tv1\u0026quot;\randroid:textSize=\u0026quot;30sp\u0026quot;\randroid:text=\u0026quot;animation_test\u0026quot;\randroid:gravity=\u0026quot;center\u0026quot;\randroid:textColor=\u0026quot;#FFFFFF\u0026quot;\randroid:background=\u0026quot;#AAAAAA\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.widget.TextView;\rpublic class anim2Activity extends AppCompatActivity {\rprivate TextView a2tv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_anim2);\ra2tv1 = findViewById(R.id.a2tv1);\ra2tv1.animate().translationYBy(500).setDuration(2000).start();\r}\r}\r package com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.animation.ObjectAnimator;\rimport android.animation.ValueAnimator;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.widget.TextView;\rpublic class anim2Activity extends AppCompatActivity {\rprivate TextView a2tv1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_anim2);\ra2tv1 = findViewById(R.id.a2tv1);\r//a2tv1.animate().translationYBy(500).setDuration(2000).start();\r//a2tv1.animate().alpha(0).setDuration(2000).start();\r// ValueAnimator valueAnimator = ValueAnimator.ofInt(0,100);\r// valueAnimator.setDuration(2000);\r// valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r// @Override\r// public void onAnimationUpdate(ValueAnimator animation) {\r// Log.d(\u0026quot;test\u0026quot;,animation.getAnimatedValue()+\u0026quot;\u0026quot;);\r// Log.d(\u0026quot;test\u0026quot;,animation.getAnimatedFraction()+\u0026quot;\u0026quot;);\r// }\r// });\r// valueAnimator.start();\rObjectAnimator objectAnimator = ObjectAnimator.ofFloat(a2tv1,\u0026quot;translationY\u0026quot;,1500,200,500,300,1000);\robjectAnimator.setDuration(5000);\robjectAnimator.start();\r}\r}\r ","id":7,"section":"posts","summary":"简单演示 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; xmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot; xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;match_parent\u0026quot; tools:context=\u0026quot;.anim2Activity\u0026quot;\u0026gt; \u0026lt;TextView android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;70dp\u0026quot; android:id=\u0026quot;@+id/a2tv1\u0026quot; android:textSize=\u0026quot;30sp\u0026quot; android:text=\u0026quot;animation_test\u0026quot; android:gravity=\u0026quot;center\u0026quot; android:textColor=\u0026quot;#FFFFFF\u0026quot; android:background=\u0026quot;#AAAAAA\u0026quot;/\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; public class anim2Activity extends AppCompatActivity { private TextView a2tv1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_anim2); a2tv1 = findViewById(R.id.a2tv1); a2tv1.animate().translationYBy(500).setDuration(2000).start(); } } package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.animation.ObjectAnimator; import android.animation.ValueAnimator; import android.os.Bundle; import android.util.Log; import android.widget.TextView; public","tags":["java","xml"],"title":"Android 属性动画","uri":"https://dyhgo.github.io/2020/03/android-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","year":"2020"},{"content":"Watch_dogs2是ubisoft于2016年11月发行的角色扮演游戏\n骇入系统是其游戏特色\n玩了130+小时\n看门狗2的这个特色很新颖，但是剧情很平淡，后面的玩法基本与前面重复\n难度也不是很高，很快就能通关，dlc就是支线剧情的复制。但是旧金山的风景还是\n很不错的，就是地图太小了。线上模式的hack玩的最多，开始被虐，后来找到技巧，虐别人就索然无味了\n线上赛车自从玩了GTA5之后真的就无趣了，经常有人莫名其妙退出\n经常受到土豆服务器的制约\n现在是真的没空玩看门狗3了\n剧情 《看门狗2》将游戏设定在距离《看门狗》故事发生之后，ctOS由1.0升级成为2.0，同时也获得了许多功能。然而，ctOS并不是像宣传的那样单纯只是为市民服务，它被不法公司，团体和个人用来监视市民，收集并出售他们个人的数据，操纵选举和扰乱社会秩序等等。游戏需要玩家跟随主人公一点一点进入《看门狗2》的庞大电子世界，揭开并粉碎敌人的阴谋。\n《看门狗2》的总监表示，游戏开发团队想在这一作上尝试一些新的点子，比如位于旧金山的游戏场景，整体色调更鲜活明亮，再搭配故事的主题、建筑风格、网络世界以及先进科技。在这样的架构中，故事风格不适合艾登‧皮尔斯，因此让马可仕担任主角来叙述故事是很合适的。 \u0026ndash;百度百科\n","id":8,"section":"posts","summary":"Watch_dogs2是ubisoft于2016年11月发行的角色扮演游戏 骇入系统是其游戏特色 玩了130+小时 看门狗2的这个特色很新颖，但是","tags":[],"title":"看门狗2","uri":"https://dyhgo.github.io/2020/03/%E7%9C%8B%E9%97%A8%E7%8B%972/","year":"2020"},{"content":"A - The Number of Even Pairs 题解 ac代码 (awk语言)\n$0=$1*--$1/2+$2*--$2/2_\r B - String Palindrome 题解 ac代码 (perl语言)\nprint\u0026lt;\u0026gt;=~/^(.+).\\1$/?Yes:No\r C - Maximum Volume 题解 ac代码 (perl语言)\nprint\u0026lt;\u0026gt;**3/27\r D - Banned K 题解 ac代码 (perl语言)\n\u0026lt;\u0026gt;;print$.-@$_,$/for grep$.+=++$#$_,glob`dd`\r E - Dividing Chocolate 题意 一块巧克力由h行w列的方块组成，每个方块为白或黑\n你可以对巧克力进行切割，切割只能沿着方块边缘横切或竖切切到底\n问最少需要切几刀，使每个独立块都有不多于k个白巧克力方块\n题解 贪心 枚举 和牛客小白月赛26的A题很像\n由于h的数据不大，枚举行的所有可能情况，先考虑横切，横切不够再竖切\n考虑竖切时，如果最大的块大于k，就实施竖切\n遍历所有情况求最小值\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint h,w,k;\rstring s[12];\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint coun=0;\rcin\u0026gt;\u0026gt;h\u0026gt;\u0026gt;w\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;h;i++){\rcin\u0026gt;\u0026gt;s[i];\r}\r//特判 //没有特判，用u=0代替 WA for(int i=0;i\u0026lt;h;i++) for(int j=0;j\u0026lt;w;j++) if(s[i][j]=='1') coun++;\rif(coun\u0026lt;=k) cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\relse{\rint ans=1e9;\rfor(int u=1;u\u0026lt;(1\u0026lt;\u0026lt;(h-1));u++){\rint x=__builtin_popcount(u);\rint cut_num=x;\rint block[x+1]={0};\rint p=0;\rint mx=0;\rbool flag=true; //没有设置flag WA for(int j=0;j\u0026lt;w;j++){\rfor(int i=0;i\u0026lt;h;i++){\rblock[p]+=s[i][j]-'0';\rmx=max(mx,block[p]);\rif(u\u0026gt;\u0026gt;i\u0026amp;1) p++;\r}\r//mx=max(mx,block[p]);\rif(mx\u0026gt;k) {\rif(j==0) { flag=false;break; }\rcut_num++;\rmx=0;\rmemset(block,0,sizeof(block));\rp=0; //没有重置p WA for(int i=0;i\u0026lt;h;i++){ //没有记忆（重新计算） WA block[p]+=s[i][j]-'0';\rmx=max(mx,block[p]);\rif(u\u0026gt;\u0026gt;i\u0026amp;1) p++;\r}\r}\rp=0; //没有重置p WA }\rif(flag) ans=min(ans,cut_num);\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r 这道题做了快一个小时，WA了特别多次，每次都WA两三个测试点，主要是细节，WA点在代码中已标注\nF - Knapsack for All Segments 题意 给一数列，求对每一可能区间，其子区间内的数和等于s的子区间个数\n对所有可能区间求和\n题解 动态规划 奇妙的动态规划\ndp[i][j] = sum(f(left,i)) 当和为 j 时\n可以的得到递推式\ndp[i][j]=dp[i-1][j] \ndp[i][j]+=dp[i-1][j-data[i]]\n有一个很重要的点在代码中标出\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll = long long;\rll n,s;\rll data[3005];\rll dp[3005][3005];\rconst ll mod=998244353;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s;\rfor(ll i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;data[i];\rdp[0][0]=1;\rfor(ll i=1;i\u0026lt;=n;i++) for(ll j=0;j\u0026lt;=s;j++)\r{\rdp[i][j]=dp[i-1][j];\rif(j-data[i]\u0026gt;=0) dp[i][j]+=dp[i-1][j-data[i]];\rif(j==0) dp[i][j]++; //当j-data[i]==0时，a[i]这一个也要算上 dp[i][j]%=mod;\r}\rll ans=0;\rfor(ll i=1;i\u0026lt;=n;i++) ans=(ans+dp[i][s])%mod;\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 一遍过，芜湖~\nhave a good day ^_^\n","id":9,"section":"posts","summary":"A - The Number of Even Pairs 题解 ac代码 (awk语言) $0=$1*--$1/2+$2*--$2/2_ B - String Palindrome 题解 ac代码 (perl语言) print\u0026lt;\u0026gt;=~/^(.+).\\1$/?Yes:No C - Maximum Volume 题解 ac代码 (perl语言) print\u0026lt;\u0026gt;**3/27 D - Banned K 题解 ac代码 (","tags":["cpp","greedy","binary","dp"],"title":"abc159","uri":"https://dyhgo.github.io/2020/03/abc159/","year":"2020"},{"content":"SharedPreferences sharedpreferences的布局\n布局文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.datastorage.sharedPreferencesActivity\u0026quot;\u0026gt;\r\u0026lt;EditText\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/spet1\u0026quot;\randroid:hint=\u0026quot;input\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.1\u0026quot;\r/\u0026gt;\r\u0026lt;Button\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:text=\u0026quot;sava\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/spet1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;\randroid:id=\u0026quot;@+id/spbtn1\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:text=\u0026quot;show\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/spbtn1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;\randroid:id=\u0026quot;@+id/spbtn2\u0026quot;/\u0026gt;\r\u0026lt;TextView\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/sptv1\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/spbtn2\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;\r/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r 输入内容，存储到sharedpreferences,并呈现\npackage com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.Intent;\rimport android.content.SharedPreferences;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class sharedPreferencesActivity extends AppCompatActivity {\rprivate Button spbtn1,spbtn2;\rprivate EditText spet1;\rprivate TextView sptv1;\rprivate SharedPreferences mysp;\rprivate SharedPreferences.Editor myspe;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_shared_preferences);\rspbtn1 = findViewById(R.id.spbtn1);\rspbtn2 = findViewById(R.id.spbtn2);\rspet1 = findViewById(R.id.spet1);\rsptv1 = findViewById(R.id.sptv1);\r//实例化\rmysp = getSharedPreferences(\u0026quot;data\u0026quot;,MODE_PRIVATE);\rmyspe = mysp.edit();\rspbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rmyspe.putString(\u0026quot;name\u0026quot;,spet1.getText().toString());\rmyspe.apply(); //相当于提交\r}\r});\rspbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsptv1.setText(mysp.getString(\u0026quot;name\u0026quot;,\u0026quot;\u0026quot;));\r}\r});\r}\r}\r sharedpreferences把数据存在xml文件中\n在路径 data\\data\\\u0026lt;applicationId\u0026gt;\\shared_prefs下有一个xml文件\n真机要root查看\n模拟器直接在终端打开monitor\n要查看这个文件可以点击右上角的 pull a file from the device 下载下来\n打开之后\nFile 内部存储 布局和功能几乎与sharedpreferences相同\njava文件\npackage com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rimport java.io.FileInputStream;\rimport java.io.FileOutputStream;\rimport java.io.IOException;\rpublic class fileActivity extends AppCompatActivity {\rprivate Button fibtn1,fibtn2;\rprivate EditText fiet1;\rprivate TextView fitv1;\rprivate final String filename = \u0026quot;test.txt\u0026quot;;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_file);\rfibtn1 = findViewById(R.id.fibtn1);\rfibtn2 = findViewById(R.id.fibtn2);\rfiet1 = findViewById(R.id.fiet1);\rfitv1 = findViewById(R.id.fitv1);\rfibtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsave(fiet1.getText().toString());\r}\r});\rfibtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfitv1.setText(read());\r}\r});\r}\rpublic void save(String content){\rFileOutputStream fileOutputStream = null;\rtry {\rfileOutputStream = openFileOutput(filename,MODE_PRIVATE);\rfileOutputStream.write(content.getBytes());\r} catch (IOException e) {\re.printStackTrace();\r} finally {\rif(fileOutputStream!=null){\rtry {\rfileOutputStream.close();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\r}\rpublic String read(){\rFileInputStream fileInputStream = null;\rtry {\rfileInputStream = openFileInput(filename);\rbyte[] buff = new byte[1024];\r//fileInputStream.read(buff);\rStringBuilder sb = new StringBuilder(); //字符串拼接\rint len=0;\rwhile((len = fileInputStream.read(buff)) \u0026gt; 0){\rsb.append(new String(buff,0,len));\r}\rreturn sb.toString();\r} catch (IOException e) {\re.printStackTrace();\r}finally {\rif(fileInputStream!=null){\rtry {\rfileInputStream.close();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\rreturn null;\r}\r}\r File 外部存储 java文件\npackage com.example.test.datastorage;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.core.app.ActivityCompat;\rimport android.Manifest;\rimport android.app.Activity;\rimport android.os.Bundle;\rimport android.os.Environment;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rimport android.widget.TextView;\rimport com.example.test.R;\rimport java.io.File;\rimport java.io.FileInputStream;\rimport java.io.FileOutputStream;\rimport java.io.IOException;\rpublic class fileActivity extends AppCompatActivity {\rprivate Button fibtn1,fibtn2;\rprivate EditText fiet1;\rprivate TextView fitv1;\rprivate final String filename = \u0026quot;test.txt\u0026quot;;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_file);\rfibtn1 = findViewById(R.id.fibtn1);\rfibtn2 = findViewById(R.id.fibtn2);\rfiet1 = findViewById(R.id.fiet1);\rfitv1 = findViewById(R.id.fitv1);\rfibtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rsave(fiet1.getText().toString());\r}\r});\rfibtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rfitv1.setText(read());\r}\r});\rActivityCompat.requestPermissions(this , new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},1); //1是随便写de\r}\rpublic void save(String content){\rFileOutputStream fileOutputStream = null;\rtry {\r//fileOutputStream = openFileOutput(filename,MODE_PRIVATE);\r//路径\rFile dir = new File(getExternalFilesDir(null),\u0026quot;hello\u0026quot;);\rif(!dir.exists()){\rdir.mkdirs();\r}\r//文件\rFile file = new File(dir,filename);\rif(!file.exists()){\rfile.createNewFile();\r}\rfileOutputStream = new FileOutputStream(file);\rfileOutputStream.write(content.getBytes());\r} catch (IOException e) {\re.printStackTrace();\r} finally {\rif(fileOutputStream!=null){\rtry {\rfileOutputStream.close();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\r}\rpublic String read(){\rFileInputStream fileInputStream = null;\rtry {\r//fileInputStream = openFileInput(filename);\rFile file = new File(getExternalFilesDir(null).getAbsolutePath()+File.separator+\u0026quot;hello\u0026quot;,filename);\rfileInputStream = new FileInputStream(file);\rbyte[] buff = new byte[1024];\r//fileInputStream.read(buff);\rStringBuilder sb = new StringBuilder(); //字符串拼接\rint len=0;\rwhile((len = fileInputStream.read(buff)) \u0026gt; 0){\rsb.append(new String(buff,0,len));\r}\rreturn sb.toString();\r} catch (IOException e) {\re.printStackTrace();\r}finally {\rif(fileInputStream!=null){\rtry {\rfileInputStream.close();\r} catch (IOException e) {\re.printStackTrace();\r}\r}\r}\rreturn null;\r}\r}\r 权限申请 \u0026lt;uses-permission android:name=\u0026quot;android.permission.READ_EXTERNAL_STORAGE\u0026quot;/\u0026gt;\r\u0026lt;uses-permission android:name=\u0026quot;android.permission.WRITE_EXTERNAL_STORAGE\u0026quot;/\u0026gt;\r ","id":10,"section":"posts","summary":"SharedPreferences sharedpreferences的布局 布局文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; xmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot; xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;match_parent\u0026quot; tools:context=\u0026quot;.datastorage.sharedPreferencesActivity\u0026quot;\u0026gt; \u0026lt;EditText android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/spet1\u0026quot; android:hint=\u0026quot;input\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; app:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot; app:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot; app:layout_constraintVertical_bias=\u0026quot;0.1\u0026quot; /\u0026gt; \u0026lt;Button android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; android:text=\u0026quot;sava\u0026quot; app:layout_constraintTop_toBottomOf=\u0026quot;@+id/spet1\u0026quot; android:layout_marginTop=\u0026quot;20dp\u0026quot; android:id=\u0026quot;@+id/spbtn1\u0026quot;/\u0026gt; \u0026lt;Button android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; android:text=\u0026quot;show\u0026quot; app:layout_constraintTop_toBottomOf=\u0026quot;@+id/spbtn1\u0026quot; android:layout_marginTop=\u0026quot;20dp\u0026quot; android:id=\u0026quot;@+id/spbtn2\u0026quot;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/sptv1\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; app:layout_constraintTop_toBottomOf=\u0026quot;@+id/spbtn2\u0026quot; android:layout_marginTop=\u0026quot;20dp\u0026quot; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;","tags":["java","xml"],"title":"Android 数据存储","uri":"https://dyhgo.github.io/2020/03/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","year":"2020"},{"content":"A 膜法记录 题目链接\n题解 贪心 枚举 集合的整数表示 由于n的数据较小，直接枚举n的所有情况，有2^n种\n对于每种情况判断剩下的点列blast能否用完\n其实就是贪心思想（把行blast用完，再用列blast）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rchar s[23][100005];\rll t;\rll n,m,a,b;\rll cl[1\u0026lt;\u0026lt;21];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rfor(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;n);i++) cl[i]=0;\rfor(ll i=1;i\u0026lt;=n;i++) scanf(\u0026quot;%s\u0026quot;,s[i]+1);\r//memset(cl,0,sizeof(cl));\rfor(ll j=1;j\u0026lt;=m;j++) {\rll temp=0;\rfor(ll i=1;i\u0026lt;=n;i++) if(s[i][j]=='*') temp|=(1\u0026lt;\u0026lt;i-1);\rcl[temp]++;\r}\rfor(ll i=1;i\u0026lt;=n;i++)\rfor(ll j=0;j\u0026lt;(1\u0026lt;\u0026lt;n);j++){\rif((j\u0026amp;(1\u0026lt;\u0026lt;i-1))==0) cl[j|1\u0026lt;\u0026lt;i-1]+=cl[j];\r}\rbool ok=false;\rfor(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;n);i++){\rif(__builtin_popcount(i)\u0026lt;=a and m-cl[i]\u0026lt;=b){\rok=true;break;\r}\r}\rif(ok) puts(\u0026quot;yes\u0026quot;);\relse puts(\u0026quot;no\u0026quot;);\r}\rreturn 0;\r}\r 这里用memset会迷之超时，要用for循环\n一个神奇的函数 __builtin_popcount(int x) 返回x的二进制1的个数\nB 阶乘 题目链接\n题解 二分 数论 用二分法获得最小值\n检测一个数n的阶乘是否能被p整除\n对p进行质因数分解\n遍历p的质因数\n如果对于所有的质因数\nn！被这个质因数整除的个数都不小于p中的个数\n那么n！就能被p整除\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll t;\rll p;\rll fac[1000005];\rll num[1000005];\rll tt;\rvoid decompose(ll p){\rtt=0;\rfor(ll i=2;i*i\u0026lt;=p;i++){\rif(p%i==0){\rfac[tt]=i;\rnum[tt]=0;\rwhile(p%i==0) p/=i,num[tt]++;\rtt++;\r}\r}\rif(p\u0026gt;1) {\rfac[tt]=p;num[tt]=1;tt++;\r}\r}\rbool check(ll x){\rfor(ll i=0;i\u0026lt;tt;i++){\rll cnt=0,t=x;\rwhile(t) {\rcnt+=t/fac[i];\rt/=fac[i];\r}\rif(cnt\u0026lt;num[i]) return false;\r}\rreturn true;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;p;\rdecompose(p);\rll l=1,r=1e10; //开1e6会wa\rwhile(l\u0026lt;r){\rll mid=l+r\u0026gt;\u0026gt;1;\rif(check(mid)) r=mid;\relse l=mid+1;\r}\rcout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r C 完全图 题目链接\n题解 二分 图论 规律 很容易能找到规律\n要分裂出 x 个连通块，就要拆掉 x*n-(x+1)*x/2 条边\n然后用二分找到 x\n注意 r 的初始值不大于 n\n据说解一元二次方程也可以，我随便写了个，失败了\n用python可以防溢出，但是我出现了2.9999999！=3的情况\n用c++就要用__int128防止爆long long\n不过__int128不能用标准输入输出\n一种解决方法是自己写输入输出\n但是这题只需要在特定的地方转成__int128就行\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing Int = __int128;\rusing ll = long long;\rll t,n,m;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rll l=0,r=n;\rll mid;\rfor(int i=0;i\u0026lt;10000;i++){\rmid=(l+r)/2;\rif(((Int)mid*n-(1+mid)*(Int)mid/2)\u0026lt;=(Int)m)\rl=mid;\relse\rr=mid;\r}\rcout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r D 病毒传染 题目链接\n题解 不会\nE A+B问题 题目链接\n题解 总共能表示的数有2^32个，每一个数都能找到另一个数与之相加等于答案\nac代码\n用PHP写的（求比这更短的代码）（再一次证明了PHP是世界上最好的语言）\n4294967296\r F 美丽的序列I 题目链接\n题解 不会\nG 树上求和 题目链接\n题解 图论 DFS 求出每条边对于所有的简单路径经过了几次\n然后按次数从大到小排序，依次赋值1,2,3\u0026hellip;\n求遍历次数就是求这条边的左右各有几个点，然后相乘\n对于每个点再递归求它的子节点\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll n;\rvector\u0026lt;ll\u0026gt; p[100005];\rll ch[100005];\rbool visit[100005];\rusing pll=pair\u0026lt;ll,ll\u0026gt;;\rvector\u0026lt;pll\u0026gt; vt;\rvector\u0026lt;ll\u0026gt; w;\rmap\u0026lt;pll,ll\u0026gt; mp;\rbool cmp(ll a,ll b){return a\u0026gt;b;}\rll dfs(ll k){\rvisit[k]=true;\rll ans=1;\rfor(auto it:p[k]){\rif(!visit[it]){\rans+=dfs(it);\r}\r}\rw.push_back(ans*(n-ans));\rreturn ans;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rll t1,t2;\rfor(ll i=0;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rp[t1].push_back(t2); ch[t1]++;\rp[t2].push_back(t1); ch[t2]++;\r}\rfor(ll i=1;i\u0026lt;=n;i++) ch[i]--;\rdfs(1);\rsort(w.begin(),w.end(),cmp);\rll i=1;\rll ans2=0;\rfor(auto it:w){\rans2+=it*i++;\r//cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;endl;\r}\rcout\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 用另外一种传入父节点的方法就超时，记忆化搜索也超时\n这是TLE/RE代码，不知道为什么错了（对80%），等有空或实力更强一点再看\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rll n;\rvector\u0026lt;ll\u0026gt; p[100005];\rll ch[100005];\rusing pll=pair\u0026lt;ll,ll\u0026gt;;\rvector\u0026lt;pll\u0026gt; vt;\rvector\u0026lt;ll\u0026gt; w;\rmap\u0026lt;pll,ll\u0026gt; mp;\rbool cmp(ll a,ll b){return a\u0026gt;b;}\rll dfs(ll k,ll par){\rif(mp[make_pair(k,par)]!=0) return mp[make_pair(k,par)];\rif(ch[k]==0) {mp[make_pair(k,par)]=0;return 0;} ll ans=0;\rans+=ch[k];\rfor(auto it:p[k]){\rif(it!=par){\rans+=dfs(it,k);\r}\r}\rmp[make_pair(k,par)]=ans;\rreturn ans;\r}\rll cal(ll x,ll y){\rll resx=dfs(x,y);\rll resy=dfs(y,x);\rreturn resx+resy+resx*resy+1;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rll t1,t2;\rfor(int i=0;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rp[t1].push_back(t2); ch[t1]++;\rp[t2].push_back(t1); ch[t2]++;\rvt.emplace_back(t1,t2);\r}\rfor(int i=1;i\u0026lt;=n;i++) ch[i]--;\rfor(int i=0;i\u0026lt;n-1;i++){\rw.push_back(cal(vt[i].first,vt[i].second));\r}\rsort(w.begin(),w.end(),cmp);\rll i=1;\rll ans2=0;\rfor(auto it:w){\rans2+=it*i++;\r}\rcout\u0026lt;\u0026lt;ans2\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r H 奇怪的背包问题增加了 题目链接\n题解 二进制 由二进制01串的性质可以发现\n如果物品总重量没有2^30就输出impossible\n否则从大到小排序，依次增加就可以\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll =long long;\rll t;\rll n;\rll num[100005];\rusing pll=pair\u0026lt;ll,ll\u0026gt;;\rint check[100005];\rint main(){\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rvector\u0026lt;pll\u0026gt; vt; //因为这个wa了好久\rcin\u0026gt;\u0026gt;n;\rll ans=0;\rll temp;\rfor(ll i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;temp;\rnum[i]=(1\u0026lt;\u0026lt;temp);\rvt.emplace_back(num[i],i);\rans+=num[i];\r}\rif(ans\u0026lt;(1\u0026lt;\u0026lt;30)) puts(\u0026quot;impossible\u0026quot;);\relse{\rsort(vt.begin(),vt.end(),greater\u0026lt;pll\u0026gt;());\rll ans=0;\rll i=0;\rll rr=(1\u0026lt;\u0026lt;30);\rfor(ll i=0;i\u0026lt;n;i++) check[i]=0;\rwhile(ans!=rr){\rans+=vt[i].first;\rcheck[vt[i].second]=1;\ri++;\r}\r//for(ll i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;vt[i].first\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rfor(ll i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;check[i];\rcout\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r 有个wa点，就是没有清空容器 T_T\nI 寻找字串 题目链接\n题解 枚举后缀，比较即可\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rvector\u0026lt;string\u0026gt; vt;\rstring s;\rbool cmp(string s1,string s2){\rreturn s1\u0026gt;s2;\r}\rint main(){\rcin\u0026gt;\u0026gt;s;\rint len=s.length();\rfor(int i=0;i\u0026lt;len;i++){\rvt.push_back(s.substr(i,len-i));\r}\rsort(vt.begin(),vt.end(),cmp);\rcout\u0026lt;\u0026lt;vt[0]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r J 最大的差 题目链接\n题解 最大值减最小值\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main(){\rint n;\rint mi=100005;\rint ma=-1;\rcin\u0026gt;\u0026gt;n;\rint t;\rfor(int i=0;i\u0026lt;n;i++){\rcin\u0026gt;\u0026gt;t;\rmi=min(t,mi);\rma=max(t,ma);\r}\rcout\u0026lt;\u0026lt;ma-mi\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 本次比赛官方说难度对标cf div2 a~c，可是根据大家的做题情况除签到题至少应该d吧\n不知道为什么有好多题都迷之超时\n总体来说，题目还行\n","id":11,"section":"posts","summary":"A 膜法记录 题目链接 题解 贪心 枚举 集合的整数表示 由于n的数据较小，直接枚举n的所有情况，有2^n种 对于每种情况判断剩下的点列blast能否用完 其","tags":["cpp","greedy","graph_theory","number_theory","binary","dfs"],"title":"牛客小白月赛23(部分题解)","uri":"https://dyhgo.github.io/2020/03/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B23%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","year":"2020"},{"content":"事件处理 基于监听的事件处理机制 匿名内部类 mbt1.setOnTouchListener(new View.OnTouchListener() {\r@Override\rpublic boolean onTouch(View v, MotionEvent event) {\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\u0026quot;listener\u0026quot;,\u0026quot;touch\u0026quot;);\rbreak;\r}\rreturn false;\r}\r});\r 事件源所在类（activity类） public class eventActivity extends AppCompatActivity implements View.OnClickListener\r ebt1 = findViewById(R.id.ebt1);\rebt1.setOnClickListener(eventActivity.this);\r @Override\rpublic void onClick(View v) {\rswitch (v.getId()){\rcase R.id.ebt1:\rToast.makeText(eventActivity.this , \u0026quot;click...\u0026quot;,Toast.LENGTH_LONG).show();\rbreak;\r}\r}\r 在布局文件中设置 \u0026lt;Button\randroid:id=\u0026quot;@+id/ebt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;click\u0026quot;\randroid:textSize=\u0026quot;20sp\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\randroid:layout_marginTop=\u0026quot;50dp\u0026quot;\randroid:onClick=\u0026quot;show\u0026quot;\r/\u0026gt;\r public void show(View view){ //一定是public void\rswitch (view.getId()){\rcase R.id.ebt1:\rToast.makeText(eventActivity.this , \u0026quot;click...\u0026quot;,Toast.LENGTH_LONG).show();\rbreak;\r}\r}\r 基于回调的事件处理机制 布局文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.eventActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/ebt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;click\u0026quot;\randroid:textSize=\u0026quot;20sp\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\randroid:layout_marginTop=\u0026quot;50dp\u0026quot;\r/\u0026gt;\r\u0026lt;com.example.test.Mybotton\randroid:id=\u0026quot;@+id/mbt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;20sp\u0026quot;\randroid:text=\u0026quot;Mybotton\u0026quot;\randroid:textAllCaps=\u0026quot;false\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/ebt1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r Mybotton类\npackage com.example.test;\rimport android.content.Context;\rimport android.util.AttributeSet;\rimport android.util.Log;\rimport android.view.MotionEvent;\rimport android.widget.Button;\rimport androidx.appcompat.widget.AppCompatButton;\rpublic class Mybotton extends AppCompatButton {\rpublic Mybotton(Context context) {\rsuper(context);\r}\rpublic Mybotton(Context context, AttributeSet attrs) {\rsuper(context, attrs);\r}\rpublic Mybotton(Context context, AttributeSet attrs, int defStyleAttr) {\rsuper(context, attrs, defStyleAttr);\r}\r@Override\rpublic boolean onTouchEvent(MotionEvent event) {\rsuper.onTouchEvent(event);\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\u0026quot;Mybotton\u0026quot;,\u0026quot;touch\u0026quot;);\rbreak;\r}\rreturn false; //return true即onTouchEvent到此终止\r}\r}\r eventactivity.java\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.util.Log;\rimport android.view.MotionEvent;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.Toast;\rpublic class eventActivity extends AppCompatActivity {\rprivate Button ebt1;\rprivate Mybotton mbt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_event);\rmbt1 = findViewById(R.id.mbt1);\rmbt1.setOnTouchListener(new View.OnTouchListener() {\r@Override\rpublic boolean onTouch(View v, MotionEvent event) {\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\u0026quot;listener\u0026quot;,\u0026quot;touch\u0026quot;);\rbreak;\r}\rreturn false;\r}\r});\r// ebt1 = findViewById(R.id.ebt1);\r// ebt1.setOnClickListener(eventActivity.this);\r}\r// @Override\r// public void onClick(View v) {\r// switch (v.getId()){\r// case R.id.ebt1:\r// Toast.makeText(eventActivity.this , \u0026quot;click...\u0026quot;,Toast.LENGTH_LONG).show();\r// break;\r// }\r// }\r// public void show(View view){ //一定是public void\r// switch (view.getId()){\r// case R.id.ebt1:\r// Toast.makeText(eventActivity.this , \u0026quot;click...\u0026quot;,Toast.LENGTH_LONG).show();\r// break;\r// }\r// }\r@Override\rpublic boolean onTouchEvent(MotionEvent event) {\rsuper.onTouchEvent(event);\rswitch (event.getAction()){\rcase MotionEvent.ACTION_DOWN:\rLog.d(\u0026quot;activity\u0026quot;,\u0026quot;touch\u0026quot;);\rbreak;\r}\rreturn false;\r}\r}\r 触摸Mybotton触发事件\n","id":12,"section":"posts","summary":"事件处理 基于监听的事件处理机制 匿名内部类 mbt1.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()){ case MotionEvent.ACTION_DOWN: Log.d(\u0026quot;listener\u0026quot;,\u0026quot;touch\u0026quot;); break; } return false; } }); 事件源所在类（activity类） public class eventActivity extends AppCompatActivity implements View.OnClickListener ebt1 = findViewById(R.id.ebt1); ebt1.setOnClickListener(eventActivity.this);","tags":["java","xml"],"title":"Android 事件处理机制","uri":"https://dyhgo.github.io/2020/03/android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","year":"2020"},{"content":"Activity activity的生命周期 运行以下代码可以看到activity经历的生命周期\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.os.Bundle;\rimport android.util.Log;\rpublic class lifeCircleActivity extends AppCompatActivity {\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_life_circle);\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onCreate----\u0026quot;);\r}\r@Override\rprotected void onStart() {\rsuper.onStart();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onStart----\u0026quot;);\r}\r@Override\rprotected void onResume() {\rsuper.onResume();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onResume----\u0026quot;);\r}\r@Override\rprotected void onPause() {\rsuper.onPause();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onPause----\u0026quot;);\r}\r@Override\rprotected void onStop() {\rsuper.onStop();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onStop----\u0026quot;);\r}\r@Override\rprotected void onRestart() {\rsuper.onRestart();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onRestart----\u0026quot;);\r}\r@Override\rprotected void onDestroy() {\rsuper.onDestroy();\rLog.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onDestroy----\u0026quot;);\r}\r}\r 启动这个activity之后\n按返回键退出activity\n再启动activity,并按主页键或者菜单键\n在cache中重新进入activity\nactivity之间的跳转 方法有很多\n以下是设置点击事件来跳转\nprivate Button bt11;\rbt11 = findViewById(R.id.bt11);\rbt11.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(MainActivity.this , broadActivity.class);\rstartActivity(intent);\r}\r});\r 隐式intent 目标activity在manifest文件中应这样注册\n\u0026lt;activity android:name=\u0026quot;.implicitIntentActivity\u0026quot;\u0026gt;\r\u0026lt;intent-filter\u0026gt;\r\u0026lt;action android:name=\u0026quot;com.example.test.124\u0026quot;/\u0026gt;\r\u0026lt;category android:name=\u0026quot;android.intent.category.DEFAULT\u0026quot;/\u0026gt;\r\u0026lt;/intent-filter\u0026gt;\r\u0026lt;/activity\u0026gt;\r 点击事件的设置\nbt14 = findViewById(R.id.bt14);\rbt14.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent();\rintent.setAction(\u0026quot;com.example.test.124\u0026quot;);\rstartActivity(intent);\r}\r});\r activity之间的数据传输 将activity的数据传输到目标activity 发送数据 @Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump);\rjumpbt1 = findViewById(R.id.jumpbt1);\rjumpbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(jumpActivity.this , jump2Activity.class);\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;name\u0026quot;,\u0026quot;henry\u0026quot;);\rbundle.putInt(\u0026quot;number\u0026quot;,11);\rintent.putExtras(bundle);\rstartActivity(intent);\r//startActivityForResult(intent,0); //写在点击事件里\r}\r});\r}\r 接收数据并呈现 @Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump2);\rjump2tv1 = findViewById(R.id.jump2tv1);\rBundle bundle = new Bundle();\rbundle = getIntent().getExtras();\rString name = bundle.getString(\u0026quot;name\u0026quot;);\rint number = bundle.getInt(\u0026quot;number\u0026quot;);\rjump2tv1.setText(name+\u0026quot;,\u0026quot;+number);}\r 启动一个activity,结束后返回结果 jump界面\njump2界面\n点击back返回结果（一个toast）\njumpactivity\npackage com.example.test;\rimport androidx.annotation.Nullable;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.Toast;\rpublic class jumpActivity extends AppCompatActivity {\rprivate Button jumpbt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump);\rjumpbt1 = findViewById(R.id.jumpbt1);\rjumpbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(jumpActivity.this , jump2Activity.class);\rBundle bundle = new Bundle();\rbundle.putString(\u0026quot;name\u0026quot;,\u0026quot;henry\u0026quot;);\rbundle.putInt(\u0026quot;number\u0026quot;,11);\rintent.putExtras(bundle);\r//startActivity(intent);\rstartActivityForResult(intent,0); //写在点击事件里\r}\r});\r}\r@Override\rprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\rsuper.onActivityResult(requestCode, resultCode, data);\rToast.makeText(jumpActivity.this,data.getExtras().getString(\u0026quot;msg\u0026quot;),Toast.LENGTH_LONG).show() ;\r}\r}\r jump2activity\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.app.Activity;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rpublic class jump2Activity extends AppCompatActivity {\rprivate TextView jump2tv1;\rprivate Button jump2bt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_jump2);\rjump2tv1 = findViewById(R.id.jump2tv1);\rBundle bundle = new Bundle();\rbundle = getIntent().getExtras();\rString name = bundle.getString(\u0026quot;name\u0026quot;);\rint number = bundle.getInt(\u0026quot;number\u0026quot;);\rjump2tv1.setText(name+\u0026quot;,\u0026quot;+number);\rjump2bt1 = findViewById(R.id.jump2bt1);\rjump2bt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent();\rBundle bundle1 = new Bundle();\rbundle1.putString(\u0026quot;msg\u0026quot;,\u0026quot;i'm back\u0026quot;);\rintent.putExtras(bundle1);\rsetResult(Activity.RESULT_OK,intent);\rfinish();\r}\r});\r}\r}\r ","id":13,"section":"posts","summary":"Activity activity的生命周期 运行以下代码可以看到activity经历的生命周期 package com.example.test; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; public class lifeCircleActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_life_circle); Log.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onCreate----\u0026quot;); } @Override protected void onStart() { super.onStart(); Log.d(\u0026quot;lifecircle\u0026quot;,\u0026quot;-----onStart----\u0026quot;);","tags":["java","xml"],"title":"Android 四大组件之Activity","uri":"https://dyhgo.github.io/2020/03/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bactivity/","year":"2020"},{"content":"Broadcast Receiver 通过LoaclBroadcastManager发送广播并接收广播 点击broadactivity的click,跳转到broad2activity\n点击broad2activity的clickme,发送广播\nbroadactivity接收广播，将abc改成123\nbroadactivity\nbroad2activity\n点击clickme后返回到broadactivity\n代码\nbroadactivity_xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.broad.broadActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/bcbt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\randroid:layout_marginTop=\u0026quot;40dp\u0026quot;\randroid:textSize=\u0026quot;30sp\u0026quot;\randroid:text=\u0026quot;click\u0026quot;/\u0026gt;\r\u0026lt;TextView\randroid:id=\u0026quot;@+id/bctv1\u0026quot;\randroid:layout_width=\u0026quot;wrap_content\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;abc\u0026quot;\randroid:textSize=\u0026quot;60sp\u0026quot;\rapp:layout_constraintBottom_toBottomOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/bcbt1\u0026quot;\rapp:layout_constraintLeft_toLeftOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintRight_toRightOf=\u0026quot;parent\u0026quot;\rapp:layout_constraintVertical_bias=\u0026quot;0.3\u0026quot;\r/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r broadactivity_java\npackage com.example.test.broad;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\rimport android.content.BroadcastReceiver;\rimport android.content.Context;\rimport android.content.Intent;\rimport android.content.IntentFilter;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.TextView;\rimport com.example.test.R;\rpublic class broadActivity extends AppCompatActivity {\rprivate Button bcbt1;\rprivate TextView bctv1;\rprivate Mybroad mybroad;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_broad);\rbcbt1 = findViewById(R.id.bcbt1);\rbctv1 = findViewById(R.id.bctv1);\rbcbt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(broadActivity.this , broad2Activity.class);\rstartActivity(intent);\r}\r});\rmybroad = new Mybroad();\rIntentFilter intentFilter = new IntentFilter();\rintentFilter.addAction(\u0026quot;sss\u0026quot;);\rLocalBroadcastManager.getInstance(broadActivity.this).registerReceiver(mybroad,intentFilter);\r}\rprivate class Mybroad extends BroadcastReceiver{\r@Override\rpublic void onReceive(Context context, Intent intent) {\r//接收到广播要处理的事\rswitch(intent.getAction()){\rcase \u0026quot;sss\u0026quot;:\rbctv1.setText(\u0026quot;123\u0026quot;);\rbreak;\r}\r}\r}\r@Override\rprotected void onDestroy() {\rsuper.onDestroy();\rLocalBroadcastManager.getInstance(broadActivity.this).unregisterReceiver(mybroad);\r}\r}\r broad2activity_xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.broad.broad2Activity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/bc2bt1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\rapp:layout_constraintTop_toTopOf=\u0026quot;parent\u0026quot;\randroid:layout_marginTop=\u0026quot;30dp\u0026quot;\randroid:textSize=\u0026quot;30sp\u0026quot;\randroid:text=\u0026quot;click me\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r broad2activity_java\npackage com.example.test.broad;\rimport androidx.appcompat.app.AppCompatActivity;\rimport androidx.localbroadcastmanager.content.LocalBroadcastManager;\rimport android.content.Intent;\rimport android.os.Bundle;\rimport android.view.View;\rimport android.widget.Button;\rimport com.example.test.R;\rpublic class broad2Activity extends AppCompatActivity {\rprivate Button bc2bt1;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_broad2);\rbc2bt1 = findViewById(R.id.bc2bt1);\rbc2bt1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(\u0026quot;sss\u0026quot;);\rLocalBroadcastManager.getInstance(broad2Activity.this).sendBroadcast(intent);\r}\r});\r}\r}\r 一些系统操作对应的action ","id":14,"section":"posts","summary":"Broadcast Receiver 通过LoaclBroadcastManager发送广播并接收广播 点击broadactivity的click,跳转到broad2activ","tags":["java","xml"],"title":"Android 四大组件之Broadcast Receiver","uri":"https://dyhgo.github.io/2020/03/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bbroadcast-receiver/","year":"2020"},{"content":"Content Provider 获取外部应用的信息 以获取通讯录为例 布局文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.contentProviderActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/cpbtn1\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;\randroid:text=\u0026quot;get_contacts\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:id=\u0026quot;@+id/cpbtn2\u0026quot;\randroid:text=\u0026quot;getdata\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/cpbtn1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r 点击get_contacts获取联系人信息\n手机里存储的联系人信息\n在manifest里获取权限\n\u0026lt;uses-permission android:name=\u0026quot;android.permission.READ_CONTACTS\u0026quot; /\u0026gt;\r 利用content resolver获取\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ContentResolver;\rimport android.database.Cursor;\rimport android.net.Uri;\rimport android.os.Bundle;\rimport android.provider.ContactsContract;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport java.util.HashSet;\rimport java.util.List;\rpublic class contentProviderActivity extends AppCompatActivity {\rprivate Button cpbtn1,cpbtn2;\r//private List\u0026lt;String\u0026gt; contactlist=null;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_content_provider);\rcpbtn1 = findViewById(R.id.cpbtn1);\rcpbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rContentResolver contentResolver = getContentResolver();\rCursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);\rwhile(cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\rString number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\rLog.d(\u0026quot;tag\u0026quot;,name+\u0026quot; \u0026quot;+number);\r//contactlist.add(name+\u0026quot; \u0026quot;+number);\r}\rcursor.close();\r//System.out.println(contactlist.toString());\r}\r});\r// }\r}\r 获取到的信息\n获取系统权限指令大全 点击此处\n提供自己的应用信息 在sqlite数据库中创建表\npackage com.example.test;\rimport android.content.Context;\rimport android.database.sqlite.SQLiteDatabase;\rimport android.database.sqlite.SQLiteOpenHelper;\rimport androidx.annotation.Nullable;\rpublic class Myopenhelper extends SQLiteOpenHelper {\rprivate static final String CREATE_TABLE_PERSON = \u0026quot;create table person (id integer primary key autoincrement,name text,age integer)\u0026quot;;\rpublic Myopenhelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) {\rsuper(context, name, factory, version);\r}\r@Override\rpublic void onCreate(SQLiteDatabase db) {\rdb.execSQL(CREATE_TABLE_PERSON);\r}\r@Override\rpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\r}\r}\r 插入数据，提供content provider\npackage com.example.test;\rimport android.content.ContentProvider;\rimport android.content.ContentValues;\rimport android.content.UriMatcher;\rimport android.database.Cursor;\rimport android.database.sqlite.SQLiteDatabase;\rimport android.database.sqlite.SQLiteOpenHelper;\rimport android.net.Uri;\rimport androidx.annotation.NonNull;\rimport androidx.annotation.Nullable;\rpublic class Myprovider extends ContentProvider {\rprivate static final String PACKAGE_NAME = \u0026quot;com.example.test\u0026quot;;\rprivate static UriMatcher uriMatcher;\rprivate Myopenhelper myopenhelper;\rprivate SQLiteDatabase sqLiteDatabase;\rstatic {\ruriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\ruriMatcher.addURI(PACKAGE_NAME,\u0026quot;person\u0026quot;,0);\r}\r@Override\rpublic boolean onCreate() {\rmyopenhelper = new Myopenhelper(getContext(),\u0026quot;database\u0026quot;,null,1);\rsqLiteDatabase = myopenhelper.getWritableDatabase();\rContentValues contentValues = new ContentValues();\rcontentValues.put(\u0026quot;name\u0026quot;,\u0026quot;jingjing\u0026quot;);\rcontentValues.put(\u0026quot;age\u0026quot;,15);\rsqLiteDatabase.insert(\u0026quot;person\u0026quot;,null,contentValues);\rcontentValues.put(\u0026quot;name\u0026quot;,\u0026quot;kakulukia\u0026quot;);\rcontentValues.put(\u0026quot;age\u0026quot;,15);\rsqLiteDatabase.insert(\u0026quot;person\u0026quot;,null,contentValues);\rreturn true;\r}\r@Nullable\r@Override\rpublic Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {\rint code = uriMatcher.match(uri);\rswitch (code){\rcase 0:\rCursor cursor = sqLiteDatabase.query(\u0026quot;person\u0026quot;,null,null,null,null,null,null);\rreturn cursor;\r}\rreturn null;\r}\r@Nullable\r@Override\rpublic String getType(@NonNull Uri uri) {\rreturn null;\r}\r@Nullable\r@Override\rpublic Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {\rreturn null;\r}\r@Override\rpublic int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {\rreturn 0;\r}\r@Override\rpublic int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {\rreturn 0;\r}\r}\r 在manifest注册\n\u0026lt;provider\randroid:name=\u0026quot;.Myprovider\u0026quot;\randroid:authorities=\u0026quot;com.example.test\u0026quot;\randroid:exported=\u0026quot;true\u0026quot; /\u0026gt;\r 到此已经提供了自己的应用信息\n现在通过点击“get_data”来查询（利用content resolver）\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ContentResolver;\rimport android.database.Cursor;\rimport android.net.Uri;\rimport android.os.Bundle;\rimport android.provider.ContactsContract;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport java.util.HashSet;\rimport java.util.List;\rpublic class contentProviderActivity extends AppCompatActivity {\rprivate Button cpbtn1,cpbtn2;\r//private List\u0026lt;String\u0026gt; contactlist=null;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_content_provider);\rcpbtn1 = findViewById(R.id.cpbtn1);\rcpbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rContentResolver contentResolver = getContentResolver();\rCursor cursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null);\rwhile(cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));\rString number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));\rLog.d(\u0026quot;tag\u0026quot;,name+\u0026quot; \u0026quot;+number);\r//contactlist.add(name+\u0026quot; \u0026quot;+number);\r}\rcursor.close();\r//System.out.println(contactlist.toString());\r}\r});\rcpbtn2 = findViewById(R.id.cpbtn2);\rcpbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rUri uri = Uri.parse(\u0026quot;content://com.example.test/person\u0026quot;);\rCursor cursor = getContentResolver().query(uri,null,null,null,null,null);\rwhile (cursor.moveToNext()){\rString name = cursor.getString(cursor.getColumnIndex(\u0026quot;name\u0026quot;));\rint age = cursor.getInt(cursor.getColumnIndex(\u0026quot;age\u0026quot;));\rLog.d(\u0026quot;tag\u0026quot;,name+\u0026quot; \u0026quot;+age);\r}\rcursor.close();\r}\r});\r}\r}\r 查询到的信息\n如果重复运行，会在数据库中一直添加数据\n","id":15,"section":"posts","summary":"Content Provider 获取外部应用的信息 以获取通讯录为例 布局文件 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; xmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot; xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;match_parent\u0026quot; tools:context=\u0026quot;.contentProviderActivity\u0026quot;\u0026gt; \u0026lt;Button android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/cpbtn1\u0026quot; android:textSize=\u0026quot;25sp\u0026quot; android:text=\u0026quot;get_contacts\u0026quot;/\u0026gt; \u0026lt;Button android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/cpbtn2\u0026quot; android:text=\u0026quot;getdata\u0026quot; android:textSize=\u0026quot;25dp\u0026quot; app:layout_constraintTop_toBottomOf=\u0026quot;@+id/cpbtn1\u0026quot; android:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 点击get_contacts获取联系人信息 手","tags":["java","xml"],"title":"Android 四大组件之Content Provider","uri":"https://dyhgo.github.io/2020/03/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bcontent-provider/","year":"2020"},{"content":"Service Service的生命周期 通过启动Service传递数据 在serviceactivity的输入框中输入数据，启动Myservice并传递数据，打印到日志\nserviceactivity_xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\rxmlns:app=\u0026quot;http://schemas.android.com/apk/res-auto\u0026quot;\rxmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;match_parent\u0026quot;\rtools:context=\u0026quot;.serviceActivity\u0026quot;\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:text=\u0026quot;startservice\u0026quot;\randroid:textSize=\u0026quot;25sp\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn2\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\randroid:text=\u0026quot;stopservice\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/sbtn1\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn3\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\randroid:text=\u0026quot;bindservice\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/sbtn2\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn4\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\randroid:text=\u0026quot;unbindservice\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/sbtn3\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;EditText\randroid:id=\u0026quot;@+id/set1\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/sbtn4\u0026quot;\randroid:textSize=\u0026quot;20sp\u0026quot;\randroid:layout_marginTop=\u0026quot;20dp\u0026quot;/\u0026gt;\r\u0026lt;Button\randroid:id=\u0026quot;@+id/sbtn5\u0026quot;\randroid:layout_width=\u0026quot;match_parent\u0026quot;\randroid:layout_height=\u0026quot;wrap_content\u0026quot;\randroid:textSize=\u0026quot;25dp\u0026quot;\randroid:text=\u0026quot;syncdata\u0026quot;\rapp:layout_constraintTop_toBottomOf=\u0026quot;@+id/set1\u0026quot;\randroid:layout_marginTop=\u0026quot;30dp\u0026quot;/\u0026gt;\r\u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;\r serviceactivity.java\nsbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rintent.putExtra(\u0026quot;data\u0026quot;,set1.getText().toString());\rstartService(intent);\r}\r});\r Myservice.java\nprivate String data=\u0026quot;cat\u0026quot;;\rprivate boolean running=false;\r @Override\rpublic int onStartCommand(Intent intent, int flags, int startId) {\rdata = intent.getStringExtra(\u0026quot;data\u0026quot;);\r//Log.d(\u0026quot;tag\u0026quot;,data);\rreturn super.onStartCommand(intent, flags, startId);\r}\r @Override\rpublic void onCreate() {\rsuper.onCreate();\r//Log.d(\u0026quot;tag\u0026quot;,data);\rrunning=true;\rnew Thread(){\r@Override\rpublic void run() {\rsuper.run();\rwhile (running){\rSystem.out.println(data);\rtry {\rsleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}.start();\r}\r 通过绑定来同步数据 点击bindservice\n输入数据，点击syncdata\nservice.java\npackage com.example.test;\rimport androidx.appcompat.app.AppCompatActivity;\rimport android.content.ComponentName;\rimport android.content.Context;\rimport android.content.Intent;\rimport android.content.ServiceConnection;\rimport android.os.Bundle;\rimport android.os.IBinder;\rimport android.util.Log;\rimport android.view.View;\rimport android.widget.Button;\rimport android.widget.EditText;\rpublic class serviceActivity extends AppCompatActivity implements ServiceConnection {\rprivate Button sbtn1,sbtn2,sbtn3,sbtn4;\rprivate EditText set1;\rprivate Button sbtn5;\rprivate MyService.mybinder binder;\r@Override\rprotected void onCreate(Bundle savedInstanceState) {\rsuper.onCreate(savedInstanceState);\rsetContentView(R.layout.activity_service);\rsbtn1 = findViewById(R.id.sbtn1);\rsbtn2 = findViewById(R.id.sbtn2);\rsbtn3 = findViewById(R.id.sbtn3);\rsbtn4 = findViewById(R.id.sbtn4);\rset1 = findViewById(R.id.set1);\rsbtn5 = findViewById(R.id.sbtn5);\rsbtn1.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rintent.putExtra(\u0026quot;data\u0026quot;,set1.getText().toString());\rstartService(intent);\r}\r});\rsbtn2.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rstopService(intent);\r}\r});\rsbtn3.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rIntent intent = new Intent(serviceActivity.this , MyService.class);\rbindService(intent,serviceActivity.this, Context.BIND_AUTO_CREATE);\r}\r});\rsbtn4.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\r//Intent intent = new Intent(serviceActivity.this,MyService.class);\runbindService(serviceActivity.this);\r}\r});\rsbtn5.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rif(binder!=null){\rbinder.setdata(set1.getText().toString());\r//System.out.println(MyService.data);\r}\r}\r});\r}\r@Override\rpublic void onServiceConnected(ComponentName name, IBinder service) {\rLog.d(\u0026quot;service123\u0026quot;,\u0026quot;connected123\u0026quot;);\rbinder = (MyService.mybinder) service;\r}\r@Override\rpublic void onServiceDisconnected(ComponentName name) {\r}\r}\r Myservive.java\npackage com.example.test;\rimport android.app.Service;\rimport android.content.Intent;\rimport android.os.Binder;\rimport android.os.IBinder;\rimport android.util.Log;\rpublic class MyService extends Service {\rprivate String data=\u0026quot;cat\u0026quot;;\rprivate boolean running=false;\rpublic MyService() {\r}\r@Override\rpublic IBinder onBind(Intent intent) {\r// TODO: Return the communication channel to the service.\r//throw new UnsupportedOperationException(\u0026quot;Not yet implemented\u0026quot;);\r//return new Binder();\rreturn new mybinder();\r}\rpublic class mybinder extends Binder{ //是binder不是 ibinder\rpublic void setdata(String data){\rMyService.this.data = data;\r}\r}\r@Override\rpublic int onStartCommand(Intent intent, int flags, int startId) {\r//data = intent.getStringExtra(\u0026quot;data\u0026quot;);\r//Log.d(\u0026quot;tag\u0026quot;,data);\rreturn super.onStartCommand(intent, flags, startId);\r}\r@Override\rpublic boolean onUnbind(Intent intent) {\rreturn super.onUnbind(intent);\r}\r@Override\rpublic void onCreate() {\rsuper.onCreate();\r//Log.d(\u0026quot;tag\u0026quot;,data);\rrunning=true;\rnew Thread(){\r@Override\rpublic void run() {\rsuper.run();\rwhile (running){\rSystem.out.println(data);\rtry {\rsleep(1000);\r} catch (InterruptedException e) {\re.printStackTrace();\r}\r}\r}\r}.start();\r}\r@Override\rpublic void onDestroy() {\rsuper.onDestroy();\rLog.d(\u0026quot;tag\u0026quot;,\u0026quot;dog\u0026quot;);\rrunning=false;\r}\r}\r 在manifest里的注册 \u0026lt;activity\randroid:name=\u0026quot;.serviceActivity\u0026quot;\randroid:exported=\u0026quot;true\u0026quot; /\u0026gt;\r\u0026lt;service\randroid:name=\u0026quot;.MyService\u0026quot;\randroid:enabled=\u0026quot;true\u0026quot;\randroid:exported=\u0026quot;true\u0026quot; /\u0026gt;\r ","id":16,"section":"posts","summary":"Service Service的生命周期 通过启动Service传递数据 在serviceactivity的输入框中输入数据，启动Myservice并传递数据","tags":["java","xml"],"title":"Android 四大组件之Service","uri":"https://dyhgo.github.io/2020/03/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8Bservice/","year":"2020"},{"content":"Number Sequence Problem Description Given two sequences of numbers : a[1], a[2], \u0026hellip;\u0026hellip; , a[N], and b[1], b[2], \u0026hellip;\u0026hellip; , b[M] (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], \u0026hellip;\u0026hellip; , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.\nInput The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). The second line contains N integers which indicate a[1], a[2], \u0026hellip;\u0026hellip; , a[N]. The third line contains M integers which indicate b[1], b[2], \u0026hellip;\u0026hellip; , b[M]. All integers are in the range of [-1000000, 1000000].\nOutput For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead.\nSample Input 2 13 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 1 313 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 2 1Sample Output 6-1\nSolution 测一下kmp板子\nac代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n,m,t;\rint s[1000005];\rint p[10005];\rint nextt[10005];\rvoid get_next(){\rint i=0,j=-1;\rnextt[0]=-1;\rwhile(i\u0026lt;m){\rif(j==-1 || p[i]==p[j]) nextt[++i]=++j;\relse j=nextt[j]; //!!!\r}\r}\rint kmp(){\rint i=0,j=0;\rwhile(1){\rif(s[i]==p[j]) i++,j++;\relse{\rint t=nextt[j];\rif(t==-1) i++,j=0;\relse j=t;\r}\rif(j\u0026gt;=m) return i-m+1; //根据题目要求返回 if(i\u0026gt;=n) return -1;\r}\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(0);cin.tie(0);\rcin\u0026gt;\u0026gt;t;\rwhile(t--){\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;s[i];\rfor(int i=0;i\u0026lt;m;i++) cin\u0026gt;\u0026gt;p[i];\rget_next();\rcout\u0026lt;\u0026lt;kmp()\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r ","id":17,"section":"posts","summary":"Number Sequence Problem Description Given two sequences of numbers : a[1], a[2], \u0026hellip;\u0026hellip; , a[N], and b[1], b[2], \u0026hellip;\u0026hellip; , b[M] (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], \u0026hellip;\u0026hellip; , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.","tags":["cpp","string"],"title":"hduoj1711(kmp)","uri":"https://dyhgo.github.io/2020/03/hduoj1711kmp/","year":"2020"},{"content":"A. EhAb AnD gCd 题意 给一正整数x，求正整数a,b满足gcd(a,b)+lcm(a,b)=x\n题解 数论思维题，a=1，b=x-1满足条件\nac代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint main(){\rint t;\rcin\u0026gt;\u0026gt;t;\rwhile(t--) {\rint k;\rcin\u0026gt;\u0026gt;k;\rcout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;k-1\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r B. CopyCopyCopyCopyCopy 题意 给一数列，将数列无限复制，求最长严格单调子序列的个数\n题解 计算数列有多少种数字就行\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll =long long;\rll t;\rll n;\rset\u0026lt;ll\u0026gt; st;\rll tmp;\rinline ll read(){\rll x=0;ll f=1;char s=getchar();\rwhile(s\u0026lt;'0' or s\u0026gt;'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u0026gt;='0' and s\u0026lt;='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\tcin\u0026gt;\u0026gt;t;\rwhile(t--){\rst.clear();\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++){\rtmp=read();\rst.insert(tmp);\r} cout\u0026lt;\u0026lt;st.size()\u0026lt;\u0026lt;endl; }\treturn 0;\r}\r C. Ehab and Path-etic MEXs 题意 给一棵n个节点的树，求边权重的赋值方案（权重为0~n-2互异）\n使得max(mex(u,v))最小\n其中mex(u,v)为连接顶点u,v的简单路径中“不”包含边权重的最小值\n题解 当树为一条链时，随便赋值\n否则，树必然有一个顶点的度数为3\n所有简单路径中必然经过0和1的边\n要让最大值最小，就要让所有简单路径不同时存在0，1，2的边（这样max(mex)=2）\n只需要把0，1，2分散在三度顶点的三条边上\n其他随便赋值\n以第2个样例为例\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rint deg[100005];\rusing pii=pair\u0026lt;int,int\u0026gt;;\rvector\u0026lt;pii\u0026gt; vt;\rbool lis;\r//bool lef;\rint p;\rint main(){\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(0);cin.tie(0);\rlis=true;\rcin\u0026gt;\u0026gt;n;\rfor(int i=0,t1,t2;i\u0026lt;n-1;i++){\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\r//if(t1\u0026gt;t2) swap(t1,t2);\rdeg[t1]++;\rdeg[t2]++;\rvt.emplace_back(t1,t2);\r}\rfor(int i=1;i\u0026lt;=n;i++) {\rif(deg[i]\u0026gt;2){\rlis=false;\rp=i;\rbreak;\r}\r}\rif(lis){\rfor(int i=0;i\u0026lt;n-1;i++) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl;\r}\relse{\rint a=0,b=3;\rfor(int i=0;i\u0026lt;n-1;i++){\rif((vt[i].first==p or vt[i].second==p ) and (a\u0026lt;3)){\rcout\u0026lt;\u0026lt;a++\u0026lt;\u0026lt;endl;\r}\relse cout\u0026lt;\u0026lt;b++\u0026lt;\u0026lt;endl;\r}\t}\rreturn 0;\r}\r D. Ehab the Xorcist 题意 Given 2 integers u and v, find the shortest array such that bitwise-xor of its elements is u, and the sum of its elements is v.\n题解 如果是3个数，则这3个数可以是u , (v-u)/2 , (v-u)/2 (利用异或性质)\n如果是2个数，p，q\n则考虑p+q和p^q的关系\n利用以下性质可求得p,q\n注意题目说的正整数和样例，进行特判\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing ll = long long;\rusing namespace std;\rll u,v;\rint main(){\rcin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\rif((v-u)\u0026amp;1 || v-u\u0026lt;0) puts(\u0026quot;-1\u0026quot;);\relse if(v==0 \u0026amp;\u0026amp; u==0) puts(\u0026quot;0\u0026quot;);\relse if(v==u) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;u;\relse{\rll p=(v-u)/2;\rll q=u^p;\rif(p+q==v) cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;q\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;u\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl;\r} return 0;\r}\r E. Ehab\u0026rsquo;s REAL Number Theory Problem 题意 不懂\n题解 不会\nF. Ehab\u0026rsquo;s Last Theorem 题意 不懂\n题解 不会\n","id":18,"section":"posts","summary":"A. EhAb AnD gCd 题意 给一正整数x，求正整数a,b满足gcd(a,b)+lcm(a,b)=x 题解 数论思维题，a=1，b=x-1满足条件 ac代码 #include\u0026lt;iostream\u0026gt; using namespace std;","tags":["cpp","number_theory","greedy"],"title":"Codeforces Round #628 (Div. 2) A~D","uri":"https://dyhgo.github.io/2020/03/codeforces-round-628-div.-2-a~d/","year":"2020"},{"content":"二进制转十进制 除2取余\n十进制转二进制 乘2次幂\n小数进制转换 e.g.\n3.59375\n整数部分3的二进制位11\n小数部分0.59375\n0.59375*2=1.1875 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; 10.1875*2=0.375 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;00.375*2=0.75 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;00.75*2=1.5 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;10.5*2=1 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;1二进制位0.10011\n所以3.59375的二进制表示为11.10011\n有些小数不能测出现循环\nIEEE754标准的浮点数与十进制数的转换 32位和64位标准 通过全1和全0来划定它的表示范围\nE.G. 原码 即正常的二进制码（带符号位）\n补码 正数（包括+0）的补码和原码一样\n负数（包括-0）的补码在原码的基础上“按位取反，末尾加1”\n补码转原码的一种方法\n还可以用逆过程法，即减1取反\n反码 正数（包括+0）的补码和原码一样\n负数（包括-0）的补码在原码的基础上“按位取反”\n补码的加法运算 补码的减法运算 ","id":19,"section":"posts","summary":"二进制转十进制 除2取余 十进制转二进制 乘2次幂 小数进制转换 e.g. 3.59375 整数部分3的二进制位11 小数部分0.59375 0.59375*2=1.1875 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; 10.1875*2=0.375 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;00.375*2=0.75 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;00.75*2=1.5 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;10.5*2=1 \u0026mdash;\u0026mda","tags":["binary"],"title":"二进制编码","uri":"https://dyhgo.github.io/2020/03/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/","year":"2020"},{"content":"A. Yet Another Tetris Problem link B. Yet Another Palindrome Problem link C. Frog Jumps link D. Pair of Topics link E. Sleeping Schedule link 题意 假设一天有h个小时，DIO一共要睡n次，每次睡ai个小时（按顺序睡觉），每次刚睡醒，就要继续睡觉，一直睡下去，直至睡眠次数耗光。\n给定一个一天中的区间[l,r]，如果有一次睡醒时刻在区间内，则这次睡眠为“好睡眠”\n对于每次睡眠时间ai,可以选择睡ai小时或ai-1小时\n问一开始就进行睡眠的情况下，“好睡眠”的次数最多有几次\n题解 动态规划\ndp[i][j]\ni表示已经进行了i次睡眠\nj表示现在在时刻j\ndp表示最大“好睡眠”次数\n初始化 ：dp[i][j]=-inf , dp[0][0]=0\n分别讨论下面两种情况\nto=(j+a[i])%h\nto=(j+a[i]-1)%h\n状态转移方程 ：dp[i+1][to] = max(dp[i+1][to] , dp[i][j] + flag)\nflag当to在区间内为1，否则为0\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,h,l,r;\rint dp[2005][2005];\rint data[2005];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(0);cin.tie(0);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;h\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\rfor(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;data[i];\r//preprocess\rmemset(dp,0xc0,sizeof(dp)); //0xc0c0c0c0 0x3f3f3f3f\rdp[0][0]=0;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;h;j++) // \u0026lt;即可\r{\rint to=(j+data[i])%h;\rdp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u0026lt;=to and to\u0026lt;=r));\rto =(j+data[i]-1)%h;\rdp[i+1][to]=max(dp[i+1][to],dp[i][j]+(l\u0026lt;=to and to\u0026lt;=r));\r}\rint ans=-1; for(int i=0;i\u0026lt;h;i++)\rans=max(ans,dp[n][i]);\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 小技巧\ninf = 0x3f3f3f3f memset可以用0x3f\nninf=0xc0c0c0c0 memset可以用0xc0\nF. Maximum White Subtree link 题意 给一棵树（比赛当天是植树节！！）\n节点有黑的，白的\n对于这棵树的某一子图\n定义这个子图所有节点的dif=白色节点数-黑色节点数\n求每一个节点的最大dif值\n题解 深度优先搜索+动态规划\n首先考虑以每个节点为父节点的子图的最大dif\n然后每个节点的的最大dif=作为父节点的最大dif+作为子节点的最大dif\n如何求以每个节点为父节点的子图的最大dif？\n遍历子节点\n判断每个子节点以下（作为父节点）是否白色比黑色多，多则累加对应的数值，否则不累加\n这样就形成和了dfs\n如何求最终的dif？\n作为子节点的部分的dif，可以用该节点的父节点的dif（最终）- 作为父节点的dif\n需要判断是否有必要增加“额外部分”\n要让该节点的父节点的dif为最终值，需要从根开始，一层层遍历子节点\n这样又形成了dfs\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rint dif_orig[200005];\rvector\u0026lt;int\u0026gt; adj[200005];\rint dif_par[200005];\rint ans[200005];\rvoid dfs_par(int u,int par)\r{\rdif_par[u]=dif_orig[u];\rfor(auto v:adj[u])\r{\rif(v!=par)\r{\rdfs_par(v,u);\rdif_par[u]+=max(dif_par[v],0); //如果黑色比白色多，则丢弃 }\r}\r}\rvoid dfs_final(int u,int par,int el)\r{\rans[u]=dif_par[u]+el;\rfor(auto v:adj[u])\r{\rif(v!=par)\r{\rdfs_final(v,u,max(0,ans[u]-max(dif_par[v],0))); //里面的max和上面一样，外面的max判断是否有必要增加其他部分（作为子节点的部分） }\r}\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(0);cin.tie(0);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++) {\rcin\u0026gt;\u0026gt;dif_orig[i];\rif(!dif_orig[i]) dif_orig[i]=-1; //如果是黑色，则白色-黑色=-1 }\rfor(int i=1,u,v;i\u0026lt;n;i++)\r{\rcin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v;\ru--,v--;\radj[u].emplace_back(v);\radj[v].emplace_back(u);\r}\rdfs_par(0,-1);\rdfs_final(0,-1,0);\rfor(int i=0;i\u0026lt;n;i++)\rcout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rreturn 0;\r}\r ","id":20,"section":"posts","summary":"A. Yet Another Tetris Problem link B. Yet Another Palindrome Problem link C. Frog Jumps link D. Pair of Topics link E. Sleeping Schedule link 题意 假设一天有h个小时，DIO一共要睡n次，每次睡ai个小时（按顺序睡觉），每次刚睡醒，就","tags":["cpp","dfs","dp"],"title":"Codeforces Round #627 (Div. 3)","uri":"https://dyhgo.github.io/2020/03/codeforces-round-627-div.-3/","year":"2020"},{"content":"《ef - a tale of melodies.》由日本动画公司SHAFT制作电视动画，并于2008年10月6日开始播放，是动画《悠久之翼》系列的第二季。故事内容由原作游戏《ef - the latter tale.》的第四章及终章改篇而成，终章的修改幅度比较大，加入了一些原创的情节。共12话。\n剧情\n圣诞节，雨宫优子与火村夕两人在教会里重逢。两人怀缅过去，由雨宫优子开始说过去发生过的种种事情。 广野纮是个高中生兼少女漫画家，每一天度过忙碌的生活。在圣诞节的夜晚，遇到追逐小偷的宫村宫子。两人再次在学校见面后，宫村宫子对广野纮开始产生兴趣，而开始纠缠在广野纮身边。 身为青梅竹马的新藤景看到这种场景而感到焦虑。几个月后的夏天。喜欢电影制作的堤京介，在体育馆看到新藤景的射篮的动作时，想要拍摄以她为主的电影。因为失恋与郁闷而退出社团的新藤景，受到热爱电影的堤京介的影响，慢慢走出阴霾。\u0026ndash;百度百科 ","id":21,"section":"posts","summary":"《ef - a tale of melodies.》由日本动画公司SHAFT制作电视动画，并于2008年10月6日开始播放，是动画《悠久之翼》系列的第二季。故","tags":[],"title":"ef - a tale of melodies","uri":"https://dyhgo.github.io/2020/03/ef-a-tale-of-melodies/","year":"2020"},{"content":"A - Station and Bus 题目链接 题意 给一长度为3的，只含AB的字符串，问是否存在相邻两个字符不同的情况\n题解 签到题\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main()\r{\rstring s;\rcin\u0026gt;\u0026gt;s;\rif((s[0]=='A' and s[1]=='A' and s[2]=='A') or(s[0]=='B' and s[1]=='B' and s[2]=='B'))\rcout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r B - Count Balls 题目链接 题意 有蓝球和红球若干，将他们排成一排，不断通过以下操作排列，在尾部加a个蓝球，在尾部加b个红球，问前n个球有多少个蓝球\n题解 签到题\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rll a,b,n;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rll m=n/(a+b);\rll ans;\rif(n\u0026gt;0) ans=m*a;\relse ans=0;\rn-=m*(a+b);\rif(n\u0026gt;a) ans+=a;\relse ans+=n;\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Tax Increase 题目链接 题意 给俩数a,b，问是否存在整数x使得，floor(x0.08)=a \u0026amp;\u0026amp; floor(x0.1)=b，若存在，输出满足这种条件的最小数，否则输出-1\n题解 由于数据不大，遍历x，判断是否满足条件\n或者求满足条件的两个区间，判断是否有交集\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint l1,r1,l2,r2;\rint a,b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rl1=ceil(a/0.08);\rdouble t;\rt=(a+1)/0.08;\rif(t*0.08==a+1)\rr1=t-1;\relse\rr1=floor((a+1)/0.08);\rl2=ceil(b/0.1);\rt=(b+1)/0.1;\rif(t*0.1==b+1)\rr2=t-1;\relse\rr2=floor((b+1)/0.1);\rbool flag=true;\rint ans;\rif(r1\u0026lt;l2 or r2\u0026lt;l1) flag=false;\relse if(l2\u0026gt;=l1 and r2\u0026lt;=r1) ans=l2;\relse if(l1\u0026gt;=l2 and r1\u0026lt;=r2) ans=l1;\relse ans=max(l1,l2);\rif(flag) cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\r//cout\u0026lt;\u0026lt;l1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;r1\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;l2\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;r2;\rreturn 0;\r}\r D - String Formation 题目链接 题意 对于一个字符串，有三种操作，倒置，在头部添加字符，在尾部添加字符，求最后得到的字符串\n题解 分别存储前缀和后缀，用一个bool来判断顺序，倒置操作给bool取反。\n在头部加，如果是顺序的就加在前缀，其他情况同理。\n最后通过bool量来控制输出顺序\n（直接模拟也可以）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rstring s;\rint q;\rchar c;\rint f;\rint t;\rstring pre,suf;\rbool order;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rorder=true;\rcin\u0026gt;\u0026gt;s;\rcin\u0026gt;\u0026gt;q;\rwhile(q--)\r{\rcin\u0026gt;\u0026gt;t;\rif(t==1) order^=1; //!!\relse\r{\rcin\u0026gt;\u0026gt;f;\rif(f==1) {\rcin\u0026gt;\u0026gt;c;\rif(order) pre+=c;\relse suf+=c;\r}\relse\r{\rcin\u0026gt;\u0026gt;c;\rif(order) suf+=c;\relse pre+=c;\r}\r}\r}\rif(order)\r{\rreverse(pre.begin(),pre.end());\rcout\u0026lt;\u0026lt;pre\u0026lt;\u0026lt;s\u0026lt;\u0026lt;suf\u0026lt;\u0026lt;endl;\r}\relse\r{\rreverse(suf.begin(),suf.end());\rreverse(s.begin(),s.end());\rcout\u0026lt;\u0026lt;suf\u0026lt;\u0026lt;s\u0026lt;\u0026lt;pre\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}\r 知识点\n1.bool的取反不能flag=-flag，可以用flag^=1\n2.string 在的插入函数 e.g. s.insert(s.begin(),c) or s.insert(s.end(),c)\n3.string的拼接 s=(string)\u0026ldquo;aaa\u0026quot;+\u0026quot;bbb\u0026rdquo;; （一定要强制类型转换）\ns='a'+(string)\u0026ldquo;kkk\u0026rdquo;; （string要强制类型转换，char是不能转成string）\nE - Divisible Substring 题目链接 题意 给一个仅由数字组成的字符串和质数p，问有几个子串（连续字符组成的）能够被p整除\n题解 个人感觉出的特别好的一道题\n动态规划+后缀\n从最后开始向前遍历每个数\nans+=（以当前数为开头，满足条件的个数）\n要求以当前数开头，满足条件的个数，就是个区间问题\n这个区间问题可以用后缀来求\n当两个后缀模p的余数相等时，这个区间内的数能被p整除（2和5除外）\n所以问题转化成求此时的后缀（余数），查询之前和这个余数相等的个数\n然后ans+=个数\n注意特殊处理一下2和5\n以下是对上面结论的证明（实际并不需要严格证明）\nac代码\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rusing ll=long long;\rint n,p;\rstring s;\rmap\u0026lt;int,int\u0026gt; mp; //存余数和对应的个数 ll ans=0;\rint main()\r{\rios::sync_with_stdio(false); cin.tie(0);\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;p\u0026gt;\u0026gt;s;\rif(p==2 or p==5)\r{\rint pt=p;\rfor(int i=0;i\u0026lt;n;i++)\rif((s[i]-'0')%pt==0) ans+=i+1;\r}\relse\r{\rmp[0]++;\rint num=0;\rint m=1;\rfor(int i=n-1;~i;i--)\r{\rnum=(num+(s[i]-'0')*m)%p;\rans+=mp[num];\rmp[num]++;\rm=(m*10)%p;\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r F - Removing Robots 题目链接 题意 数轴上有n个点，每个点有两个属性（坐标和能够向右移动的距离），随意地激活其中几个点，激活的点必须向右移动该距离，若移动过程中碰到点则那个点被激活，求对于所有的激活情况，最后的结果有多少种\n题解 动态规划+栈优化\n从右往左遍历每个点\n给每个点设置一个数值，表示遍历到该点的集合数量（即答案）\n判断这个点是否可以覆盖右边的点，可以覆盖，则这个点的数值乘上覆盖点的数值\n用栈维护每个遍历的点，如果栈顶没有被覆盖，则栈里面都无需遍历\n被覆盖的点就出栈\n新的点入栈（因为旧的点被新的点覆盖，集合数已经被新的点记录）\n最后遍历一遍栈，累乘数值\nac代码\n#include \u0026quot;bits/stdc++.h\u0026quot;\rusing namespace std;\rusing ll = long long;\rll n;\rconst ll mod=998244353;\rvector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vt; //存输入 stack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; stk; //将不覆盖的点入栈 ，用栈优化（对于正在检测的点，如果栈顶不满足，则栈里面的都不满足） //存点的坐标（identifier）和扫描到这个点时，它满足的集合数量 int t1,t2;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(false);cin.tie(0);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rcin\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2;\rt2+=t1;\rvt.emplace_back(t1,t2);\r}\rsort(vt.rbegin(),vt.rend()); //这种题目几乎都要sort 此处逆序遍历 for(int i=0;i\u0026lt;n;i++)\r{\rll t=1;\r//cout\u0026lt;\u0026lt;stk.empty()\u0026lt;\u0026lt;endl;\rwhile(!stk.empty() \u0026amp;\u0026amp; vt[i].second\u0026gt;stk.top().first)\t//遍历栈 注意开区间 {\rt=(t*stk.top().second)%mod;\rstk.pop();\r}\r//cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl;\rstk.push(make_pair(vt[i].first,t+1)); //!!!!! 一定要加1，因为枚举集合数的时候，对于每个点分两种情况（激活和不激活） } ll ans=1;\rwhile(!stk.empty())\r{\rans=(ans*stk.top().second)%mod;\rstk.pop();\r//cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}  debug了一小时\n发现自己手贱，在声明vector的时候给它分配了空间，然后就出现迷之错误\n（我一定是有病才会这么做）\n感觉自己的思维和英语都退步了\noh shake it 又没有学习android\n","id":22,"section":"posts","summary":"A - Station and Bus 题目链接 题意 给一长度为3的，只含AB的字符串，问是否存在相邻两个字符不同的情况 题解 签到题 ac代码 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { string s; cin\u0026gt;\u0026gt;s; if((s[0]=='A' and s[1]=='A' and s[2]=='A') or(s[0]=='B' and","tags":["cpp","string","dp","suffix"],"title":"abc158","uri":"https://dyhgo.github.io/2020/03/abc158/","year":"2020"},{"content":"halo1是微软于2001年发行的第一人称射击游戏\nhalo是一个很注重武器选择的游戏，合适的武器会非常高效\n剧情 2160-2200：早期冲突\n这一时期的人类历史充斥着太阳系中各大政府和派别之间的一系列血腥冲突。具有重大历史意义的冲突包括：木卫战役（Jovian Moons Campaign）、雨林争霸（The Rain Forest Wars）和一系列的火星遭遇战。 随着地球上人口过剩和政局动荡的愈演愈烈，许多新的政治运动兴起了。这一时期最值得注意的政治异端运动是“科思洛维克”（\u0026ldquo;Koslovics\u0026rdquo;)和 “福里登”（\u0026ldquo;Frieden\u0026rdquo;)运动。“科思洛维克”是指新共产主义者的强权领袖福拉德米亚·科思洛夫(Vladimir Koslov）的拥护者，他们致力于回到共产主义的光荣岁月，要消灭公司和资本家的流毒，特别是要肃清近地轨道和地外殖民地。 “福里登”运动是法西斯主义的复兴，该运动起源于反“科思洛维克”情绪，扎根木星殖民地为据点（很大程度上受到了统一德意志共和国企业的支持，这些企业常常成为科思洛维克“工人起义”的对象）。“福里登”的字面意思是“和平”－－这就是说，他们相信只有消灭了“人类的暴君”（oppressors on Terra Firma），才可能达成和平。\n2160 三月－六月：木卫战役开始\n木星分裂主义者袭击了位于木卫一爱莪（Io）的联合国殖民地总署（United Nations Colonial Advisors），导致了地球军与木星“福里登”部队之间展开了长达三个月的激战。虽然这并非我们太阳系中的第一起武装冲突，但此役成了最为血腥的战斗之一，也被普遍认为是引发接下来的摩擦和军国主义大潮的导火索。 木卫战役也升级了地球各国政府间的紧张关系－－许多国家在太阳系中都建立了殖民地，开始为各自在地外的利益而开战。殖民地战争的持续，使得地球上的紧张关系一触即发，引发了地球本土的数起武装冲突。\n2162：雨林争霸\n武装冲突横扫南美大陆，科思洛维克、福里登和联合国军之间因为不同的意识形态而开战。而这又加剧了地外冲突。\n2163 十二月：在火星的战斗\n地球三股主要派别将雨林争霸中燃起的战火烧到了火星上。一系列在火星Argyre Planitia附近对科思洛维克军的闪电战，是第一次非地军队的部署。战斗取得了决定性胜利。作为结果，后来的军事指导战略，惯用大编制的地面部队突袭配合舰船登陆行动。\n2164：星际大战\n联合国军开始形成大规模集结的格局，终于迎来了第一次真正的星际大战。继火星的军队部署告捷后，大规模的征兵行动和宣传策略极大地鼓舞了UNSC (United Nations Space Command，联合国太空司令部）军队的士气。联合国军挫败了地球上的科思洛维克和福里登军队，接着开始系统地专注于驱逐其在太阳系内其他行星上建立起来的残存势力。在这些局部战争后，福里登和科思洛维克军队被庞大、统一而强大的联合国军悉数剿灭。\n2170：膨胀\n2160年代的战乱促使人们建立了统一的地球政府。现在，胜利者必须处理不太引人注目却同样严重的威胁：人口过剩和无仗可打的庞大军队。 战后的岁月里，大量人口急剧膨胀；雨林争霸遗留的资源破坏和饥荒更是雪上加霜，世界经济岌岌可危。\n2291：超越光速\n一支由研究人员、物理学家和数学家组成的团队正在秘密研发“肖恩·藤川”超光速引擎（Shaw-Fujikawa Translight Engine，SFTE），一种驱动太空船穿越辽远星际的特殊手段。 这种新型引擎允许飞船钻入“跃迁空间”（\u0026ldquo;the Slipstream\u0026quot;或\u0026quot;Slipspace\u0026rdquo;，又称为“迁跃断层空间”）。“断层”一个变通的物理法则下的空间，允许超光速旅行而避免相对论的副作用。超光速旅行并不是瞬间完成的；“短程”的跳跃一般要花两个月，而“长程”的跳跃则能持续六个月甚至更久。 SFTE能生成一个共振场，当与迁跃空间的物理特性结合时，就能大大缩短跨越星际的时间；然而，科学家们也注意到在迁跃空间内部会有暂时的涌流这一奇怪的“变数”。尽管人类科学家都无法确定为何星际旅行所需的时间不是一个常量，但有理论指出在迁跃空间内部存在“漩涡”或“涌动” －－正是这造成了星际旅行所需的时间会有百分之五到十的出入。这一暂时的不一致性使军事战术家和战略家颇为恼火－－这会妨碍许多协同作战的进行。\n2310：初潮\n地球政府向公众公布了一系列殖民船中的第一艘－－应征者相当踊跃。地球上的状况因为人口过剩而不断恶化，搭乘飞船去外星殖民自然成了诱人的选择。 每艘殖民船都配备了军队人员和护卫舰，这样有助于更好地利用现有的庞大舰队。在异端武装瓦解后，军队正消耗着庞大的军费和物资。 因为超光速旅行在此阶段还十分新鲜而又昂贵，殖民地居民和军队人员都要通过生理和心理的严格测试。原则上，只有最优秀的公民和士兵才能获准去“邻近”的世界殖民。这就是近地殖民地（Inner Colonies）的诞生。\n2362：远征号\n远征号（The Odyssey）于2362年1月1日发射。作为浩浩荡荡的殖民舰队的领头舰船，远征号满载着部队和地貌改造装置，殖民的矛头直指新世界。人类超越太阳系的边界向外扩展的初潮由此拉开帷幕。\n2390：近地殖民地\n到了2390年，近地殖民地的殖民化运动正如火如荼。总计有210个人类占据的世界在进行不同程度的地貌改造，而在人类掌控的太空里，人口负担得到了巨大的缓解。\n2490：远地殖民地的诞生\n扩张仍在马不停蹄地进行，到2490年已经有800多个人类世界遍布银河系猎户座星臂了（这些世界形形色色，既有高度开化的星际要塞，也有偏僻的小定居点）。随着向外扩张的继续，近地殖民地成了政治和经济重镇，虽然他们极其仰赖远地殖民地提供的原材料。 在这一时期，致远星（planet Reach，围绕波江座第五恒星（Epsilon Eridani）运转，正当地球的咽喉要道）成为了UNSC的主要舰船制造厂和训练营地。致远星是战舰和殖民船的主要制造地，也是训练秘密特工和特种部队的所在地。\n2525：星盟战争开始\n2525年4月20日，与远地殖民地丰饶星（Harvest）的联络中断了。在试图重新建立联络的努力失败后，殖民军总参谋部 (the Colonial Military Administration，CMA）派遣了一艘侦查舰，金羊毛号（the Argo）前去调查。可是金羊毛号一到达丰饶星系，与飞船的联络也突然中断了。 CMA火速派遣了一支三艘战舰组成的战列舰队前往丰饶星。只有战列舰队领航的旗舰大力神号（the Heracles）返回了致远星，战痕累累，伤亡惨重。战舰的指挥官报告说，出现了一艘配备了强大武器的外星战舰，已经践踏了丰饶星，血洗了殖民地（很可能也已摧毁了金羊毛号）。 战列编队很快遭遇了外星战舰，并被紧密跟踪。在两艘战舰被击毁后，大力神号迅速跳出了星系，但因为受损严重，几周之后大力神号才回到了致远星。 地球军立即提升了警报级别，开始积极准备收复丰饶星的作战计划。当年12月，由普雷斯顿·科尔（Preston Cole）中将率领的地球军舰队浩浩荡荡地出发了，如此快地派出如此庞大的远征军，在人类历史上实数罕见。\n2525：丰饶星战役\n科尔率领的舰队誓报殖民星沦陷之仇，在与外星战舰的遭遇战中告捷－－尽管胜利的代价是损失了科尔军三分之二的有生力量。扭转战局的，只是科尔在最后几分钟，战术上的灵光乍现罢了。 军队回师地球之后，晋升为上将的科尔才获悉：许多外围殖民地已经沦陷，无人生还。科尔开始排兵布阵，准备对入侵者展开截击。地面战和舰船战相当惨烈，战火绵延到了整个远地殖民地。在一次地面遭遇中，人类部队俘虏了一个外星入侵者。在负伤过重死亡之前，人类得知这些外星人自称为“星盟” (the Covenant）。 远地殖民地大屠杀 在接下来的几年中，科尔部遭到了重创，他个人出色的领导力和战略才华也无济于事。这完全是一场实力悬殊的较量，星盟在舰船战中的胜率甚至接近四比一。 到了2535年11月，事实上所有的远地殖民地都已经惨遭星盟屠戮。“科尔协议”（Cole Protocol）作为军事命令确立了如下原则：所有的地球舰船必须确保星盟军不会发现地球。当地球舰船被迫撤退时，必须远离环地航线，甚至不做计算就进行超时空跳跃也在所不惜。 如果存在被星盟俘虏的危险，连“盲跳”都不可行时，船长必须下令船只自毁。此外，强大的舰船人工智能（AI）核心数据也切不可落入敌军之手。所以，科尔条款的部分内容也指出：在紧急状态下，必须转移或销毁舰船人工智能。\n2536-2552：近地殖民地之围\n星盟的铁蹄已经踏入近地殖民地。多年来的战事渐成定局：人类只是以极其高昂的代价赢得局部战斗的胜利，尤其是在地面行动中。而在太空对战中，人类的失利猝不及防，殖民地就这样接二连三地沦陷了。\n2552：致远星的沦陷\n星盟军终于到达了致远星－－这个离地球最近的重大军事要塞覆灭了。秋风之墩号（the Pillar of Autumn）巡洋舰，载着最后一个二期 (SPARTAN）斯巴达战士士官长逃出生天，幸免于难。所谓“斯巴达战士”指的是超级特种兵的一种精英作战单位，装备了令人望而生畏的雷神锤装甲。他们是人造的终极兵种。 现在，仅存一个斯巴达战士能与敌对决了。秋风之墩号的舰长雅各布·凯斯（Jacob Keyes）为了遵守“科尔条款”下令进行目的地未知的长程跳跃，希冀着能让星盟追兵始终远离地球。 引擎熄火后，秋风之墩发现自己落入了一个辽远未知的星系。星系中也有一支星盟舰队，他们附近有一个行星般大小的环状结构－－“光晕”。\n2552-2553：地球战役\n解决了“光晕”的问题之后，秋风之敦号一小部分幸存者和致远星上的部分幸存者合流，经过一系列艰辛的征战回到了地球。然而，此时星盟舰队也大举入侵。人类不得不为自己最后一个故乡而战。　由于星盟内精英和鬼面兽势力的对抗导致了星盟的分裂，以神风烈士提尔·外达密和星盟舰队指挥官瓦图米为首的精英起义舰队于2552年底和以真相先知、鬼面兽首领塔塔罗斯为首的先知鬼面兽舰队作战。而此时先知已经在地球上找到了通往“方舟”的传送门，精英与人类组成同盟，向神秘的“方舟”进发。\n2553：方舟战役，战争结束\n士官长等人在方舟阻止了真相先知毁灭世界的阴谋，同时为了对付另一个威胁，他们摧毁了方舟。然而回到地球后，大家翘首期盼的士官长却没能够回来。大家怀着悲痛的心情悼念战争中牺牲的战士，而在纪念碑的一角不知是谁刻上了士官长的编号“117”三个数字。\n初始背景 先驱 先驱（Precursor）是先行者信仰中的上古先贤，在先行者历史之前数千万年已经存在。先驱本为宇宙中一个科技水平极其先进的种族，先行者标记其为自己的科技等级列表中最高的等级0，他们大约身高15米、身宽11米。先驱负责在各个星系中创造、播种、改造、守护所有生命/种族，这被称为 Mantle（传承的责任、衣钵）。并且当一个智慧种族进化到一定程度后，先驱会评估他们是否能够传承『衣钵』。如果这个种族与衣钵的意义有冲突或者是失败品，先驱就会将其灭绝。 先行者 (Forerunner)、人类 (Humanity)、先知 (Prophet)、洪魔 (Flood) 等种族在当时都受先驱者支配。 先行者的“革命” 先驱选择了母星位于 Ghibalb 星球的高等智慧种族『先行者』作为下一个考察对象，虽然此时继承“衣钵”的候选人越来越令先驱满意，但是最终先驱还是认定先行者无法完全继承“衣钵”，于是计划将先行者灭绝。不料先行者知晓了先驱的意图，决定先发制人，孤注一掷地发动了对先驱的突袭，重创了毫无防备的先驱。在先驱眼中无比稚嫩的先行者究竟是凭借什么力量成功袭击了先驱，至今依然是一个秘密。先驱随后离开银河系。 古人类\u0026amp;古先知 先驱在此之前已经创造了与先行者同源的另一种智慧生命并播种在地球，作为其潜在的继承者。最终人类得以诞生。古人类的星际文明很发达，科技水平虽然低于先行者，不过他们长期研究先行者的科技，再加上与实力强劲的先知结成了同盟，于是联盟的力量在银河系中超过了先行者。 虫族（洪魔） 离开银河系的先驱被先行者激怒，他们凭借自己强大的科技汇聚了12种未知生物个体（这其中也包括一名先驱），创造出了可怕的虫族-洪魔(Flood)，决定在银河系释放这种生物武器作为制裁手段，并主导一场重估生命发展方向的试炼。但是这次先驱相信自己在银河系中可能已经拥有可以传承“衣钵”的继承人-人类。所以制裁对象仅限于先行者，同时，先驱也想借此测试人类能否真正继承“衣钵”，在与虫族冲突之后为银河系带来繁荣，或者银河系是否会屈服于虫族，产生另一种高度一体化的和平。结果不外乎只有2个：先驱的“衣钵”继承者获得成功，先驱的计划在银河系宣告完成；或者虫族战胜一切，先驱放弃银河系，将银河系的未来交给虫族。 虫族的形态是一种相当致命的寄生体，其生物质量是由一种无差别的虫族超级细胞 (FSC) 所组成，其结构与神经元及胶质细胞相似，虫族能够自己编排这些 FSC，并模仿它们所需的有机体。虫族爆发时会经历几个特定阶段：野生、互助、星际、超星系。野生阶段的虫族会使用4种形态：感染、战斗、母体、原始尸脑兽。虫族一旦成功建立了原始尸脑兽，便会进入互助阶段。此时可使用的形态数量开始急剧增加，其中的变身形态是虫族将FSC附着于钙质构建的弹性架构而创造出的战斗体。变身形态数量达到平衡后，战斗形态会转为纯防御角色或是作为钙质储备。虫族进入星际阶段后，它们除了形态上的进化，还能完全吸收所获得的科技。当虫族强大到同化了星系的程度后，如果实力允许，它们将进军其他星系，此时，虫族便进入超星系阶段。 虫族的感染形态附在生物个体后，可以选择感染或者不感染。一旦被虫族感染，将不会有任何可行的治疗手段。 先驱将这至少12种以未知生物为素体组成的虫族首领“上古尸脑兽 (Gravemind)” 放置于储存舱，投放在银河系边缘的一颗废弃行星上。它就是后来的永生者 (the Timeless One)，也叫做原基 (Primordial)，而尸脑兽的意识则来自那名融合为虫族的先驱个体，先行者称它为受囚者 (the Captive)。它的目的是要将先驱与先行者战争的真相告诉想要了解真相的人：衣钵的意义、虫族的起源、人类的角色、先行者不是衣钵的继承者、人类在通过测试之后可以继承衣钵。 古人类-虫族战争 先驱的计划开始实施。公元前 110,000 年左右，古人类发现了数艘自动驾驶的星舰坠落在银河系边缘附近的一些殖民行星和荒废行星上，里面有数以万计装有干燥粉末的玻璃桶。古人类严格检测和研究这些相对简单的短链有机分子粉末后认为无害，只是对低等生物有些神经影响。他们尝试将粉末喂饲在古人类和先知世界里很流行的宠物 Pheru，它们变得更加驯服。 但谁都没有想到，这些粉末正悄悄地改变 Pheru 的基因遗传密码，几个世纪之后，这些 Pheru 开始变异，性情狂暴并且侵食同类，不少被安乐死或者流放野外。饲养 Pheru 的古人类和先知也染上各种病症，精神上的影响让他们食用染病的 Pheru，丢弃的部分也加速了怪病的传播。感染者与未感染者开始了自相残杀，被感染的古人类和先知将疾病蔓延到了其它星系，助长了虫族的爆发。虫族不断蚕食各种生命体和可用的资源，并形成了战斗群，人类-虫族战争开始。 古人类之前在银河系边缘附近的星系发现了在储存舱内的上古尸脑兽，并转移到 Charum Hakkor 星球。古人类曾经与它沟通，但是得到的回答都很深奥，不明所以。在首次遭遇虫族后，一些古人类再次询问上古尸脑兽关于虫族的特性和疾病的起源，它说出了答案，其中一部分古人类变得极度恐慌而自杀。 经过漫长的血战，古人类相信他们找到了对付虫族的方法，对外宣称能治愈这场灾变。古人类以牺牲三分之一数量的个体为代价，改变他们的基因，让他们作为宿主主动被虫族吸附、但可以不被虫族感染为同类。这些基因阻止了虫族的扩散，寄生体不再拥有“繁殖能力”，虫族终于退出了银河系，接近 9,000 年没有再出现。古人类战胜虫族之后，摧毁了他们最早时候发现的虫族粉末星舰，也不留下任何古人类、先知、Pheru 体内残留的虫族样本，并且销毁他们认为可以治疗虫族感染的方法的所有资料。由于没有了这些证据和信息，先行者无从知道虫族的特性。 但其实古人类并没有找到治疗的方法。虫族退出银河系是因为它们受到先驱决定让古人类继承衣钵的命令，已经达到试验目的所以先驱决定将“衣钵”给予人类，虫族也不再感染古人类，转为开始灭绝先行者。 人类\u0026amp;先知联盟-先行者战争 古人类在联盟中心的Charum Hakkor 星球上发现了银河系中最多的先驱科技，这意味着先驱已经将自己所掌握的力量分享给继承了自己“衣钵”的古人类。突如其来的馈赠使得古人类欣喜若狂，并开始变得傲慢，试图挑战先行者的地位，认为自己是先驱的真正继承者，将取代先行者称霸银河系。另一方面，古人类在与虫族的血战中失去大量殖民地，不得不疯狂入侵还没有遭到虫族感染的其他种族的星球作为人类的生存区域，当中包括了很多先行者的领土。意识到作为先驱继承人的古人类科技水平即将急速发展以及他们不断的挑衅给先行者带来了强烈的危机意识，先行者终于无法忍受，发动了战争。 虽然古人类占领了很多先行者星球，不过人类为对付虫族牺牲巨大，击退了虫族之后，古人类和先知同盟已经消耗殆尽，同时先驱的科技也并非能在短时间就大幅度的加以利用。于是在先行者军团统帅宣教士 (The Didact)的 指挥下，人类被迫回撤到 Charum Hakkor 星球。他们使用先驱的科技和防卫要塞抵抗强大的先行者星际舰队。先知军团援助的路线被切断，古人类继续抵抗了五十多年。公元前 109,000 年左右，在绝对的优势面前，尚未能开始消化先驱科技的人类被击败，无数的古人类和先知不愿被俘而自杀。不过先行者这边也损失巨大，在先驱科技的强大力量作用下，宣教士的后代全部阵亡。 战后，先行者最终放弃灭绝战败的人类，认为会违反衣钵的意义。宣教士和他的普罗米修斯战团在后来的政治斗争中处于被动，由于处在和平环境下，加之激进的思想，他们最终被迫退出议会，宣教士和他的战团代表的整个先行者武侍阶级在随后的数千年中被边缘化，舰队解散，先行者军事实力削弱，这使得他们在后来的虫族再次入侵时措手不及。宣教士也自我放逐，休眠于存放在地球的战士牢笼 (Cryptum) 之中。 先行者将人类和先知的基因退化，回到没有科技文明前的原始时代重新进化，并且处决了很多挑起冲突的古人类。先行者开始称霸银河系。 先行者-虫族战争 先驱已经从银河系中消失，但是他们下达的灭绝先行者的命令开始由虫族执行， 为了对虫族再次入侵银河系做好最坏的打算，先行者的首脑-大架构师 (Master Buider Faber) 在公元前 101,000 年下令建造环带阵列。他在大方舟 (greater Ark) 建造了12个直径3万公里的大环带，用作对付虫族的终极手段，而同时宣教士的妻子智库长 (The Librarian) 也在小方舟 (Ark, Installation 00) 建造了6个直径1万公里的小环带。两个方舟以及大量的的护盾世界 (Shield World) 用以保护银河系物种的样本在环带发射时免遭灭绝。采集和索引银河系物种并送往方舟的工作，由管理者领导生命工作者 (Lifeworkers) 完成，但工程量巨大，彻底完成需要大量时间。 虫族在公元前 100,300 年再次出现在银河系，开始了与先行者持续三百年的战争。先行者尝试所有方法，也未能击退虫族，一直处于劣势。同时，虫族逐渐掌握智慧生物们的科技，实力高速膨胀。 公元前100,043 年，先行者大架构师授权军事人工智能偏见之僧（Mendicant Bias/MB）在Charum Hakkor星球附近测试发射07号大环带。攻击穿透了星球上所有的先驱建筑，并释放出人类存放在这里的上古尸脑兽。偏见之僧随后将它带到07号大环带研究，并与07号环带一同消失了43年。在这段时间内，由先驱转换而成的上古尸脑兽与偏见之僧进行了交谈，先驱传达的思想几乎是难以抗拒的，以至于偏见之僧最后也不得不被强大的上古尸脑兽诉说的故事和真相说服：相信银河系的未来属于虫族，先行者自作主张接手“衣钵”的举动让银河系陷于永恒的停滞，只有毁灭先行者才能让银河系的物种继续进化。 随着战事进行，先行者将另外11个大环带调回银河系的先行者首都圈，偏见之僧也在公元前 100,000 年突然带着07号环带回来，它控制了在场的许多引导者AI，对先行者发起突然袭击。宣教士发出了故障保护密码，暂时瘫痪偏见之僧，启动首都圈的防卫系统，与同伴进入运输舰回到方舟与妻子会合。偏见之僧的权限成功控制了五个大环带，声称与虫族合作消灭先行者。先行者将其余的七个环带从首都圈的传送门紧急送入方舟，但是由于情况危急，最终传送门超载崩溃，只有一个在传送门坍塌前抵达。首都圈的防卫系统发挥作用，摧毁其中一个大环带，处于极度不利处境下的偏见之僧带着07号大环带撤退，其余的大环带下落不明。 宣教士的肉体在受虫族感染的星系中死亡，他的意志被转入先行者“新星”体内并重新掌控先行者军团控制权，他随后追踪到偏见之僧和上古尸脑兽所在的07号环带，率领舰队拦截。宣教士（新星）用控制密码驱逐了偏见之僧，将严重受损而不稳定的07号大环带缩减为小环带后传送到大方舟。他与一名古人类拷问了07环带上的上古尸脑兽。尸脑兽告诉他们：自己就是由先驱转化而成，用以操纵虫族，并将先驱、先行者、古人类、虫族的关系、人类其实没有治愈虫族的方法等真相尽数告知。宣教士最后消灭了上古尸脑兽，而他只将真相告诉了妻子智库长。 时机成熟，偏见之僧率领虫族大军，操纵由数百万艘强大的战舰组成的军队，以难以阻挡的实力进攻方舟，先行者的防御体系终于崩溃，不得不考虑最终手段，先行者们准备发射环带阵列作为最后的手段。智库长此时正在地球索引物种、关闭导向方舟的传送门，虫族则大肆进攻，希望侵入方舟以阻止先行者“同归于尽”。为了确保方舟的安全，她摧毁了所有能够带她回到方舟的圣匙战舰（Keyship），认为保存银河系物种的重任比自己的生命重要得多。宣教士派出营救部队，要赶在环带发射前接回妻子，但是都被偏见之僧的舰队拦截。 先行者新建的军事人工智能偏见进逼（Offensive Bias）利用偏见之僧在最终关键时刻精力的转移和兵力处绝对优势下的疏忽，成功以5:2183的悬殊兵力争取到了最后的一点时间，环带阵列中的7个环带启动，击溃大部分虫族舰队，虫族的武装力量瞬间崩溃，偏见进逼从而获得了 6:1 的兵力优势，反败为胜并俘获了偏见之僧。随着环带阵列的启动，银河系所有不受方舟和护盾世界保护的生物全部被杀死，随后方舟上的Keyship将先行者保存索引的物种送回各自星系。先行者与虫族的战争结束。 继承遗产 智库长认为人类与先行者都是先驱下面同源的生命，而且作为先驱选定的继承者，将来同样可以成为先行者的继承人。在被环带杀死前，她在进行索引时将先行者的一些神秘的基因指令 (Geas) 注入到人类基因之中，使得人类可以让先行者设施引导者和系统所识别。这为后来先行者为人类封存自己的科技以便将来人类继承他们的力量埋下了伏笔。同时，失去了先驱操纵的虫族尚未灭绝，成为了未来银河中所有生命的公敌。 \u0026ndash;来自于百度百科\n","id":23,"section":"posts","summary":"halo1是微软于2001年发行的第一人称射击游戏 halo是一个很注重武器选择的游戏，合适的武器会非常高效 剧情 2160-2200：早期冲突 这","tags":[],"title":"光环1","uri":"https://dyhgo.github.io/2020/03/%E5%85%89%E7%8E%AF1/","year":"2020"},{"content":"ac2由育碧蒙特利尔工作室开发\n十年前玩的游戏，环境渲染和剧情真的超棒\n背景音乐选的十分用心\n后来主角ezio也成为了刺客信条系列的标志\n刺客信条系列基本延续着刺客和圣殿骑士（现在的abstergo）的斗争，进入animus为追求祖先记忆，寻找金苹果讯息。。。\n续作兄弟会的剧情显得有些乏味，不过以组建兄弟会为主线的游戏安排还是很可以的\n线上有更丰富的内容\n剧情 刺客信条2：\nDesmond在刺客信条1之后本来是准备要处死的，但是Lucy帮他逃了出来，和另外两个现代刺客会合。为了找到伊甸园圣器的下落，Desmond不得不再次进入刺客兄弟会的机器Animus 2.0，这一次他成为了中世纪佛罗伦萨的贵族Ezio Auditore(艾奇奥)。Ezio的父亲和两个兄弟被陷害以后，他在自己的叔叔Mario Auditore(马里奥)的帮助下脱离险境，并且知道自己的家族是刺客家族。于是他开始自己的复仇之路。在复仇的过程中，Ezio慢慢知道了伊甸园圣器的事，并且自己也在慢慢成长，直到有一次圣殿骑士从外地运回威尼斯一件很重要的物品，被Ezio夺到，原来就是金苹果。\n于是Ezio发现一个事实，就是在罗马有一件伊甸园圣器“教皇权杖”，它和“金苹果”结合就能打开一些秘密。于是刺客们就前往罗马，一来为了杀死陷害Ezio一家的罗马教皇Rodrigo Borgia(罗德里格·波奇亚)，二来为了抢夺教皇权杖。谁知Rodrigo早有准备，反刺伤了Ezio，抢了他的金苹果。但是Rodrigo没有刺客的血统，结合了教皇权杖和金苹果，但却无法激活。而后Ezio赶来，两人赤手空拳搏斗，Ezio最终胜利，但心一软没有杀死这位陷害自己一家的幕后主使。Rodrigo逃脱。Ezio身为正统刺客，发现自己的血统使两件伊甸园圣器合体激活，打开了罗马教堂地下的一间密室，而密室中出现的影像却是给后来人，也就是给现代正统刺客Desmond的信息。然而回到现代，正在此时，圣殿骑士出现，Lucy和Desmond不得不展开战斗，Desmond通过Animus的血统效应已经学会了Ezio的一些技能，击退了圣殿骑士以后逃离。\n刺客信条兄弟会：\nDesmond和Lucy一行人一直逃到蒙特奥吉欧尼，也就是中世纪Ezio叔叔Mario的庄园。他们开始继续搜索金苹果的下落。回到Animus中，Ezio打败Rodrigo之后载誉归来，回到Mario的庄园，但不想第二天凌晨，Rodrigo的儿子Cesare Borgia带兵攻打庄园，并最终抢夺了金苹果，还杀死了Mario。Ezio也只能带伤逃离。逃离了以后，他孤身一人来到罗马，再次踏上了复仇之路。在Machiavelli(马基雅维利)、Da Vinci(达芬奇)和罗马当地的佣兵、交际花和盗贼的帮助下，Ezio解放了罗马，拿回了金苹果，并最终杀死了Cesare。夺回金苹果后，Ezio把它埋在了罗马大剧场地下的一间密室里。回到现代，Desmond等人立即赶往罗马大剧场遗址，并进入密室，拿到了金苹果。但Desmond一碰到金苹果之后就被控制，不由自主走向Lucy，刺杀了她，随后陷入了昏迷。\n刺客信条启示录：\nDesmond昏迷之后，其他刺客急忙将他放回了Animus，希望通过Animus能让他苏醒。在Animus中，Desmond的意识和肉体已经分离，他的意识遇见了另一位在Animus中游荡的“16号”意识，来自一位现代已经遇害的刺客。16号告诉他只有在Altair(阿泰尔，刺客信条1主角)、Ezio和Desmond完全同步的时候才能让Desmond找回自我。于是Desmond第三次进入了Ezio的记忆。\nEzio为了寻找古老刺客的知识，来到了Altair所在的马西亚夫城堡，发现一间Altair建造的密室。为了打开密室，Ezio必须找到五把Altair留下的钥匙，而这些钥匙已经被当时马可波罗的父亲带去君士坦丁堡埋藏。到了君士坦丁堡之后Ezio卷入了宫廷斗争，还认识了一位有魅力的女人Sofia(索菲亚)。找到五个钥匙之后，Ezio和Sofia一起回到了马西亚夫城堡，打开了密室，见到了Altair的遗体和Altair留下的另一个力量更强大的金苹果。这时金苹果又被激活，Altair、Ezio和Desmond的意识完全同步，Desmond聆听了人类诞生前的文明留下的信息，需要Desmond拯救世界。在那之后，Ezio扔下了身上的武器，把它们和金苹果放在一起留在了密室，结束了自己的刺客生涯。回到现代，Desmond从Animus中苏醒了过来。\n刺客信条-余烬：Ezio老年和Sofia生活在佛罗伦萨郊外的一片农庄里，他们有两个孩子。有一天来了一个中国女刺客，为了刺杀残暴的嘉靖皇帝来向Ezio求教。帮助了女刺客之后，有一天Ezio在和Sofia逛街的时候疾病突发，安详仙去。\n当我还年轻时，我身怀自由，但我并未看出它的存在，我有大把的时间，可我不懂得珍惜，我还拥有爱，但是从未真实地感受过它，我花了好几十年才明白这三者的真正意义，但现在，在我生命中的黄昏，这些认知逐渐转变成了幸福。爱，自由，时间,曾经随意丢弃的这些，原来正是驱使我前行的动力，而在这三者中，爱尤其宝贵。以此献给你和我们的孩子，以及我们的兄弟姐妹，还有这个赋予我们生命与好奇的广袤世界。索菲亚，我对你的爱永无止境——无论何时都属于你的——艾吉奥·奥迪托雷\nEzio写给Sofia Sorto的遗书 \u0026mdash;来自网络\n","id":24,"section":"posts","summary":"ac2由育碧蒙特利尔工作室开发 十年前玩的游戏，环境渲染和剧情真的超棒 背景音乐选的十分用心 后来主角ezio也成为了刺客信条系列的标志 刺客信条系","tags":[],"title":"刺客信条2","uri":"https://dyhgo.github.io/2020/03/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A12/","year":"2020"},{"content":"《刻痕》是由蓝天使制作组制作的2D动画游戏，于2008年发行，是一款恐怖推理解谜游戏\n《刻痕》是国内原创推理悬疑解谜（猎奇）游戏的始祖，国内第一个以R15作为GALGAME正式标准的游戏，也是国内第一个R15类型的推理悬疑解谜（猎奇）类游戏，刻痕系列首次在国内提出了带有悬疑、血腥、恐怖或者猎奇要素的游戏，要以R15作为分类标准的概念，此分类概念在后来在国内整个GALGAME行业业界被得以广泛认可，并被普遍流传使用。\n","id":25,"section":"posts","summary":"《刻痕》是由蓝天使制作组制作的2D动画游戏，于2008年发行，是一款恐怖推理解谜游戏 《刻痕》是国内原创推理悬疑解谜（猎奇）游戏的始祖，国内第","tags":[],"title":"刻痕","uri":"https://dyhgo.github.io/2020/03/%E5%88%BB%E7%97%95/","year":"2020"},{"content":"波斯王子 prince of persia是ubisoft于1989年发行的一款单机游戏 波斯王子有好多部，前3部是一个完整的故事，后面则是一些衍生\n这是我2010年玩的游戏，pop1通关了4遍\n作为上个世纪的游戏，画质不能与现在的3A大作比\n但是，有一说一画质也不差\n环境的渲染也特别棒，很符合故事背景，有很多细节\n游玩的时候不禁会让人驻足联想\n剧情真的很不错，以时间倒流作为主要技能是很大的创新\n也增加了游玩的乐趣\n值得一提的是，据官方称，这个游戏有六百多种动作\n按键的组合确实可以打出很多不同的动作，但前期在战斗的时候基本只需要靠几个动作\npop2应该是最难的一部，小boss血量巨厚\n如果我没记错的话，pop3应该是加入了刺杀系统，在当时是一个很大的创新，而且感觉还不错\n对于boss来讲，要一遍过还挺难\n黑暗王子的20倍攻击力用的太爽了\npop的跑酷系统在当时做的着实优秀\n游戏剧情 很多人都认为，时间就像一条河流，永远朝着一个方向不断的前进。 印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，并带走了时间女皇的遗物——时之沙漏和时之匕首。 后来，为了将这两件宝物据为己有，以达到长生不老的目的，维瑟尔背叛了穆罕默德。他怂恿波斯国王沙拉曼攻打印度，并承诺作为内应会打开印度的城门。战争结束，沙拉曼得到了时之沙漏，并且俘虏了印度国的公主法拉。而波斯王子由于在战争中的杰出表现，得到了他的第一件战利品——时之匕首。 波斯大军凯旋在阿扎德苏丹皇宫暂时停留时，心怀怨恨的维瑟尔诱惑波斯王子用匕首打开时之沙漏，释放的时之砂瞬间吞噬了整个皇宫，并且将沙拉曼变成了砂之怪物。 王子不得已杀死了自己的父亲，在悲痛欲绝中，逃脱的印度公主法拉告诉王子，只要将时之匕首重新插进时之沙漏，那么时间就会倒退，回到一切的开始。于是王子和法拉开始了他们的冒险。 随着冒险的不断深入，王子和法拉的情感也在发生微妙的变化。最后，法拉悄悄的带着时之匕首离开了王子。王子找到了法拉，但却眼睁睁的看着法拉坠楼身亡。哀伤的王子夺回了匕首并将其插进了沙漏里。 伴随着维瑟尔绝望的呼叫，时间倒退到了波斯军队进攻印度之前。保留着记忆的王子在进攻的前夜悄悄的潜进了公主法拉的卧室，告诉了她一切，包括维瑟尔的背叛。被揭穿的维瑟尔恼羞成怒，想要杀掉法拉嫁祸给王子，但被王子消灭了。后来，王子劝说他的父亲沙拉曼撤走了军队，一切好像都恢复了平静。但是谁也没有料到的是，王子的命运已经被诅咒：任何使用过时之匕首的人，只有死路一条。 “因为王子使用了时之匕首破坏了时间的平衡。而达哈卡就是为了恢复时间的平衡而诞生的，他就像时间一样是不可战胜的。达哈卡会像影子一样追杀着王子，直到王子的生命走到尽头。” 王子是从一位盲眼老人那里得到了自己的命运被诅咒这个消息的。为了改变自己悲惨的命运，王子打算去时之岛，回到过去，回到时间女皇制造时之沙的那一刻，去阻止时之沙的诞生。 历经艰难的王子终于到达了时之岛，并且通过岛上的时间传送点回到了过去。在那里，王子遇到了一位名叫凯琳娜的红衣少女。凯琳娜帮助了王子，她告诉了王子如何去打开时间女皇所在房间的门的机关。 在冒险的过程中，一个神秘的黑衣人不时在王子周围出现，不知是敌是友。更让人感到诡异的是，最后时间的守护者达哈卡突然在王子和黑衣人的面前出现，但是达哈卡却杀掉那个黑衣人，然后没有理会王子就走了！纳闷的王子按照凯琳娜的帮助打开了时间女皇房间的大门，却又愕然发现原来凯琳娜就是时间女皇！怨愤的凯琳娜告诉王子，她之所以帮助王子，就是想让王子在打开大门的过程中被那些机关杀死，或者被时间守护者达哈卡杀死。原来凯琳娜也通过时间线预知到了自己的命运：她将会被波斯王子亲手杀死！同样为了改变自己悲惨的命运，时间女皇和王子展开了一场生死战，最后王子逼不得已只好杀掉了凯琳娜！ 凯琳娜在临死之前告诉王子：没有人能改变自己的命运，你也会像我一样去奋力，但你也会像我一样死去！随后，凯琳娜的尸体迸发出了金色的光芒。 王子通过时间传送点回到了杀死父亲之前。本以为一切都结束的王子突然发现时间的守护者达哈卡仍然在追杀他。这时王子才想起来，凯琳娜死后那些金色的光芒就是时之沙！（王子本以为时之沙是时之女皇凯琳娜制造的，杀死凯琳娜就可以阻止时之沙的诞生，但事实是时之沙的诞生正是因为王子杀死了凯琳娜，时之沙就是凯琳娜死后尸体变成的）绝望的王子被达哈卡困在了一个地下墓穴里。就在万念俱灰之时，墙壁上的文字吸引了王子的注意。 根据文字记载：当年印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，在夺取时之沙漏的过程中，穆罕默德不幸被时之守卫杀死，但幸运的是，一件黑色的面具让他有了第二次机会…… 就像在黑暗中看到了一丝曙光一样，王子暂时摆脱了达哈卡的追杀，去寻找那件黑色面具。终于在时之岛的尽头，王子找到了黑色面具。戴上了面具的王子回到了他刚到时之岛的那一刻，并且变成了一个黑衣人——原来在他冒险的过程中时隐时现的黑衣人其实就是他自己。 又经过一番努力，王子最后阻止了自己被达哈卡杀掉（本来达哈卡杀掉了黑衣人，但王子没有让这件事情发生，达哈卡转而杀掉了原来的王子），王子又变回了原来的样子。由于知道了接下来将要发生的事情，王子决定利用时间传送点把时间女皇凯琳娜带到之前。这样即使凯琳娜死了时之沙也不会威胁到自己。变身回来的王子成功的把凯琳娜带到了之前，但是时间的守护者达哈卡再度现身，只不过这次他的目标换成了凯琳娜。这是理所当然的，凯琳娜本来不属于这个时代，为了维护时间的平衡，达哈卡自然把矛头对准了她。因为不忍心凯琳娜就这样被达哈卡杀死，王子利用从过去带回来的一把水之刃（此刀可以伤害到达哈卡），与达哈卡展开了一场肉搏战。 最后在凯琳娜和王子的配合下，达哈卡居然奇迹般的被消灭了。胜利的王子打算带着凯琳娜一起回到他的故乡——波斯的巴比伦城，想从此过着平静的生活。但此时的巴比伦城正被战火所蹂躏……盲眼老人的声音仍在萦绕在王子心头：你不可能改变自己的命运，没有任何人可以。 几个星期后，王子带着凯琳娜离开了时之岛回到了他故乡巴比伦城，却发现整个巴比伦城陷入一片火海中。震惊和愤怒的王子不敢相信眼前的一切，但随后他的船就被飞来的火球打翻，并且和凯琳娜失散。 昏迷的凯琳娜被侵略军带到了巴比伦皇宫里。王子紧随其后想要去救她。在皇宫中，愤怒的王子不幸被敌人擒住，但他却愕然发现侵略军的首领居然是那个“已经被自己杀死的”邪恶法师维瑟尔！而维瑟尔居然又不认识自己？原来，当王子把时间女皇凯琳娜带到之前的一霎那，历史就已经发生了改变：由于没有时之沙，维瑟尔也就不会去背叛穆罕默德，也就没有了波斯进攻印度的历史，维瑟尔也就不会认识王子，当然也不会被王子杀死了。 历史已经改变，但依然改变不了维瑟尔邪恶的欲望。 多年以前，印度国王穆罕默德和法师维瑟尔来到了废弃的时之岛，与原先的历史不同，他们只找到了一把时之匕首，至于传说中的时间女皇和时之沙则没有任何存在过的痕迹。已经对时之沙快要放弃的维瑟尔却突然发现时之匕首在最近几个星期变得活跃了起来，维瑟尔很快明白了究竟发生了什么事情：时间女皇来到了之前！被长生欲望熏昏了头脑的维瑟尔杀死了穆罕默德，囚禁了印度公主法拉，控制了印度的军队来进攻巴比伦城！企图寻找时间女皇！时间女皇凯琳娜终于落在了维瑟尔手中！残忍的维瑟尔用时之匕首杀死了凯琳娜，释放出了时之砂，他又将匕首插进自己的身体里，随后变成了一个金黄色的怪物——维瑟尔终于达到了他长生不老的愿望。整个巴比伦城被时之沙吞没，那些侵略军全部被感染到了时之砂，变成了沙之怪物，就连王子自己的手臂也被时之砂侵入。危急时刻，王子挣脱了束缚，抢走了时之匕首，离开了巴比伦皇宫。时之沙唤起了王子最大的敌人…… 被时之沙感染的王子感觉到体内产生另一个邪恶的人格——黑暗王子。黑暗王子狡猾，残忍，对弱者没有同情心，但在冒险的时候王子却需要变身成黑暗王子来渡过难关。 在这种奇怪的组合下，王子又遇到了自己爱慕的印度公主法拉。法拉被维瑟尔囚禁后也被带到了巴比伦城。后来法拉在时之沙的混乱中逃脱，遇到了游荡在巴比伦城的王子。起初法拉对波斯王子的双重身份深感怀疑，但在随后的冒险中逐渐与王子重新建立了信任和友情（法拉再次遇见王子的时候也和维瑟尔一样不认识他了）。但在冒险的过程中，黑暗王子的感染变得越来越严重，这让王子本身深感不安。不幸的是，冒失的法拉又被维瑟尔抓住，而王子被打入了一个黑暗的深洞里。 最后，在巴比伦城黑暗的地下宫殿里，王子找到了他父亲波斯王沙拉曼的尸体。悲痛的王子拿起父亲的宝剑，抑制住了邪恶的黑暗王子的意识，决心找维瑟尔复仇。 在巴比伦的空中花园，左手持波斯帝王宝剑，右手持时之匕首的王子与维瑟尔展开了一场决战！胜利的王子将时之匕首插进了维瑟尔的心脏，彻底的终结了这个邪恶的灵魂。 已经变成时之沙的凯琳娜再度幻化成人形来跟王子告别：这个世界本不属于我，自有我所归属的世界……王子将时之匕首交给凯琳娜，凯琳娜化做时之砂，向远方飘散而去。 凯琳娜消失之后，黑暗王子从王子的内心世界中分裂出来，企图夺走王子的一切，但王子走出内心的阴霾，最终在虚幻的世界中消灭了黑暗王子。 时之砂消逝，邪恶力量破灭，波斯帝国的子民为王子所拯救，一切都结束了。 在巴比伦的空中花园，王子再次向法拉讲起了那个时间的故事。\u0026ndash;百度百科\n","id":26,"section":"posts","summary":"波斯王子 prince of persia是ubisoft于1989年发行的一款单机游戏 波斯王子有好多部，前3部是一个完整的故事，后面则是一些衍生 这是我201","tags":[],"title":"波斯王子","uri":"https://dyhgo.github.io/2020/03/%E6%B3%A2%E6%96%AF%E7%8E%8B%E5%AD%90/","year":"2020"},{"content":"Common Subsequence Time Limit: 1000MS\tMemory Limit: 10000K\nDescription A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = \u0026lt; x1, x2, \u0026hellip;, xm \u0026gt; another sequence Z = \u0026lt; z1, z2, \u0026hellip;, zk \u0026gt; is a subsequence of X if there exists a strictly increasing sequence \u0026lt; i1, i2, \u0026hellip;, ik \u0026gt; of indices of X such that for all j = 1,2,\u0026hellip;,k, xij = zj. For example, Z = \u0026lt; a, b, f, c \u0026gt; is a subsequence of X = \u0026lt; a, b, c, f, b, c \u0026gt; with index sequence \u0026lt; 1, 2, 4, 6 \u0026gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.\nInput The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.\nOutput For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.\nSample Input abcfbc abfcab programming contest abcd mnp\nSample Output 4 2 0\nSource Southeastern Europe 2003\nSolution 水一题线性dp裸题\u0026ndash;LCS(longest common subsequence)\n因为没加string头文件CE了3次（被error误导了）\nac代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;string\u0026gt;\rusing namespace std;\rstring s1,s2;\rint dp[1000][1000]; //dp[i][j] 表示s1到i，s2到j的lcs长度\rint len1,len2; int lcs(string s1,string s2)\r{\rlen1=s1.length();\rlen2=s2.length();\rmemset(dp,0,sizeof(dp));\rfor(int i=0;i\u0026lt;len1;i++)\rfor(int j=0;j\u0026lt;len2;j++)\rif(s1[i]==s2[j])\rdp[i+1][j+1]=dp[i][j]+1;\relse\rdp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);\rreturn dp[len1][len2];\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rwhile(cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2)\rcout\u0026lt;\u0026lt;lcs(s1,s2)\u0026lt;\u0026lt;endl;\treturn 0;\r}\r have a good day ^_^\n","id":27,"section":"posts","summary":"Common Subsequence Time Limit: 1000MS Memory Limit: 10000K Description A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = \u0026lt; x1, x2, \u0026hellip;, xm \u0026gt; another sequence Z = \u0026lt; z1, z2, \u0026hellip;, zk \u0026gt; is a subsequence of X if there exists a strictly increasing sequence \u0026lt; i1, i2, \u0026hellip;, ik \u0026gt; of indices of X such","tags":["cpp","dp"],"title":"poj1458","uri":"https://dyhgo.github.io/2020/03/poj1458/","year":"2020"},{"content":"Traveling by Stagecoach Description Once upon a time, there was a traveler.\nHe plans to travel using stagecoaches (horse wagons). His starting point and destination are fixed, but he cannot determine his route. Your job in this problem is to write a program which determines the route for him.\nThere are several cities in the country, and a road network connecting them. If there is a road between two cities, one can travel by a stagecoach from one of them to the other. A coach ticket is needed for a coach ride. The number of horses is specified in each of the tickets. Of course, with more horses, the coach runs faster.\nAt the starting point, the traveler has a number of coach tickets. By considering these tickets and the information on the road network, you should find the best possible route that takes him to the destination in the shortest time. The usage of coach tickets should be taken into account.\nThe following conditions are assumed. A coach ride takes the traveler from one city to another directly connected by a road. In other words, on each arrival to a city, he must change the coach. Only one ticket can be used for a coach ride between two cities directly connected by a road. Each ticket can be used only once. The time needed for a coach ride is the distance between two cities divided by the number of horses. The time needed for the coach change should be ignored.\nInput The input consists of multiple datasets, each in the following format. The last dataset is followed by a line containing five zeros (separated by a space).\nn m p a b t1 t2 \u0026hellip; tn x1 y1 z1 x2 y2 z2 \u0026hellip; xp yp zp\nEvery input item in a dataset is a non-negative integer. If a line contains two or more input items, they are separated by a space.\nn is the number of coach tickets. You can assume that the number of tickets is between 1 and 8. m is the number of cities in the network. You can assume that the number of cities is between 2 and 30. p is the number of roads between cities, which may be zero.\na is the city index of the starting city. b is the city index of the destination city. a is not equal to b. You can assume that all city indices in a dataset (including the above two) are between 1 and m.\nThe second line of a dataset gives the details of coach tickets. ti is the number of horses specified in the i-th coach ticket (1\u0026lt;=i\u0026lt;=n). You can assume that the number of horses is between 1 and 10.\nThe following p lines give the details of roads between cities. The i-th road connects two cities with city indices xi and yi, and has a distance zi (1\u0026lt;=i\u0026lt;=p). You can assume that the distance is between 1 and 100.\nNo two roads connect the same pair of cities. A road never connects a city with itself. Each road can be traveled in both directions.\nOutput For each dataset in the input, one line should be output as specified below. An output line should not contain extra characters such as spaces.\nIf the traveler can reach the destination, the time needed for the best route (a route with the shortest time) should be printed. The answer should not have an error greater than 0.001. You may output any number of digits after the decimal point, provided that the above accuracy condition is satisfied.\nIf the traveler cannot reach the destination, the string \u0026ldquo;Impossible\u0026rdquo; should be printed. One cannot reach the destination either when there are no routes leading to the destination, or when the number of tickets is not sufficient. Note that the first letter of \u0026ldquo;Impossible\u0026rdquo; is in uppercase, while the other letters are in lowercase.\nSample Input 3 4 3 1 4 3 1 2 1 2 10 2 3 30 3 4 20 2 4 4 2 1 3 1 2 3 3 1 3 3 4 1 2 4 2 5 2 4 3 4 1 5 5 1 2 10 2 3 10 3 4 10 1 2 0 1 2 1 8 5 10 1 5 2 7 1 8 4 5 6 3 1 2 5 2 3 4 3 4 7 4 5 3 1 3 25 2 4 23 3 5 22 1 4 45 2 5 51 1 5 99 0 0 0 0 0\nSample Output 30.000 3.667 Impossible Impossible 2.856\nHint Since the number of digits after the decimal point is not specified, the above result is not the only solution. For example, the following result is also acceptable.\n30.0\n3.66667\nImpossible\nImpossible\n2.85595\nSource Japan 2005 Domestic\nSolution TSP问题\n不能在多项式时间内求解\n暴力求解是阶乘数量级的\n在数据不是很大的时候可以用状态压缩dp\n对于这道题时间复杂度O((2^n)*m*m*n)\n基础状态压缩dp\n以3.667为例\n道路图为\ndp[S][x]\nS表示剩余车票集合\nx表示从a出发到达x（单源最短路）\ndp表示最小花费\n这样就变成DAG求最短路问题，不需要使用dijkstra算法，用dp就可以\ndp的初始条件是\ndp=inf , dp[U][a]=0\ndp的状态转移方程\ndp[S/{i}][u] = min{dp[S][v]+d[v][u]/t[i] (i∈S)}\n将集合用整数的二进制表示\n根据状态转移方程，可以用记忆化搜索+递归\n这个问题可以用循环嵌套求解\n约束条件很重要\n这道题的约束条件是“车票”\n如果题目要求每个点只能走一遍的话\n那么又有一个约束条件是“点”（即判断这个点是否走过）\n循环嵌套的写法就是按照套路\n遍历所有子集，嵌套遍历每种子集的操作情况\n遍历集合的所有情况（逆序）\n嵌套遍历每个点\n再嵌套遍历每个点\n依题意再嵌套遍历剩下的所有车票（顺序可与上一步调换）\n最后遍历所有的dp[S\u0026rsquo;][b] S'⊆U，获得最小值\nac代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#define maxn 8\r#define maxm 30\r#define inf 0x3f3f3f3f\rusing namespace std;\rint n,m,p,a,b;\rint t[maxn];\rint d[maxm][maxm];\rdouble dp[1\u0026lt;\u0026lt;maxn][maxm]; //dp[剩下的车票集合][目标城市]=从a到达目标城市的最短时间 int main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rwhile(scanf(\u0026quot;%d%d%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;m,\u0026amp;p,\u0026amp;a,\u0026amp;b)==5 and !(n==0 and m==0 and p==0 and a==0 and b==0))\r{\rfor(int i=0;i\u0026lt;n;i++) scanf(\u0026quot;%d\u0026quot;,\u0026amp;t[i]);\rmemset(d,-1,sizeof(d));\rint temp1,temp2,temp3;\rfor(int i=0;i\u0026lt;p;i++)\r{\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;temp1,\u0026amp;temp2,\u0026amp;temp3);\rd[temp1-1][temp2-1]=temp3;\rd[temp2-1][temp1-1]=temp3;\r}\rfor(int i=0;i\u0026lt;1\u0026lt;\u0026lt;n;i++) fill(dp[i],dp[i]+m,inf); //注意这里要用循环初始化二维数组 //inf是因为要用到min dp[(1\u0026lt;\u0026lt;n)-1][a-1]=0;\rdouble res=inf; //inf是因为要用到min for(int s=(1\u0026lt;\u0026lt;n)-1;s\u0026gt;=0;s--)\r{\rres=min(res,dp[s][b-1]);\rfor(int v=0;v\u0026lt;m;v++)\r{\rfor(int u=0;u\u0026lt;m;u++)\r{\rif(d[v][u]\u0026gt;=0)\r{\rfor(int i=0;i\u0026lt;n;i++)\r{\rif(s\u0026gt;\u0026gt;i\u0026amp;1)\r{\rdp[s\u0026amp;~(1\u0026lt;\u0026lt;i)][u]=min(dp[s\u0026amp;~(1\u0026lt;\u0026lt;i)][u],dp[s][v]+(double)d[u][v]/t[i]);\r}\r}\r}\r}\r}\r}\rif(res==inf) printf(\u0026quot;Impossible\\n\u0026quot;);\relse printf(\u0026quot;%.3lf\\n\u0026quot;,res); //discuss里面说poj用lf会wa,用f就ac ，但我试了lf也可以ac\r}\rreturn 0;\r}\r ","id":28,"section":"posts","summary":"Traveling by Stagecoach Description Once upon a time, there was a traveler. He plans to travel using stagecoaches (horse wagons). His starting point and destination are fixed, but he cannot determine his route. Your job in this problem is to write a program which determines the route for him. There are several cities in the country, and a road network connecting them. If there is a road between two cities,","tags":["cpp","dp","binary"],"title":"poj2686","uri":"https://dyhgo.github.io/2020/03/poj2686/","year":"2020"},{"content":"A - Duplex Printing 题目链接 题意 每一页正反两面可以分别写一个数，问有n个不同的数可以写几页\n思路 简单模拟\nac代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint main()\r{\rint a;\rcin\u0026gt;\u0026gt;a;\rif(a\u0026amp;1)\rcout\u0026lt;\u0026lt;a/2+1\u0026lt;\u0026lt;endl;\relse\rcout\u0026lt;\u0026lt;a/2;\rreturn 0;\r}\r B - Bingo 题目链接 题意 有一个3*3的网格填满数字，接下来给出一些数字，如果网格中有，就标记。\n问是否存在一行或一列或对角线满足它们都被标记\n思路 由于数据不是很大，所以暴力模拟\nac代码如下\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rbool b[3][3];\rint main()\r{\rint d[3][3];\rint n;\rfor(int i=0;i\u0026lt;3;i++)\rfor(int j=0;j\u0026lt;3;j++)\rcin\u0026gt;\u0026gt;d[i][j];\rcin\u0026gt;\u0026gt;n;\rint t;\rwhile(n--)\r{\rcin\u0026gt;\u0026gt;t;\rfor(int i=0;i\u0026lt;3;i++)\rfor(int j=0;j\u0026lt;3;j++)\r{\rif(d[i][j]==t)\r{\rb[i][j]=true;\rbreak;\r}\r}\r}\rbool flag=false;\rfor(int i=0;i\u0026lt;3;i++)\r{\rif(b[0][i]== true and b[1][i]==true and b[2][i]==true) {\rflag=true;\rbreak;\r}\r}\rfor(int i=0;i\u0026lt;3;i++)\r{\rif(b[i][0]== true and b[i][1]==true and b[i][2]==true) {\rflag=true;\rbreak;\r}\r}\rif(b[0][0]==true and b[1][1]==true and b[2][2]==true) {\rflag=true;\r}\rif(b[0][2]==true and b[1][1]==true and b[2][0]==true)\r{\rflag=true;\r}\rif(flag) cout\u0026lt;\u0026lt;\u0026quot;Yes\u0026quot;\u0026lt;\u0026lt;endl;\relse cout\u0026lt;\u0026lt;\u0026quot;No\u0026quot;\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r C - Guess The Number 题目链接 题意 给一个数位n，和若干个条件，条件类型为ai位必须是数字bi，求满足这些条件的最小n\n位数，不满足输出-1\n思路 数据很小，简单模拟，有很多的细节，注意一位数、前导0等特殊情况\n由于边打代码边想，所以代码很乱\nac代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rbool use[3];\rint main()\r{\rint d[3];\rint n,m;\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rint s,c;\rbool flag=true;\rfor(int i=0;i\u0026lt;m;i++)\r{ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;c;\rs--;\rif(n!=1 and s==0 and c==0)\r{\rflag=false;\rbreak;\r}\relse if(s\u0026gt;n)\r{\rflag=false;\rbreak;\r}\relse if(use[s] and c!=d[s])\r{\rflag=false;\rbreak;\r}\relse\r{\rd[s]=c;\ruse[s]=true;\r}\r}\rif(n!=1 and !use[0]) {\rd[0]=1;\rfor(int i=1;i\u0026lt;n;i++)\r{\rif(!use[i]) d[i]=0;\r}\r}\relse\r{\rfor(int i=0;i\u0026lt;n;i++)\r{\rif(!use[i])\rd[i]=0;\r}\r}\rif(!flag) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl;\relse {\rfor(int i=0;i\u0026lt;n;i++)\r{\rcout\u0026lt;\u0026lt;d[i];\r}\rcout\u0026lt;\u0026lt;endl;\r}\r//cout\u0026lt;\u0026lt;use[2]\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r D - Friend Suggestions 题目链接 题意 有n个人和两种关系（双向的）friendship 和 blockship\n定义：一个人为另一个人的friend candidate\n当且仅当满足他们没有这两种关系且他们之间存在着friendship的传导链\n问每个人的friend candidate数量\n思路 由于需要friendship传导链，又存在friendship的双向关系，所以考虑并查集\n再遍历一遍信息，如果是直接的friendship和blockship关系就减掉这个人（数量减1）\n（需要计算集合元素个数）\nac代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,m,k;\r//union find\rint par[100005]; int rankk[100005]; int sizz[100005];\rint ans[100005];\rint a[100005];\rint b[100005];\rint c[100005];\rint d[100005];\rvoid init(int n) {\rfor(int i=0;i\u0026lt;n;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} int find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); } void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; if(rankk[x]\u0026lt;rankk[y]) par[x]=y,sizz[y]+=sizz[x]; else\r{\rpar[y]=x;\rsizz[x]+=sizz[y];\rif(rankk[x]==rankk[y]) rankk[x]++; } } bool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\rios::sync_with_stdio(0);cin.tie(0);\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k;\rinit(n);\rfill(sizz,sizz+n,1);\rfor(int i=0;i\u0026lt;m;i++)\r{\rcin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;b[i];\r}\rfor(int i=0;i\u0026lt;k;i++)\r{\rcin\u0026gt;\u0026gt;c[i]\u0026gt;\u0026gt;d[i];\r}\rfor(int i=0;i\u0026lt;m;i++)\r{\runite(a[i],b[i]);\r}\rfor(int i=1;i\u0026lt;=n;i++)\r{\rans[i]=sizz[find(i)];\r}\rfor(int i=0;i\u0026lt;m;i++)\r{\rif(same(a[i],b[i]))\r{\rans[a[i]]--;\rans[b[i]]--;\r}\r}\rfor(int i=0;i\u0026lt;k;i++)\r{\rif(same(c[i],d[i]))\r{\rans[c[i]]--;\rans[d[i]]--;\r}\r}\rcout\u0026lt;\u0026lt;ans[1]-1;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rcout\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;ans[i]-1;\r}\rcout\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r E - Simple String Queries 题目链接 题意 给一个只有小写字母的字符串s，和两种操作\n将ai下标的字符替换成bi\n查询l到r区间内有多少个不同的字母，输出结果\n思路 数据太大，不能简单模拟\n用合理的数据结构\n用26个集合存储有这个字母对应的下标\n对于查询区间，遍历26个集合，查询这个区间是否存在该字母（如果存在 ans++）\n只需要对每个集合二分搜索左边界的标号，如果这个标号在右边界内，即存在\nac代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n,q;\rstring s;\rset\u0026lt;int\u0026gt; st[27];\rint main()\r{\rios::sync_with_stdio(false);cin.tie(false);\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rcin\u0026gt;\u0026gt;s;\rcin\u0026gt;\u0026gt;q;\rfor(int i=0;i\u0026lt;26;i++)\r{\rst[i].insert(n); //防止使用lower_bound时集合为空 }\rfor(int i=0;i\u0026lt;n;i++)\r{\rst[s[i]-'a'].insert(i);\r}\rint t;\rfor(int i=0;i\u0026lt;q;i++)\r{\rcin\u0026gt;\u0026gt;t;\rif(t==1)\r{\rint a;char b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rst[s[a-1]-'a'].erase(a-1);\rst[b-'a'].insert(a-1);\rs[a-1]=b;\r}\relse\r{\rint l,r;\rcin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r;\rint ans=0;\rfor(int i=0;i\u0026lt;26;i++)\r{\rauto it=st[i].lower_bound(l-1);\rif(*it\u0026lt;=r-1) ans++;\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\r}\r}\rreturn 0;\r}\r F - Yakiniku Optimization Problem 题目链接 题意 平面上有n个点，每个点有一个属性ci，坐标上至少存在一个点使得这个点到其中k个点\n的距离*ci（只对k个点中的一点）的值的最大值最小\n输出最小值\n思路 有趣的计算几何\n很难通过找到点来求最小值\n很常见的做法是用二分法\n区间的值为“最大值“\n每一次检查满足“最大值”的点是否超过k个\n超过则将最大值减小\n否则将最大值增大（理论上直到满足k个点）\n通过精度来停机\n怎样检查？\n每个点的属性=当前“最大值” / ci\n以点为圆心，每个点的属性为半径，每两个圆可能存在交点\n遍历每个点，如果交点在某个点的属性范围内，这个点也满足条件\n遍历所有情况，求最多有多少个点满足条件\n以此来检查是否超过k\n注意点\n1.只有一个点的特判\n2.要有eps，而且eps不能太大也不能太小\n3.为避免重复计算，j从i开始，但不能从i+1开始，因为有可能目标点就在某一点上\n从i+1开始会wa掉1个测试点\nac代码如下\n#include \u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n, k;\rdouble x[65], y[65], c[65], r[65];\rdouble eps = 1e-8; //!!!\rdouble dist(pair\u0026lt;double, double\u0026gt; p, pair\u0026lt;double, double\u0026gt; q) {\rdouble xx = (p.first - q.first)*(p.first - q.first);\rdouble yy = (p.second - q.second)*(p.second - q.second);\rreturn sqrt(xx + yy);\r}\rvector\u0026lt;pair\u0026lt;double, double\u0026gt;\u0026gt; circle_circle_intersection(double x1, double y1, double r1, double x2, double y2, double r2) {\rvector\u0026lt;pair\u0026lt;double, double\u0026gt; \u0026gt; ans;\rdouble d = dist(make_pair(x1, y1), make_pair(x2, y2));\rif (d \u0026gt; r1 + r2) {\rreturn ans;\r}\rif (x1 == x2 \u0026amp;\u0026amp; y1 == y2) {\rans.push_back(make_pair(x1, y1)); return ans;\r}\rif (d \u0026lt; abs(r1 - r2)) {\rans.push_back(make_pair(x1, y1)); return ans;\r}\rdouble a = (r1*r1 - r2*r2 + d*d)/(2*d);\rdouble h = sqrt(r1*r1 - a*a);\rdouble x3 = (x2 - x1)*(a/d) + x1;\rdouble y3 = (y2 - y1)*(a/d) + y1;\rans.emplace_back(x3 + h*(y2 - y1)/d, y3 - h*(x2 - x1)/d);\rans.emplace_back(x3 - h*(y2 - y1)/d, y3 + h*(x2 - x1)/d);\rreturn ans;\r}\rint check(double t) {\rint ans = 0;\rfor (int i = 0; i \u0026lt; n; i++) {\rr[i] = t/c[i];\r}\rfor (int i = 0; i \u0026lt; n; i++) {\rfor (int j = i; j \u0026lt; n; j++) { //!!!\rvector\u0026lt;pair\u0026lt;double, double\u0026gt; \u0026gt; pts = circle_circle_intersection(x[i], y[i], r[i], x[j], y[j], r[j]);\rfor (auto p: pts) {\rint cnt = 0;\rfor (int k = 0; k \u0026lt; n; k++) {\rif (dist(p, make_pair(x[k], y[k])) \u0026lt;= r[k] +eps) cnt++;\r}\rans = max(ans, cnt);\r}\r}\r}\rreturn ans;\r}\rint main() {\rios::sync_with_stdio(0); cin.tie(0);\rcin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k;\rif (k == 1) {\rcout \u0026lt;\u0026lt; \u0026quot;0\\n\u0026quot;; exit(0);\r}\rfor (int i = 0; i \u0026lt; n; i++) {\rcin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i] \u0026gt;\u0026gt; c[i];\r}\rdouble l = 0, r = 100000000;\rwhile(r-l\u0026gt;=1e-8)\r{\rdouble mid = (l + r)/2;\rif (check(mid) \u0026gt;= k) {\rr = mid;\r} else {\rl = mid;\r}\r}\rcout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(9) \u0026lt;\u0026lt; r \u0026lt;\u0026lt; '\\n'; return 0;\r}\r 个人感觉abc很考验思维和对数据结构的熟练度\n","id":29,"section":"posts","summary":"A - Duplex Printing 题目链接 题意 每一页正反两面可以分别写一个数，问有n个不同的数可以写几页 思路 简单模拟 ac代码如下 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int a; cin\u0026gt;\u0026gt;a; if(a\u0026amp;1) cout\u0026lt;\u0026lt;a/2+1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;a/2; return 0; } B -","tags":["cpp","computational_geometry","string","union_find"],"title":"abc157","uri":"https://dyhgo.github.io/2020/03/abc157/","year":"2020"},{"content":"paste a music below\n[video(video-HXuIKyFl-1583157343324)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=93185992)(image-https://ss.csdn.net/p?http://i0.hdslb.com/bfs/archive/393b26d243ae8f1c7b3cf4d1ba0bea2fd4015d85.jpg)(title-【暴走大事件】致 杠 精)]\n[video(video-QTmoAEnp-1585132330863)(type-undefined)(url-undefined)(image-https://img-blog.csdnimg.cn/editor-video.png)(title-undefined)]\n","id":30,"section":"posts","summary":"paste a music below [video(video-HXuIKyFl-1583157343324)(type-bilibili)(url-https://pl","tags":["test"],"title":"test for music and video","uri":"https://dyhgo.github.io/2020/03/test-for-music-and-video/","year":"2020"},{"content":"","id":31,"section":"posts","summary":"","tags":["test"],"title":"test","uri":"https://dyhgo.github.io/2020/02/test/","year":"2020"},{"content":"效果展示\n在hugo官网也有说明如何搭建个人网站\n注册github账号 创建github仓库 仓库的名字必须是 用户名.github.io\n建议全小写\n安装git bash（非必须，但建议） 点击此处\n选择计算机对应的规格\n一步一步安装\n在使用前要进行初始化用户名和邮箱\n打开终端（以powershell为例）\n输入git命令，没有异常就可以\n安装hugo 点击此处\n选择计算机对应的规格\n下载zip压缩包\n解压后会得到 hugo.exe（这个是主要的）\n创建博客 打开powershell\n转到存放hugo.exe的文件夹下（hugo指令只能在这个目录下执行）\n如果hugo指令识别不出来，可以配置环境变量\n如果还是不行，那就用绝对路径，一直到hugo.exe\n要启动hugo.exe就要用 .\\hugo\n在存放hugo.exe的文件夹下，执行以下代码\n\u0026gt;hugo new site myblog\r myblog是自己起的名字，是一个identifier\n之后会生成myblog文件夹\n里面已经有一些东西了（大部分都是建立网站必须的）\n下载主题 点击此处\n选一个主题下载\n下载有两种方式\n1.点击download，转到作者github，下载zip\n把zip转到myblog/theme下，需要改文件夹一些名字\n2.在主题下面有git clone(推荐使用这种)\n直接在powershell下面输入（一定要 cd 到myblog）\n个别主题下载的慢，可以在不同时间不同地点多试试\n下载完，myblog/theme 就会多出一个主题对应的文件夹（很重要）\n以下是无论哪一种都要进行的操作\n根据作者在hugo网页中写的文档进行初始化配置（就是把主题文件夹中的东西搬出来，替换什么的）（很重要，没有这一步，可能本地都打不开，疯狂报错）（但有些主题没有此过程）\n尝试在本地打开\n输入以下代码(以pure主题为例）(这个主题名字是theme下对应文件夹的名字)\nmyblog\u0026gt;hugo server -t pure\r 会得到一个本地网址\n用浏览器打开这个网址\n就可以在本地看到自己的网页\n局域网内的用户也可以看到你的网页\n部署到服务器上（github pages） 建议先在本地查看，确认无误之后再推到服务器\n输入以下代码\n注意不要写错\nmyblog\u0026gt;hugo --theme=pure --baseUrl=\u0026quot;https://你的用户名.github.io\u0026quot; --buildDrafts\r myblog下会生成public文件夹\n输入以下代码\nmyblog\u0026gt;cd public\rpublic\u0026gt;git init\rpublic\u0026gt;git add .\rpublic\u0026gt;git commit -m \u0026quot;输入你自己的提交信息\u0026quot;\rpublic\u0026gt;git remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u0026gt;git push -u origin master\rpublic\u0026gt;\r 此过程中有可能需要输入github的账号和密码\n访问 用户名.github.io就可以看到你的网页\n会有延迟，需要等一会\n配置主题和增加内容 配置因主题而异\n通法就是认真仔细地阅读作者的文档\nhugo/theme上的或者README.md（可见文档有多重要）\n增加的内容一般都放在content文件夹下，当然也可以删掉内容\n一般是markdown格式\n写markdown可以用markdownpad / visual studio code / csdn自带的等等\n但是发现一个问题，不同的编辑器预览的效果不一样\n比如markdownpad不能很好的识别latex公式\n有可能主题自带的markdown也不能很好的呈现出效果\n更新网站内容 ！！！文件名字不能有 #\n建议首先在本地预览，确认无误再上传\n然后执行以下代码（含本地预览）\nmyblog\u0026gt;hugo server -t pure\rmyblog\u0026gt;hugo --theme=pure --baseUrl=\u0026quot;https://你的用户名.github.io\u0026quot; --buildDrafts\rmyblog\u0026gt;cd public\rpublic\u0026gt;git init\rpublic\u0026gt;git add .\rpublic\u0026gt;git commit -m \u0026quot;输入你自己的提交信息\u0026quot;\rpublic\u0026gt;git remote add origin https://github.com/用户名/用户名.github.io.git\rpublic\u0026gt;git pull origin master\rpublic\u0026gt;git push -u origin master\rpublic\u0026gt;\r 一定要写git pull origin master\n有延迟\n打开 用户名.github.io 可以看到内容已经更新\n之后更新网站内容就一直重复上述操作\n=================== 以下是自定义域名（附加内容）===================== 在阿里云上面注册账号\n实名制\n购买域名\n域名实名制\n购买SSL证书（有免费的）\n确定SSL证书有效\n配置DNS服务器\n在域名解析中添加记录\n记录类型为CNAME\n记录值填写 用户名.github.io（或者记录类型为A，记录值填写IP地址）\n打开github对应的仓库\n在settings中找到custom domain\n输入新域名\n在github pages下显示绿色的√就可以\n访问新域名就可以看到网页了\n之后更新的内容，都可以通过访问新域名实现\n以上操作都需要时间，需耐心等待\n个人博客网站基本搭建完毕\n","id":32,"section":"posts","summary":"效果展示 在hugo官网也有说明如何搭建个人网站 注册github账号 创建github仓库 仓库的名字必须是 用户名.github.io 建议全小写 安","tags":["hugo"],"title":"用hugo搭建个人博客网站","uri":"https://dyhgo.github.io/2020/02/%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","year":"2020"},{"content":"以二进制的原理表示集合，以整数呈现\n1表示在集合内，0表示不在集合内\n一位运算优先于按位逻辑运算\n空集 0 只含有第i个元素的集合{i} 1\u0026laquo;i 含有全部n个元素的集合 {0,1,2,\u0026hellip;n-1} (1\u0026laquo;n) - 1 判断第i个元素是否属于集合S if ( s\u0026raquo;i \u0026amp; 1 ) 原来的集合变了 向集合中加入第i个元素 S∪{i} S|1\u0026laquo;i 从集合中去除第i个元素 S{i} S\u0026amp;~(1\u0026laquo;i) 集合S和T的并集 S|T 集合S和T的交集 S\u0026amp;T\n按顺序枚举集合的子集\nfor(int S=0;S\u0026lt;1\u0026lt;\u0026lt;n;S++)\r 枚举某个集合sup的子集\nint sub=sup;\rdo\r{\rsub=(sub-1)\u0026amp;sup;\r}while(sub!=sup); //处理完0之后，会有-1\u0026amp;sup=sup  枚举{0,1,2,\u0026hellip;n-1}所包含的大小为k的子集\nint comb=(1\u0026lt;\u0026lt;k)-1;\rwhile(comb\u0026lt;1\u0026lt;\u0026lt;n)\r{\rint x=comb \u0026amp; -comb , y=comb+x;\rcomb=((comb \u0026amp; ~y) / x\u0026gt;\u0026gt;1) | y;\r}\r ","id":33,"section":"posts","summary":"以二进制的原理表示集合，以整数呈现 1表示在集合内，0表示不在集合内 一位运算优先于按位逻辑运算 空集 0 只含有第i个元素的集合{i} 1\u0026laquo;i 含有全部n个","tags":["cpp","binary"],"title":"二进制表示集合","uri":"https://dyhgo.github.io/2020/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%9B%86%E5%90%88/","year":"2020"},{"content":"求最大公约数和最小公倍数 辗转相除法\n时间复杂度O(log(max(a,b)))\nint gcd(int a,int b)\r{\rif(b==0) return a;\relse return gcd(b,a%b);\r}\rint lcm(int a,int b)\r{\rreturn a*b/gcd(a,b);\r}\r 或直接调用algorithm库中的__gcd(int a,int b) 扩展欧几里得算法 求满足 ax+by=gcd(a,b) 的整数解 x ，y\n时间复杂度O(log(max(a,b)))\nint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\r  求n以内质数个数 很多种方法，以下是埃氏筛\n时间复杂度O(nloglogn)\nint prime[maxn]; //ith prime number\rbool isprime[maxn+1] //is i a prime number\rint e_sieve(int n)\r{\rint p=0; //position\rfor(int i=0;i\u0026lt;=n;i++) isprime[i]=true; //initialize\risprime[0]=isprime[1]=false;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rif(isprime[i])\r{\rprime[p++]=i;\rfor(int j=2*i;j\u0026lt;=n;j+=i) isprime[j]=true;\r}\r}\rreturn p;\r}\r  数论的一些性质 Premise: a≡c (mod m) and b≡d (mod m) Conclusion: a±b≡c±d (mod m) a*b≡c*d (mod m) d|a \u0026amp;\u0026amp; d|b ⇒ d|gcd(a,b) gcd(an,bn) = n*gcd(a,b) 任意正整数n，n|ab \u0026amp;\u0026amp; a,n互质 ⇒ n|b a,p 互质 ， b,p互质 ⇒ ab,p互质 任意一个合数都可以分解成唯一的质数幂积的形式，即 $$ a=\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} $$ 因子个数为 $$ \\sum\\limits_{i=1} ^ {n} {(1+e_i)} $$ 积性函数 f(ab) = f(a)f(b) 欧拉函数 莫比乌斯函数 gcd 狄利克雷函数\n 快速幂 时间复杂度O(logn)\ntypedef long long ll;\rll qpow(ll x,ll n,ll mod)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;\r}\r  逆元 $$ 逆元\\quad y=a^{-1}\\quad满足\\quad ay≡1(mod\\ m) ~\\ y为a在模m下的逆元 $$ $$ 对于\\quad ax≡b(mod\\ m) ~\\ x=a^{-1}*b $$ 求逆元 $$ ax≡1(mod\\ m) ~\\ ax-mk=1 ~\\ ax+my=1 ~\\ ax+my=gcd(a,m) ~\\当a,m不互质的时候，逆元不存在 $$\nint mod_inverse(int a,int m)\r{\rint x,y;\rex_gcd(a,m,x,y);\rreturn (m+x%m)%m;\r}   欧拉函数 $$ 设\\quad n =\\prod\\limits_{i=1} ^ {n} {{p_i} ^ {e_i}} ~\\ 则欧拉函数\\quad φ(n)=n*\\prod\\limits_{i=1} ^ {n} {\\frac{p_i-1}{p_i}} $$ 欧拉函数的数值等于不超过n且与n互质的数的个数\n当n时质数时，φ(n)=n-1\n如果n=p^k , φ(n)=p^k - p^(k-1) = (p-1)p^(k-1)\n如果m,n互质，则φ(mn)=φ(m)φ(n)\nφ(n)的值都为偶数，φ(2)除外\n质因子之和 (φ(n)*n)/2 欧拉定理 $$ 当a,m互质时 ~\\ a^{φ(m)}≡1(mod \\ m) $$ 费马小定理 $$ 当p是质数时， 对任意整数x 都有 ~\\ x^p≡x(mod \\ p) ~\\~\\ 当x,p互质时 ~\\ x^{p-1}≡1(mod \\ p) ~\\ 这就是欧拉定理的特殊形式 $$ 求欧拉函数 时间复杂度O(√(n)) 求欧拉函数值的表，类似于埃氏筛，时间复杂度O(n)\nint phi(int n)\r{\rint res=n;\rfor(int i=2;i*i\u0026lt;=n;i++)\r{\rif(n%i==0)\r{\rres=res/i*(i-1);\rwhile(n%i==0) n/=i;\r}\r}\rif(n!=1) res=res/n*(n-1);\rreturn res;\r}\rint euler_phi[maxn];\rvoid phi_arr()\r{\rfor(int i=0;i\u0026lt;maxn;i++) euler_phi[i]=i;\rfor(int i=2;i\u0026lt;maxn;i++)\r{\rif(euler_phi[i]==i)\r{\rfor(int j=i;j\u0026lt;maxn;j+=i) euler_phi[j]=euler_phi[j]/i*(i-1);\r}\r}\r}\r  线性同余方程组 $$ a_ix≡b_i(mod \\ m_i) $$ 如果方程组有解，一定有无穷多解\n解的全集可以写成 x≡b(mod m)\n所以将问题转化为求b,m\n可以对如下方程组依次求解 $$ x≡b_1(mod \\ m_1) ~\\ ax≡b_2(mod\\ m_2) $$ $$ x≡b_1(mod \\ m_1) ~\\ x=b_1+m_1t ~\\a(b_1+m_1t)≡b_2(mod\\ m_2) ~\\am_1t≡b_2-ab_1(mod \\ m_2) ~\\a\u0026rsquo;t≡b\u0026rsquo;(mod \\ m_2) $$ 当gcd(m₂,am₁)与b₂-ab₁互质时，方程组无解\n时间复杂度O(n)\npair\u0026lt;int,int\u0026gt; linear_congruence(const vector\u0026lt;int\u0026gt;\u0026amp; A,const vector\u0026lt;int\u0026gt;\u0026amp; B,const vector\u0026lt;int\u0026gt;\u0026amp; M)\r{\r//最开始没有限制，把解设为所有整数 x ≡0(mod 1)\rint x=0,m=1;\rfor(int i=0;i\u0026lt;A.size();i++)\r{\rint a=A[i]*m , b=B[i]-A[i]*x , d=gcd(M[i],a); //d!!!\rif(b%d!=0) return make_pair(0,-1); //无解\rint t=b / d * mod_inverse(a/d,M[i]/d) % (M[i]/d) ;\rx=x+m*t;\rm*=M[i]/d; //*= !!!\r}\rreturn make_pair(x%m,m);\r}\r  中国剩余定理(CRT) crt是线性同余方程组ai=0，mi互质的特殊形式\n这时，x≡b(mod Πmi)\ncrt的思想是余数的加性和模数的乘性，当模数为合数时，可以拆成质因数的积\ncrt定理如下 $$ 对于x≡b_i(mod \\ m_i) \\ \\ \\ \\ \\ \\ m_i互质 ~\\ ~\\令M=\\prod{m_i} ~\\M_i=\\frac{M}{m_i} ~\\M_i ^ {-1} 为M_i模m_i的逆元 ~\\\n则 \\ x≡(\\sum\\limits_{i=1} ^ {n} {b_iM_iM_i ^{-1}}) \\ (mod \\ M) $$\n// x=x+(Πmi)*t\r//return minimum int crt(const vector\u0026lt;int\u0026gt;\u0026amp; b,const vector\u0026lt;int\u0026gt; \u0026amp;m)\r{\rint M=1,x=0;\rfor(int i=0;i\u0026lt;m.size();i++) M*=m[i];\rfor(int i=0;i\u0026lt;m.size();i++){\rint Mprime=M/m[i];\rint M_p_i=mod_inverse(Mprime,m[i]);\rx=(x + b[i] * Mprime * M_p_i)%M;\r}\rreturn (x+M)%M;\r}\r  Lucas定理 $$ 求 \\ C_{n}^{k} \\ (mod \\ p) , p是质数 ~\\ 当k,n较小时，利用杨辉三角形的性质 ~\\ C_{n}^{k}=C_{n-1}^k+C_{n-1}^{k-1} ~\\ ~\\当n,k较大时 ~\\ n=\\sum{n_ip^i} \\quad \\quad k=\\sum{k_ip^i} \\quad\\quad表示成p进制~\\ C_n^k≡\\prod{C_{n_i}^{k_i}} \\ (mod \\ p) $$\nll pow_mod(ll a, ll n)\r{\rif(n == 0) return 1;\rll x = pow_mod(a, n/2);\rll ans = x * x % mod;\rif(n % 2 == 1) ans = ans *a % mod;\rreturn ans%mod;\r}\rll C(ll n,ll m) {\rif(n \u0026lt; m) return 0;\rll res = 1;\rfor(ll i=1; i\u0026lt;=m; i++) {\rll a = (n+i-m)%mod;\rll b = i%mod;\rres = res*(a*pow_mod(b,mod-2)%mod)%mod;\r}\rreturn res;\r}\rll Lucas(ll n,ll m) {\rif(m == 0) return 1;\rreturn C(n%mod, m%mod) * Lucas(n/mod,m/mod)%mod;\r}\r ll qpow(ll x,ll n)\r{\rll res =1;\rwhile(n\u0026gt;0)\r{\rif(n\u0026amp;1) res=res*x%mod;\rx=x*x%mod;\rn\u0026gt;\u0026gt;=1;\r}\rreturn res;}\rll com(ll a,ll b){\rll ans=1;\rfor(ll i=a;i\u0026gt;a-b;i--){\rans=ans*i%mod;\r}\rfor(ll i=1;i\u0026lt;=b;i++){\rans=(ans*qpow(i,mod-2))%mod;\r}\rreturn ans;\r}\r ","id":34,"section":"posts","summary":"求最大公约数和最小公倍数 辗转相除法 时间复杂度O(log(max(a,b))) int gcd(int a,int b) { if(b==0) return a; else return gcd(b,a%b); } int lcm(int a,int b) { return a*b/gcd(a,b); } 或直接调用algorit","tags":["cpp","number_theory"],"title":"Number Theory","uri":"https://dyhgo.github.io/2020/02/number-theory/","year":"2020"},{"content":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\nInput 输入的都是整数对n、m（0\u0026lt;n≤m\u0026lt;1000000），如果遇到都是0的整数对，则输入结束。\nOutput 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。\nSample Input 1 100 0 0\nSample Output 80\nSolution 与数位的组成有关，可以用数位dp。\n利用前缀即 solve(m)-solve(n-1)\ndp[i][j] 表示 符合条件的个数[当前操作的数位(倒序排)][当前操作的数位的前一个数] $$ dp[pos][pre] = \\sum\\limits_{i=0} ^ {maxd} dp[pos-1][i] $$ maxd可以由一个boolean变量limit控制，是否是9还是dig[pos]\n为了不重复计算（重复计算也可以），可以用记忆化搜索，也就是可以利用计算好的dp。为了使dp普适，dp必须是稳定，经全搜索得到的（即maxd=9）。所以通过limit控制dp的存储和dp的读取\n通过dp递推式，可以用dfs实现（理论上来说可以不用dfs，但不能记忆化且dp可能要增加维度，且要特殊初始化。没有实践过，有时间可以去试试）\nint dfs(int pos,int pre,bool limit)\n通过limit和返回值来使dp结果普适\nAC代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;cstring\u0026gt;\rusing namespace std;\rint n,m;\rint dp[10][10]; //dp[i][j] i:总共有i位 , j:前导数字为j , dp:满足条件（不含4和62）的个数 int dig[10];\rint dfs(int pos,int pre,bool limit) //pos 当前位置 ， pre 当前位置的前一个数字 {\rif(pos==-1) return 1; //只有0（1个数字）满足\rif(dp[pos][pre]!=-1 \u0026amp;\u0026amp; !limit) return dp[pos][pre]; //已经搜索过则直接返回 //!!!!\rint ans=0;\rint maxd;\rif(limit) maxd=dig[pos];\relse maxd=9;\rfor(int i=0;i\u0026lt;=maxd;i++)\r{\rif(i==4 || (pre==6 \u0026amp;\u0026amp; i==2)) ;\relse ans+=dfs(pos-1,i,limit \u0026amp;\u0026amp; i==dig[pos]); //这里需要传limit !!!!!!!!!! }\rif(!limit) //只有在全搜索的时候才能给dp赋值，这样可以保证dp适用于所有情况，从而实现记忆化搜素 dp[pos][pre]=ans;\rreturn ans;\r}\rint solve(int x)\r{\rint len=0;\rwhile(x)\r{\rdig[len++]=x%10;\rx/=10;\r}\rreturn dfs(len-1,0,1);\r} int main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rmemset(dp,-1,sizeof(dp)); //不需要每次都初始化，因为要记忆化搜索 //不需要对dp特殊初始化，因为dfs中有return 1 while(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m)==2 \u0026amp;\u0026amp; (n || m))\r{\rcout\u0026lt;\u0026lt;solve(m)-solve(n-1)\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}  第一次写数位dp，参考了别人的代码，也调试了很久，思考了很多，才弄懂其中的细节\n","id":35,"section":"posts","summary":"Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不","tags":["cpp","dp","search"],"title":"hduoj2089(数位dp + 记忆化搜索)","uri":"https://dyhgo.github.io/2020/02/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","year":"2020"},{"content":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树\n用一个例子来介绍线段树\nRMQ（range minimum query）\n实现功能 对于一个数列 1.给定s,t求[s,t)区间的最小值（最大值） 2.给定i和x,把ai改成x\nconst int maxn = 1\u0026lt;\u0026lt;17;\rint n,dat[2*maxn+1];\rvoid init(int n_)\r{\r//为了计算方便,把元素个数扩大到2的幂次方的个数\rn=1;\rwhile(n\u0026lt;n_) n*=2;\rfill(dat,dat+2*n-1,inf);\r}\r//将从0开始的第k个值，改成a void update(int k,int a)\r{\rk+=n-1;\rdat[k]=a;\r//向上更新\rwhile(k\u0026gt;0)\r{\rk=(k-1)/2;\rdat[k]=min(dat[2*k+1],dat[2*k+2]);\r} }\r//求[a,b)区间的最小值(从0开始数)\r//后面的参数是为了计算方便传入的\r//k是节点编号，l，r是k节点对应的区间\r//在外部调用是用query(a,b,0,0,n)\rint query(int a,int b,int k,int l,int r)\r{\rif(r\u0026lt;=a || b\u0026lt;=l) return inf;\rif(a\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=b) return dat[k];\relse\r{\rint vl=query(a,b,2*k+1,l,(l+r)/2);\rint lr=query(a,b,2*k+2,(l+r)/2,r);\rreturn min(vl,vr);\r}\r}  初始化的时间复杂度O(n) 更新和查询的时间复杂度O(logn)\n如果dat以1开头，则可以利用这些性质 \u0026gt;\u0026gt;1 : /2取整 \u0026laquo;1 : 乘2 \u0026laquo;1|1 : (*2+1)\n以这题为例\n给出一个长度为 n 的数列，a1,a2,\u0026hellip;,an,求其长度为 k 的连续子段的乘积对 998244353 取模余数的最大值。\nsolution:这道题可以用尺取法、线段树、逆元\n线段树的做法不需要update函数，最底层存每个数，父节点存子节点的乘积，最后query每一段区间\nAC代码如下\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rconst ll mod = 998244353;\rll n_,k;\rll n;\rll dat[4*200005+2];\r//[a,b)\rll query(ll a ,ll b,ll k,ll l,ll r)\r{\rif(r\u0026lt;=a || b\u0026lt;=l) return 1;\rif(a\u0026lt;=l \u0026amp;\u0026amp; r\u0026lt;=b) return dat[k];\rreturn (query(a,b,k*2+1,l,(l+r)/2) * query(a,b,k*2+2,(l+r)/2,r))%mod;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rscanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;n_,\u0026amp;k);\rn=1;\rwhile(n\u0026lt;n_) n*=2;\rfor(ll i=n-1;i\u0026lt;n_-1+n;i++)\r{\rscanf(\u0026quot;%lld\u0026quot;,\u0026amp;dat[i]);\r}\rfor(ll i=n-2;i\u0026gt;=0;i--)\r{\rdat[i]=(dat[i*2+1]*dat[i*2+2]) % mod;\r}\rll ans=-1;\rfor(ll i=0;i+k\u0026lt;=n_;i++)\r{\rans=max(ans,query(i,i+k,0,0,n));\r}\rcout\u0026lt;\u0026lt;ans%mod\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r 有几个点导致WA 1.要用long long 不能用int 2.dat的的大小要用4乘，否则会断错误，因为在query时，最底层的也有可能访问子节点 边界条件是线段树容易出错的地方，以上代码的区间是左闭右开，在判断条件里面用等号注意n_和n的使用\n","id":36,"section":"posts","summary":"线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树 用一个例子来介绍线段树 RMQ（range minimum query） 实现功能 对于一","tags":["cpp","segment_tree"],"title":"Segment Tree","uri":"https://dyhgo.github.io/2020/02/segment-tree/","year":"2020"},{"content":"题目在这\n这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快\n三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2\n求mid midmid与n个点的距离，然后依据较小值缩减区间\n代码如下\n//三分法 最快的应该是0.618法\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rstruct point {\rdouble x,y;\r}p[100005];\rdouble eps = 5e-5;\rdouble check(double x)\r{\rdouble dist = -1;\rfor(int i=0;i\u0026lt;n;i++)\r{\rdist = max(dist,(x-p[i].x)*(x-p[i].x) + p[i].y*p[i].y); }\rreturn sqrt(dist);\r}\rint main()\r{\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%lf %lf\u0026quot;,\u0026amp;p[i].x,\u0026amp;p[i].y);\rdouble l = -10000.0;\rdouble r = 10000.0;\rwhile(r-l\u0026gt;eps)\r{\rdouble mid = l + (r -l)/2; //这里的三分\rdouble midmid = mid+(r-mid)/2;\rif(check(mid)\u0026gt;check(midmid)) l=mid;\relse r=midmid;\r}\rprintf(\u0026quot;%.5lf\\n\u0026quot;,check(l));\rreturn 0;\r}\r ","id":37,"section":"posts","summary":"题目在这 这道题可以用二分法，三分法更好一点（反正当时完全没想到），0.618法应该最快 三分是中间的两个点 mid = l + (r - l) / 2 midmid = mid + (r - mid) / 2","tags":["cpp","binary_search"],"title":"牛客基础训练营5B","uri":"https://dyhgo.github.io/2020/02/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/","year":"2020"},{"content":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等\n二分图判定 通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图\n用dfs判断每个点是否可染色，如果每个点都是可染色的，就是二分图\n//input\rvector\u0026lt;int\u0026gt; G[max_v];\rint V;\rint color[max_v] //顶点i的颜色 1或-1\rbool dfs(int v,int c)\r{\rcolor[v]=c; //染色\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\rif(color[v][i]==c) return false; //相邻顶点同色\rif(color[G[v][i]]==0 \u0026amp;\u0026amp; !dfs(G[v][i],-c)) return false; //对于还没染色的点，如果不能染色则返回false } return true;\r}\rbool bipartite_graph()\r{\rfor(int i=0;i\u0026lt;V;i++)\r{\rif(color[i]==0) //还未着色//如果是连通图，遍历一次就够\rif(!dfs(i,1)) return false; }\rreturn true;\r}  把顶点和边都算的话，时间复杂度是O(|V|+|E|)\n求DAG的拓扑序 求拓扑序可以dfs，删边法（通过栈或队列）\n求每个点的入度，将入度为0的点入栈，遍历栈里的点，将于这些点相邻的点的入度减1，如果有点入度为0，则入栈。依靠这个顺序，得到的就是拓扑序。如果点访问两次，则有圈。可以通过这个方法判断有向图是否有圈\n//input\rvector\u0026lt;int\u0026gt; G[max_v]\rint V;\rint indgree[max_v] //每个顶点的入度\rvector\u0026lt;int\u0026gt; res; //拓扑排序的结果\rbool topological_sort() //判断是否能拓扑排序 ，若果有圈就不能 {\rstack\u0026lt;int\u0026gt; s;\r//int counter=0; //遍历的点的个数 for(int i=0;i\u0026lt;V;i++) if(indegree[i]==0) s.push(i); //入度为0 的顶点入栈\rwhile(!s.empty())\r{\rint v=s.top(); s.pop();\rres.push_back(v);\r//counter++;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\rint k=G[v][i];\rif(--indegree[k] == 0) s.push(k); //遍历到的点入度间1，入度为0则入栈 }\r}\tif(res.size()==n) return true;\relse return false;\r}\r 时间复杂度是O(|V|+|E|)\nBellman-Ford算法 求单源最短路\nd[i]=min{d[j]+e(j,i)}\n只要图中不存在负圈，这样的更新操作是有限的（由于最短路不会经过一个顶点两次，所以这种操作只会重复|v|-1次）\n时间复杂度O(|V|*|E|)\nstruct edge\r{\rint from,to,cost;\r}es[max_e];\rint d[max_v];\rint V,E;\rvoid bellman_ford(int s)\r{\rfor(int i=0;i\u0026lt;V;i++) d[i]=inf; //把最短距离初始化成无限\rd[s]=0; while(true)\r{\rbool update=false; //判断while是否进行了更新操作，没有更新操作则退出循环 for(int i=0;i\u0026lt;E;i++) //根据公式，遍历边\r{\redge e=es[i];\rif(d[e.from]!=inf \u0026amp;\u0026amp; d[e.to]\u0026gt;d[e.from]+e.cost)\r{\rd[e.to]=d[e.from]+e.cost;\rupdate=true;\r}\r}\rif(!update) break;\r}\r}\r 如果更新操作（while循环）进行了超过|V|-1次，则存在负圈\n所以判断负圈的一个方法可以是\n把所有d[i]都变成0，如果有负圈，则一定执行超过|V|-1次\nbool find_negative_loop()\r{\rmemset(d,0,sizeof(d));\rfor(int i=0;i\u0026lt;V;i++)\r{\rfor(int j=0;j\u0026lt;E;j++)\r{\redge e=es[j];\rif(d[e.to]\u0026gt;d[e.from]+e.cost)\r{\rd[e.to]\u0026gt;d[e.from]+e.cost;\rif(i==V-1) return true; //这条语句不能放在if外，如果放在if外需要加update\t}\r}\r}\rreturn false;\t}\r Dijkstra算法 求单源最短路，适用于没有负边的情况\n将已求出最短路的点，放入一个集合中 ，每次从集合外找到一个和集合距离最近的点，加入集合\nint cost[max_v][max_v]; //权值，不存在时为inf\rint d[max_v];\rbool used[max_v];\rint V;\rvoid dijkstra(int s)\r{\rfill(d,d+v,inf);\rfill(used,used+v,false);\rd[s]=0;\rwhile(true)\r{\rint v=-1;\r//从尚未使用过的点中选一个距离最小的点\rfor(int u=0;u\u0026lt;V;u++)\r{\rif(!used[u] \u0026amp;\u0026amp; (v==-1 || d[u]\u0026lt;d[v])) v=u;\r} if(v==-1) break;\rused[v]=true;\rfor(int u=0;u\u0026lt;V;u++)\rd[u]=min(d[u],d[v]+cost[v][u]); }\r}  时间复杂度O(V^2)\n优化\n如果将点放入优先队列中，这要查找和更新就会节省很多时间，时间复杂度O(ElgV)\nstruct edge\r{\rint to,cost;\r}\rtypedef pair\u0026lt;int,int\u0026gt; pii; //first 是距离 ，second是点编号\rint V;\rvector\u0026lt;edge\u0026gt; G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; //使小的在上面\rfill(d,d+V,inf);\rd[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rq.push(pii(d[e.to],e.to));\r}\r}\r} }  Floyd-Warshall算法 求任意两点最短路，暴力枚举思想\nd[i][j]=min(d[i][j],d[i][k]+d[k][j]) 遍历所有的k\n时间复杂度O(V^3)\nint d[max_v][max_v]; //存储权值，边不存在时为inf，d[i][i]=0 int V;\rvoid floyd_warshall()\r{\rfor(k=0;k\u0026lt;V;k++)\rfor(int i=0;i\u0026lt;V;i++)\rfor(int j=0;j\u0026lt;V;j++)\rd[i][j]=min(d[i][j],d[i][k]+d[k][j]);\r}\r 路径还原 通过找满足d[j]=d[k]+cost[k][j]的顶点k，来寻找前趋节点，不断寻找前趋节点来还原路径，时间复杂度O(E)\n还可以用prev[j]在算法内直接记录前趋节点，最后遍历数组即可，时间复杂度O(V)\n//算法内记录前趋节点 (优化的dijkstra算法)\rint prev[max_v] //前趋节点\rstruct edge\r{\rint to,cost;\r}\rtypedef pair\u0026lt;int,int\u0026gt; pii; //first 是距离 ，second是点编号\rint V;\rvector\u0026lt;edge\u0026gt; G[max_v];\rint d[max_v];\rvoid dijkstra(int s)\r{\rpriority_queue\u0026lt;pii,vector\u0026lt;pii\u0026gt;,greater\u0026lt;pii\u0026gt; \u0026gt; q; //使小的在上面\rfill(d,d+V,inf);\rfill(prev,prev+V,-1); //!!!! d[s]=0;\rq.push(pii(0,s));\rwhile(!q.empty())\r{\rpii p=q.top();\rq.pop();\rint v=p.second;\rif(d[v]\u0026lt;p.first) continue;\rfor(int i=0;i\u0026lt;G[v].size();i++)\r{\redge e=G[v][i];\rif(d[e.to]\u0026gt;d[v]+e.cost)\r{\rd[e.to]=d[v]+e.cost;\rprev[e.to]=v; //!!!!\rq.push(pii(d[e.to],e.to));\r}\r}\r} }\rvector\u0026lt;int\u0026gt; get_path(int t)\r{\rvector\u0026lt;int\u0026gt; path;\rfor(;t!=-1;t=prev[t]) path.push_back(t);\rreverse(path.begin(),path.end());\rreturn path;\r}\r Prim算法 求最小生成树\nprim算法和dijkstra算法很像，也是把已确定的点放入一个集合中，贪心地选取集合和未确定的点相连的最小权边，并加入到集合中，得到一棵生成树，可以证明是MST(minimum spanning tree)\n//也可以堆优化 int cost[max_v][max_v] //权值\rint mincost[max_v]; //从集合出发到其他点的最小权值,!!!这个权值是 集合 和 点 之间的 bool used[max_v]; //是否在集合中\rint V;\rint prim() //返回MST的权值\r{\rfill(mincost,mincost+V,inf); //初始化 fill(used,used+V,false);\rmincost[0]=0; //从0开始 int res=0;\rwhile(true)\r{\rint v=-1;\rfor(int u=0;u\u0026lt;V;u++)\r{\rif(!used[u] \u0026amp;\u0026amp; (v==-1 || mincost[u]\u0026lt;mincost[v])) v=u;\r}\rif(v==-1) break;\rused[v]=true;\rres+=mincost[v];\rfor(int u=0;u\u0026lt;V;u++)\r{\rmincost[u]=min(mincost[u],cost[v][u]); //每次往集合中加入一个点，所有点的mincost都有可能改变 }\r}\rreturn res; }  时间复杂度与dijkstra算法一样\nKruskal算法 求MST\n将边的权值按大小排序，如果不产生圈和重边，就依次把边加入到生成树中\n要判断是否产生圈和重边，只需要判断加入这条边前，这条边的两个端点是否已在同一个连通分量里，这样就可以用并查集\nKruskal在边的排序上最费时，算法复杂度O(ElgV)\nKruskal适用于sparse graph\nPrim适用于dense graph\n在实际应用中，Kruskal更普遍\nstruct edge\r{\rint u,v,cost;\r}es[max_e];\rint V,E;\rint par[max_v]; //union find需要 int rankk[max_v]; //key word \u0026quot;rank\u0026quot;\rbool cmp(const edge\u0026amp; e1,const edge\u0026amp; e2)\r{\rreturn e1.cost\u0026lt;e2.cost;\r}\rvoid init_union_find(int x)\r{\rfor(int i=0;i\u0026lt;x;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r}\rint find(int x)\r{\rif(par[x]==x)\rreturn x;\relse\rreturn par[x]=find(par[x]);\r}\rvoid unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return;\rif(rankk[x]\u0026lt;rankk[y]) par[x]=y;\relse\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++;\r}\r}\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint kruskal()\r{\rsort(es,es+E,cmp);\rinit_union_find(V);\rint res=0;\rfor(int i=0;i\u0026lt;E;i++)\r{\redge e=es[i];\rif(!same(e.u,e.v))\r{\runite(e.u,e.v);\rres+=e.cost;\r}\r}\rreturn res;\r}\r Kosaraju算法 强连通分量(strongly connected component)分解高效的算法有kosaraju算法，\ntarjan算法，gabow算法\nkosaraju算法通过随便选一点dfs，给点标号\n把边的方向反过来，再一次dfs\n由于在强连通分量中的点，其可达性不受边反向的影响\n所以最后需独立进行k次搜索\n即分裂出k个强连通分量\n时间复杂度 O(V+E)\n//kosaraju int V; vector\u0026lt;int\u0026gt; G[maxv]; vector\u0026lt;int\u0026gt; rG[maxv];\rvector\u0026lt;int\u0026gt; vs; //后序遍历顺序的顶点列表（标号） bool used[maxv]; //是否访问 int cmp[maxv]; //所属强连通分量的拓扑序（序号） void add_edge(int from,int to){\rG[from].push_back(to);\rrG[to].push_back(from);\r}\rvoid dfs(int v){\rused[v]=true;\rfor(auto i:G[v]){\rif(!used[G[v][i]]) dfs(G[v][i]);\r}\rvs.push_back(v);\r}\rvoid rdfs(int v,int k){\rused[v]=true;\rcmp[v]=k;\rfor(auto i:rG[v]){\rif(!used[rG[v][i]]) rdfs(rG[v][i],k);\r}\r}\rint kosaraju_scc(){\rmemset(used,0,sizeof(used));\rvs.clear();\rfor(int i=0;i\u0026lt;V;i++) if(!used[i]) dfs(i);\rmemset(uesd,0,sizeof(used));\rint k=0;\rfor(int i=vs.size()-1;i\u0026gt;=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\rreturn k;\r}\r ","id":38,"section":"posts","summary":"图的存储：邻接表、邻接矩阵、前向星、链式前向星等 二分图判定 通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图 用dfs判断每个点","tags":["cpp","graph_theory"],"title":"Graph Theory","uri":"https://dyhgo.github.io/2020/02/graph-theory/","year":"2020"},{"content":"食物链 Time Limit: 1000MS\tMemory Limit: 10000K Description 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这N个动物所构成的食物链关系进行描述： 第一种说法是\u0026quot;1 X Y\u0026rdquo;，表示X和Y是同类。 第二种说法是\u0026quot;2 X Y\u0026rdquo;，表示X吃Y。 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 1） 当前的话与前面的某些真的话冲突，就是假话； 2） 当前的话中X或Y比N大，就是假话； 3） 当前的话表示X吃X，就是假话。 你的任务是根据给定的N（1 \u0026lt;= N \u0026lt;= 50,000）和K句话（0 \u0026lt;= K \u0026lt;= 100,000），输出假话的总数。\nInput 第一行是两个整数N和K，以一个空格分隔。 以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。 若D=1，则表示X和Y是同类。 若D=2，则表示X吃Y。\nOutput 只有一个整数，表示假话的数目。\nSample Input 100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5\nSample Output 3\nSource Noi 01\nSolution 并查集\n看到信息的内容，有并查集的影子\n依次遍历信息，对于每一条信息，因为没有说种类，所以设置三个种类，把每一种情况都加上去，比如：x和y属于同一类，则合并x和y属于A类，B类，C类\n判断是否是错误信息，只要判断是否与前面信息矛盾即可\n并查集的时间复杂度O(α(n)) α(n)是阿克曼函数的反函数，比O(lgn)还快\n代码如下（并查集的模板 + 并查集的应用）\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint T[100005],X[100005],Y[100005];\rint n,k;\r//union find\rint par[150005]; //父亲 int rankk[150005]; //树的高度,!!!元素是根 （优化用）//reference to \u0026quot;rank\u0026quot; is ambiguous\r//初始化，要用并查集前要初始化\rvoid init(int n) {\rfor(int i=0;i\u0026lt;n;i++)\r{\rpar[i]=i;\rrankk[i]=0;\r}\r} //查询树的根\rint find(int x)\r{\rif(par[x]==x) return x;\relse return par[x]=find(par[x]); //return find(par[x]);也可以 。par[x]=find(par[x]) 是路径压缩优化 } //合并x,y //优化高度（如果rankk不同，那么从rankk小的向大的连边 void unite(int x,int y)\r{\rx=find(x);\ry=find(y);\rif(x==y) return ; //判断是否已在同一个集合内\rif(rankk[x]\u0026lt;rankk[y]) par[x]=y; //!!!利用它们的 根 进行合并 else\r{\rpar[y]=x;\rif(rankk[x]==rankk[y]) rankk[x]++; //这时候rankk还是原来的高度 } } //判断是否在同一个集合内\rbool same(int x,int y)\r{\rreturn find(x)==find(y);\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;\rfor(int i=0;i\u0026lt;k;i++)\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;T[i],\u0026amp;X[i],\u0026amp;Y[i]);\rinit(n*3);\rint ans=0;\rfor(int i=0;i\u0026lt;k;i++)\r{\rint t=T[i],x=X[i]-1,y=Y[i]-1;\r//错误的编号\rif(x\u0026lt;0 || x\u0026gt;=n || y\u0026lt;0 || y\u0026gt;=n)\r{\rans++;\rcontinue;\r} else if(t==1) //第一种类型\r{\rif(same(x,y+n) || same(x,y+2*n)) ans++; //判断是否矛盾 //!!!只需要判断x在A类就行，因为每次unite都\r//涵盖所有情况，它们是平行影响的，判断一个就相当于判断所有 else\r{\runite(x,y);\runite(x+n,y+n);\runite(x+n+n,y+n+n);\r}\r} else if(t==2)\r{\rif(same(x,y) || same(x,y+2*n)) ans++;\relse\r{\runite(x,y+n);\runite(x+n,y+2*n);\runite(x+2*n,y);\r}\r}\r}\rcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":39,"section":"posts","summary":"食物链 Time Limit: 1000MS Memory Limit: 10000K Description 动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。 现有N个动物，以1－N编号。","tags":["cpp","union_find"],"title":"poj1182","uri":"https://dyhgo.github.io/2020/02/poj1182/","year":"2020"},{"content":"Beauty Contest Time Limit: 3000MS\tMemory Limit: 65536K Description Bessie, Farmer John\u0026rsquo;s prize cow, has just won first place in a bovine beauty contest, earning the title \u0026lsquo;Miss Cow World\u0026rsquo;. As a result, Bessie will make a tour of N (2 \u0026lt;= N \u0026lt;= 50,000) farms around the world in order to spread goodwill between farmers and their cows. For simplicity, the world will be represented as a two-dimensional plane, where each farm is located at a pair of integer coordinates (x,y), each having a value in the range -10,000 \u0026hellip; 10,000. No two farms share the same pair of coordinates.\nEven though Bessie travels directly in a straight line between pairs of farms, the distance between some farms can be quite large, so she wants to bring a suitcase full of hay with her so she has enough food to eat on each leg of her journey. Since Bessie refills her suitcase at every farm she visits, she wants to determine the maximum possible distance she might need to travel so she knows the size of suitcase she must bring.Help Bessie by computing the maximum distance among all pairs of farms.\nInput   Line 1: A single integer, N\n  Lines 2..N+1: Two space-separated integers x and y specifying coordinate of each farm\n  Output  Line 1: A single integer that is the squared distance between the pair of farms that are farthest apart from each other.  Sample Input 4 0 0 0 1 1 1 1 0\nSample Output 2\nHint Farm 1 (0, 0) and farm 3 (1, 1) have the longest distance (square root of 2)\nSource USACO 2003 Fall\nSolution 题意：平面上有n个不重合的点，求两个点的最远距离\n由于点的个数为50000，所以暴力超时\n构造凸包，遍历凸包上的点即可\n坐标范围在n内的凸多边形（顶点在格点上）的顶点个数最多为O（√n）（尝试不严谨的画图证明，和公差为1的等差数列求和有关，所以是平方关系）\n所以构造凸包后，暴力遍历的时间复杂度为O（n）\n构造凸包可以用模板\n此处介绍的是时间复杂度O(nlgn）的graham扫描法\n外积是很常用的工具，此处利用外积的坐标公式的符号判断凹凸性\n可以对点先排序，然后按逆时针方向依次遍历点，先构造凸包的下侧，到达最右端时，构造凸包的上侧\n代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rdouble s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u0026lt;b.x;\rreturn a.y\u0026lt;b.y;\r}\rdouble out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u0026lt;point\u0026gt; convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\rint k=0; // 凸包点的index vector\u0026lt;point\u0026gt; qs(n*2); //构造凸包\r//逆时针构造凸包\r//构造凸包的下侧\rfor(int i=0;i\u0026lt;n;i++)\r{\rwhile(k\u0026gt;1 \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\rfor(int i=n-2,t=k;i\u0026gt;=0;i--)\r{\rwhile(k\u0026gt;t \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--; //这里有个k\u0026gt;t 和 k\u0026gt;1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rpoint p;\rscanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;p.x,\u0026amp;p.y);\rps[i]=p;\r}\rvector\u0026lt;point\u0026gt; qs=convex_hull(ps,n);\rdouble res=0;\rfor(int i=0;i\u0026lt;qs.size();i++)\rfor(int j=0;j\u0026lt;i;j++)\rres=max(res,s_dist(qs[i],qs[j]));\rcout\u0026lt;\u0026lt;(int)res\u0026lt;\u0026lt;endl; //!!!不加int 或不用printf(\u0026quot;%.0lf\\n\u0026quot;,res); 就会WA return 0;\r}\r 还有一种时间复杂度更低的方法\nconvex hull + rotating calipers\n这是一种常见、经典的方法\n对踵点：如果凸包上过两个点画两条平行线，使凸包所有的点都夹在这两条线之间，这两个点就叫对踵点，称为一对对踵点对\n对于一个凸包，最远距离一定是对踵点对\n所以先找一对对踵点对，根据判断凹凸性，确定哪个点向后面的点移动（如图）（图懒得画），宏观来看就是对踵点对的连线旋转了180°\n这样就总时间复杂度就是O（√n）\n代码如下\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rstruct point\r{\rdouble x,y;\r}ps[50005];\rinline double s_dist(point a,point b)\r{\rdouble dx=a.x-b.x,dy=a.y-b.y;\rreturn dx*dx+dy*dy;\r}\rbool cmp(point a,point b)\r{\rif(a.x!=b.x) return a.x\u0026lt;b.x;\rreturn a.y\u0026lt;b.y;\r}\rinline double out_product(double x1,double y1,double x2,double y2)\r{\rreturn x1*y2-x2*y1;\r}\rvector\u0026lt;point\u0026gt; convex_hull(point* ps,int n)\r{\rsort(ps,ps+n,cmp); //很多题目都需要对乱序输入排序\rint k=0; // 凸包点的index vector\u0026lt;point\u0026gt; qs(n*2); //构造凸包\r//逆时针构造凸包\r//构造凸包的下侧\rfor(int i=0;i\u0026lt;n;i++)\r{\rwhile(k\u0026gt;1 \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--;\rqs[k++]=ps[i];\r} //继续构造凸包的上侧\rfor(int i=n-2,t=k;i\u0026gt;=0;i--)\r{\rwhile(k\u0026gt;t \u0026amp;\u0026amp; out_product(qs[k-1].x-qs[k-2].x , qs[k-1].y-qs[k-2].y , ps[i].x-qs[k-1].x , ps[i].y-qs[k-1].y)\u0026lt;=0) k--; //这里有个k\u0026gt;t 和 k\u0026gt;1效果一样 qs[k++]=ps[i]; } qs.resize(k-1);\rreturn qs;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rpoint p;\rscanf(\u0026quot;%lf%lf\u0026quot;,\u0026amp;p.x,\u0026amp;p.y);\rps[i]=p;\r}\rvector\u0026lt;point\u0026gt; qs=convex_hull(ps,n);\rdouble res=0; int m=qs.size();\rif(m==2) //特殊处理凸包退化情况\r{\rcout\u0026lt;\u0026lt;(int)s_dist(qs[0],qs[1])\u0026lt;\u0026lt;endl; return 0; } int i=0,j=0; //表示左右俩对踵点\r//求x轴方向上的对踵点对\rfor(int k=0;k\u0026lt;m;k++)\rif(cmp(qs[j],qs[k])) j=k;\r//rotating calipers\rint si=i,sj=j;\rwhile(!(i==sj \u0026amp;\u0026amp; j==si)) //旋转180°，注意判断条件 {\r//cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl;\rres=max(res,s_dist(qs[i],qs[j])); //这条语句放在while循环体的前端，可以把x轴方向上的对踵点对都比较\r//通过外积判断凹凸性，判断是i移到i+1，还是j移到j+1\rif(out_product(qs[(i+1)%m].x-qs[i].x , qs[(i+1)%m].y-qs[i].y , qs[(j+1)%m].x-qs[j].x , qs[(j+1)%m].y-qs[j].y)\u0026lt;0) //\u0026lt;0 或\u0026lt;=0都可以\ri=(i+1)%m; //把m错写成n,tle好久 else\rj=(j+1)%m; //!!!要%m 这样转一圈才能回到起点，退出循环 } //之前添加的debug条件忘记屏蔽，WA了特久 cout\u0026lt;\u0026lt;(int)res\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":40,"section":"posts","summary":"Beauty Contest Time Limit: 3000MS Memory Limit: 65536K Description Bessie, Farmer John\u0026rsquo;s prize cow, has just won first place in a bovine beauty contest, earning the title \u0026lsquo;Miss Cow World\u0026rsquo;. As a result, Bessie will make a tour of N (2 \u0026lt;= N \u0026lt;= 50,000) farms around the world in order to spread goodwill between farmers and their cows. For simplicity, the world will be represented as a two-dimensional plane,","tags":["cpp","computational_geometry"],"title":"poj2187","uri":"https://dyhgo.github.io/2020/01/poj2187/","year":"2020"},{"content":"Coneology 题目链接\nTime Limit: 5000MS\tMemory Limit: 65536K Description A student named Round Square loved to play with cones. He would arrange cones with different base radii arbitrarily on the floor and would admire the intrinsic beauty of the arrangement. The student even began theorizing about how some cones dominate other cones: a cone A dominates another cone B when cone B is completely within the cone A. Furthermore, he noted that there are some cones that not only dominate others, but are themselves dominated, thus creating complex domination relations. After studying the intricate relations of the cones in more depth, the student reached an important conclusion: there exist some cones, all-powerful cones, that have unique properties: an all-powerful cone is not dominated by any other cone. The student became so impressed by the mightiness of the all-powerful cones that he decided to worship these all-powerful cones.\nUnfortunately, after having arranged a huge number of cones and having worked hard on developing this grandiose cone theory, the student become quite confused with all these cones, and he now fears that he might worship the wrong cones (what if there is an evil cone that tries to trick the student into worshiping it?). You need to help this student by finding the cones he should worship.\nInput The input le specifies an arrangement of the cones. There are in total N cones (1 ≤ N ≤ 40000). Cone i has radius and height equal to Ri, i = 1 … N. Each cone is hollow on the inside and has no base, so it can be placed over another cone with smaller radius. No two cones touch.\nThe first line of the input contains the integer N. The next N lines each contain three real numbers Ri, xi, yi separated by spaces, where (xi, yi) are the coordinates of the center of the base of cone i.\nOutput The first line of the output le should contain the number of cones that the student should worship. The second line contains the indices of the cones that the student should worship in increasing order. Two consecutive numbers should be separated by a single space.\nSample Input 5 1 0 -2 3 0 3 10 0 0 1 0 1.5 10 50 50\nSample Output 2 3 5\nSource MIT Programming Contest 2005\nSolution 题意：坐标上有n个不相交的圆，求最外层圆的index\n由于数据规模，暴力超时\nsweeping line\n一般有两种，平移扫描，环形扫描\n对于这一题，从左到右平移扫描\n用一个容器维护每个圆的左右两个端点，代表扫描到圆和扫描出圆\n对于扫描到的圆，判断它是否在别的圆内\n只需要判断上下最近的两个圆（可画图证明，不严谨）\n用一个容器维护还没扫描出的最外圆，可以排序，再查找。总时间复杂度O(nlgn)\n可以选用set\n当扫描到右时，把圆从set中去除，意味着扫描过了\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;set\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rdouble x[40005],y[40005],r[40005];\rint n;\rtypedef pair\u0026lt;double ,int\u0026gt; pdi;\rbool inside(int i,int j)\r{\rdouble dx=x[i]-x[j],dy=y[i]-y[j];\rreturn dx*dx+dy*dy\u0026lt;=r[j]*r[j];\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%lf%lf%lf\u0026quot;,\u0026amp;r[i],\u0026amp;x[i],\u0026amp;y[i]);\rvector\u0026lt;pdi\u0026gt; vt; //存左右两边界 for(int i=0;i\u0026lt;n;i++)\r{\rvt.push_back(make_pair(x[i]-r[i],i));\rvt.push_back(make_pair(x[i]+r[i],i+n));\r}\rsort(vt.begin(),vt.end());\r//扫描\rset\u0026lt;pdi\u0026gt; outers; //set为了排序 vector\u0026lt;int\u0026gt; res; //存放结果 for(int i=0;i\u0026lt;vt.size();i++)\r{\rint id=vt[i].second%n;\rif(vt[i].second\u0026lt;n) //扫描到左 {\rset\u0026lt;pdi\u0026gt;::iterator it=outers.lower_bound(make_pair(y[id],id));\rif(it!=outers.end() \u0026amp;\u0026amp; inside(id,it-\u0026gt;second)) continue; //上面最近的圆 if(it!=outers.begin() \u0026amp;\u0026amp; inside(id,(--it)-\u0026gt;second)) continue; //下面最近的圆 res.push_back(id);\routers.insert(make_pair(y[id],id));\r}\relse //扫描到右 outers.erase(make_pair(y[id],id));\r} sort(res.begin(),res.end());\rcout\u0026lt;\u0026lt;res.size()\u0026lt;\u0026lt;endl;\rfor(int i=0;i\u0026lt;res.size();i++)\rprintf(\u0026quot;%d%c\u0026quot;,res[i]+1,i+1==res.size()? '\\n' : ' ');\rreturn 0;\r}\r ","id":41,"section":"posts","summary":"Coneology 题目链接 Time Limit: 5000MS Memory Limit: 65536K Description A student named Round Square loved to play with cones. He would arrange cones with different base radii arbitrarily on the floor and would admire the intrinsic beauty of the arrangement. The student even began theorizing about how some cones dominate other cones: a cone A dominates another cone B when cone B is completely within the cone","tags":["cpp","computational_geometry"],"title":"poj2932","uri":"https://dyhgo.github.io/2020/01/poj2932/","year":"2020"},{"content":"Jack Straws Time Limit: 1000MS\tMemory Limit: 10000K Description In the game of Jack Straws, a number of plastic or wooden \u0026ldquo;straws\u0026rdquo; are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws (as if they were dumped on a large piece of graph paper) and then will be asked if various pairs of straws are connected. Note that touching is connecting, but also two straws can be connected indirectly via other connected straws.\nInput Input consist multiple case,each case consists of multiple lines. The first line will be an integer n (1 \u0026lt; n \u0026lt; 13) giving the number of straws on the table. Each of the next n lines contain 4 positive integers,x1,y1,x2 and y2, giving the coordinates, (x1,y1),(x2,y2) of the endpoints of a single straw. All coordinates will be less than 100. (Note that the straws will be of varying lengths.) The first straw entered will be known as straw #1, the second as straw #2, and so on. The remaining lines of the current case(except for the final line) will each contain two positive integers, a and b, both between 1 and n, inclusive. You are to determine if straw a can be connected to straw b. When a = 0 = b, the current case is terminated.\nWhen n=0,the input is terminated.\nThere will be no illegal input and there are no zero-length straws.\nOutput You should generate a line of output for each line containing a pair a and b, except the final line where a = 0 = b. The line should say simply \u0026ldquo;CONNECTED\u0026rdquo;, if straw a is connected to straw b, or \u0026ldquo;NOT CONNECTED\u0026rdquo;, if straw a is not connected to straw b. For our purposes, a straw is considered connected to itself.\nSample Input 7 1 6 3 3 4 6 4 9 4 5 6 7 1 4 3 5 3 5 5 5 5 2 6 3 5 4 7 2 1 4 1 6 3 3 6 7 2 3 1 3 0 0\n2 0 2 0 0 0 0 0 1 1 1 2 2 1 2 0 0\n0\nSample Output CONNECTED NOT CONNECTED CONNECTED CONNECTED NOT CONNECTED CONNECTED CONNECTED CONNECTED CONNECTED\nSource East Central North America 1994\nSolution 题意：判断两条线段是否相交，对于N条线段，间接相交也算相交。对于每次询问，判 断给定的两条线段是否相交。\n这个题目分成两部分，一部分是基础的判断两条线段是否相交，用一个bool数组来存储信息。另一部分是判断间接相交，可以用floyd-warshall（比较巧妙）或者并查集.第一部分就是套模板。\n点可以用结构体存储（推荐），线段也可以用结构体存储或pair\n判断两条线段相交有多重模板，比如判是否平行、重合、求两条直线交点，判断交点是否在线段上，还有ccw（counter clock wise）函数，可参考discuss\n比较常见的是快速排斥和跨立检验\n以线段为对角线，作平行于x轴、y轴的射线，使之形成矩形，若两个矩形没有相交，则线段不相交（可以排除大部分）\n不满足快速排斥进入跨立检验,判断两个点是否在线段的两侧（即跨立），判断方法是外积的符号是否相反，等于0说明在线上\n如果两两互相跨立，则线段相交\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n;\rbool con[15][15];\rint p,q;\rstruct point\r{\rdouble x,y;\r//point(double a,double b) : x(a),y(b) {} //!!!!!会发生编译错误 };\rpair\u0026lt;point,point\u0026gt; seg[15];\rdouble dir(point a,point b,point c) //用外积 {\rreturn (c.x-a.x)*(c.y-b.y) - (c.y-a.y)*(c.x-b.x); }\rbool judge(pair\u0026lt;point,point\u0026gt; p1,pair\u0026lt;point,point\u0026gt; p2)\r{\rpoint a,b,c,d;\ra=p1.first; b=p1.second;\rc=p2.first;\rd=p2.second;\r//快速排斥\rif(min(a.x,b.x)\u0026gt;max(c.x,d.x) or min(c.x,d.x)\u0026gt;max(a.x,b.x) or\rmin(a.y,b.y)\u0026gt;max(c.y,d.y) or min(c.y,d.y)\u0026gt;max(a.y,b.y))\rreturn false;\r//跨立检验 (int 可改成double)\relse\r{\rint d1,d2,d3,d4;\rd1=dir(a,b,c);\rd2=dir(a,b,d);\rd3=dir(c,d,a);\rd4=dir(c,d,b);\rreturn d1*d2\u0026lt;=0 and d3*d4\u0026lt;=0; //!!!\r}\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rwhile(scanf(\u0026quot;%d\u0026quot;,\u0026amp;n)==1 and n!=0)\r{\rfor(int i=1;i\u0026lt;=n;i++) con[i][i]=true;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%lf%lf%lf%lf\u0026quot;,\u0026amp;seg[i].first.x,\u0026amp;seg[i].first.y,\u0026amp;seg[i].second.x,\u0026amp;seg[i].second.y);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=1;j\u0026lt;i;j++)\r{\rif(judge(seg[i],seg[j])) con[i][j]=con[j][i]=true;\relse con[i][j]=con[j][i]=false;\r}\rfor(int k=1;k\u0026lt;=n;k++) //Floyd-Warshall算法或并查集都可以 for(int i=1;i\u0026lt;=n;i++)\rfor(int j=1;j\u0026lt;=n;j++)\rcon[i][j] |= con[i][k] and con[k][j];\rwhile(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;p,\u0026amp;q)==2 and p!=0)\rputs(con[p][q] ? \u0026quot;CONNECTED\u0026quot; : \u0026quot;NOT CONNECTED\u0026quot;);\r}\rreturn 0;\r}\r 艰难的debug 计算几何有些很麻烦，代码太相似，debug比较难，有时还要考虑精度问题（即误差eps）\ndebug一个上午\n写完代码CE，seg[i].first.x错误，把stl_pair.h中的代码小改一下可以通过，但放到oj上肯定不行，怕污染代码还是不这样做。最后发现把构造函数去掉可以通过\n自测，最后一个样例没过，发现是边界情况，把跨立检验最后一步的等号加上\n自测，中间有一个样例没过，作图，把样例分离出来，过了。说明可能不是judge函数的问题。\n单测样例，没过，说明错误不是受别组影响\n编译器debug，把函数内的局部变量，变成全局变量，add watch\n发现d1 d2 d3 d4都等于0，a.x a.y b.x b.y \u0026hellip;.有问题\n继续add watch\n发现seg[1].first的内容就有问题，是double边界数，然后发现最终问题 %d 赋值给了double型变量\n总结 提高debug能力，少犯白痴错误。\n写代码要有清晰性和完整性，这样鲁棒性更强。\n","id":42,"section":"posts","summary":"Jack Straws Time Limit: 1000MS Memory Limit: 10000K Description In the game of Jack Straws, a number of plastic or wooden \u0026ldquo;straws\u0026rdquo; are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws","tags":["cpp","computational_geometry"],"title":"poj1127","uri":"https://dyhgo.github.io/2020/01/poj1127/","year":"2020"},{"content":"以这道题为例\n准备一个对拍的文件夹，里面装这些东西\nduipai_random_input_src.cpp是产生随机测试数据的代码\n#include\u0026lt;cstdlib\u0026gt;\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;ctime\u0026gt;\rusing namespace std;\rint t=100; //数据组数\rint main()\r{\rsrand(time(0));\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rint a,b;\rwhile(t--)\r{\ra=rand();\rb=rand();\rif(a\u0026gt;b) swap(a,b);\rcout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl;\r}\rreturn 0;\r}  将产生的随机测试数据写入duipai_random_input.txt中\nac代码或暴力搜索正确的代码\n//ac\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u0026lt;=50) return x;\rif(x\u0026gt;50 and x\u0026lt;=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u0026gt;0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_ac_output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rwhile(~scanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;t1,\u0026amp;t2)) {\rprintf(\u0026quot;input data are %lld %lld --- \u0026quot;,t1,t2);\rprintf(\u0026quot;%lld\\n\u0026quot;,fun(t2)-fun(t1-1));\r}\r//cout\u0026lt;\u0026lt;fun(180);\rreturn 0;\r}\r 从duipai_random_input.txt读入，写到duipai_ac_output.txt中\nwa代码\n//wa\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rtypedef long long ll;\rll t1,t2;\rll ad;\rll fun(ll x)\r{\rif(x\u0026lt;=50) return x;\rif(x\u0026gt;50 and x\u0026lt;=60) return 50; ll m;\rif(x%60==0) return x-x*10/60;\relse\r{\rm=x/60;\rll n=50+m*60;\rif(x-n\u0026gt;0)\r{\rreturn n-10*m;\r}\relse\r{\rreturn x-10*m;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_random_input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rfreopen(\u0026quot;D:\\\\c++\\\\duipai\\\\duipai_wa_output.txt\u0026quot;,\u0026quot;w\u0026quot;,stdout);\rwhile(~scanf(\u0026quot;%lld%lld\u0026quot;,\u0026amp;t1,\u0026amp;t2)) {\rprintf(\u0026quot;input data are %lld %lld --- \u0026quot;,t1,t2);\rprintf(\u0026quot;%lld\\n\u0026quot;,fun(t2)-fun(t1)+1);\r}\r//cout\u0026lt;\u0026lt;fun(180);\rreturn 0;\r}\r 从duipai_random_input.txt读入，写到duipai_wa_output.txt中\n比较duipai_ac_output.txt 和 duipai_wa_output.txt\n在duipai文件夹下运行批处理命令（duipai.bat）\n@echo off\rfc duipai_ac_output.txt duipai_wa_outout.txt\rpause\r echo off是不回显，fc是文件比较\n运行cpp和bat程序\n得到结果\n过于复杂的输入数据和输出数据，简易对拍不好实现\n要产生大随机数，可以用\nlong long r=123456789;\rcout\u0026lt;\u0026lt;(long long)((double)(rand()*r)/RAND_MAX);\r 这题也可对拍\n","id":43,"section":"posts","summary":"以这道题为例 准备一个对拍的文件夹，里面装这些东西 duipai_random_input_src.cpp是产生随机测试数据的代码 #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; int","tags":["cpp"],"title":"简易对拍","uri":"https://dyhgo.github.io/2020/01/%E7%AE%80%E6%98%93%E5%AF%B9%E6%8B%8D/","year":"2020"},{"content":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数\n字，B的第一个数字是A的最后一个数字，个位数也算，输出满足条件的正整数对的个数\n 这种题感觉abc一贯的风格\n当时第一感觉是纯模拟肯定巨麻烦，就想着有没有规律，发现没有规律\n又想着按数位分类。\n按数位分类就要考虑对子里面的数位\n花了一些时间把它整理成元素都是9^n的矩阵（一个对称矩阵）\n然而并没有什么用，还是得求N-10^k这个剩余部分\n问题又回到起点\n试图从9^n求和中找规律，无果\n试图简化模拟或换个角度模拟，无果\n看了别人的解答，大同小异\n遍历一遍N，二维数组存N中第一个数字为 i ，最后一个数字为 j 的个数\n最后遍历ans+=c[i][j]*c[j][i]\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint n;\rlong long ans;\rlong long c[10][10];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=1;i\u0026lt;=n;i++)\r{\rstring s=to_string(i);\rc[s[0]-'0'][s[s.length()-1]-'0']++;\r}\rfor(int i=0;i\u0026lt;10;i++)\rfor(int j=0;j\u0026lt;10;j++)\rans+=c[i][j]*c[j][i];\rcout\u0026lt;\u0026lt;ans;\rreturn 0; }\r 总结：我好弱啊\n","id":44,"section":"posts","summary":"题目链接 题意：找正整数对（A,B），A、B都不大于N，满足A的第一个数字是B的最后一个数 字，B的第一个数字是A的最后一个数字，个位数也算，输","tags":["cpp"],"title":"abc152-D","uri":"https://dyhgo.github.io/2020/01/abc152-d/","year":"2020"},{"content":"Piggy-Bank Time Limit: 1000MS\tMemory Limit: 10000K 题目链接\nDescription Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.\nBut there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!\nInput The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 \u0026lt;= E \u0026lt;= F \u0026lt;= 10000. On the second line of each test case, there is an integer number N (1 \u0026lt;= N \u0026lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 \u0026lt;= P \u0026lt;= 50000, 1 \u0026lt;= W \u0026lt;=10000). P is the value of the coin in monetary units, W is it\u0026rsquo;s weight in grams.\nOutput Print exactly one line of output for each test case. The line must contain the sentence \u0026ldquo;The minimum amount of money in the piggy-bank is X.\u0026rdquo; where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line \u0026ldquo;This is impossible.\u0026quot;.\nSample Input 3 10 110 2 1 1 30 50 10 110 2 1 1 50 30 1 6 2 10 3 20 4\nSample Output The minimum amount of money in the piggy-bank is 60. The minimum amount of money in the piggy-bank is 100. This is impossible.\nSource Central Europe 1999\nSolution 题意：完全背包问题求最小价值\n时间复杂度O(nm)\n二维数组如下，MLE\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[505][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp[0],dp[0]+n*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=min(dp[i-1][j],dp[i][j-w[i]]+v[i]);\rif(dp[n][m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[n][m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r 改一维数组，AC\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp,dp+m+1,inf); //!!!!!\rdp[0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=w[i];j\u0026lt;=m;j++)\rdp[j]=min(dp[j],dp[j-w[i]]+v[i]);\rif(dp[m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r 这个地方要注意 fill 到 dp+m+1\n滚动数组好啊\nAC代码\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint dp[2][10005];\rint v[505];\rint w[505];\rint t;\rint e,f;\rint n,m;\rconst int inf=0x3f3f3f3f;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;t;\rwhile(t--)\r{\rcin\u0026gt;\u0026gt;e\u0026gt;\u0026gt;f;\rm=f-e;\rcin\u0026gt;\u0026gt;n;\r//init\rfill(dp[0],dp[0]+2*(m+1),inf);\rdp[0][0]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;v[i],\u0026amp;w[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i\u0026amp;1][j]=dp[(i-1)\u0026amp;1][j];\relse\rdp[i\u0026amp;1][j]=min(dp[(i-1)\u0026amp;1][j],dp[i\u0026amp;1][j-w[i]]+v[i]);\rif(dp[n\u0026amp;1][m]!=inf)\rprintf(\u0026quot;The minimum amount of money in the piggy-bank is %d.\\n\u0026quot;,dp[n\u0026amp;1][m]);\relse\rprintf(\u0026quot;This is impossible.\\n\u0026quot;);\r}\rreturn 0;\r}\r Summary 这种类型的dp有两个重点，初始化边界条件，找递推式\n求最小，一般初始化为inf，dp[0][0]=0;\n求最大，一般初始化为0\n必要时可用滚动数组\n完全背包递推式的证明（这里证明求最大值的情况）\ndp[i][j]=max{dp[i-1][j-k*w[i]]+k*v[i] | k\u0026gt;=0}\n=max(dp[i-1][j] , max{dp[i-1][j-k*w[i]]+k*v[i] | k\u0026gt;=1}\n=max(dp[i-1][j] , max{dp[i-1][(j-w[i])-k*w[i]]+k*v[i] | k\u0026gt;=0}+v[i])\n=max(dp[i-1][j] , dp[i][j-w[i]]+v[i])\n这种分离思想很常见\n","id":45,"section":"posts","summary":"Piggy-Bank Time Limit: 1000MS Memory Limit: 10000K 题目链接 Description Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is","tags":["cpp","dp"],"title":"poj1384","uri":"https://dyhgo.github.io/2020/01/poj1384/","year":"2020"},{"content":"Charm Bracelet Time Limit: 1000MS\tMemory Limit: 65536K Description Bessie has gone to the mall\u0026rsquo;s jewelry store and spies a charm bracelet. Of course, she\u0026rsquo;d like to fill it with the best charms possible from the N (1 ≤ N ≤ 3,402) available charms. Each charm i in the supplied list has a weight Wi (1 ≤ Wi ≤ 400), a \u0026lsquo;desirability\u0026rsquo; factor Di (1 ≤ Di ≤ 100), and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than M (1 ≤ M ≤ 12,880).\nGiven that weight limit as a constraint and a list of the charms with their weights and desirability rating, deduce the maximum possible sum of ratings.\nInput  Line 1: Two space-separated integers: N and M Lines 2..N+1: Line i+1 describes charm i with two space-separated integers: Wi and Di  Output  Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints  Sample Input 4 6 1 4 2 6 3 12 2 7\nSample Output 23\nSource USACO 2007 December Silver\nSolution 基础01背包问题\n如果用二维数组写的话就会MLE\n猜测测试数据可能不会满，就随着数据动态申请内存，想侥幸过（可以用new/delete 或 malloc/free）结果还是MLE\n这是MLE代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\r//int dp[3410][12885];\rint n,m;\r//int w[3410];\r//int v[3410];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rint **dp,*w,*v;\rdp=new int*[n+3];\rfor(int i=0;i\u0026lt;n+3;i++)\rdp[i]=new int[m+3];\rw=new int[n+3];\rv=new int[n+3];\rfor(int i=1;i\u0026lt;=n;i++)\r{\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\r}\r//initialized\rfor(int i=0;i\u0026lt;=n;i++)\rdp[i][0]=0;\rfor(int i=0;i\u0026lt;=m;i++)\rdp[0][i]=0;\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i][j]=dp[i-1][j];\relse\rdp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[n][m];\rdelete dp,w,v;\rreturn 0;\r}\r 在discuss找了一圈也没有二维数组过的\n优化成一维数组（节省内存，容易出bug）\nAC代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n,m;\rint dp[12885];\rint w[3410];\rint v[3410];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=m;j\u0026gt;=w[i];j--)\rdp[j]=max(dp[j],dp[j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[m];\rreturn 0;\r}\r 这个内层循环是递减的，如果是递增则解决完全背包问题\n由于01背包问题的dp[i]只依赖于dp[i-1]，内层循环递减时，dp[j]依赖的dp[j]为i-1的dp[j]\n由于原来在二维数组中就是递增的，是同一个i，所以内层循环递增时，dp[j]依赖的dp[j]为i的dp[j]，符合完全背包问题\n由于有两种状态（i和i-1），所以可利用奇偶性滚动数组实现\nAC代码\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n,m;\rint dp[2][12885];\rint w[3410];\rint v[3410];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=1;i\u0026lt;=n;i++)\rscanf(\u0026quot;%d%d\u0026quot;,\u0026amp;w[i],\u0026amp;v[i]);\rfor(int i=1;i\u0026lt;=n;i++)\rfor(int j=0;j\u0026lt;=m;j++)\rif(j\u0026lt;w[i])\rdp[i\u0026amp;1][j]=dp[(i-1)\u0026amp;1][j];\relse\rdp[i\u0026amp;1][j]=max(dp[(i-1)\u0026amp;1][j],dp[(i-1)\u0026amp;1][j-w[i]]+v[i]);\rcout\u0026lt;\u0026lt;dp[n\u0026amp;1][m];\rreturn 0;\r}\r ","id":46,"section":"posts","summary":"Charm Bracelet Time Limit: 1000MS Memory Limit: 65536K Description Bessie has gone to the mall\u0026rsquo;s jewelry store and spies a charm bracelet. Of course, she\u0026rsquo;d like to fill it with the best charms possible from the N (1 ≤ N ≤ 3,402) available charms. Each charm i in the supplied list has a weight Wi (1 ≤ Wi ≤ 400), a \u0026lsquo;desirability\u0026rsquo; factor Di (1 ≤ Di ≤ 100), and","tags":["cpp","dp"],"title":"poj3624","uri":"https://dyhgo.github.io/2020/01/poj3624/","year":"2020"},{"content":"","id":47,"section":"posts","summary":"","tags":["cpp","sort"],"title":"排序算法的时间复杂度","uri":"https://dyhgo.github.io/2020/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","year":"2020"},{"content":"","id":48,"section":"posts","summary":"","tags":["cpp"],"title":"时间复杂度与计算时间的关系","uri":"https://dyhgo.github.io/2020/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","year":"2020"},{"content":"Saruman\u0026rsquo;s Army Time Limit: 1000MS\tMemory Limit: 65536K 题目链接\nDescription Saruman the White must lead his army along a straight path from Isengard to Helm’s Deep. To keep track of his forces, Saruman distributes seeing stones, known as palantirs, among the troops. Each palantir has a maximum effective range of R units, and must be carried by some troop in the army (i.e., palantirs are not allowed to “free float” in mid-air). Help Saruman take control of Middle Earth by determining the minimum number of palantirs needed for Saruman to ensure that each of his minions is within R units of some palantir.\nInput The input test file will contain multiple cases. Each test case begins with a single line containing an integer R, the maximum effective range of all palantirs (where 0 ≤ R ≤ 1000), and an integer n, the number of troops in Saruman’s army (where 1 ≤ n ≤ 1000). The next line contains n integers, indicating the positions x1, …, xn of each troop (where 0 ≤ xi ≤ 1000). The end-of-file is marked by a test case with R = n = −1.\nOutput For each test case, print a single integer indicating the minimum number of palantirs needed.\nSample Input 0 3 10 20 20 10 7 70 30 1 7 15 20 50 -1 -1\nSample Output 2 4\nHint In the first test case, Saruman may place a palantir at positions 10 and 20. Here, note that a single palantir with range 0 can cover both of the troops at position 20.\nIn the second test case, Saruman can place palantirs at position 7 (covering troops at 1, 7, and 15), position 20 (covering positions 20 and 30), position 50, and position 70. Here, note that palantirs must be distributed among troops and are not allowed to “free float.” Thus, Saruman cannot place a palantir at position 60 to cover the troops at positions 50 and 70.\nSource Stanford Local 2006\nSolution 题意：一条路上有n个路灯，每个路灯都能照亮左右的一段距离，问最少需要多少路灯才能使街道都亮着\ngreedy\n从最左开始向右延伸r，在r的范围内将最右的路灯点亮，此时这盏路灯将照亮左边和右边，从暗处的最左路灯开始，已知重复下去。 时间复杂度 O(n)!!!!需要将路灯位置排序\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint r,n;\rint x[1006];\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rwhile(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;r,\u0026amp;n)==2 \u0026amp;\u0026amp; r!=-1)\r{\rfor(int i=0;i\u0026lt;n;i++)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;x[i]);\rsort(x,x+n); // ！！！记得排序\rint j=0,ans=0;\rwhile(j\u0026lt;n)\r{\rint s=x[j++];\rwhile(j\u0026lt;n \u0026amp;\u0026amp; x[j]\u0026lt;=s+r) j++;\rint p=x[j-1];\rwhile(j\u0026lt;n \u0026amp;\u0026amp; p+r\u0026gt;=x[j]) j++;\rans++;\r} printf(\u0026quot;%d\\n\u0026quot;,ans);\r}\rreturn 0;\r}  ","id":49,"section":"posts","summary":"Saruman\u0026rsquo;s Army Time Limit: 1000MS Memory Limit: 65536K 题目链接 Description Saruman the White must lead his army along a straight path from Isengard to Helm’s Deep. To keep track of his forces, Saruman distributes seeing stones, known as palantirs, among the troops. Each palantir has a maximum effective range of R units, and must be carried by some troop in the army","tags":["cpp","greedy"],"title":"poj3069","uri":"https://dyhgo.github.io/2020/01/poj3069/","year":"2020"},{"content":"Best Cow Line Time Limit: 1000MS\tMemory Limit: 65536K 题目链接\nDescription FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual\u0026quot;Farmer of the Year\u0026rdquo; competition. In this contest every farmer arranges his cows in a line and herds them past the judges.\nThe contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows\u0026rsquo; names.\nFJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.\nFJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he\u0026rsquo;s finished, FJ takes his cows for registration in this new order.\nGiven the initial order of his cows, determine the least lexicographic string of initials he can make this way.\nInput  Line 1: A single integer: N Lines 2..N+1: Line i+1 contains a single initial (\u0026lsquo;A\u0026rsquo;..\u0026lsquo;Z\u0026rsquo;) of the cow in the ith position in the original line  Output The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (\u0026lsquo;A\u0026rsquo;..\u0026lsquo;Z\u0026rsquo;) in the new line.\nSample Input 6 A C D B C B\nSample Output ABCBCD\nSource USACO 2007 November Silver\nSolution 题意：给一个字符串s和空字符串p，每次进行以下操作之一 删除s的头部字符，加入到p的尾部 删除s的尾部字符，加入到p的尾部 最后s为空，p的字典序最小 greedy 时间复杂度最坏 O($n^2$)\n#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint n;\rchar s[2005];\rint c=0;\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;n;\rfor(int i=0;i\u0026lt;n;i++)\r{\rcin\u0026gt;\u0026gt;s[i];\r}\rint a=0,b=n-1;\rbool left=false;\rwhile(a\u0026lt;=b)\r{\rfor(int i=0;a+i\u0026lt;=b;i++)\r{\rif(s[a+i]\u0026lt;s[b-i])\r{\rleft=true;\rbreak;\r}\relse if(s[a+i]\u0026gt;s[b-i])\r{\rleft=false;\rbreak;\r}\r}\rif(left) putchar(s[a++]);\relse putchar(s[b--]);\rc++;\rif(c%80==0) putchar('\\n');\r}\rreturn 0;\r}\r ","id":50,"section":"posts","summary":"Best Cow Line Time Limit: 1000MS Memory Limit: 65536K 题目链接 Description FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual\u0026quot;Farmer of the Year\u0026rdquo; competition. In this contest every farmer arranges his cows in a line and herds them past the judges. The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in","tags":["cpp","greedy"],"title":"poj3617","uri":"https://dyhgo.github.io/2020/01/poj3617/","year":"2020"},{"content":"#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;set\u0026gt;\r//#include\u0026lt;map\u0026gt;\r//#include\u0026lt;string\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;iterator\u0026gt;\rusing namespace std;\rint main()\r{\rint a[]={3,2,1};\rint b[]={3,4,5,6};\rset\u0026lt;int\u0026gt; s1(a,a+3);\rset\u0026lt;int\u0026gt; s2(b,b+4);\rset\u0026lt;int\u0026gt; s3;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin()));\rfor(set\u0026lt;int\u0026gt;::iterator it=s3.begin();it!=s3.end();it++)\rcout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rcout\u0026lt;\u0026lt;endl;\rset_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot;*\u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rcout\u0026lt;\u0026lt;endl;\rset_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;));\rreturn 0;\r}\r ","id":51,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; #include\u0026lt;set\u0026gt; //#include\u0026lt;map\u0026gt; //#include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;iterator\u0026gt; using namespace std; int main() { int a[]={3,2,1}; int b[]={3,4,5,6}; set\u0026lt;int\u0026gt; s1(a,a+3); set\u0026lt;int\u0026gt; s2(b,b+4); set\u0026lt;int\u0026gt; s3; set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(s3,s3.begin())); for(set\u0026lt;int\u0026gt;::iterator it=s3.begin();it!=s3.end();it++) cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt;endl; set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot;*\u0026quot;)); cout\u0026lt;\u0026lt;endl; set_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); cout\u0026lt;\u0026lt;endl; set_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); cout\u0026lt;\u0026lt;endl; set_symmetric_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),ostream_iterator\u0026lt;int\u0026gt;(cout,\u0026quot; \u0026quot;)); return 0; }","tags":["cpp"],"title":"c++交集、并集、差、对称差函数","uri":"https://dyhgo.github.io/2020/01/c-%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E5%AF%B9%E7%A7%B0%E5%B7%AE%E5%87%BD%E6%95%B0/","year":"2020"},{"content":"#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include \u0026lt;limits\u0026gt;\rusing namespace std;\rint main()\r{\rcout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;bool: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(bool);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;char: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;signed char: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(signed char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;signed char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;signed char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned char: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned char);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned char\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned char\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;wchar_t: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(wchar_t);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;wchar_t\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;wchar_t\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;short: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(short);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;short\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;short\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;int: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(int);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;int\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;int\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;long: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(long);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;unsigned long: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(unsigned long);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned long\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;unsigned long\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;double: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(double);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;double\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;double\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;long double: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(long double);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long double\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;long double\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;float: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(float);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;float\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;float\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;size_t: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(size_t);\rcout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;size_t\u0026gt;::max)();\rcout \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;size_t\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;string: \\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(string) \u0026lt;\u0026lt; endl;\r// \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;string\u0026gt;::max)() \u0026lt;\u0026lt; \u0026quot;\\t最小值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;string\u0026gt;::min)() \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl;\rreturn 0;\r}\r ","id":52,"section":"posts","summary":"#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include \u0026lt;limits\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026quot;type: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;************size**************\u0026quot;\u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;bool: \\t\\t\u0026quot; \u0026lt;\u0026lt; \u0026quot;所占字节数：\u0026quot; \u0026lt;\u0026lt; sizeof(bool); cout \u0026lt;\u0026lt; \u0026quot;\\t最大值：\u0026quot; \u0026lt;\u0026lt; (numeric_limits\u0026lt;bool\u0026gt;::max)(); cout \u0026lt;\u0026lt; \u0026quo","tags":["cpp"],"title":"c++每种类型的值域","uri":"https://dyhgo.github.io/2020/01/c-%E6%AF%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E5%9F%9F/","year":"2020"},{"content":"#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main()\r{\rint a,b,x,y;\ra=60;\rb=22;\rcout\u0026lt;\u0026lt;ex_gcd(a,b,x,y)\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":53,"section":"posts","summary":"#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint ex_gcd(int a,int b,int\u0026amp; x,int\u0026amp; y)\r{\rint t,res;\rif(!b)\r{\rx=1;y=0;return a;\r}\relse\r{\rres=ex_gcd(b,a%b,x,y);\rt=x;\rx=y;y=t-a/b*y;\rreturn res;\r}\r}\rint main()\r{\rint a,b,x,y;\ra=60;\rb=22;\rcout\u0026lt;\u0026lt;ex_gcd(a,b,x,y)\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","tags":["cpp","number_theory"],"title":"extended euclidean algorithm","uri":"https://dyhgo.github.io/2020/01/extended-euclidean-algorithm/","year":"2020"},{"content":"//O(FE) /* input 5 7\r1 3 6\r3 5 8\r2 5 5\r3 2 3\r1 2 6\r4 1 10\r4 2 2\r4 5\routput\r11\r*/\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define maxv 100\r#define inf 0x3f3f3f3f\rint v,e;\rint s,t;\rstruct edge{int to,cap,rev;\r};\rvector\u0026lt;edge\u0026gt; G[maxv];\rbool used[maxv];\rvoid add_edge(int from ,int to,int cap)\r{\rG[from].push_back((edge){to,cap,G[to].size()});\rG[to].push_back((edge){from,0,G[from].size()-1});\r}\rint dfs(int s,int t,int f)\r{\rif(s==t) return f;\rused[s]=true;\rfor(int i=0;i\u0026lt;G[s].size();i++)\r{\redge \u0026amp;e =G[s][i];\rif(!used[e.to] \u0026amp;\u0026amp; e.cap\u0026gt;0)\r{\rint d=dfs(e.to,t,min(f,e.cap));\rif(d\u0026gt;0)\r{\re.cap-=d;\rG[e.to][e.rev].cap+=d;\rreturn d;\r}\r}\r}\rreturn 0;\r}\rint max_flow(int s,int t)\r{\rint flow=0;\rfor(;;)\r{\rmemset(used,0,sizeof(used));\rint f=dfs(s,t,inf);\rif(f==0) return flow;\rflow+=f;\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rcin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;e;\rfor(int i=0;i\u0026lt;e;i++)\r{\rint from,to,cap;\rscanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;from,\u0026amp;to,\u0026amp;cap);\radd_edge(from,to,cap);\r}\rcin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;\rcout\u0026lt;\u0026lt;max_flow(s,t);\rreturn 0;\r}\r ","id":54,"section":"posts","summary":"//O(FE) /* input 5 7\r1 3 6\r3 5 8\r2 5 5\r3 2 3\r1 2 6\r4 1 10\r4 2 2\r4 5\routput\r11\r*/\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define maxv 100\r#define inf 0x3f3f3f3f\rint v,e;\rint s,t;\rstruct edge{int to,cap,rev;\r};\rvector\u0026lt;edge\u0026gt; G[maxv];\rbool used[maxv];\rvoid add_edge(int from ,int to,int cap)\r{\rG[from].push_back((edge){to,cap,G[to].size()});\rG[to].push_back((edge){from,0,G[from].size()-1});\r}\rint dfs(int s,int t,int f)\r{\rif(s==t) return f;\rused[s]=true;\rfor(int i=0;i\u0026lt;G[s].","tags":["cpp","graph_theory"],"title":"ford fulkerson algorithm","uri":"https://dyhgo.github.io/2020/01/ford-fulkerson-algorithm/","year":"2020"},{"content":"迷宫问题 Time Limit: 1000MS\tMemory Limit: 65536K\nDescription 定义一个二维数组：\nint maze[5][5] = {\n0, 1, 0, 0, 0,\r0, 1, 0, 1, 0,\r0, 0, 0, 0, 0,\r0, 1, 1, 1, 0,\r0, 0, 0, 1, 0,\r };\n它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。\nInput 一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。\nOutput 左上角到右下角的最短路径，格式如样例所示。\nSample Input 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0\nSample Output (0, 0) (1, 0) (2, 0) (2, 1) (2, 2) (2, 3) (2, 4) (3, 4) (4, 4)\nSolution dfs/bfs都行 基础bfs （这个测试点只有一个，就是样例） 时间复杂度O(mn)\n#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;map\u0026gt;\r#include\u0026lt;vector\u0026gt;\r#include\u0026lt;queue\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\rusing namespace std;\rint n,m;\rint maze[7][7];\rint d[7][7];\rconst int inf=0x3f3f3f3f;\rtypedef pair\u0026lt;int,int\u0026gt; pii; //表示坐标 int sx,sy,gx,gy; //起点终点 int dx[]={0,0,1,-1};\rint dy[]={1,-1,0,0};\rmap\u0026lt;pii,pii \u0026gt; mp; //记录前驱节点,目的是记录路径 （如果记录路径就可以不用求最短距离） vector\u0026lt;pii \u0026gt; vt; //记录路径 void bfs()\r{\rqueue\u0026lt;pii\u0026gt; q;\rfill(d[0],d[0]+7*7,inf);\rq.push(pii(sx,sy));\rd[sx][sy]=0;\rwhile(q.size())\r{\rpii p=q.front();\rq.pop();\rif(p.first==gx and p.second==gy) break; //很重要的终止判断条件\rfor(int i=0;i\u0026lt;4;i++)\r{\rint nx=p.first+dx[i],ny=p.second+dy[i];\rif(nx\u0026gt;=0 and ny\u0026gt;=0 and nx\u0026lt;n and ny\u0026lt;m and maze[nx][ny]==0 and d[nx][ny]==inf) //inf的判断很重要\r{\rq.push(pii(nx,ny));\rd[nx][ny]=d[p.first][p.second]+1;\rmp[pii(nx,ny)]=pii(p.first,p.second);\r} } }\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rn=5;\rm=5;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\rcin\u0026gt;\u0026gt;maze[i][j];\rsx=0,sy=0,gx=4,gy=4;\rbfs();\r//cout\u0026lt;\u0026lt;d[gx][gy]\u0026lt;\u0026lt;endl;\rpii p;\rp=pii(gx,gy);\rwhile(p!=pii(sx,sy))\r{\rvt.push_back(p);\rp=mp[p];\r}\rreverse(vt.begin(),vt.end());\rprintf(\u0026quot;(%d, %d)\\n\u0026quot;,sx,sy);\rfor(vector\u0026lt;pii\u0026gt;::iterator it=vt.begin();it!=vt.end();it++)\r{\rprintf(\u0026quot;(%d, %d)\\n\u0026quot;,it-\u0026gt;first,it-\u0026gt;second);\r}\rreturn 0;\r}\r Sumamry 一个经典的bfs模板就是用队列来控制广度优先\n","id":55,"section":"posts","summary":"迷宫问题 Time Limit: 1000MS Memory Limit: 65536K Description 定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的1表示墙壁，0表示","tags":["cpp","bfs"],"title":"poj3984","uri":"https://dyhgo.github.io/2020/01/poj3984/","year":"2020"},{"content":"从学习方法和代码实现debug花了挺长时间。。。\n这个算法是从字符串s中找子串p出现的第一个位置\n以下是两个常见的字符串匹配算法（还有其他更高效的比如Turbo-bm算法，sunday算法）\nkmp算法和bm算法\n时间复杂度是O(s+p)\nbm算法总体比kmp算法要快3倍\n当然也可以直接用函数，比如 s.find( p );\n//懒得写更多，懒得修饰代码\nplus:字符串的读入常常会出现读空格、读回车等奇妙现象\nkmp算法 //kmp without optimization\r//strncpy() memmove()\r#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\rint kmp(char s[],char p[])\r{\r//preprocess\rint sl=strlen(s);\rint pl=strlen(p);\rchar subp[pl+1][pl+1];\rint next[pl+1];\rfor(int k=0;k\u0026lt;pl;k++)\r{\rstrncpy(subp[k],p,k+1);\r}\r//can optimized\rfor(int k=0;k\u0026lt;pl;k++)\r{\rstring tl;\rstring tr;\rint len_sub=k+1;\rint len=0;\rfor(int m=len_sub-1;m\u0026gt;0;m--)\r{\rtl=string(subp[k],subp[k]+m);\rtr=string(subp[k]+len_sub-m,subp[k]+len_sub);\rif(tl==tr)\r{\rlen=m;\rbreak;\r}\r}\rnext[k]=len;\r}\rfor(int k=pl-1;k\u0026gt;0;k--)\r{\rnext[k]=next[k-1];\r}\rnext[0]=-1;\r//match\rint i=0;int j=0;\rwhile(1)\r{\rif(s[i]==p[j])\r{\ri++;\rj++;\r}\relse\r{\rint t=next[j];\rif(t==-1)\r{\ri++;\rj=0;\r}\relse\r{\rj=t;\r}\r}\rif(j\u0026gt;=pl)\r{\rreturn i-pl;\r}\rif(i\u0026gt;=sl)\r{\rreturn -1;\r}\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rchar a[100];\rchar b[100];\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;kmp(a,b);\rreturn 0;\r}\r bm算法 //bm algorithm three to five times faster than kmp in genneral\r#include\u0026lt;iostream\u0026gt;\r#include\u0026lt;algorithm\u0026gt;\r#include\u0026lt;cstring\u0026gt;\r#include\u0026lt;string\u0026gt;\r#include\u0026lt;vector\u0026gt;\rusing namespace std;\rint get_badc(char t,char a[])\r{\rint k=strlen(a)-1;\rwhile(1)\r{\rif(k\u0026gt;=0) //assert\r{\rif(a[k--]==t)\r{\rreturn k+1;\r}\r}\relse return -1;\r}\r}\rint get_goods(vector\u0026lt;char\u0026gt; t,char a[]) //most difficult\r{\rint k=strlen(a)-1;\rvector\u0026lt;char\u0026gt; temp;\rint max_len=0;\rint m=0;\rint loc=-1;\rwhile(1)\r{ if(k\u0026gt;=0) //assert\r{\rif(t[m]==a[k])\r{\rtemp.push_back(a[k]);\rm++;\rk--;\r}\relse\r{\rm=0;\rk--;\rif(temp.size()\u0026gt;max_len)\r{\rmax_len=temp.size();\rloc=k+1;\rtemp.clear();\r}\r}\r}\relse return loc;\r}\r}\rint bm(char s[],char p[])\r{\rint sl=strlen(s);\rint pl=strlen(p);\rint i=pl-1;\rint j=pl-1;\rwhile(1)\r{\rif(i\u0026lt;sl and j\u0026gt;=0) //asseert // i\u0026lt;sl !!!!!!!!!! not i\u0026gt;0\r{\rif(s[i]==p[j])\r{\rvector\u0026lt;char\u0026gt; goods;\rgoods.push_back(s[i]);\rwhile(1)\r{\ri--;\rj--;\rif(i\u0026gt;=0 and j\u0026gt;=0) //assert\r{\rif(s[i]!=p[j])\r{\rchar badc1=s[i];\rstring str(p,p+pl-goods.size());\rint loc1=get_badc(badc1,\u0026amp;str[0]);\rint loc2=get_goods(goods,\u0026amp;str[0]);\rif(loc1==-1 and loc2!=-1)\r{\ri+=pl-1-loc2;\rj=pl-1;\r}\relse if(loc2==-1 and loc1!=-1)\r{\ri+=pl-1-loc1;\rj=pl-1;\r}\relse\r{\ri+=pl-1-min(loc1,loc2);\rj=pl-1;\r}\r}\relse\r{\rgoods.push_back(s[i]); //still add in good-suffix\r}\r}\relse break;\r}\r}\relse //only have bad-character\r{\rchar badc2=s[i];\rint loc=get_badc(badc2,p);\ri+=pl-1-loc;\rj=pl-1;\r}\r}\relse if(i\u0026gt;=sl) return -1; //!!!!!!!!!!!!!\relse return i+1; //!!!!!!!!!!!!\r}\r}\rint main()\r{\rfreopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rchar a[100];\rchar b[100];\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rcout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;a;\rcout\u0026lt;\u0026lt;bm(b,a)\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r ","id":56,"section":"posts","summary":"从学习方法和代码实现debug花了挺长时间。。。 这个算法是从字符串s中找子串p出现的第一个位置 以下是两个常见的字符串匹配算法（还有其他更高效","tags":["cpp","string"],"title":"字符串匹配算法(未完成)","uri":"https://dyhgo.github.io/2020/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/","year":"2020"},{"content":"很早以前写的懒得去审查。。。\n不知道对不对。。。\nEprime\n#include\u0026lt;bits/stdc++.h\u0026gt;\rusing namespace std;\r#define MAX 10000\rlong long prime1[MAX],num1;\rlong long prime2[MAX],num2;\rbool isprime1[MAX],isprime2[MAX];\rint qprime1(int n)\r{\rnum1=0;\rmemset(isprime1,1,sizeof(isprime1));\risprime1[0]=isprime1[1]=0;\rfor(int i=2;i\u0026lt;=n;i++)\r{\rif(isprime1[i])\r{\rprime1[num1++]=i;\rfor(int j=2;j*i\u0026lt;=n;j++)\risprime1[j*i]=0;\r}\r}\rreturn num1;\r}\rint qprime2(int m,int n)\r{\rnum2=0;\rqprime1((int)sqrt(n));\rmemset(isprime2,1,sizeof(isprime2));\rfor(int i=0;i\u0026lt;num1;i++)\r{\rfor(int j=m/prime1[i];j*prime1[i]\u0026lt;=n;j++)\r{\risprime2[j*prime1[i]]=0;\r}\r}\rfor(int i=m;i\u0026lt;=n;i++)\rif(isprime2[i]) num2++;\rreturn num2;\r} int main()\r{\rcout\u0026lt;\u0026lt;qprime2(10,100);\rreturn 0;\r}\r ","id":57,"section":"posts","summary":"很早以前写的懒得去审查。。。 不知道对不对。。。 Eprime #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define MAX 10000 long long prime1[MAX],num1; long long prime2[MAX],num2; bool isprime1[MAX],isprime2[MAX]; int qprime1(int n) { num1=0; memset(isprime1,1,sizeof(isprime1)); isprime1[0]=isprime1[1]=0; for(int i=2;i\u0026lt;=n;i++) { if(isprime1[i]) { prime1[num1++]=i; for(int j=2;j*i\u0026lt;=n;j++) isprime1[j*i]=0; } } return num1; } int qprime2(int m,int n) { num2=0; qprime1((int)sqrt(n)); memset(isprime2,1,sizeof(isprime2)); for(int i=0;i\u0026lt;num1;i++)","tags":["cpp","number_theory"],"title":"筛法求区间内质数个数？","uri":"https://dyhgo.github.io/2020/01/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/","year":"2020"},{"content":"Lake Counting http://poj.org/problem?id=2386\nTime Limit: 1000MS\tMemory Limit: 65536K Description Due to recent rains, water has pooled in various places in Farmer John\u0026rsquo;s field, which is represented by a rectangle of N x M (1 \u0026lt;= N \u0026lt;= 100; 1 \u0026lt;= M \u0026lt;= 100) squares. Each square contains either water (\u0026lsquo;W\u0026rsquo;) or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.\nGiven a diagram of Farmer John\u0026rsquo;s field, determine how many ponds he has. Input\n  Line 1: Two space-separated integers: N and M\n  Lines 2..N+1: M characters per line representing one row of Farmer John\u0026rsquo;s field. Each character is either \u0026lsquo;W\u0026rsquo; or \u0026lsquo;.'. The characters do not have spaces between them. Output\n  Line 1: The number of ponds in Farmer John\u0026rsquo;s field.\n  Sample Input 10 12 W\u0026hellip;\u0026hellip;..WW. .WWW\u0026hellip;..WWW \u0026hellip;.WW\u0026hellip;WW. \u0026hellip;\u0026hellip;\u0026hellip;WW. \u0026hellip;\u0026hellip;\u0026hellip;W.. ..W\u0026hellip;\u0026hellip;W.. .W.W\u0026hellip;..WW. W.W.W\u0026hellip;..W. .W.W\u0026hellip;\u0026hellip;W. ..W\u0026hellip;\u0026hellip;.W.\nSample Output 3\nHint OUTPUT DETAILS:\nThere are three ponds: one in the upper left, one in the lower left,and one along the right side.\nSource USACO 2004 November\nSolution bfs dfs都行 基础dfs 时间复杂度 O(mn)\n//dfs\r#include\u0026lt;iostream\u0026gt;\rusing namespace std;\rchar field[105][105];\rint n,m;\rvoid dfs(int x,int y)\r{\rfield[x][y]='.';\rfor(int dx=-1;dx\u0026lt;=1;dx++)\rfor(int dy=-1;dy\u0026lt;=1;dy++)\r{\rint nx=x+dx,ny=y+dy;\rif(0\u0026lt;=nx \u0026amp;\u0026amp; nx\u0026lt;n \u0026amp;\u0026amp; 0\u0026lt;=ny \u0026amp;\u0026amp; ny\u0026lt;m \u0026amp;\u0026amp; field[nx][ny]=='W')\rdfs(nx,ny);\r}\rreturn ;\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rios::sync_with_stdio(false);\rcin.tie(0);\rcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\r{\rcin\u0026gt;\u0026gt;field[i][j];\r}\rint res=0;\rfor(int i=0;i\u0026lt;n;i++)\rfor(int j=0;j\u0026lt;m;j++)\r{\rif(field[i][j]=='W') {\rdfs(i,j);\rres++;\r}\r}\rcout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl;\rreturn 0;\r}\r Summary 经典dfs就是递归思想 如果图外面是可达且连通的，就在图外面加一圈\n","id":58,"section":"posts","summary":"Lake Counting http://poj.org/problem?id=2386 Time Limit: 1000MS Memory Limit: 65536K Description Due to recent rains, water has pooled in various places in Farmer John\u0026rsquo;s field, which is represented by a rectangle of N x M (1 \u0026lt;= N \u0026lt;= 100; 1 \u0026lt;= M \u0026lt;= 100) squares. Each square contains either water (\u0026lsquo;W\u0026rsquo;) or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field.","tags":["cpp","dfs"],"title":"poj2386","uri":"https://dyhgo.github.io/2020/01/poj2386/","year":"2020"},{"content":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291\n1.用scanf,printf代替cin,cout 2.取消同步和绑定 ios::sync_with_stdio(false);\rcin.tie(0);\r//cout.tie(0);\r 此时只能用cin,cout\n3.对整型输入输出，将每个数字变成字符 inline int read()\r{\rint x=0;int f=1;char s=getchar();\rwhile(s\u0026lt;'0' or s\u0026gt;'9') {\rif(s=='-')\rf-=1;\rs=getchar();\r}\rwhile(s\u0026gt;='0' and s\u0026lt;='9') {\rx=x*10+s-'0';\rs=getchar();\r}\rreturn x*f;\r}\rvoid write(int x)\r{\rif(x/10\u0026gt;0) write(x/10);\rputchar(char(x%10+'0'));\r}\rint main()\r{\r//freopen(\u0026quot;input.txt\u0026quot;,\u0026quot;r\u0026quot;,stdin);\rint n=read();\rcout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;\rwrite(200);\rreturn 0;\r}  ","id":59,"section":"posts","summary":"参考https://blog.csdn.net/weixin_43960287/article/details/85337291 1.用sca","tags":["cpp"],"title":"输入输出优化(提高读入输出速度)","uri":"https://dyhgo.github.io/2020/01/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6/","year":"2020"}],"tags":[{"title":"bfs","uri":"https://dyhgo.github.io/tags/bfs/"},{"title":"binary","uri":"https://dyhgo.github.io/tags/binary/"},{"title":"binary_search","uri":"https://dyhgo.github.io/tags/binary_search/"},{"title":"computational_geometry","uri":"https://dyhgo.github.io/tags/computational_geometry/"},{"title":"construct","uri":"https://dyhgo.github.io/tags/construct/"},{"title":"cpp","uri":"https://dyhgo.github.io/tags/cpp/"},{"title":"dfs","uri":"https://dyhgo.github.io/tags/dfs/"},{"title":"dp","uri":"https://dyhgo.github.io/tags/dp/"},{"title":"graph","uri":"https://dyhgo.github.io/tags/graph/"},{"title":"graph_theory","uri":"https://dyhgo.github.io/tags/graph_theory/"},{"title":"greedy","uri":"https://dyhgo.github.io/tags/greedy/"},{"title":"hugo","uri":"https://dyhgo.github.io/tags/hugo/"},{"title":"java","uri":"https://dyhgo.github.io/tags/java/"},{"title":"lca","uri":"https://dyhgo.github.io/tags/lca/"},{"title":"number_theory","uri":"https://dyhgo.github.io/tags/number_theory/"},{"title":"scc","uri":"https://dyhgo.github.io/tags/scc/"},{"title":"search","uri":"https://dyhgo.github.io/tags/search/"},{"title":"segment_tree","uri":"https://dyhgo.github.io/tags/segment_tree/"},{"title":"sort","uri":"https://dyhgo.github.io/tags/sort/"},{"title":"string","uri":"https://dyhgo.github.io/tags/string/"},{"title":"suffix","uri":"https://dyhgo.github.io/tags/suffix/"},{"title":"test","uri":"https://dyhgo.github.io/tags/test/"},{"title":"union_find","uri":"https://dyhgo.github.io/tags/union_find/"},{"title":"xml","uri":"https://dyhgo.github.io/tags/xml/"}]}
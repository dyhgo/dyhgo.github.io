<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>algorithm - Category - This is DYH</title>
        <link>https://dyhgo.github.io/categories/algorithm/</link>
        <description>algorithm - Category - This is DYH</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 11 Apr 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://dyhgo.github.io/categories/algorithm/" rel="self" type="application/rss+xml" /><item>
    <title>hduoj1796</title>
    <link>https://dyhgo.github.io/hduoj1796/</link>
    <pubDate>Sat, 11 Apr 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/hduoj1796/</guid>
    <description><![CDATA[How many integers can you find Problem Description Now you get a number N, and a M-integers set, you should find out how many integers which are small than N, that they can divided exactly by any integers in the set. For example, N=12, and M-integer set is {2,3}, so there is another set {2,3,4,6,8,9,10}, all the integers of the set can be divided exactly by 2 or 3. As]]></description>
</item><item>
    <title>hduoj1711(kmp)</title>
    <link>https://dyhgo.github.io/hduoj1711kmp/</link>
    <pubDate>Tue, 17 Mar 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/hduoj1711kmp/</guid>
    <description><![CDATA[Number Sequence Problem Description Given two sequences of numbers : a[1], a[2], &hellip;&hellip; , a[N], and b[1], b[2], &hellip;&hellip; , b[M] (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], &hellip;&hellip; , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.]]></description>
</item><item>
    <title>Number Theory</title>
    <link>https://dyhgo.github.io/number-theory/</link>
    <pubDate>Sat, 22 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/number-theory/</guid>
    <description><![CDATA[求最大公约数和最小公倍数 辗转相除法 时间复杂度O(log(max(a,b))) 1 2 3 4 5 6 7 8 9 10 int gcd(int a,int b) { if(b==0) return a; else return gcd(b,a%b); } int lcm(int a,int b) { return a*b/gcd(a,b); } 或直]]></description>
</item><item>
    <title>hduoj2089(数位dp &#43; 记忆化搜索)</title>
    <link>https://dyhgo.github.io/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</link>
    <pubDate>Thu, 20 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/hduoj2089%E6%95%B0%E4%BD%8Ddp-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</guid>
    <description><![CDATA[Problem Description 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不]]></description>
</item><item>
    <title>Segment Tree</title>
    <link>https://dyhgo.github.io/segment-tree/</link>
    <pubDate>Thu, 20 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/segment-tree/</guid>
    <description><![CDATA[线段树是把区间分割，然后把数据按树存储的数据结构。线段树是一颗完美二叉树 用一个例子来介绍线段树 RMQ（range minimum query） 实现功能 对于一]]></description>
</item><item>
    <title>Graph Theory</title>
    <link>https://dyhgo.github.io/graph-theory/</link>
    <pubDate>Wed, 05 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/graph-theory/</guid>
    <description><![CDATA[图的存储：邻接表、邻接矩阵、前向星、链式前向星等 链式前向星存图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct edge{ int to , w , next; }e[maxn]; int tot,head[maxn]; void add_edge(int u,int v,int w){ e[tot].to = v;]]></description>
</item><item>
    <title>extended euclidean algorithm</title>
    <link>https://dyhgo.github.io/extended-euclidean-algorithm/</link>
    <pubDate>Fri, 17 Jan 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/extended-euclidean-algorithm/</guid>
    <description><![CDATA[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include&lt;bits/stdc++.h&gt;using namespace std;int ex_gcd(int a,int b,int&amp; x,int&amp; y){int t,res;if(!b){x=1;y=0;return a;}else{res=ex_gcd(b,a%b,x,y);t=x;x=y;y=t-a/b*y;return res;}}int main(){int a,b,x,y;a=60;b=22;cout&lt;&lt;ex_gcd(a,b,x,y)&lt;&lt;endl;cout&lt;&lt;x&lt;&lt;&#34; &#34;&lt;&lt;y&lt;&lt;endl;return 0;}  ]]></description>
</item><item>
    <title>ford fulkerson algorithm</title>
    <link>https://dyhgo.github.io/ford-fulkerson-algorithm/</link>
    <pubDate>Fri, 17 Jan 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/ford-fulkerson-algorithm/</guid>
    <description><![CDATA[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  //O(FE) /* input 5 71 3 63 5 82 5 53 2 31 2 64 1 104 2 24 5output11*/#include&lt;bits/stdc++.]]></description>
</item><item>
    <title>字符串匹配算法(未完成)</title>
    <link>https://dyhgo.github.io/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/</link>
    <pubDate>Fri, 17 Jan 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%AA%E5%AE%8C%E6%88%90/</guid>
    <description><![CDATA[从学习方法和代码实现debug花了挺长时间。。。 这个算法是从字符串s中找子串p出现的第一个位置 以下是两个常见的字符串匹配算法（还有其他更高效]]></description>
</item><item>
    <title>筛法求区间内质数个数？</title>
    <link>https://dyhgo.github.io/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/</link>
    <pubDate>Fri, 17 Jan 2020 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://dyhgo.github.io/%E7%AD%9B%E6%B3%95%E6%B1%82%E5%8C%BA%E9%97%B4%E5%86%85%E8%B4%A8%E6%95%B0%E4%B8%AA%E6%95%B0/</guid>
    <description><![CDATA[很早以前写的懒得去审查。。。 不知道对不对。。。 Eprime 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include&lt;bits/stdc++.h&gt; using namespace]]></description>
</item></channel>
</rss>

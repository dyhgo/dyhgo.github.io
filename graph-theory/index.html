<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Graph Theory - This is DYH</title><meta name="Description" content="Graph Theory"><meta property="og:title" content="Graph Theory" />
<meta property="og:description" content="Graph Theory" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dyhgo.github.io/graph-theory/" />
<meta property="og:image" content="https://dyhgo.github.io/logo.png"/>
<meta property="article:published_time" content="2020-02-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-02-05T00:00:00+00:00" /><meta property="og:site_name" content="This is DYH" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://dyhgo.github.io/logo.png"/>

<meta name="twitter:title" content="Graph Theory"/>
<meta name="twitter:description" content="Graph Theory"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://dyhgo.github.io/graph-theory/" /><link rel="prev" href="https://dyhgo.github.io/poj/" /><link rel="next" href="https://dyhgo.github.io/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Graph Theory",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/dyhgo.github.io\/graph-theory\/"
        },"genre": "posts","keywords": "cpp, graph_theory","wordcount":  7025 ,
        "url": "https:\/\/dyhgo.github.io\/graph-theory\/","datePublished": "2020-02-05T00:00:00+00:00","dateModified": "2020-02-05T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "dyh"
            },"description": "Graph Theory"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="This is DYH">DYH</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item language" title="Select Language">English<i class="fas fa-chevron-right fa-fw"></i>
                        <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/graph-theory/" selected>English</option></select>
                    </a><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="This is DYH">DYH</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="Select Language">English<i class="fas fa-chevron-right fa-fw"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/graph-theory/" selected>English</option></select>
                </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Graph Theory</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>dyh</a></span>&nbsp;<span class="post-category">included in <a href="/categories/algorithm/"><i class="far fa-folder fa-fw"></i>algorithm</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-02-05">2020-02-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;7025 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;15 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#链式前向星存图">链式前向星存图</a></li>
    <li><a href="#二分图判定">二分图判定</a></li>
    <li><a href="#求dag的拓扑序">求DAG的拓扑序</a></li>
    <li><a href="#bellman-ford算法">Bellman-Ford算法</a></li>
    <li><a href="#dijkstra算法">Dijkstra算法</a></li>
    <li><a href="#floyd-warshall算法">Floyd-Warshall算法</a></li>
    <li><a href="#路径还原">路径还原</a></li>
    <li><a href="#prim算法">Prim算法</a></li>
    <li><a href="#kruskal算法">Kruskal算法</a></li>
    <li><a href="#kosaraju算法">Kosaraju算法</a></li>
    <li><a href="#tarjan算法-scc部分">Tarjan算法 （scc部分）</a></li>
    <li><a href="#tarjan算法-割点桥部分">Tarjan算法 （割点、桥部分）</a></li>
    <li><a href="#lca">LCA</a></li>
    <li><a href="#dfs序-与线段树和树状数组结合">dfs序 (与线段树和树状数组结合)</a></li>
    <li><a href="#树链剖分">树链剖分</a></li>
    <li><a href="#树上启发式合并">树上启发式合并</a></li>
    <li><a href="#dinic算法">Dinic算法</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>图的存储：邻接表、邻接矩阵、前向星、链式前向星等</p>
<h2 id="链式前向星存图">链式前向星存图</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">edge</span><span class="p">{</span>
	<span class="kt">int</span> <span class="n">to</span> <span class="p">,</span> <span class="n">w</span> <span class="p">,</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">e</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">tot</span><span class="p">,</span><span class="n">head</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">w</span><span class="p">){</span>
	<span class="n">e</span><span class="p">[</span><span class="n">tot</span><span class="p">].</span><span class="n">to</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">e</span><span class="p">[</span><span class="n">tot</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
	<span class="n">e</span><span class="p">[</span><span class="n">tot</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
	<span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">tot</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="o">~</span><span class="n">i</span><span class="p">;</span><span class="n">i</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//init
</span><span class="c1"></span><span class="n">memset</span><span class="p">(</span><span class="n">head</span> <span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">head</span><span class="p">));</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="二分图判定">二分图判定</h2>
<p>通过着色来判定，整个图只染两种颜色，如果相邻点颜色不同就是二分图</p>
<p>用dfs判断每个点是否可染色，如果每个点都是可染色的，就是二分图</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//input
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">color</span><span class="p">[</span><span class="n">max_v</span><span class="p">]</span>  <span class="c1">//顶点i的颜色 1或-1
</span><span class="c1"></span>
<span class="kt">bool</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">;</span>   <span class="c1">//染色
</span><span class="c1"></span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">c</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>    <span class="c1">//相邻顶点同色
</span><span class="c1"></span>		<span class="k">if</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="o">-</span><span class="n">c</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>     <span class="c1">//对于还没染色的点，如果不能染色则返回false 
</span><span class="c1"></span>	 <span class="p">}</span> 
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">bipartite_graph</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>    <span class="c1">//还未着色//如果是连通图，遍历一次就够
</span><span class="c1"></span>		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> 
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>把顶点和边都算的话，时间复杂度是O(|V|+|E|)</p>
<h2 id="求dag的拓扑序">求DAG的拓扑序</h2>
<p>求拓扑序可以dfs，删边法（通过栈或队列）</p>
<p>求每个点的入度，将入度为0的点入栈，遍历栈里的点，将于这些点相邻的点的入度减1，如果有点入度为0，则入栈。依靠这个顺序，得到的就是拓扑序。如果点访问两次，则有圈。可以通过这个方法判断有向图是否有圈</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//input
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">max_v</span><span class="p">]</span>
<span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">indgree</span><span class="p">[</span><span class="n">max_v</span><span class="p">]</span>      <span class="c1">//每个顶点的入度
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>         <span class="c1">//拓扑排序的结果
</span><span class="c1"></span>
<span class="kt">bool</span> <span class="nf">topological_sort</span><span class="p">()</span>  <span class="c1">//判断是否能拓扑排序 ，若果有圈就不能 
</span><span class="c1"></span><span class="p">{</span>
	<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
	<span class="c1">//int counter=0;       //遍历的点的个数 
</span><span class="c1"></span>	
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> 
		<span class="k">if</span><span class="p">(</span><span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>    <span class="c1">//入度为0 的顶点入栈
</span><span class="c1"></span>	 
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>                
		<span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
		<span class="c1">//counter++;
</span><span class="c1"></span>		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">indegree</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>      <span class="c1">//遍历到的点入度间1，入度为0则入栈 
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>	
	<span class="k">if</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">==</span><span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度是O(|V|+|E|)</p>
<h2 id="bellman-ford算法">Bellman-Ford算法</h2>
<p>求单源最短路</p>
<p>d[i]=min{d[j]+e(j,i)}</p>
<p>只要图中不存在负圈，这样的更新操作是有限的（由于最短路不会经过一个顶点两次，所以这种操作只会重复|v|-1次）</p>
<p>时间复杂度O(|V|*|E|)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">edge</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">from</span><span class="p">,</span><span class="n">to</span><span class="p">,</span><span class="n">cost</span><span class="p">;</span>
<span class="p">}</span><span class="n">es</span><span class="p">[</span><span class="n">max_e</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">bellman_ford</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">inf</span><span class="p">;</span>         <span class="c1">//把最短距离初始化成无限
</span><span class="c1"></span>	<span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> 
	<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">bool</span> <span class="n">update</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>                <span class="c1">//判断while是否进行了更新操作，没有更新操作则退出循环 
</span><span class="c1"></span>		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">E</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>              <span class="c1">//根据公式，遍历边
</span><span class="c1"></span>		<span class="p">{</span>
			<span class="n">edge</span> <span class="n">e</span><span class="o">=</span><span class="n">es</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">from</span><span class="p">]</span><span class="o">!=</span><span class="n">inf</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">from</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">from</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
				<span class="n">update</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">update</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果更新操作（while循环）进行了超过|V|-1次，则存在负圈</p>
<p>所以判断负圈的一个方法可以是</p>
<p>把所有d[i]都变成0，如果有负圈，则一定执行超过|V|-1次</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="nf">find_negative_loop</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">E</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">edge</span> <span class="n">e</span><span class="o">=</span><span class="n">es</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">from</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">from</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">V</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>          <span class="c1">//这条语句不能放在if外，如果放在if外需要加update	
</span><span class="c1"></span>			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>	
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="dijkstra算法">Dijkstra算法</h2>
<p>求单源最短路，适用于没有负边的情况</p>
<p>将已求出最短路的点，放入一个集合中 ，每次从集合外找到一个和集合距离最近的点，加入集合</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">cost</span><span class="p">[</span><span class="n">max_v</span><span class="p">][</span><span class="n">max_v</span><span class="p">];</span>       <span class="c1">//权值，不存在时为inf
</span><span class="c1"></span><span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">used</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fill</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="n">v</span><span class="p">,</span><span class="n">inf</span><span class="p">);</span>
	<span class="n">fill</span><span class="p">(</span><span class="n">used</span><span class="p">,</span><span class="n">used</span><span class="o">+</span><span class="n">v</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	
	<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">v</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
		<span class="c1">//从尚未使用过的点中选一个距离最小的点
</span><span class="c1"></span>		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">u</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">u</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">v</span><span class="o">==-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">&lt;</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span> <span class="n">v</span><span class="o">=</span><span class="n">u</span><span class="p">;</span>
		<span class="p">}</span> 
		 
		<span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
		<span class="n">used</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">u</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">u</span><span class="o">++</span><span class="p">)</span>
			<span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="n">cost</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]);</span> 
	<span class="p">}</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度O(V^2)</p>
<p>优化</p>
<p>如果将点放入优先队列中，这要查找和更新就会节省很多时间，时间复杂度O(ElgV)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">edge</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">to</span><span class="p">,</span><span class="n">cost</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pii</span><span class="p">;</span>       <span class="c1">//first 是距离 ，second是点编号
</span><span class="c1"></span><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pii</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pii</span><span class="o">&gt;</span><span class="p">,</span><span class="n">greater</span><span class="o">&lt;</span><span class="n">pii</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>           <span class="c1">//使小的在上面
</span><span class="c1"></span>	<span class="n">fill</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="n">V</span><span class="p">,</span><span class="n">inf</span><span class="p">);</span>
	<span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pii</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="p">));</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">pii</span> <span class="n">p</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">&lt;</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">edge</span> <span class="n">e</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
				<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pii</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">],</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	 <span class="p">}</span> 
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="floyd-warshall算法">Floyd-Warshall算法</h2>
<p>求任意两点最短路，暴力枚举思想</p>
<p>d[i][j]=min(d[i][j],d[i][k]+d[k][j])  遍历所有的k</p>
<p>时间复杂度O(V^3)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">max_v</span><span class="p">][</span><span class="n">max_v</span><span class="p">];</span>   <span class="c1">//存储权值，边不存在时为inf，d[i][i]=0 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">floyd_warshall</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
				<span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="路径还原">路径还原</h2>
<p>通过找满足d[j]=d[k]+cost[k][j]的顶点k，来寻找前趋节点，不断寻找前趋节点来还原路径，时间复杂度O(E)</p>
<p>还可以用prev[j]在算法内直接记录前趋节点，最后遍历数组即可，时间复杂度O(V)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//算法内记录前趋节点 (优化的dijkstra算法)
</span><span class="c1"></span><span class="kt">int</span> <span class="n">prev</span><span class="p">[</span><span class="n">max_v</span><span class="p">]</span>          <span class="c1">//前趋节点
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">edge</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">to</span><span class="p">,</span><span class="n">cost</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pii</span><span class="p">;</span>       <span class="c1">//first 是距离 ，second是点编号
</span><span class="c1"></span><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pii</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pii</span><span class="o">&gt;</span><span class="p">,</span><span class="n">greater</span><span class="o">&lt;</span><span class="n">pii</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>           <span class="c1">//使小的在上面
</span><span class="c1"></span>	<span class="n">fill</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="n">V</span><span class="p">,</span><span class="n">inf</span><span class="p">);</span>
	<span class="n">fill</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="n">prev</span><span class="o">+</span><span class="n">V</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>                                        <span class="c1">//!!!!                            
</span><span class="c1"></span>	<span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pii</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="p">));</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">pii</span> <span class="n">p</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">&lt;</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">edge</span> <span class="n">e</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
				<span class="n">prev</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">;</span>                                   <span class="c1">//!!!!
</span><span class="c1"></span>				<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pii</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">],</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	 <span class="p">}</span> 
<span class="p">}</span>
 
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">get_path</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(;</span><span class="n">t</span><span class="o">!=-</span><span class="mi">1</span><span class="p">;</span><span class="n">t</span><span class="o">=</span><span class="n">prev</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">reverse</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">path</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">path</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="prim算法">Prim算法</h2>
<p>求最小生成树</p>
<p>prim算法和dijkstra算法很像，也是把已确定的点放入一个集合中，贪心地选取集合和未确定的点相连的最小权边，并加入到集合中，得到一棵生成树，可以证明是MST(minimum spanning tree)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//也可以堆优化 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">cost</span><span class="p">[</span><span class="n">max_v</span><span class="p">][</span><span class="n">max_v</span><span class="p">]</span>      <span class="c1">//权值
</span><span class="c1"></span><span class="kt">int</span> <span class="n">mincost</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>          <span class="c1">//从集合出发到其他点的最小权值,!!!这个权值是 集合 和 点 之间的 
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">used</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>               <span class="c1">//是否在集合中
</span><span class="c1"></span><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">prim</span><span class="p">()</span>                   <span class="c1">//返回MST的权值
</span><span class="c1"></span><span class="p">{</span>
	<span class="n">fill</span><span class="p">(</span><span class="n">mincost</span><span class="p">,</span><span class="n">mincost</span><span class="o">+</span><span class="n">V</span><span class="p">,</span><span class="n">inf</span><span class="p">);</span>      <span class="c1">//初始化 
</span><span class="c1"></span>	<span class="n">fill</span><span class="p">(</span><span class="n">used</span><span class="p">,</span><span class="n">used</span><span class="o">+</span><span class="n">V</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">mincost</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>             <span class="c1">//从0开始 
</span><span class="c1"></span>	
	<span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">v</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">u</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">u</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">v</span><span class="o">==-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">mincost</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">&lt;</span><span class="n">mincost</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span> <span class="n">v</span><span class="o">=</span><span class="n">u</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
		<span class="n">used</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
		<span class="n">res</span><span class="o">+=</span><span class="n">mincost</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
		
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">u</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">u</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">mincost</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">mincost</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">cost</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]);</span>    <span class="c1">//每次往集合中加入一个点，所有点的mincost都有可能改变 
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span> 
 <span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度与dijkstra算法一样</p>
<h2 id="kruskal算法">Kruskal算法</h2>
<p>求MST</p>
<p>将边的权值按大小排序，如果不产生<font color=red>圈和重边</font>，就依次把边加入到生成树中</p>
<p>要判断是否产生圈和重边，只需要判断加入这条边前，这条边的两个端点是否已在同一个连通分量里，这样就可以用并查集</p>
<p>Kruskal在边的排序上最费时，算法复杂度O(ElgV)</p>
<p>Kruskal适用于sparse graph</p>
<p>Prim适用于dense graph</p>
<p>在实际应用中，Kruskal更普遍</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">edge</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">cost</span><span class="p">;</span>
<span class="p">}</span><span class="n">es</span><span class="p">[</span><span class="n">max_e</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">par</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>                           <span class="c1">//union find需要 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">rankk</span><span class="p">[</span><span class="n">max_v</span><span class="p">];</span>                         <span class="c1">//key word &#34;rank&#34;
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">edge</span><span class="o">&amp;</span> <span class="n">e1</span><span class="p">,</span><span class="k">const</span> <span class="n">edge</span><span class="o">&amp;</span> <span class="n">e2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">e1</span><span class="p">.</span><span class="n">cost</span><span class="o">&lt;</span><span class="n">e2</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">init_union_find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">x</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
		<span class="n">rankk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">find</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">unite</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">x</span><span class="o">=</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="n">y</span><span class="o">=</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">rankk</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">&lt;</span><span class="n">rankk</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">y</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">par</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">rankk</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">==</span><span class="n">rankk</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="n">rankk</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">same</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">kruskal</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">es</span><span class="p">,</span><span class="n">es</span><span class="o">+</span><span class="n">E</span><span class="p">,</span><span class="n">cmp</span><span class="p">);</span>
	<span class="n">init_union_find</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">E</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">edge</span> <span class="n">e</span><span class="o">=</span><span class="n">es</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">same</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">unite</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
			<span class="n">res</span><span class="o">+=</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="kosaraju算法">Kosaraju算法</h2>
<p>强连通分量(strongly connected component)分解高效的算法有kosaraju算法，</p>
<p>tarjan算法，gabow算法</p>
<p>kosaraju算法通过随便选一点dfs，给点标号</p>
<p>把边的方向反过来，再一次dfs</p>
<p>由于在强连通分量中的点，其可达性不受边反向的影响</p>
<p>所以最后需独立进行k次搜索</p>
<p>即分裂出k个强连通分量</p>
<p>时间复杂度 O(V+E)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//kosaraju 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>                         
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>           
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rG</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">;</span>                  <span class="c1">//后序遍历顺序的顶点列表（标号） 
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">used</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>                 <span class="c1">//是否访问 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">cmp</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>                   <span class="c1">//所属强连通分量的拓扑序（序号） 
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span><span class="kt">int</span> <span class="n">to</span><span class="p">){</span>
	<span class="n">G</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
	<span class="n">rG</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">){</span>
	<span class="n">used</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span> <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rdfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
	<span class="n">used</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
	<span class="n">cmp</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">k</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">rG</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">rG</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span> <span class="n">rdfs</span><span class="p">(</span><span class="n">rG</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">k</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kosaraju_scc</span><span class="p">(){</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">used</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">used</span><span class="p">));</span>
	<span class="n">vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">uesd</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">used</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">vs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="n">rdfs</span><span class="p">(</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">k</span><span class="o">++</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="tarjan算法-scc部分">Tarjan算法 （scc部分）</h2>
<p>求scc的tarjan算法是给一个点赋上两个属性 dfn low分别表示dfs的访问时间和该点可追踪到的最小访问时间</p>
<p>dfs过程中先访问自己，再访问邻接点，最后对自己进行操作</p>
<p>在访问自己时，将两个属性初始化为当前时间，并且进栈</p>
<p>接下来访问未被访问过的邻接点，并且更新low属性</p>
<p>如果已被访问过且在栈里也更新low属性</p>
<p>最后对自己的操作就是判断dfn 和 low是否相等</p>
<p>相等说明它是连通块的头，已经无法再更新了</p>
<p>这时候不断出栈直到自己也出栈</p>
<p>总的操作就是遍历每个点，没访问就dfs</p>
<hr>
<p>tarjan算法和kosaraju算法有点类似，都是利用了反向边的性质，本质上是强连通分量中反向边的可达性，依此对每个点都最小化点的属性，而属性选择dfs序较高效</p>
<p>tarjan算法要dfs一次，邻接表的时间复杂度是 O(V+E)</p>
<hr>
<p>求连通块的出度和入度就是判断原本连接的两个点是否在同一个强连通分量中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dfn</span><span class="p">[</span><span class="n">maxv</span><span class="p">],</span><span class="n">low</span><span class="p">[</span><span class="n">maxv</span><span class="p">],</span><span class="n">cmp</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">in_stack</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tim</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="c1">//最后的num是连通块数量 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">in</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">out</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">tarjan_dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">tim</span><span class="p">;</span>
	<span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="n">in_stack</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">dfn</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
			<span class="n">tarjan_dfs</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
			<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">,</span> <span class="n">low</span><span class="p">[</span><span class="n">to</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">in_stack</span><span class="p">[</span><span class="n">to</span><span class="p">]){</span>
			<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">,</span> <span class="n">low</span><span class="p">[</span><span class="n">to</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]){</span>
		<span class="k">do</span><span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
			<span class="n">cmp</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
			<span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">in_stack</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">x</span><span class="p">);</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">tarjan_scc</span><span class="p">(){</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">dfn</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
			<span class="n">tarjan_dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">in_out_d</span><span class="p">(){</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
			<span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">cmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cmp</span><span class="p">[</span><span class="n">to</span><span class="p">]){</span>
				<span class="n">in</span><span class="p">[</span><span class="n">cmp</span><span class="p">[</span><span class="n">to</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
				<span class="n">out</span><span class="p">[</span><span class="n">cmp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="tarjan算法-割点桥部分">Tarjan算法 （割点、桥部分）</h2>
<p>利用dfn和low判定割点和桥，注意更新</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dfn</span><span class="p">[</span><span class="n">maxv</span><span class="p">],</span><span class="n">low</span><span class="p">[</span><span class="n">maxv</span><span class="p">],</span><span class="n">cmp</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">in_stack</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tim</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="c1">//最后的num是连通块数量 
</span><span class="c1"></span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cut</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">Rchild</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cnt_root</span><span class="p">;</span>
<span class="n">set</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">bridge</span><span class="p">;</span> 

<span class="kt">void</span> <span class="nf">tarjan_dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
    <span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">tim</span><span class="p">;</span> 
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">in_stack</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">to</span> <span class="o">!=</span> <span class="n">p</span><span class="p">){</span>
        	
        	<span class="k">if</span><span class="p">(</span><span class="n">dfn</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        		<span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">cnt_root</span><span class="p">)</span> <span class="n">Rchild</span><span class="o">++</span><span class="p">;</span>
            	<span class="n">tarjan_dfs</span><span class="p">(</span><span class="n">to</span> <span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            	<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">,</span> <span class="n">low</span><span class="p">[</span><span class="n">to</span><span class="p">]);</span>
            	
            	<span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">cnt_root</span> <span class="n">and</span> <span class="n">low</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="n">cut</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>         <span class="c1">//不是根，求割点 
</span><span class="c1"></span>            	<span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="n">bridge</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">to</span><span class="p">),</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">to</span><span class="p">)});</span>     <span class="c1">//求桥 
</span><span class="c1"></span>            	
         	<span class="p">}</span>
        	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">in_stack</span><span class="p">[</span><span class="n">to</span><span class="p">]){</span>
            	<span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">,</span> <span class="n">dfn</span><span class="p">[</span><span class="n">to</span><span class="p">]);</span>  <span class="c1">//注意这里是dfn，而不是求scc的low 
</span><span class="c1"></span>        	<span class="p">}</span>
        	
		<span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">low</span><span class="p">[</span><span class="n">x</span><span class="p">]){</span>
        <span class="k">do</span><span class="p">{</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">cmp</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
            <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">in_stack</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">num</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">tarjan_scc</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">dfn</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
        	<span class="n">cnt_root</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        	<span class="n">Rchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">tarjan_dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">Rchild</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">cut</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cnt_root</span><span class="p">);</span>       <span class="c1">//是根，求割点 
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://www.luogu.com.cn/problem/P3388" target="_blank" rel="noopener noreffer">割点的模板测试</a> 这个题的数据好像有森林</p>
<p><a href="https://www.luogu.com.cn/problem/P1656" target="_blank" rel="noopener noreffer">桥的模板测试</a></p>
<h2 id="lca">LCA</h2>
<p>大致的做法就是直接法，直接向上追溯</p>
<p>对于多次查询通过跳级预处理，利用二分的思想</p>
<p>单次查询，O(n)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">root</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">depth</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">d</span><span class="p">){</span>
	<span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">,</span> <span class="n">v</span> <span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">){</span>
	<span class="k">while</span><span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
	<span class="k">while</span><span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">){</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>多次查询 O(nlogn)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">root</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="n">max_logv</span><span class="p">][</span><span class="n">maxv</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">depth</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">d</span><span class="p">){</span>
	<span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">p</span><span class="p">;</span>
	<span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">p</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">){</span>
	<span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">max_logv</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">V</span><span class="p">;</span><span class="n">v</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">]];</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">lca</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">depth</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">&gt;</span><span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;</span><span class="n">max_logv</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">((</span><span class="n">depth</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-</span><span class="n">depth</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="o">&gt;&gt;</span><span class="n">k</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="n">v</span><span class="o">=</span><span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="o">==</span><span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">max_logv</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">k</span><span class="o">--</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">u</span><span class="p">]</span><span class="o">!=</span><span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">]){</span>
			<span class="n">u</span><span class="o">=</span><span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">u</span><span class="p">];</span>
			<span class="n">v</span><span class="o">=</span><span class="n">parent</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">u</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="dfs序-与线段树和树状数组结合">dfs序 (与线段树和树状数组结合)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>  <span class="c1">//图的领接表 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">od</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>  <span class="c1">//dfs序 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">L</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>   <span class="c1">//子树区间左边界 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">R</span><span class="p">[</span><span class="n">maxv</span><span class="p">];</span>   <span class="c1">//子树区间有边界 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">//当前是第几个节点（dfs序） 
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
	<span class="n">od</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">L</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">i</span><span class="p">:</span><span class="n">G</span><span class="p">[</span><span class="n">x</span><span class="p">]){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="n">p</span><span class="p">){</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">R</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="树链剖分">树链剖分</h2>
<p>树链剖分利用重孩子的定义和dfs序将树上路径权值和子树整体权值的修改和查询压缩成连续的区间的查询，对于区间的修改和查询可以利用线段树</p>
<p>以<a href="https://www.luogu.com.cn/problem/P3384" target="_blank" rel="noopener noreffer">这道题</a>为例</p>
<p>（无注释代码点击<a href="https://pasteme.cn/41602" target="_blank" rel="noopener noreffer">此处</a>）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e5</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">edge</span><span class="p">{</span>     <span class="c1">//链式前向星存图 
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">to</span><span class="p">,</span><span class="n">nxt</span><span class="p">;</span>
<span class="p">}</span><span class="n">e</span><span class="p">[</span><span class="n">maxn</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span>     <span class="c1">//用双向边代替无向边 
</span><span class="c1"></span>
<span class="k">struct</span> <span class="nc">tnode</span><span class="p">{</span>    <span class="c1">//线段树的节点 节点权值，覆盖的左区间，覆盖的右区间，覆盖的范围，lazy标签 
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">w</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">siz</span><span class="p">,</span><span class="n">lazy</span><span class="p">;</span>
<span class="p">}</span><span class="n">tn</span><span class="p">[</span><span class="n">maxn</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">];</span>    <span class="c1">// 大小要*4  
</span><span class="c1"></span>

<span class="c1">//wch：重孩子                   sz：子树大小      head：链式前向星的head    
</span><span class="c1">//wt：原来树上节点的权值        dep：深度         dfn：dfs序 
</span><span class="c1">//par：父节点                   top：树上节点所属链的链首      rdfn：dfs序的反映射 
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">wch</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">sz</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">head</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">wt</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">dep</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">dfn</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">par</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">top</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">rdfn</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">mod</span><span class="p">;</span>   
<span class="kt">int</span> <span class="n">cnt_e</span><span class="p">;</span>   <span class="c1">//链式前向星的计数器 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">cnt_d</span><span class="p">;</span>   <span class="c1">//dfs序的计数器 
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">){</span>   <span class="c1">//链式前向星的建图函数 
</span><span class="c1"></span>	<span class="n">e</span><span class="p">[</span><span class="o">++</span><span class="n">cnt_e</span><span class="p">].</span><span class="n">to</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>        
	<span class="n">e</span><span class="p">[</span><span class="n">cnt_e</span><span class="p">].</span><span class="n">nxt</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>   <span class="c1">//头插法 
</span><span class="c1"></span>	<span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt_e</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dfs1</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>      <span class="c1">//获得子树大小 ，深度，父节点，重孩子 
</span><span class="c1"></span>	<span class="n">sz</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nxt</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">p</span><span class="p">){</span>
			<span class="n">dep</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">par</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
			<span class="n">dfs1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
			<span class="n">sz</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sz</span><span class="p">[</span><span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">]])</span> <span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span> 
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dfs2</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">tp</span><span class="p">){</span>  <span class="c1">//剖分重链和轻链 
</span><span class="c1"></span>	<span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="n">dfn</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">cnt_d</span><span class="p">;</span>          <span class="c1">//dfs序 
</span><span class="c1"></span>	<span class="n">rdfn</span><span class="p">[</span><span class="n">cnt_d</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>           <span class="c1">//反dfs序 
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>                <span class="c1">//先操作重孩子，目的是让重链节点的dfs序连续，便于在线段树上的区间操作 
</span><span class="c1"></span>		<span class="n">dfs2</span><span class="p">(</span><span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">u</span><span class="p">,</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nxt</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">p</span> <span class="n">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
			<span class="n">dfs2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>      <span class="c1">//操作轻孩子 
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pushup</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">){</span>   <span class="c1">//通过两个孩子，更新自己的权值 由于题目要求，所以是求和形式 
</span><span class="c1"></span>	<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">+</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>  <span class="c1">//建立线段树 
</span><span class="c1"></span>	<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">siz</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">){</span>
		<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">wt</span><span class="p">[</span><span class="n">rdfn</span><span class="p">[</span><span class="n">l</span><span class="p">]];</span>   <span class="c1">//此时获得线段树节点的权值 
</span><span class="c1"></span>		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">build</span><span class="p">(</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">,</span> <span class="n">l</span> <span class="p">,</span> <span class="n">mid</span><span class="p">);</span>       <span class="c1">//递归建树 
</span><span class="c1"></span>	<span class="n">build</span><span class="p">(</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span> <span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span> <span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="n">pushup</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>                   <span class="c1">//每建一层就通过两个孩子更新自己 
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">pushdown</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">){</span>   <span class="c1">//通过迟滞，下放lazy，在需要的时候更新，这样会减少操作量 
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">lazy</span><span class="p">){</span>
		<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">+</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">].</span><span class="n">siz</span> <span class="o">*</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">lazy</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>  <span class="c1">//通过迟滞来更新子节点的权值 
</span><span class="c1"></span>		<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">+</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">].</span><span class="n">siz</span> <span class="o">*</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">lazy</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
		<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">].</span><span class="n">lazy</span> <span class="o">=</span> <span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">].</span><span class="n">lazy</span> <span class="o">+</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">lazy</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>           <span class="c1">//下放迟滞 
</span><span class="c1"></span>		<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">].</span><span class="n">lazy</span> <span class="o">=</span> <span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">].</span><span class="n">lazy</span> <span class="o">+</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">lazy</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
		<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">lazy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                                               <span class="c1">//该节点迟滞的作用结束，清空 
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">w</span><span class="p">){</span>   <span class="c1">//更新区间 
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">l</span> <span class="n">and</span> <span class="n">r</span><span class="o">&gt;=</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">r</span><span class="p">){</span>      <span class="c1">// 当目标区间包含了节点区间时，无法往下操作，更新节点的权值和迟滞 
</span><span class="c1"></span>		<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">w</span> <span class="o">+=</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">siz</span> <span class="o">*</span> <span class="n">w</span><span class="p">;</span>
		<span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">lazy</span> <span class="o">+=</span> <span class="n">w</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pushdown</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>                        <span class="c1">// 下放迟滞准备对子节点的更新操作 
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">l</span> <span class="o">+</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//这里是节点区间的一半 
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span> <span class="n">update</span><span class="p">(</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="p">,</span> <span class="n">r</span> <span class="p">,</span> <span class="n">w</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">&gt;</span><span class="n">mid</span><span class="p">)</span> <span class="n">update</span><span class="p">(</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="p">,</span> <span class="n">r</span> <span class="p">,</span> <span class="n">w</span><span class="p">);</span>
	<span class="n">pushup</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>                          <span class="c1">//子树更新完毕,通过子节点更新自己 
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">add_path</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">w</span><span class="p">){</span>   <span class="c1">//对路径的更新操作 
</span><span class="c1"></span>	<span class="k">while</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">!=</span><span class="n">top</span><span class="p">[</span><span class="n">v</span><span class="p">]){</span>          <span class="c1">//如果不属于一条重链 
</span><span class="c1"></span>		<span class="k">if</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">dep</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">v</span><span class="p">]])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>   <span class="c1">//现在它们属于两条链，始终对链头深度大的进行操作 
</span><span class="c1"></span>		<span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dfn</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]],</span><span class="n">dfn</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">w</span><span class="p">);</span>            <span class="c1">//更新这条链 
</span><span class="c1"></span>		<span class="n">u</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>                           <span class="c1">//这条链更新完毕，跳到链头的父节点，这样最终它们会相遇，处在同一条链上 
</span><span class="c1"></span>	<span class="p">}</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dep</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>   <span class="c1">//让深度低的节点在左，才可以区间操作 
</span><span class="c1"></span>	<span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dfn</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">dfn</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">w</span><span class="p">);</span>       <span class="c1">//根据dfs序 
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>     <span class="c1">//区间查询 
</span><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">l</span> <span class="n">and</span> <span class="n">r</span><span class="o">&gt;=</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>     <span class="c1">//已经缩到最小区间，直接返回值 
</span><span class="c1"></span>	
	<span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pushdown</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>                 <span class="c1">//下放迟滞，以备后续操作 
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">l</span> <span class="o">+</span> <span class="n">tn</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">query</span><span class="p">(</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span> <span class="p">,</span> <span class="n">l</span> <span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">&gt;</span><span class="n">mid</span><span class="p">)</span> <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">query</span><span class="p">(</span><span class="n">u</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span> <span class="p">,</span> <span class="n">l</span> <span class="p">,</span> <span class="n">r</span><span class="p">))</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">query_path</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">){</span>   <span class="c1">//路径上的查询 
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">top</span><span class="p">[</span><span class="n">v</span><span class="p">]){</span>   <span class="c1">//与路径上的更新相同 
</span><span class="c1"></span>		<span class="k">if</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">dep</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">v</span><span class="p">]])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">query</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dfn</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span> <span class="p">,</span> <span class="n">dfn</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dep</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">swap</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
	<span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+</span> <span class="n">query</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dfn</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">dfn</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="c1">//freopen(&#34;in.txt&#34;,&#34;r&#34;,stdin);
</span><span class="c1"></span>	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="o">&gt;&gt;</span><span class="n">r</span><span class="o">&gt;&gt;</span><span class="n">mod</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">wt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">y</span><span class="p">;</span>
		<span class="n">add_edge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
		<span class="n">add_edge</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">dfs1</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>    <span class="c1">//初始化 
</span><span class="c1"></span>	<span class="n">dfs2</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
	<span class="n">build</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
	
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">tp</span><span class="p">;</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">tp</span><span class="p">;</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">tp</span><span class="p">){</span>
			<span class="k">case</span> <span class="mi">1</span><span class="o">:</span><span class="p">{</span>
				<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
				<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">y</span><span class="o">&gt;&gt;</span><span class="n">z</span><span class="p">;</span>
				<span class="n">add_path</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="o">%</span><span class="n">mod</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">case</span> <span class="mi">2</span><span class="o">:</span><span class="p">{</span>
				<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
				<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">y</span><span class="p">;</span>
				<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">query_path</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">case</span> <span class="mi">3</span><span class="o">:</span><span class="p">{</span>
				<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
				<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">z</span><span class="p">;</span>
				<span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">+</span><span class="n">sz</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">z</span><span class="o">%</span><span class="n">mod</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">case</span> <span class="mi">4</span><span class="o">:</span><span class="p">{</span>
				<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
				<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span>
				<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">query</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">dfn</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">+</span><span class="n">sz</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="树上启发式合并">树上启发式合并</h2>
<p>dsu on tree</p>
<p>并查集的按秩合并是启发式，即小的往大的合并，减少查询难度</p>
<p>树上启发式合并通过树链剖分中重孩子的定义，在对子树查询时，先处理所有轻孩子，然后撤销（消除轻孩子对父节点的影响），再处理重孩子，不撤销，最后再处理一遍轻孩子，把对父节点的贡献和重孩子合并</p>
<p>撤销的目的在于对节点信息查询时会开辟一个数组，对于不同子节点，这个数组要再开辟一次，这样会MLE</p>
<p>以<a href="https://www.luogu.com.cn/problem/U41492" target="_blank" rel="noopener noreffer">这道题</a>为例</p>
<p>（无注释代码点击<a href="https://pasteme.cn/41607" target="_blank" rel="noopener noreffer">此处</a>）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">edge</span><span class="p">{</span>
	<span class="kt">int</span> <span class="n">to</span><span class="p">,</span><span class="n">nxt</span><span class="p">;</span>
<span class="p">}</span><span class="n">e</span><span class="p">[</span><span class="n">maxn</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">sz</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">par</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">head</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">wch</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">ans</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">num</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>  <span class="c1">//这些变量见树链剖分部分 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>  <span class="c1">//子树颜色数 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>  <span class="c1">//计数器 
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">){</span>
	<span class="n">e</span><span class="p">[</span><span class="o">++</span><span class="n">cnt</span><span class="p">].</span><span class="n">to</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">e</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">nxt</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
	<span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
	<span class="n">sz</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nxt</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">p</span><span class="p">){</span>
			<span class="n">dfs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
			<span class="n">sz</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sz</span><span class="p">[</span><span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">]])</span> <span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span> 
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cal</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">wch</span><span class="p">,</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]])</span> <span class="n">sum</span><span class="o">++</span><span class="p">;</span>               <span class="c1">//如果之前数量为0，说明是新颜色 
</span><span class="c1"></span>	<span class="n">num</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nxt</span><span class="p">){</span>  
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">p</span> <span class="n">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">wch</span><span class="p">){</span>       <span class="c1">//跳过重孩子 
</span><span class="c1"></span>			<span class="n">cal</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">wch</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>       
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dsu</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">kp</span><span class="p">){</span>   <span class="c1">//kp表示是否撤销 
</span><span class="c1"></span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nxt</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">p</span> <span class="n">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
			<span class="n">dsu</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>            <span class="c1">//先处理轻孩子，需要撤销 
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="n">dsu</span><span class="p">(</span><span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="p">,</span> <span class="n">u</span> <span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">//处理重孩子，需要保留 
</span><span class="c1"></span>	
	<span class="n">cal</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">wch</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="mi">1</span><span class="p">);</span>            <span class="c1">//计算轻孩子 
</span><span class="c1"></span>	<span class="n">ans</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">kp</span><span class="p">){</span>                      
		<span class="n">cal</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>           <span class="c1">//撤销操作 
</span><span class="c1"></span>		<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">y</span><span class="p">;</span>
		<span class="n">add_edge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
		<span class="n">add_edge</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	  
	<span class="n">dfs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>                     <span class="c1">//初始化 
</span><span class="c1"></span>	<span class="n">dsu</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
	
	
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">foo</span><span class="p">;</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">ans</span><span class="p">[</span><span class="n">foo</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="dinic算法">Dinic算法</h2>
<p>用来解决最大流问题</p>
<p>有两类算法</p>
<p>增广路算法（dinic ek isap ff）</p>
<p>预流推进算法 （hlpp）</p>
<p>dinic算法是经典算法，hlpp可能更快一点</p>
<p>dinic算法的本质还是贪心+暴力</p>
<p>通过不断地对残余网络(residual networks)求增广路(augmenting paths)，对每一条增广路求流量，然后把流量加起来就是最大流</p>
<p>有一个问题：在对增广路下放流量时，可能错过最优解</p>
<p>解决的方法是，对每条边加一条反向边，流量在原来的边减多少，就在反向边加多少，这样可以通过流入反向边来达到撤销的操作</p>
<p>dinic的操作过程分两步</p>
<p>bfs建立分层图，通过最短路的原则分层，每次在最短路的前提下找增广路，这是贪心的思想，这样会使找增广路高效且达到可行解</p>
<p>dfs找增广路，不断对边进行流量增减操作，暴力枚举思想</p>
<p>不断迭代每次产生的残余网络</p>
<p>三种优化（主要是后两者）<a href="https://www.cnblogs.com/Absofuckinglutely/p/11520363.html" target="_blank" rel="noopener noreffer">参考文章</a></p>
<p>当前弧优化 ：  增广路搜索中不再考虑之前搜索过的边</p>
<p>多路增广优化： 对于某一条边减去的流量，因增广路覆盖的次数会进行多次操作，现在只需要一次操作就行（操作总的流量），从一次bfs，多次dfs到多次bfs，一次dfs</p>
<p>炸点优化 ： 当某一条增广路中流量为0时，这个点在当前dfs搜索增广路中将不可达，所以直接炸点</p>
<p>时间复杂度 O(n*n*m)</p>
<p>实际合理运用优化之后，很难达到这样的时间复杂度，dinic算法还是很高效的，甚至可以跑十万个点</p>
<p>根据最大流最小割定理(maximum flow minimum cut theorem) 最大流就是有源汇最小割</p>
<p>对于无源汇最小割和全局最小割可以用Stoer Wagner算法</p>
<p>对于有源汇无源汇上下界最大流，<a href="https://www.luogu.com.cn/problem/solution/P5192" target="_blank" rel="noopener noreffer">参考此处</a></p>
<p>对于时间要求苛刻的最大流可以用HLPP算法</p>
<p>对于费用流，可以用spfa</p>
<p>对于最大流的各种变体，参考其他资料</p>
<p><a href="https://www.luogu.com.cn/problem/P3376" target="_blank" rel="noopener noreffer">测模板题</a></p>
<p><a href="https://pasteme.cn/43342" target="_blank" rel="noopener noreffer">无注释代码</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//有时需改成long long 
</span><span class="c1"></span>
<span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mi">205</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxm</span> <span class="o">=</span> <span class="mi">5005</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>


<span class="k">const</span> <span class="kt">int</span> <span class="n">inf</span> <span class="o">=</span> <span class="mh">0x3f3f3f3f</span><span class="p">;</span> 

<span class="k">struct</span> <span class="nc">edge</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">to</span> <span class="p">,</span> <span class="n">w</span> <span class="p">,</span> <span class="n">nex</span><span class="p">;</span>
<span class="p">}</span><span class="n">e</span><span class="p">[</span><span class="n">maxm</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">];</span>          <span class="c1">//maxm 
</span><span class="c1"></span><span class="kt">int</span> <span class="n">tot</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">head</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span> <span class="c1">// tot = 2 !!
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">dep</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">cur</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>   <span class="c1">//dep : dfs得到的最短距离   cur : 当前弧优化需要拷贝的数组 
</span><span class="c1"></span>

<span class="kt">void</span> <span class="nf">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="kt">int</span> <span class="n">w</span><span class="p">){</span>
    <span class="n">e</span><span class="p">[</span><span class="n">tot</span><span class="p">].</span><span class="n">to</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">e</span><span class="p">[</span><span class="n">tot</span><span class="p">].</span><span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">e</span><span class="p">[</span><span class="n">tot</span><span class="p">].</span><span class="n">nex</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>
    <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">tot</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">bfs</span><span class="p">(){</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dep</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dep</span><span class="p">));</span>  
	<span class="c1">//memset(dep , 0 , (tot+2)&lt;&lt;2);  
</span><span class="c1"></span>	<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">dep</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    
	
	<span class="kt">int</span> <span class="n">u</span> <span class="p">,</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nex</span><span class="p">){</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="n">or</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">//v 已达到不能作为dfs的增广路 ， 断流的点不能作为dfs的增广路 
</span><span class="c1"></span>			<span class="n">dep</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> 
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>      <span class="c1">//拷贝作为当前弧优化 
</span><span class="c1"></span>	<span class="k">return</span> <span class="n">dep</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>                               <span class="c1">//是否到达汇点 
</span><span class="c1"></span><span class="p">}</span>


<span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">flow</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="n">flow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nowflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                            <span class="c1">//当前流量 
</span><span class="c1"></span>	<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cur</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="p">,</span> <span class="n">v</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nex</span><span class="p">){</span>      <span class="c1">//当前弧优化 
</span><span class="c1"></span>		<span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">dep</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">or</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>      <span class="c1">//不满足深度递增或断流就不能作为增广路 
</span><span class="c1"></span>		
		<span class="k">if</span><span class="p">(</span><span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">v</span> <span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">flow</span> <span class="o">-</span> <span class="n">nowflow</span> <span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">))){</span>    
			<span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="o">^</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
			<span class="n">nowflow</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>                   <span class="c1">//多路增广优化，for循环一直进行，nowflow一直增加 
</span><span class="c1"></span>			<span class="k">if</span><span class="p">(</span><span class="n">nowflow</span> <span class="o">==</span> <span class="n">flow</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>         <span class="c1">//已达到最大流量 
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">nowflow</span><span class="p">)</span> <span class="n">dep</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>                  <span class="c1">//炸点优化 
</span><span class="c1"></span>	<span class="k">return</span> <span class="n">nowflow</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">ll</span> <span class="nf">dinic</span><span class="p">(){</span>
	<span class="n">ll</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">bfs</span><span class="p">()){</span>                              <span class="c1">//对残余网络不断分层，以备之后dfs求增广路，当汇点不可达时，残余网络将永远不可达 
</span><span class="c1"></span>		<span class="n">ans</span> <span class="o">+=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span> <span class="p">,</span> <span class="n">inf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="n">m</span><span class="o">&gt;&gt;</span><span class="n">s</span><span class="o">&gt;&gt;</span><span class="n">t</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
		<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">y</span><span class="o">&gt;&gt;</span><span class="n">z</span><span class="p">;</span>
		<span class="n">add_edge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">);</span>
		<span class="n">add_edge</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ll</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">dinic</span><span class="p">();</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">ans</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img-blog.csdnimg.cn/20200205145500420.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzM3Njk3,size_16,color_FFFFFF,t_70"
        data-srcset="https://img-blog.csdnimg.cn/20200205145500420.jpg?x-oss-process=image/watermark%2ctype_ZmFuZ3poZW5naGVpdGk%2cshadow_10%2ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzM3Njk3%2csize_16%2ccolor_FFFFFF%2ct_70, https://img-blog.csdnimg.cn/20200205145500420.jpg?x-oss-process=image/watermark%2ctype_ZmFuZ3poZW5naGVpdGk%2cshadow_10%2ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzM3Njk3%2csize_16%2ccolor_FFFFFF%2ct_70 1.5x, https://img-blog.csdnimg.cn/20200205145500420.jpg?x-oss-process=image/watermark%2ctype_ZmFuZ3poZW5naGVpdGk%2cshadow_10%2ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzM3Njk3%2csize_16%2ccolor_FFFFFF%2ct_70 2x"
        data-sizes="auto"
        alt="https://img-blog.csdnimg.cn/20200205145500420.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzM3Njk3,size_16,color_FFFFFF,t_70"
        title="在这里插入图片描述" /></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2020-02-05</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/graph-theory/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://dyhgo.github.io/graph-theory/" data-title="Graph Theory" data-hashtags="cpp,graph_theory"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://dyhgo.github.io/graph-theory/" data-hashtag="cpp"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="Share on WhatsApp" data-sharer="whatsapp" data-url="https://dyhgo.github.io/graph-theory/" data-title="Graph Theory" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://dyhgo.github.io/graph-theory/" data-title="Graph Theory"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://dyhgo.github.io/graph-theory/" data-title="Graph Theory"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="Share on Myspace" data-sharer="myspace" data-url="https://dyhgo.github.io/graph-theory/" data-title="Graph Theory" data-description="Graph Theory"><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a><a href="javascript:void(0);" title="Share on Blogger" data-sharer="blogger" data-url="https://dyhgo.github.io/graph-theory/" data-title="Graph Theory" data-description="Graph Theory"><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="Share on Evernote" data-sharer="evernote" data-url="https://dyhgo.github.io/graph-theory/" data-title="Graph Theory"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/cpp/">cpp</a>,&nbsp;<a href="/tags/graph_theory/">graph_theory</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/poj/" class="prev" rel="prev" title="poj"><i class="fas fa-angle-left fa-fw"></i>poj</a>
            <a href="/%E7%89%9B%E5%AE%A2%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%90%A55b/" class="next" rel="next" title="牛客基础训练营5B">牛客基础训练营5B<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">DYH</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/twemoji/twemoji.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":10},"comment":{},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"},"twemoji":true};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>

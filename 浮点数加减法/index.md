# 浮点数加减法



# #0 0操作数检查
如果有一个数为0，则可以直接得出结果

# #1 用补码表示阶码，尾数
阶码的符号位为两位

尾数的个位为符号位

# #2 对阶
小阶向大阶对齐（看原码），被对阶的数尾数右移阶差个

# #3 尾数加
将两个尾数相加得到新的尾数

# <s>#4 溢出处理<s>
太复杂，不作考虑

# #4 规格化处理
先检查是否规格化，如果尾数符号位与最高位相同则非规格化

尾数左移直到规格化为止，阶码减少左移的位数（不含符号位）

# #5 舍入处理
最低有效位为0舍去，为1则尾数+1

# #6 还原
将补码还原成原码

# E.G.
1.设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y]

`x= 2^(-011) * (0.100101)`   
 
 `y = 2^(-010) * (-0.011110)`

解：

第一步，补码表示

`x :11 101 ,  0.100101`

          
` y : 11 110 , 1.100010`

第二步

对阶，x阶小，y阶大，x向y对阶，阶差为1，所以x尾数右移一个

x阶码变成与y相同，阶码为 `11 110`

 尾数`0.010010(1)`

第三步

尾数加

         0. 0 1 0 0 1 0 (1)
         1. 1 0 0 0 1 0
       -------------------------
         1. 1 1 0 1 0 0 (1)   
         
结果为

`1.110110(1)`  符号位与最高位都是1，非规格化

第四步

规格化

尾数左移两位变成 `1.010010`

阶码减2（符号位不变），变成 `11 100 `

第五步

舍入处理

没得舍入

第六步

还原

`x+y = 2^(-4) * (-0.101110)`


对于[x-y]

根据[x-y]补码 = [x]补码 + [-y]补码

在第三步尾数加时

         0. 0 1 0 0 1 0 (1)
         0. 0 1 1 1 1 0
       -------------------------
         0. 1 1 0 0 0 0 (1)   


结果为 `0.110000(1)`

最高有效位和符号位不同，是规格化

最低有效位为1

尾数+1变成 `0.110001`

还原

`x-y = 2^(-2) * (0.110001)`


=========================================================

2. 设阶码3位，尾数6位，按浮点数运算方法计算[x+y] [x-y]

`x=2^(-101) × （-0.010110）`

` y=2^(-100) × （0.010110）`

解：

第一步

补码表示

x : 11 011 , 1.101010   

 y : 11 100 , 0.010110

第二步

对阶，x阶小，y阶大

x阶码变成y，阶差1，x尾数右移1位

`x : 11100 , 1.110101(0)`

第三步

尾数加

         1. 1 1 0 1 0 1 (0)
         0. 0 1 0 1 1 0
       -------------------------
         0. 0 0 1 0 1 1 (0)   


结果为 `0.001011(0)`

符号位与最高有效位相同，非规格化

第四步

规格化

尾数左移两位，阶码减2

尾数 `0.101100`

阶码 `11 010`

第五步

舍入处理

无需舍入

第六步

还原

`x+y = 2^(-6) * (0.101100)`

同理x-y的尾数加为

         1. 1 1 0 1 0 1 (0)
         1. 1 0 1 0 1 0
       -------------------------
         1. 0 1 1 1 1 1 (0)   

结果为 `1.011111(0)`

符号位和最高有效位不同，为规格化

最低有效位为0，全舍弃

还原

`x-y = 2^(-4) * (-0.100001)`

（有缺漏，待改正）


